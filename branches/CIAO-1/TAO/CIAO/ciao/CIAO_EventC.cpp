// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:320

#include "CIAO_EventC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "CIAO_EventC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_EventBase[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x42617365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventBase:1.0
  10,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74426173), 
  ACE_NTOHL (0x65000000),  // name = EventBase
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_EventBase (
    CORBA::tk_value,
    sizeof (_oc_Components_EventBase),
    (char *) &_oc_Components_EventBase,
    0,
    sizeof (Components::EventBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EventBase,
    &_tc_TAO_tc_Components_EventBase
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_EventBase_add_ref (
    Components::EventBase *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_EventBase_remove_ref (
    Components::EventBase *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::EventBase_var
// *************************************************************

Components::EventBase_var::EventBase_var (void)
  : ptr_ (0)
{}

Components::EventBase_var::EventBase_var (EventBase* p)
  : ptr_ (p)
{}

Components::EventBase_var::EventBase_var (const EventBase* p)
  : ptr_ (ACE_const_cast (EventBase *, p))
{}

Components::EventBase *
Components::EventBase_var::ptr (void) const
{
  return this->ptr_;
}

Components::EventBase_var::EventBase_var (const EventBase_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::EventBase_var::~EventBase_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::EventBase_var &
Components::EventBase_var::operator= (EventBase *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EventBase_var &
Components::EventBase_var::operator= (const EventBase_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    EventBase *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::EventBase_var::operator const Components::EventBase* () const // cast
{
  return this->ptr_;
}

Components::EventBase_var::operator Components::EventBase* () // cast 
{
  return this->ptr_;
}

Components::EventBase *
Components::EventBase_var::operator-> (void) const
{
  return this->ptr_;
}

Components::EventBase *
Components::EventBase_var::in (void) const
{
  return this->ptr_;
}

Components::EventBase *&
Components::EventBase_var::inout (void)
{
  return this->ptr_;
}

Components::EventBase *&
Components::EventBase_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::EventBase *
Components::EventBase_var::_retn (void)
{
  // yield ownership of managed obj reference
  EventBase* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::EventBase_var::tao_add_ref (
    EventBase *p
  )
{
  CORBA::add_ref (p);
}

void
Components::EventBase_var::tao_remove_ref (
    EventBase *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::EventBase_out
// *************************************************************

Components::EventBase_out::EventBase_out (EventBase *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::EventBase_out::EventBase_out (EventBase_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::EventBase_out::EventBase_out (const EventBase_out &p)
  : ptr_ (ACE_const_cast (EventBase_out&, p).ptr_)
{}

Components::EventBase_out &
Components::EventBase_out::operator= (const EventBase_out &p)
{
  this->ptr_ = ACE_const_cast (EventBase_out&, p).ptr_;
  return *this;
}

Components::EventBase_out &
Components::EventBase_out::operator= (const EventBase_var &p)
{
  EventBase *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::EventBase_out &
Components::EventBase_out::operator= (EventBase *p)
{
  this->ptr_ = p;
  return *this;
}

Components::EventBase_out::operator Components::EventBase*& () // cast
{
  return this->ptr_;
}

Components::EventBase *&
Components::EventBase_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::EventBase *
Components::EventBase_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::EventBase *
Components::EventBase::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (EventBase *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::EventBase::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::EventBase::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::EventBase::_tao_any_destructor (void *_tao_void_pointer)
{
  EventBase *tmp =
    ACE_static_cast (
        EventBase *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::EventBase::_tao_unmarshal (
    TAO_InputCDR &strm,
    EventBase *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        EventBase::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = EventBase::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::EventConsumerBase::_tao_class_id = 0;

Components::EventConsumerBase_ptr
tao_Components_EventConsumerBase_duplicate (
    Components::EventConsumerBase_ptr p
  )
{
  return Components::EventConsumerBase::_duplicate (p);
}

void
tao_Components_EventConsumerBase_release (
    Components::EventConsumerBase_ptr p
  )
{
  CORBA::release (p);
}

Components::EventConsumerBase_ptr
tao_Components_EventConsumerBase_nil (
    void
  )
{
  return Components::EventConsumerBase::_nil ();
}

Components::EventConsumerBase_ptr
tao_Components_EventConsumerBase_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::EventConsumerBase::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_EventConsumerBase_upcast (
    void *src
  )
{
  Components::EventConsumerBase **tmp =
    ACE_static_cast (Components::EventConsumerBase **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::EventConsumerBase_var
// *************************************************************

Components::EventConsumerBase_var::EventConsumerBase_var (void)
  : ptr_ (EventConsumerBase::_nil ())
{}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::ptr (void) const
{
  return this->ptr_;
}

Components::EventConsumerBase_var::EventConsumerBase_var (const ::Components::EventConsumerBase_var &p)
  : TAO_Base_var (),
    ptr_ (EventConsumerBase::_duplicate (p.ptr ()))
{}

Components::EventConsumerBase_var::~EventConsumerBase_var (void)
{
  CORBA::release (this->ptr_);
}

Components::EventConsumerBase_var &
Components::EventConsumerBase_var::operator= (EventConsumerBase_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EventConsumerBase_var &
Components::EventConsumerBase_var::operator= (const ::Components::EventConsumerBase_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::EventConsumerBase::_duplicate (p.ptr ());
  }
  return *this;
}

Components::EventConsumerBase_var::operator const ::Components::EventConsumerBase_ptr &() const // cast
{
  return this->ptr_;
}

Components::EventConsumerBase_var::operator ::Components::EventConsumerBase_ptr &() // cast 
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::in (void) const
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr &
Components::EventConsumerBase_var::inout (void)
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr &
Components::EventConsumerBase_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::EventConsumerBase_ptr val = this->ptr_;
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
  return val;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::tao_duplicate (EventConsumerBase_ptr p)
{
  return ::Components::EventConsumerBase::_duplicate (p);
}

void
Components::EventConsumerBase_var::tao_release (EventConsumerBase_ptr p)
{
  CORBA::release (p);
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::tao_nil (void)
{
  return ::Components::EventConsumerBase::_nil ();
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::EventConsumerBase::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::EventConsumerBase_var::tao_upcast (void *src)
{
  EventConsumerBase **tmp =
    ACE_static_cast (EventConsumerBase **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::EventConsumerBase_out
// *************************************************************

Components::EventConsumerBase_out::EventConsumerBase_out (EventConsumerBase_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
}

Components::EventConsumerBase_out::EventConsumerBase_out (EventConsumerBase_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
}

Components::EventConsumerBase_out::EventConsumerBase_out (const ::Components::EventConsumerBase_out &p)
  : ptr_ (ACE_const_cast (EventConsumerBase_out &, p).ptr_)
{}

::Components::EventConsumerBase_out &
Components::EventConsumerBase_out::operator= (const ::Components::EventConsumerBase_out &p)
{
  this->ptr_ = ACE_const_cast (EventConsumerBase_out&, p).ptr_;
  return *this;
}

Components::EventConsumerBase_out &
Components::EventConsumerBase_out::operator= (const ::Components::EventConsumerBase_var &p)
{
  this->ptr_ = ::Components::EventConsumerBase::_duplicate (p.ptr ());
  return *this;
}

Components::EventConsumerBase_out &
Components::EventConsumerBase_out::operator= (EventConsumerBase_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::EventConsumerBase_out::operator ::Components::EventConsumerBase_ptr &() // cast
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr &
Components::EventConsumerBase_out::ptr (void)
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_EventConsumerBase_push_event : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_EventConsumerBase_push_event (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::EventBase * evt);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_EventConsumerBase_push_event (const TAO_ClientRequestInfo_Components_EventConsumerBase_push_event &);
  void operator= (const TAO_ClientRequestInfo_Components_EventConsumerBase_push_event &);
  Components::EventBase * evt_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::TAO_ClientRequestInfo_Components_EventConsumerBase_push_event (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::EventBase * evt    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    evt_ (evt)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_EventConsumerBase_push_event_exceptiondata[] = 
  {
    Components::_tc_BadEventType
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_EventConsumerBase_push_event_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_EventConsumerBase_Proxy_Impl::_TAO_EventConsumerBase_Proxy_Impl (void)
{}

Components::_TAO_EventConsumerBase_Remote_Proxy_Impl::_TAO_EventConsumerBase_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_EventConsumerBase_Remote_Proxy_Impl::push_event (
    CORBA_Object *_collocated_tao_target_,
    Components::EventBase * evt
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::BadEventType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_EventConsumerBase_push_event_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/BadEventType:1.0",
      Components::BadEventType::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "push_event",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_EventConsumerBase_push_event _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          evt
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << evt)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_EventConsumerBase_push_event_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_EventConsumerBase_Proxy_Broker::_TAO_EventConsumerBase_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Proxy_Broker::~_TAO_EventConsumerBase_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Proxy_Broker * (*Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_EventConsumerBase_Remote_Proxy_Broker *
Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::the_TAO_EventConsumerBase_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_EventConsumerBase_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::_TAO_EventConsumerBase_Remote_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::~_TAO_EventConsumerBase_Remote_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Proxy_Impl&
Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::select_proxy (
    ::Components::EventConsumerBase *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::EventConsumerBase::EventConsumerBase (int collocated)
{
  this->Components_EventConsumerBase_setup_collocation (collocated);
}

void
Components::EventConsumerBase::Components_EventConsumerBase_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EventConsumerBase_Proxy_Broker_ =
      ::Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EventConsumerBase_Proxy_Broker_ =
      ::Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::the_TAO_EventConsumerBase_Remote_Proxy_Broker ();
}

Components::EventConsumerBase::~EventConsumerBase (void)
{}

void 
Components::EventConsumerBase::_tao_any_destructor (void *_tao_void_pointer)
{
  EventConsumerBase *tmp = ACE_static_cast (EventConsumerBase *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::EventConsumerBase_ptr
Components::EventConsumerBase::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return EventConsumerBase::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/EventConsumerBase:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (EventConsumerBase::_nil ());
      
      if (is_a == 0)
        {
          return EventConsumerBase::_nil ();
        }
    }
  
  return EventConsumerBase::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::EventConsumerBase_ptr 
Components::EventConsumerBase::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return EventConsumerBase::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      EventConsumerBase_ptr default_proxy = EventConsumerBase::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::EventConsumerBase (
                  stub,
                  1,
                  obj->_servant ()
                ),
              EventConsumerBase::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::EventConsumerBase (
                  stub,
                  0,
                  obj->_servant ()
                ),
              EventConsumerBase::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          EventConsumerBase_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &EventConsumerBase::_tao_class_id
                )
            )
        );
}

Components::EventConsumerBase_ptr
Components::EventConsumerBase::_duplicate (EventConsumerBase_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::EventConsumerBase::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/EventConsumerBase:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::EventConsumerBase::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, EventConsumerBase)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::EventConsumerBase::_interface_repository_id (void) const
{
  return "IDL:Components/EventConsumerBase:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::EventConsumerBase::push_event (
    Components::EventBase * evt
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::BadEventType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_EventConsumerBase_Proxy_Impl &proxy = 
    this->the_TAO_EventConsumerBase_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.push_event (
      this,
      evt
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_EventConsumerBase[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x42617365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
  18,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74436f6e), 
  ACE_NTOHL (0x73756d65), 
  ACE_NTOHL (0x72426173), 
  ACE_NTOHL (0x65000000),  // name = EventConsumerBase
};

static CORBA::TypeCode _tc_TAO_tc_Components_EventConsumerBase (
    CORBA::tk_objref,
    sizeof (_oc_Components_EventConsumerBase),
    (char *) &_oc_Components_EventConsumerBase,
    0,
    sizeof (Components::EventConsumerBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EventConsumerBase,
    &_tc_TAO_tc_Components_EventConsumerBase
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ConsumerDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e7375), 
  ACE_NTOHL (0x6d657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/ConsumerDescription:1.0
  20,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ConsumerDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker


  1, // member count
  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_objref, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x76656e74), 
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x42617365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
    18,
    ACE_NTOHL (0x4576656e), 
    ACE_NTOHL (0x74436f6e), 
    ACE_NTOHL (0x73756d65), 
    ACE_NTOHL (0x72426173), 
    ACE_NTOHL (0x65000000),  // name = EventConsumerBase

  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConsumerDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ConsumerDescription),
    (char *) &_oc_Components_ConsumerDescription,
    0,
    sizeof (Components::ConsumerDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConsumerDescription,
    &_tc_TAO_tc_Components_ConsumerDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_ConsumerDescription_add_ref (
    Components::ConsumerDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_ConsumerDescription_remove_ref (
    Components::ConsumerDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::ConsumerDescription_var
// *************************************************************

Components::ConsumerDescription_var::ConsumerDescription_var (void)
  : ptr_ (0)
{}

Components::ConsumerDescription_var::ConsumerDescription_var (ConsumerDescription* p)
  : ptr_ (p)
{}

Components::ConsumerDescription_var::ConsumerDescription_var (const ConsumerDescription* p)
  : ptr_ (ACE_const_cast (ConsumerDescription *, p))
{}

Components::ConsumerDescription *
Components::ConsumerDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ConsumerDescription_var::ConsumerDescription_var (const ConsumerDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ConsumerDescription_var::~ConsumerDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ConsumerDescription_var &
Components::ConsumerDescription_var::operator= (ConsumerDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ConsumerDescription_var &
Components::ConsumerDescription_var::operator= (const ConsumerDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ConsumerDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::ConsumerDescription_var::operator const Components::ConsumerDescription* () const // cast
{
  return this->ptr_;
}

Components::ConsumerDescription_var::operator Components::ConsumerDescription* () // cast 
{
  return this->ptr_;
}

Components::ConsumerDescription *
Components::ConsumerDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ConsumerDescription *
Components::ConsumerDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ConsumerDescription *&
Components::ConsumerDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ConsumerDescription *&
Components::ConsumerDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ConsumerDescription *
Components::ConsumerDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ConsumerDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::ConsumerDescription_var::tao_add_ref (
    ConsumerDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::ConsumerDescription_var::tao_remove_ref (
    ConsumerDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::ConsumerDescription_out
// *************************************************************

Components::ConsumerDescription_out::ConsumerDescription_out (ConsumerDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ConsumerDescription_out::ConsumerDescription_out (ConsumerDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ConsumerDescription_out::ConsumerDescription_out (const ConsumerDescription_out &p)
  : ptr_ (ACE_const_cast (ConsumerDescription_out&, p).ptr_)
{}

Components::ConsumerDescription_out &
Components::ConsumerDescription_out::operator= (const ConsumerDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumerDescription_out&, p).ptr_;
  return *this;
}

Components::ConsumerDescription_out &
Components::ConsumerDescription_out::operator= (const ConsumerDescription_var &p)
{
  ConsumerDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ConsumerDescription_out &
Components::ConsumerDescription_out::operator= (ConsumerDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::ConsumerDescription_out::operator Components::ConsumerDescription*& () // cast
{
  return this->ptr_;
}

Components::ConsumerDescription *&
Components::ConsumerDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ConsumerDescription *
Components::ConsumerDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::ConsumerDescription *
Components::ConsumerDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (ConsumerDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::ConsumerDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::ConsumerDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  if (rval == 0)
    {
      rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
    }
  
  return rval;
}

void
Components::ConsumerDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ConsumerDescription *tmp =
    ACE_static_cast (
        ConsumerDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::ConsumerDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ConsumerDescription (strm);
}

CORBA::Boolean Components::ConsumerDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ConsumerDescription (strm);
}

CORBA::Boolean Components::ConsumerDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    ConsumerDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        ConsumerDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ConsumerDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::ConsumerDescription_init::ConsumerDescription_init (void)
{
}

Components::ConsumerDescription_init::~ConsumerDescription_init (void)
{
}

const char* 
Components::ConsumerDescription_init::tao_repository_id (void)
{
  return Components::ConsumerDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::ConsumerDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::ConsumerDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::ConsumerDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::ConsumerDescription **old = ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_ConsumerDescription_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::ConsumerDescription **tmp = ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_ConsumerDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ConsumerDescription **tmp = ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_ConsumerDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONSUMERDESCRIPTIONS_CS_)
#define _COMPONENTS_CONSUMERDESCRIPTIONS_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::ConsumerDescriptions
// *************************************************************

Components::ConsumerDescriptions::ConsumerDescriptions (void)
{}

Components::ConsumerDescriptions::ConsumerDescriptions (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConsumerDescription,Components::ConsumerDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::ConsumerDescriptions::ConsumerDescriptions (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::ConsumerDescription_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConsumerDescription,Components::ConsumerDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::ConsumerDescriptions::ConsumerDescriptions (const ConsumerDescriptions &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConsumerDescription,Components::ConsumerDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::ConsumerDescriptions::~ConsumerDescriptions (void) // dtor
{}

void Components::ConsumerDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  ConsumerDescriptions *tmp = ACE_static_cast (ConsumerDescriptions*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ConsumerDescriptions[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e7375), 
  ACE_NTOHL (0x6d657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e733a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/ConsumerDescriptions:1.0
  21,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e73), 
  ACE_NTOHL (0x0),  // name = ConsumerDescriptions
  CORBA::tk_sequence, // typecode kind
  480, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    464, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x6f6e7375), 
      ACE_NTOHL (0x6d657244), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/ConsumerDescription:1.0
      20,
      ACE_NTOHL (0x436f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = ConsumerDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker


      1, // member count
      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_objref, // typecode kind
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x76656e74), 
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x42617365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
        18,
        ACE_NTOHL (0x4576656e), 
        ACE_NTOHL (0x74436f6e), 
        ACE_NTOHL (0x73756d65), 
        ACE_NTOHL (0x72426173), 
        ACE_NTOHL (0x65000000),  // name = EventConsumerBase

      1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConsumerDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_ConsumerDescriptions),
    (char *) &_oc_Components_ConsumerDescriptions,
    0,
    sizeof (Components::ConsumerDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConsumerDescriptions,
    &_tc_TAO_tc_Components_ConsumerDescriptions
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_EmitterDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6d697474), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/EmitterDescription:1.0
  19,
  ACE_NTOHL (0x456d6974), 
  ACE_NTOHL (0x74657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e0000),  // name = EmitterDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker


  1, // member count
  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_objref, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x76656e74), 
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x42617365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
    18,
    ACE_NTOHL (0x4576656e), 
    ACE_NTOHL (0x74436f6e), 
    ACE_NTOHL (0x73756d65), 
    ACE_NTOHL (0x72426173), 
    ACE_NTOHL (0x65000000),  // name = EventConsumerBase

  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_EmitterDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_EmitterDescription),
    (char *) &_oc_Components_EmitterDescription,
    0,
    sizeof (Components::EmitterDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EmitterDescription,
    &_tc_TAO_tc_Components_EmitterDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_EmitterDescription_add_ref (
    Components::EmitterDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_EmitterDescription_remove_ref (
    Components::EmitterDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::EmitterDescription_var
// *************************************************************

Components::EmitterDescription_var::EmitterDescription_var (void)
  : ptr_ (0)
{}

Components::EmitterDescription_var::EmitterDescription_var (EmitterDescription* p)
  : ptr_ (p)
{}

Components::EmitterDescription_var::EmitterDescription_var (const EmitterDescription* p)
  : ptr_ (ACE_const_cast (EmitterDescription *, p))
{}

Components::EmitterDescription *
Components::EmitterDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::EmitterDescription_var::EmitterDescription_var (const EmitterDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::EmitterDescription_var::~EmitterDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::EmitterDescription_var &
Components::EmitterDescription_var::operator= (EmitterDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EmitterDescription_var &
Components::EmitterDescription_var::operator= (const EmitterDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    EmitterDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::EmitterDescription_var::operator const Components::EmitterDescription* () const // cast
{
  return this->ptr_;
}

Components::EmitterDescription_var::operator Components::EmitterDescription* () // cast 
{
  return this->ptr_;
}

Components::EmitterDescription *
Components::EmitterDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::EmitterDescription *
Components::EmitterDescription_var::in (void) const
{
  return this->ptr_;
}

Components::EmitterDescription *&
Components::EmitterDescription_var::inout (void)
{
  return this->ptr_;
}

Components::EmitterDescription *&
Components::EmitterDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::EmitterDescription *
Components::EmitterDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  EmitterDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::EmitterDescription_var::tao_add_ref (
    EmitterDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::EmitterDescription_var::tao_remove_ref (
    EmitterDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::EmitterDescription_out
// *************************************************************

Components::EmitterDescription_out::EmitterDescription_out (EmitterDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::EmitterDescription_out::EmitterDescription_out (EmitterDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::EmitterDescription_out::EmitterDescription_out (const EmitterDescription_out &p)
  : ptr_ (ACE_const_cast (EmitterDescription_out&, p).ptr_)
{}

Components::EmitterDescription_out &
Components::EmitterDescription_out::operator= (const EmitterDescription_out &p)
{
  this->ptr_ = ACE_const_cast (EmitterDescription_out&, p).ptr_;
  return *this;
}

Components::EmitterDescription_out &
Components::EmitterDescription_out::operator= (const EmitterDescription_var &p)
{
  EmitterDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::EmitterDescription_out &
Components::EmitterDescription_out::operator= (EmitterDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::EmitterDescription_out::operator Components::EmitterDescription*& () // cast
{
  return this->ptr_;
}

Components::EmitterDescription *&
Components::EmitterDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::EmitterDescription *
Components::EmitterDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::EmitterDescription *
Components::EmitterDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (EmitterDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::EmitterDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::EmitterDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  if (rval == 0)
    {
      rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
    }
  
  return rval;
}

void
Components::EmitterDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  EmitterDescription *tmp =
    ACE_static_cast (
        EmitterDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::EmitterDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_EmitterDescription (strm);
}

CORBA::Boolean Components::EmitterDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_EmitterDescription (strm);
}

CORBA::Boolean Components::EmitterDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    EmitterDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        EmitterDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = EmitterDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::EmitterDescription_init::EmitterDescription_init (void)
{
}

Components::EmitterDescription_init::~EmitterDescription_init (void)
{
}

const char* 
Components::EmitterDescription_init::tao_repository_id (void)
{
  return Components::EmitterDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::EmitterDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::EmitterDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::EmitterDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::EmitterDescription **old = ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_EmitterDescription_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::EmitterDescription **tmp = ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_EmitterDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::EmitterDescription **tmp = ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_EmitterDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_EMITTERDESCRIPTIONS_CS_)
#define _COMPONENTS_EMITTERDESCRIPTIONS_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::EmitterDescriptions
// *************************************************************

Components::EmitterDescriptions::EmitterDescriptions (void)
{}

Components::EmitterDescriptions::EmitterDescriptions (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::EmitterDescription,Components::EmitterDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::EmitterDescriptions::EmitterDescriptions (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::EmitterDescription_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::EmitterDescription,Components::EmitterDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::EmitterDescriptions::EmitterDescriptions (const EmitterDescriptions &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::EmitterDescription,Components::EmitterDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::EmitterDescriptions::~EmitterDescriptions (void) // dtor
{}

void Components::EmitterDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  EmitterDescriptions *tmp = ACE_static_cast (EmitterDescriptions*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_EmitterDescriptions[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6d697474), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e733a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/EmitterDescriptions:1.0
  20,
  ACE_NTOHL (0x456d6974), 
  ACE_NTOHL (0x74657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e7300),  // name = EmitterDescriptions
  CORBA::tk_sequence, // typecode kind
  480, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    464, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      38,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f45), 
      ACE_NTOHL (0x6d697474), 
      ACE_NTOHL (0x65724465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e3a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/EmitterDescription:1.0
      19,
      ACE_NTOHL (0x456d6974), 
      ACE_NTOHL (0x74657244), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e0000),  // name = EmitterDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker


      1, // member count
      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_objref, // typecode kind
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x76656e74), 
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x42617365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
        18,
        ACE_NTOHL (0x4576656e), 
        ACE_NTOHL (0x74436f6e), 
        ACE_NTOHL (0x73756d65), 
        ACE_NTOHL (0x72426173), 
        ACE_NTOHL (0x65000000),  // name = EventConsumerBase

      1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_EmitterDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_EmitterDescriptions),
    (char *) &_oc_Components_EmitterDescriptions,
    0,
    sizeof (Components::EmitterDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EmitterDescriptions,
    &_tc_TAO_tc_Components_EmitterDescriptions
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_SubscriberDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x75627363), 
  ACE_NTOHL (0x72696265), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/SubscriberDescription:1.0
  22,
  ACE_NTOHL (0x53756273), 
  ACE_NTOHL (0x63726962), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker


  2, // member count
  3,
  ACE_NTOHL (0x636b0000),  // name = ck
  CORBA::tk_value, // typecode kind
  172, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6f6b69), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
    7,
    ACE_NTOHL (0x436f6f6b), 
    ACE_NTOHL (0x69650000),  // name = Cookie
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    1, // member count
    12,
    ACE_NTOHL (0x636f6f6b), 
    ACE_NTOHL (0x69655661), 
    ACE_NTOHL (0x6c756500),  // name = cookieValue
    CORBA::tk_alias, // typecode kind for typedefs
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4f63), 
      ACE_NTOHL (0x74657453), 
      ACE_NTOHL (0x65713a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
      9,
      ACE_NTOHL (0x4f637465), 
      ACE_NTOHL (0x74536571), 
      ACE_NTOHL (0x0),  // name = OctetSeq
      CORBA::tk_sequence, // typecode kind
      12, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_octet,

        0U,


    0, // data member visibility marker


  1, // data member visibility marker

  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_objref, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x76656e74), 
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x42617365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
    18,
    ACE_NTOHL (0x4576656e), 
    ACE_NTOHL (0x74436f6e), 
    ACE_NTOHL (0x73756d65), 
    ACE_NTOHL (0x72426173), 
    ACE_NTOHL (0x65000000),  // name = EventConsumerBase

  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_SubscriberDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_SubscriberDescription),
    (char *) &_oc_Components_SubscriberDescription,
    0,
    sizeof (Components::SubscriberDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_SubscriberDescription,
    &_tc_TAO_tc_Components_SubscriberDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_SubscriberDescription_add_ref (
    Components::SubscriberDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_SubscriberDescription_remove_ref (
    Components::SubscriberDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::SubscriberDescription_var
// *************************************************************

Components::SubscriberDescription_var::SubscriberDescription_var (void)
  : ptr_ (0)
{}

Components::SubscriberDescription_var::SubscriberDescription_var (SubscriberDescription* p)
  : ptr_ (p)
{}

Components::SubscriberDescription_var::SubscriberDescription_var (const SubscriberDescription* p)
  : ptr_ (ACE_const_cast (SubscriberDescription *, p))
{}

Components::SubscriberDescription *
Components::SubscriberDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::SubscriberDescription_var::SubscriberDescription_var (const SubscriberDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::SubscriberDescription_var::~SubscriberDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::SubscriberDescription_var &
Components::SubscriberDescription_var::operator= (SubscriberDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::SubscriberDescription_var &
Components::SubscriberDescription_var::operator= (const SubscriberDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    SubscriberDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::SubscriberDescription_var::operator const Components::SubscriberDescription* () const // cast
{
  return this->ptr_;
}

Components::SubscriberDescription_var::operator Components::SubscriberDescription* () // cast 
{
  return this->ptr_;
}

Components::SubscriberDescription *
Components::SubscriberDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::SubscriberDescription *
Components::SubscriberDescription_var::in (void) const
{
  return this->ptr_;
}

Components::SubscriberDescription *&
Components::SubscriberDescription_var::inout (void)
{
  return this->ptr_;
}

Components::SubscriberDescription *&
Components::SubscriberDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::SubscriberDescription *
Components::SubscriberDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  SubscriberDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::SubscriberDescription_var::tao_add_ref (
    SubscriberDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::SubscriberDescription_var::tao_remove_ref (
    SubscriberDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::SubscriberDescription_out
// *************************************************************

Components::SubscriberDescription_out::SubscriberDescription_out (SubscriberDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::SubscriberDescription_out::SubscriberDescription_out (SubscriberDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::SubscriberDescription_out::SubscriberDescription_out (const SubscriberDescription_out &p)
  : ptr_ (ACE_const_cast (SubscriberDescription_out&, p).ptr_)
{}

Components::SubscriberDescription_out &
Components::SubscriberDescription_out::operator= (const SubscriberDescription_out &p)
{
  this->ptr_ = ACE_const_cast (SubscriberDescription_out&, p).ptr_;
  return *this;
}

Components::SubscriberDescription_out &
Components::SubscriberDescription_out::operator= (const SubscriberDescription_var &p)
{
  SubscriberDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::SubscriberDescription_out &
Components::SubscriberDescription_out::operator= (SubscriberDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::SubscriberDescription_out::operator Components::SubscriberDescription*& () // cast
{
  return this->ptr_;
}

Components::SubscriberDescription *&
Components::SubscriberDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::SubscriberDescription *
Components::SubscriberDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::SubscriberDescription *
Components::SubscriberDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (SubscriberDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::SubscriberDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::SubscriberDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  if (rval == 0)
    {
      rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
    }
  
  return rval;
}

void
Components::SubscriberDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  SubscriberDescription *tmp =
    ACE_static_cast (
        SubscriberDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::SubscriberDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_SubscriberDescription (strm);
}

CORBA::Boolean Components::SubscriberDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_SubscriberDescription (strm);
}

CORBA::Boolean Components::SubscriberDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    SubscriberDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        SubscriberDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = SubscriberDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::SubscriberDescription_init::SubscriberDescription_init (void)
{
}

Components::SubscriberDescription_init::~SubscriberDescription_init (void)
{
}

const char* 
Components::SubscriberDescription_init::tao_repository_id (void)
{
  return Components::SubscriberDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::SubscriberDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::SubscriberDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::SubscriberDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::SubscriberDescription **old = ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_SubscriberDescription_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::SubscriberDescription **tmp = ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_SubscriberDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::SubscriberDescription **tmp = ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_SubscriberDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_)
#define _COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::SubscriberDescriptions
// *************************************************************

Components::SubscriberDescriptions::SubscriberDescriptions (void)
{}

Components::SubscriberDescriptions::SubscriberDescriptions (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SubscriberDescription,Components::SubscriberDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::SubscriberDescriptions::SubscriberDescriptions (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::SubscriberDescription_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SubscriberDescription,Components::SubscriberDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::SubscriberDescriptions::SubscriberDescriptions (const SubscriberDescriptions &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SubscriberDescription,Components::SubscriberDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::SubscriberDescriptions::~SubscriberDescriptions (void) // dtor
{}

void Components::SubscriberDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  SubscriberDescriptions *tmp = ACE_static_cast (SubscriberDescriptions*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_SubscriberDescriptions[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x75627363), 
  ACE_NTOHL (0x72696265), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/SubscriberDescriptions:1.0
  23,
  ACE_NTOHL (0x53756273), 
  ACE_NTOHL (0x63726962), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
  CORBA::tk_sequence, // typecode kind
  680, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    664, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      41,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f53), 
      ACE_NTOHL (0x75627363), 
      ACE_NTOHL (0x72696265), 
      ACE_NTOHL (0x72446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:Components/SubscriberDescription:1.0
      22,
      ACE_NTOHL (0x53756273), 
      ACE_NTOHL (0x63726962), 
      ACE_NTOHL (0x65724465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker


      2, // member count
      3,
      ACE_NTOHL (0x636b0000),  // name = ck
      CORBA::tk_value, // typecode kind
      172, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6f6b69), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
        7,
        ACE_NTOHL (0x436f6f6b), 
        ACE_NTOHL (0x69650000),  // name = Cookie
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        1, // member count
        12,
        ACE_NTOHL (0x636f6f6b), 
        ACE_NTOHL (0x69655661), 
        ACE_NTOHL (0x6c756500),  // name = cookieValue
        CORBA::tk_alias, // typecode kind for typedefs
        76, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f63), 
          ACE_NTOHL (0x74657453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
          9,
          ACE_NTOHL (0x4f637465), 
          ACE_NTOHL (0x74536571), 
          ACE_NTOHL (0x0),  // name = OctetSeq
          CORBA::tk_sequence, // typecode kind
          12, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_octet,

            0U,


        0, // data member visibility marker


      1, // data member visibility marker

      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_objref, // typecode kind
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x76656e74), 
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x42617365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
        18,
        ACE_NTOHL (0x4576656e), 
        ACE_NTOHL (0x74436f6e), 
        ACE_NTOHL (0x73756d65), 
        ACE_NTOHL (0x72426173), 
        ACE_NTOHL (0x65000000),  // name = EventConsumerBase

      1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_SubscriberDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_SubscriberDescriptions),
    (char *) &_oc_Components_SubscriberDescriptions,
    0,
    sizeof (Components::SubscriberDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_SubscriberDescriptions,
    &_tc_TAO_tc_Components_SubscriberDescriptions
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_PublisherDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x75626c69), 
  ACE_NTOHL (0x73686572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/PublisherDescription:1.0
  21,
  ACE_NTOHL (0x5075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = PublisherDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data member visibility marker


  1, // member count
  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_alias, // typecode kind for typedefs
  492, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    42,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f53), 
    ACE_NTOHL (0x75627363), 
    ACE_NTOHL (0x72696265), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x733a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/SubscriberDescriptions:1.0
    23,
    ACE_NTOHL (0x53756273), 
    ACE_NTOHL (0x63726962), 
    ACE_NTOHL (0x65724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
    CORBA::tk_sequence, // typecode kind
    404, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      388, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        41,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f53), 
        ACE_NTOHL (0x75627363), 
        ACE_NTOHL (0x72696265), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:Components/SubscriberDescription:1.0
        22,
        ACE_NTOHL (0x53756273), 
        ACE_NTOHL (0x63726962), 
        ACE_NTOHL (0x65724465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffffe0c, // negative offset (-500)
        2, // member count
        3,
        ACE_NTOHL (0x636b0000),  // name = ck
        CORBA::tk_value, // typecode kind
        172, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f43), 
          ACE_NTOHL (0x6f6f6b69), 
          ACE_NTOHL (0x653a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
          7,
          ACE_NTOHL (0x436f6f6b), 
          ACE_NTOHL (0x69650000),  // name = Cookie
          0, // value modifier
          CORBA::tk_null, // no stateful base valuetype

          1, // member count
          12,
          ACE_NTOHL (0x636f6f6b), 
          ACE_NTOHL (0x69655661), 
          ACE_NTOHL (0x6c756500),  // name = cookieValue
          CORBA::tk_alias, // typecode kind for typedefs
          76, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            31,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f4f63), 
            ACE_NTOHL (0x74657453), 
            ACE_NTOHL (0x65713a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
            9,
            ACE_NTOHL (0x4f637465), 
            ACE_NTOHL (0x74536571), 
            ACE_NTOHL (0x0),  // name = OctetSeq
            CORBA::tk_sequence, // typecode kind
            12, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              CORBA::tk_octet,

              0U,


          0, // data member visibility marker


        1, // data member visibility marker

        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        CORBA::tk_objref, // typecode kind
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f45), 
          ACE_NTOHL (0x76656e74), 
          ACE_NTOHL (0x436f6e73), 
          ACE_NTOHL (0x756d6572), 
          ACE_NTOHL (0x42617365), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
          18,
          ACE_NTOHL (0x4576656e), 
          ACE_NTOHL (0x74436f6e), 
          ACE_NTOHL (0x73756d65), 
          ACE_NTOHL (0x72426173), 
          ACE_NTOHL (0x65000000),  // name = EventConsumerBase

        1, // data member visibility marker


      0U,


  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_PublisherDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_PublisherDescription),
    (char *) &_oc_Components_PublisherDescription,
    0,
    sizeof (Components::PublisherDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_PublisherDescription,
    &_tc_TAO_tc_Components_PublisherDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_PublisherDescription_add_ref (
    Components::PublisherDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_PublisherDescription_remove_ref (
    Components::PublisherDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::PublisherDescription_var
// *************************************************************

Components::PublisherDescription_var::PublisherDescription_var (void)
  : ptr_ (0)
{}

Components::PublisherDescription_var::PublisherDescription_var (PublisherDescription* p)
  : ptr_ (p)
{}

Components::PublisherDescription_var::PublisherDescription_var (const PublisherDescription* p)
  : ptr_ (ACE_const_cast (PublisherDescription *, p))
{}

Components::PublisherDescription *
Components::PublisherDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::PublisherDescription_var::PublisherDescription_var (const PublisherDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::PublisherDescription_var::~PublisherDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::PublisherDescription_var &
Components::PublisherDescription_var::operator= (PublisherDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::PublisherDescription_var &
Components::PublisherDescription_var::operator= (const PublisherDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    PublisherDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::PublisherDescription_var::operator const Components::PublisherDescription* () const // cast
{
  return this->ptr_;
}

Components::PublisherDescription_var::operator Components::PublisherDescription* () // cast 
{
  return this->ptr_;
}

Components::PublisherDescription *
Components::PublisherDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::PublisherDescription *
Components::PublisherDescription_var::in (void) const
{
  return this->ptr_;
}

Components::PublisherDescription *&
Components::PublisherDescription_var::inout (void)
{
  return this->ptr_;
}

Components::PublisherDescription *&
Components::PublisherDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::PublisherDescription *
Components::PublisherDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  PublisherDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::PublisherDescription_var::tao_add_ref (
    PublisherDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::PublisherDescription_var::tao_remove_ref (
    PublisherDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::PublisherDescription_out
// *************************************************************

Components::PublisherDescription_out::PublisherDescription_out (PublisherDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::PublisherDescription_out::PublisherDescription_out (PublisherDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::PublisherDescription_out::PublisherDescription_out (const PublisherDescription_out &p)
  : ptr_ (ACE_const_cast (PublisherDescription_out&, p).ptr_)
{}

Components::PublisherDescription_out &
Components::PublisherDescription_out::operator= (const PublisherDescription_out &p)
{
  this->ptr_ = ACE_const_cast (PublisherDescription_out&, p).ptr_;
  return *this;
}

Components::PublisherDescription_out &
Components::PublisherDescription_out::operator= (const PublisherDescription_var &p)
{
  PublisherDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::PublisherDescription_out &
Components::PublisherDescription_out::operator= (PublisherDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::PublisherDescription_out::operator Components::PublisherDescription*& () // cast
{
  return this->ptr_;
}

Components::PublisherDescription *&
Components::PublisherDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::PublisherDescription *
Components::PublisherDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::PublisherDescription *
Components::PublisherDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (PublisherDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::PublisherDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::PublisherDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  if (rval == 0)
    {
      rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
    }
  
  return rval;
}

void
Components::PublisherDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  PublisherDescription *tmp =
    ACE_static_cast (
        PublisherDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::PublisherDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_PublisherDescription (strm);
}

CORBA::Boolean Components::PublisherDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_PublisherDescription (strm);
}

CORBA::Boolean Components::PublisherDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    PublisherDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        PublisherDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = PublisherDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::PublisherDescription_init::PublisherDescription_init (void)
{
}

Components::PublisherDescription_init::~PublisherDescription_init (void)
{
}

const char* 
Components::PublisherDescription_init::tao_repository_id (void)
{
  return Components::PublisherDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::PublisherDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::PublisherDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::PublisherDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::PublisherDescription **old = ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_PublisherDescription_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::PublisherDescription **tmp = ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_PublisherDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::PublisherDescription **tmp = ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_PublisherDescription_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_PUBLISHERDESCRIPTIONS_CS_)
#define _COMPONENTS_PUBLISHERDESCRIPTIONS_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::PublisherDescriptions
// *************************************************************

Components::PublisherDescriptions::PublisherDescriptions (void)
{}

Components::PublisherDescriptions::PublisherDescriptions (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::PublisherDescription,Components::PublisherDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::PublisherDescriptions::PublisherDescriptions (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::PublisherDescription_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::PublisherDescription,Components::PublisherDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::PublisherDescriptions::PublisherDescriptions (const PublisherDescriptions &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::PublisherDescription,Components::PublisherDescription_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::PublisherDescriptions::~PublisherDescriptions (void) // dtor
{}

void Components::PublisherDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  PublisherDescriptions *tmp = ACE_static_cast (PublisherDescriptions*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_PublisherDescriptions[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x75626c69), 
  ACE_NTOHL (0x73686572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e73), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/PublisherDescriptions:1.0
  22,
  ACE_NTOHL (0x5075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x73000000),  // name = PublisherDescriptions
  CORBA::tk_sequence, // typecode kind
  904, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    888, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f50), 
      ACE_NTOHL (0x75626c69), 
      ACE_NTOHL (0x73686572), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e3a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/PublisherDescription:1.0
      21,
      ACE_NTOHL (0x5075626c), 
      ACE_NTOHL (0x69736865), 
      ACE_NTOHL (0x72446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = PublisherDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data member visibility marker


      1, // member count
      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_alias, // typecode kind for typedefs
      492, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        42,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f53), 
        ACE_NTOHL (0x75627363), 
        ACE_NTOHL (0x72696265), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x733a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/SubscriberDescriptions:1.0
        23,
        ACE_NTOHL (0x53756273), 
        ACE_NTOHL (0x63726962), 
        ACE_NTOHL (0x65724465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
        CORBA::tk_sequence, // typecode kind
        404, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_value, // typecode kind
          388, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            41,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x436f6d70), 
            ACE_NTOHL (0x6f6e656e), 
            ACE_NTOHL (0x74732f53), 
            ACE_NTOHL (0x75627363), 
            ACE_NTOHL (0x72696265), 
            ACE_NTOHL (0x72446573), 
            ACE_NTOHL (0x63726970), 
            ACE_NTOHL (0x74696f6e), 
            ACE_NTOHL (0x3a312e30), 
            ACE_NTOHL (0x0),  // repository ID = IDL:Components/SubscriberDescription:1.0
            22,
            ACE_NTOHL (0x53756273), 
            ACE_NTOHL (0x63726962), 
            ACE_NTOHL (0x65724465), 
            ACE_NTOHL (0x73637269), 
            ACE_NTOHL (0x7074696f), 
            ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
            0, // value modifier
            0xffffffff, // indirection
            0xfffffe0c, // negative offset (-500)
            2, // member count
            3,
            ACE_NTOHL (0x636b0000),  // name = ck
            CORBA::tk_value, // typecode kind
            172, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f43), 
              ACE_NTOHL (0x6f6f6b69), 
              ACE_NTOHL (0x653a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
              7,
              ACE_NTOHL (0x436f6f6b), 
              ACE_NTOHL (0x69650000),  // name = Cookie
              0, // value modifier
              CORBA::tk_null, // no stateful base valuetype

              1, // member count
              12,
              ACE_NTOHL (0x636f6f6b), 
              ACE_NTOHL (0x69655661), 
              ACE_NTOHL (0x6c756500),  // name = cookieValue
              CORBA::tk_alias, // typecode kind for typedefs
              76, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4f63), 
                ACE_NTOHL (0x74657453), 
                ACE_NTOHL (0x65713a31), 
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
                9,
                ACE_NTOHL (0x4f637465), 
                ACE_NTOHL (0x74536571), 
                ACE_NTOHL (0x0),  // name = OctetSeq
                CORBA::tk_sequence, // typecode kind
                12, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  CORBA::tk_octet,

                  0U,


              0, // data member visibility marker


            1, // data member visibility marker

            9,
            ACE_NTOHL (0x636f6e73), 
            ACE_NTOHL (0x756d6572), 
            ACE_NTOHL (0x0),  // name = consumer
            CORBA::tk_objref, // typecode kind
            72, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              37,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f45), 
              ACE_NTOHL (0x76656e74), 
              ACE_NTOHL (0x436f6e73), 
              ACE_NTOHL (0x756d6572), 
              ACE_NTOHL (0x42617365), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:Components/EventConsumerBase:1.0
              18,
              ACE_NTOHL (0x4576656e), 
              ACE_NTOHL (0x74436f6e), 
              ACE_NTOHL (0x73756d65), 
              ACE_NTOHL (0x72426173), 
              ACE_NTOHL (0x65000000),  // name = EventConsumerBase

            1, // data member visibility marker


          0U,


      1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_PublisherDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_PublisherDescriptions),
    (char *) &_oc_Components_PublisherDescriptions,
    0,
    sizeof (Components::PublisherDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_PublisherDescriptions,
    &_tc_TAO_tc_Components_PublisherDescriptions
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::Events::_tao_class_id = 0;

Components::Events_ptr
tao_Components_Events_duplicate (
    Components::Events_ptr p
  )
{
  return Components::Events::_duplicate (p);
}

void
tao_Components_Events_release (
    Components::Events_ptr p
  )
{
  CORBA::release (p);
}

Components::Events_ptr
tao_Components_Events_nil (
    void
  )
{
  return Components::Events::_nil ();
}

Components::Events_ptr
tao_Components_Events_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Events::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Events_upcast (
    void *src
  )
{
  Components::Events **tmp =
    ACE_static_cast (Components::Events **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::Events_var
// *************************************************************

Components::Events_var::Events_var (void)
  : ptr_ (Events::_nil ())
{}

::Components::Events_ptr
Components::Events_var::ptr (void) const
{
  return this->ptr_;
}

Components::Events_var::Events_var (const ::Components::Events_var &p)
  : TAO_Base_var (),
    ptr_ (Events::_duplicate (p.ptr ()))
{}

Components::Events_var::~Events_var (void)
{
  CORBA::release (this->ptr_);
}

Components::Events_var &
Components::Events_var::operator= (Events_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Events_var &
Components::Events_var::operator= (const ::Components::Events_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Events::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Events_var::operator const ::Components::Events_ptr &() const // cast
{
  return this->ptr_;
}

Components::Events_var::operator ::Components::Events_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_var::in (void) const
{
  return this->ptr_;
}

::Components::Events_ptr &
Components::Events_var::inout (void)
{
  return this->ptr_;
}

::Components::Events_ptr &
Components::Events_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Events::_nil ();
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Events_ptr val = this->ptr_;
  this->ptr_ = ::Components::Events::_nil ();
  return val;
}

::Components::Events_ptr
Components::Events_var::tao_duplicate (Events_ptr p)
{
  return ::Components::Events::_duplicate (p);
}

void
Components::Events_var::tao_release (Events_ptr p)
{
  CORBA::release (p);
}

::Components::Events_ptr
Components::Events_var::tao_nil (void)
{
  return ::Components::Events::_nil ();
}

::Components::Events_ptr
Components::Events_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Events::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Events_var::tao_upcast (void *src)
{
  Events **tmp =
    ACE_static_cast (Events **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::Events_out
// *************************************************************

Components::Events_out::Events_out (Events_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Events::_nil ();
}

Components::Events_out::Events_out (Events_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Events::_nil ();
}

Components::Events_out::Events_out (const ::Components::Events_out &p)
  : ptr_ (ACE_const_cast (Events_out &, p).ptr_)
{}

::Components::Events_out &
Components::Events_out::operator= (const ::Components::Events_out &p)
{
  this->ptr_ = ACE_const_cast (Events_out&, p).ptr_;
  return *this;
}

Components::Events_out &
Components::Events_out::operator= (const ::Components::Events_var &p)
{
  this->ptr_ = ::Components::Events::_duplicate (p.ptr ());
  return *this;
}

Components::Events_out &
Components::Events_out::operator= (Events_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Events_out::operator ::Components::Events_ptr &() // cast
{
  return this->ptr_;
}

::Components::Events_ptr &
Components::Events_out::ptr (void)
{
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_get_consumer : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_consumer (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * sink_name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EventConsumerBase_ptr result);

private:
  TAO_ClientRequestInfo_Components_Events_get_consumer (const TAO_ClientRequestInfo_Components_Events_get_consumer &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_consumer &);
  const char * sink_name_;
  
  Components::EventConsumerBase_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_get_consumer::TAO_ClientRequestInfo_Components_Events_get_consumer (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * sink_name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    sink_name_ (sink_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= sink_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_consumer::result (::Components::EventConsumerBase_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_subscribe : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_subscribe (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * publisher_name,
      Components::EventConsumerBase_ptr subscriber);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Cookie * result);

private:
  TAO_ClientRequestInfo_Components_Events_subscribe (const TAO_ClientRequestInfo_Components_Events_subscribe &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_subscribe &);
  const char * publisher_name_;
  Components::EventConsumerBase_ptr subscriber_;
  
  Components::Cookie * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_subscribe::TAO_ClientRequestInfo_Components_Events_subscribe (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    publisher_name_ (publisher_name),
    subscriber_ (subscriber)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_subscribe::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= publisher_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->subscriber_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_subscribe::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_subscribe_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_AlreadyConnected,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (3);
  for (CORBA::ULong i = 0; i < 3; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_subscribe_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_subscribe::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_subscribe::result (::Components::Cookie * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_unsubscribe : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_unsubscribe (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * publisher_name,
      Components::Cookie * ck);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Events_unsubscribe (const TAO_ClientRequestInfo_Components_Events_unsubscribe &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_unsubscribe &);
  const char * publisher_name_;
  Components::Cookie * ck_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_unsubscribe::TAO_ClientRequestInfo_Components_Events_unsubscribe (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * publisher_name,
    Components::Cookie * ck    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    publisher_name_ (publisher_name),
    ck_ (ck)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_unsubscribe::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= publisher_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->ck_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_unsubscribe::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_unsubscribe_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_unsubscribe_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_unsubscribe::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_connect_consumer : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_connect_consumer (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * emitter_name,
      Components::EventConsumerBase_ptr consumer);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Events_connect_consumer (const TAO_ClientRequestInfo_Components_Events_connect_consumer &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_connect_consumer &);
  const char * emitter_name_;
  Components::EventConsumerBase_ptr consumer_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_connect_consumer::TAO_ClientRequestInfo_Components_Events_connect_consumer (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    emitter_name_ (emitter_name),
    consumer_ (consumer)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_connect_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= emitter_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->consumer_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_connect_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_connect_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_AlreadyConnected,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (3);
  for (CORBA::ULong i = 0; i < 3; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_connect_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_connect_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_disconnect_consumer : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_disconnect_consumer (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * source_name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EventConsumerBase_ptr result);

private:
  TAO_ClientRequestInfo_Components_Events_disconnect_consumer (const TAO_ClientRequestInfo_Components_Events_disconnect_consumer &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_disconnect_consumer &);
  const char * source_name_;
  
  Components::EventConsumerBase_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_disconnect_consumer::TAO_ClientRequestInfo_Components_Events_disconnect_consumer (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * source_name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    source_name_ (source_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= source_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_disconnect_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_NoConnection
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_disconnect_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::result (::Components::EventConsumerBase_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_get_all_consumers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_all_consumers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConsumerDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_all_consumers (const TAO_ClientRequestInfo_Components_Events_get_all_consumers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_all_consumers &);
  
  Components::ConsumerDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_get_all_consumers::TAO_ClientRequestInfo_Components_Events_get_all_consumers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_all_consumers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_all_consumers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_all_consumers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_all_consumers::result (::Components::ConsumerDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_get_named_consumers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_named_consumers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConsumerDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_named_consumers (const TAO_ClientRequestInfo_Components_Events_get_named_consumers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_named_consumers &);
  const Components::NameList & names_;
  
  Components::ConsumerDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_get_named_consumers::TAO_ClientRequestInfo_Components_Events_get_named_consumers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_named_consumers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_named_consumers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_consumers_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_consumers_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_named_consumers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_named_consumers::result (::Components::ConsumerDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_get_all_emitters : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_all_emitters (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EmitterDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_all_emitters (const TAO_ClientRequestInfo_Components_Events_get_all_emitters &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_all_emitters &);
  
  Components::EmitterDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_get_all_emitters::TAO_ClientRequestInfo_Components_Events_get_all_emitters (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_all_emitters::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_all_emitters::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_all_emitters::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_all_emitters::result (::Components::EmitterDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_get_named_emitters : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_named_emitters (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EmitterDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_named_emitters (const TAO_ClientRequestInfo_Components_Events_get_named_emitters &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_named_emitters &);
  const Components::NameList & names_;
  
  Components::EmitterDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_get_named_emitters::TAO_ClientRequestInfo_Components_Events_get_named_emitters (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_named_emitters::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_named_emitters::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_emitters_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_emitters_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_named_emitters::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_named_emitters::result (::Components::EmitterDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_get_all_publishers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_all_publishers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::PublisherDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_all_publishers (const TAO_ClientRequestInfo_Components_Events_get_all_publishers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_all_publishers &);
  
  Components::PublisherDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_get_all_publishers::TAO_ClientRequestInfo_Components_Events_get_all_publishers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_all_publishers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_all_publishers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_all_publishers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_all_publishers::result (::Components::PublisherDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Events_get_named_publishers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_named_publishers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::PublisherDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_named_publishers (const TAO_ClientRequestInfo_Components_Events_get_named_publishers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_named_publishers &);
  const Components::NameList & names_;
  
  Components::PublisherDescriptions * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Events_get_named_publishers::TAO_ClientRequestInfo_Components_Events_get_named_publishers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_named_publishers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_named_publishers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_publishers_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_publishers_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_named_publishers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_named_publishers::result (::Components::PublisherDescriptions * result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Events_Proxy_Impl::_TAO_Events_Proxy_Impl (void)
{}

Components::_TAO_Events_Remote_Proxy_Impl::_TAO_Events_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::EventConsumerBase_ptr Components::_TAO_Events_Remote_Proxy_Impl::get_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * sink_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_get_consumer_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

Components::EventConsumerBase_var _tao_retval (Components::EventConsumerBase::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_consumer",
      12,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_consumer _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          sink_name
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << sink_name)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_consumer_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EventConsumerBase_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::Cookie * Components::_TAO_Events_Remote_Proxy_Impl::subscribe (
    CORBA_Object *_collocated_tao_target_,
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_subscribe_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/AlreadyConnected:1.0",
      Components::AlreadyConnected::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    }
  };

::Components::Cookie_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "subscribe",
      9,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_subscribe _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          publisher_name,
          subscriber
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << publisher_name) &&
              (_tao_out << subscriber)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_subscribe_exceptiondata, 3 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Cookie * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_Events_Remote_Proxy_Impl::unsubscribe (
    CORBA_Object *_collocated_tao_target_,
    const char * publisher_name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_unsubscribe_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "unsubscribe",
      11,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_unsubscribe _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          publisher_name,
          ck
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << publisher_name) &&
              (_tao_out << ck)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_unsubscribe_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_Events_Remote_Proxy_Impl::connect_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_connect_consumer_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/AlreadyConnected:1.0",
      Components::AlreadyConnected::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "connect_consumer",
      16,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_connect_consumer _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          emitter_name,
          consumer
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << emitter_name) &&
              (_tao_out << consumer)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_connect_consumer_exceptiondata, 3 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::EventConsumerBase_ptr Components::_TAO_Events_Remote_Proxy_Impl::disconnect_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * source_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_disconnect_consumer_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/NoConnection:1.0",
      Components::NoConnection::_alloc
    }
  };

Components::EventConsumerBase_var _tao_retval (Components::EventConsumerBase::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "disconnect_consumer",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_disconnect_consumer _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          source_name
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << source_name)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_disconnect_consumer_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EventConsumerBase_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::ConsumerDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_all_consumers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::ConsumerDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::ConsumerDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ConsumerDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_consumers",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_all_consumers _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConsumerDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::ConsumerDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_named_consumers (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_get_named_consumers_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

Components::ConsumerDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::ConsumerDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ConsumerDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_consumers",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_named_consumers _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          names
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << names)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_named_consumers_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConsumerDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::EmitterDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_all_emitters (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::EmitterDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::EmitterDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::EmitterDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_emitters",
      16,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_all_emitters _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EmitterDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::EmitterDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_named_emitters (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_get_named_emitters_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

Components::EmitterDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::EmitterDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::EmitterDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_emitters",
      18,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_named_emitters _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          names
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << names)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_named_emitters_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EmitterDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::PublisherDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_all_publishers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::PublisherDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::PublisherDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::PublisherDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_publishers",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_all_publishers _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::PublisherDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::PublisherDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_named_publishers (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Events_get_named_publishers_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

Components::PublisherDescriptions_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    Components::PublisherDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::PublisherDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_publishers",
      20,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_named_publishers _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          names
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << names)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_named_publishers_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::PublisherDescriptions * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Events_Proxy_Broker::_TAO_Events_Proxy_Broker (void)
{
}

Components::_TAO_Events_Proxy_Broker::~_TAO_Events_Proxy_Broker (void)
{
}

Components::_TAO_Events_Proxy_Broker * (*Components__TAO_Events_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Events_Remote_Proxy_Broker *
Components::_TAO_Events_Remote_Proxy_Broker::the_TAO_Events_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Events_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Events_Remote_Proxy_Broker::_TAO_Events_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Events_Remote_Proxy_Broker::~_TAO_Events_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Events_Proxy_Impl&
Components::_TAO_Events_Remote_Proxy_Broker::select_proxy (
    ::Components::Events *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::Events::Events (int collocated)
{
  this->Components_Events_setup_collocation (collocated);
}

void
Components::Events::Components_Events_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Events_Proxy_Broker_ =
      ::Components__TAO_Events_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Events_Proxy_Broker_ =
      ::Components::_TAO_Events_Remote_Proxy_Broker::the_TAO_Events_Remote_Proxy_Broker ();
}

Components::Events::~Events (void)
{}

void 
Components::Events::_tao_any_destructor (void *_tao_void_pointer)
{
  Events *tmp = ACE_static_cast (Events *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Events_ptr
Components::Events::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Events::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/Events:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Events::_nil ());
      
      if (is_a == 0)
        {
          return Events::_nil ();
        }
    }
  
  return Events::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Events_ptr 
Components::Events::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Events::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Events_ptr default_proxy = Events::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Events_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Events (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Events::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Events (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Events::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Events_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Events::_tao_class_id
                )
            )
        );
}

Components::Events_ptr
Components::Events::_duplicate (Events_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::Events::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/Events:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::Events::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, Events)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::Events::_interface_repository_id (void) const
{
  return "IDL:Components/Events:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::EventConsumerBase_ptr Components::Events::get_consumer (
    const char * sink_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_consumer (
      this,
      sink_name
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::Cookie * Components::Events::subscribe (
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.subscribe (
      this,
      publisher_name,
      subscriber
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::Events::unsubscribe (
    const char * publisher_name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.unsubscribe (
      this,
      publisher_name,
      ck
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::Events::connect_consumer (
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.connect_consumer (
      this,
      emitter_name,
      consumer
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::EventConsumerBase_ptr Components::Events::disconnect_consumer (
    const char * source_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.disconnect_consumer (
      this,
      source_name
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::ConsumerDescriptions * Components::Events::get_all_consumers (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_consumers (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::ConsumerDescriptions * Components::Events::get_named_consumers (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_consumers (
      this,
      names
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::EmitterDescriptions * Components::Events::get_all_emitters (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_emitters (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::EmitterDescriptions * Components::Events::get_named_emitters (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_emitters (
      this,
      names
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::PublisherDescriptions * Components::Events::get_all_publishers (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_publishers (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::PublisherDescriptions * Components::Events::get_named_publishers (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_publishers (
      this,
      names
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Events[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  26,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/Events:1.0
  7,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74730000),  // name = Events
};

static CORBA::TypeCode _tc_TAO_tc_Components_Events (
    CORBA::tk_objref,
    sizeof (_oc_Components_Events),
    (char *) &_oc_Components_Events,
    0,
    sizeof (Components::Events)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Events,
    &_tc_TAO_tc_Components_Events
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::ConsumerDescription::_tao_marshal__Components_ConsumerDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::ConsumerDescription::_tao_unmarshal__Components_ConsumerDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:297

// Accessor to set the member.
void
OBV_Components::ConsumerDescription::consumer (Components::EventConsumerBase_ptr val)
{
  this->_pd_consumer = Components::EventConsumerBase::_duplicate (val);
}

// Retrieve the member.
Components::EventConsumerBase_ptr 
OBV_Components::ConsumerDescription::consumer () const
{
  return this->_pd_consumer.ptr ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::EmitterDescription::_tao_marshal__Components_EmitterDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::EmitterDescription::_tao_unmarshal__Components_EmitterDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:297

// Accessor to set the member.
void
OBV_Components::EmitterDescription::consumer (Components::EventConsumerBase_ptr val)
{
  this->_pd_consumer = Components::EventConsumerBase::_duplicate (val);
}

// Retrieve the member.
Components::EventConsumerBase_ptr 
OBV_Components::EmitterDescription::consumer () const
{
  return this->_pd_consumer.ptr ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::SubscriberDescription::_tao_marshal__Components_SubscriberDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::SubscriberDescription::_tao_unmarshal__Components_SubscriberDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:431

// Accessor to set the member.
void
OBV_Components::SubscriberDescription::ck (Components::Cookie* val)
{
  CORBA::add_ref (val);
  this->_pd_ck = val;
}

// Retrieve the member
Components::Cookie *
OBV_Components::SubscriberDescription::ck () const
{
  return this->_pd_ck.ptr ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:297

// Accessor to set the member.
void
OBV_Components::SubscriberDescription::consumer (Components::EventConsumerBase_ptr val)
{
  this->_pd_consumer = Components::EventConsumerBase::_duplicate (val);
}

// Retrieve the member.
Components::EventConsumerBase_ptr 
OBV_Components::SubscriberDescription::consumer () const
{
  return this->_pd_consumer.ptr ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::PublisherDescription::_tao_marshal__Components_PublisherDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::PublisherDescription::_tao_unmarshal__Components_PublisherDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::PublisherDescription::consumer (const Components::SubscriberDescriptions &val)
{
  this->_pd_consumer = val;
}

// Readonly get method.
const Components::SubscriberDescriptions &
OBV_Components::PublisherDescription::consumer (void) const
{
  return this->_pd_consumer;
}

// Read/write get method.
Components::SubscriberDescriptions &
OBV_Components::PublisherDescription::consumer (void)
{
  return this->_pd_consumer;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::EventBase *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_EventBase, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::EventBase **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_EventBase, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::EventBase::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::EventBase *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EventBase
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::EventBase *const_holder =
          ACE_static_cast (
              const Components::EventBase *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::EventBase *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::EventBase *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_EventBase,
                1,
                ACE_static_cast (void *, tmp),
                Components::EventBase::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::EventBase, Components::EventBase_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::EventBase, Components::EventBase_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::EventConsumerBase_ptr _tao_elem
  )
{
  Components::EventConsumerBase_ptr _tao_objptr =
    Components::EventConsumerBase::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::EventConsumerBase_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_EventConsumerBase, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::EventConsumerBase::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::EventConsumerBase_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::EventConsumerBase::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EventConsumerBase
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_EventConsumerBase,
            1,
            _tao_elem,
            Components::EventConsumerBase::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::EventConsumerBase::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::EventConsumerBase::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::EventConsumerBase,Components::EventConsumerBase_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::EventConsumerBase,Components::EventConsumerBase_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ConsumerDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_ConsumerDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ConsumerDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_ConsumerDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::ConsumerDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::ConsumerDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConsumerDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::ConsumerDescription *const_holder =
          ACE_static_cast (
              const Components::ConsumerDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::ConsumerDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::ConsumerDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_ConsumerDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConsumerDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ConsumerDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConsumerDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ConsumerDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConsumerDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ConsumerDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ConsumerDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ConsumerDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ConsumerDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConsumerDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ConsumerDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ConsumerDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ConsumerDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ConsumerDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConsumerDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::EmitterDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_EmitterDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::EmitterDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_EmitterDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::EmitterDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::EmitterDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EmitterDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::EmitterDescription *const_holder =
          ACE_static_cast (
              const Components::EmitterDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::EmitterDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::EmitterDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_EmitterDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::EmitterDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::EmitterDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_EmitterDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::EmitterDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_EmitterDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::EmitterDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::EmitterDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::EmitterDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::EmitterDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EmitterDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::EmitterDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::EmitterDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::EmitterDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_EmitterDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::EmitterDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::SubscriberDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_SubscriberDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::SubscriberDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_SubscriberDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::SubscriberDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::SubscriberDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_SubscriberDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::SubscriberDescription *const_holder =
          ACE_static_cast (
              const Components::SubscriberDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::SubscriberDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::SubscriberDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_SubscriberDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::SubscriberDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::SubscriberDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_SubscriberDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::SubscriberDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_SubscriberDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::SubscriberDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::SubscriberDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::SubscriberDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::SubscriberDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_SubscriberDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::SubscriberDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::SubscriberDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::SubscriberDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_SubscriberDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::SubscriberDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::PublisherDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_PublisherDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::PublisherDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_PublisherDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::PublisherDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::PublisherDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_PublisherDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::PublisherDescription *const_holder =
          ACE_static_cast (
              const Components::PublisherDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::PublisherDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::PublisherDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_PublisherDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::PublisherDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::PublisherDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PublisherDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::PublisherDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PublisherDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::PublisherDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::PublisherDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::PublisherDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::PublisherDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_PublisherDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::PublisherDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::PublisherDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::PublisherDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_PublisherDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::PublisherDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Events_ptr _tao_elem
  )
{
  Components::Events_ptr _tao_objptr =
    Components::Events::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Events_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Events, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Events::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::Events_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Events::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Events
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Events,
            1,
            _tao_elem,
            Components::Events::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::Events::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Events::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Events,Components::Events_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::Events,Components::Events_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::EventBase * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::EventBase * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::EventBase *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::EventBase *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::EventBase::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::EventBase *&_tao_valuetype
  )
{
  return Components::EventBase::_tao_unmarshal (strm, _tao_valuetype);
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::EventConsumerBase_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::EventConsumerBase_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::EventConsumerBase::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::ConsumerDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::ConsumerDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::ConsumerDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::ConsumerDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::ConsumerDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::ConsumerDescription *&_tao_valuetype
  )
{
  return Components::ConsumerDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::ConsumerDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (! this->_tao_marshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm << _pd_consumer.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::ConsumerDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (! this->_tao_unmarshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm >> _pd_consumer.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ConsumerDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ConsumerDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::EmitterDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::EmitterDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::EmitterDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::EmitterDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::EmitterDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::EmitterDescription *&_tao_valuetype
  )
{
  return Components::EmitterDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::EmitterDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (! this->_tao_marshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm << _pd_consumer.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::EmitterDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (! this->_tao_unmarshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm >> _pd_consumer.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::EmitterDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::EmitterDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::SubscriberDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::SubscriberDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::SubscriberDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::SubscriberDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::SubscriberDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::SubscriberDescription *&_tao_valuetype
  )
{
  return Components::SubscriberDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::SubscriberDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (! this->_tao_marshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm << _pd_ck.in ()) &&
    (strm << _pd_consumer.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::SubscriberDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (! this->_tao_unmarshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm >> _pd_ck.out ()) &&
    (strm >> _pd_consumer.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::SubscriberDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::SubscriberDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::PublisherDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::PublisherDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::PublisherDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::PublisherDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::PublisherDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::PublisherDescription *&_tao_valuetype
  )
{
  return Components::PublisherDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::PublisherDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (! this->_tao_marshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm << _pd_consumer)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::PublisherDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (! this->_tao_unmarshal__Components_PortDescription (strm))
    {
      return 0;
    }
  
  if (
    (strm >> _pd_consumer)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::PublisherDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::PublisherDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Events_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Events_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::Events::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

