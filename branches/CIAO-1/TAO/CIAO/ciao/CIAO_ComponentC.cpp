// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:320

#include "CIAO_ComponentC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "CIAO_ComponentC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_PrimaryKeyBase[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x72696d61), 
  ACE_NTOHL (0x72794b65), 
  ACE_NTOHL (0x79426173), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/PrimaryKeyBase:1.0
  15,
  ACE_NTOHL (0x5072696d), 
  ACE_NTOHL (0x6172794b), 
  ACE_NTOHL (0x65794261), 
  ACE_NTOHL (0x73650000),  // name = PrimaryKeyBase
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_PrimaryKeyBase (
    CORBA::tk_value,
    sizeof (_oc_Components_PrimaryKeyBase),
    (char *) &_oc_Components_PrimaryKeyBase,
    0,
    sizeof (Components::PrimaryKeyBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_PrimaryKeyBase,
    &_tc_TAO_tc_Components_PrimaryKeyBase
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_PrimaryKeyBase_add_ref (
    Components::PrimaryKeyBase *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_PrimaryKeyBase_remove_ref (
    Components::PrimaryKeyBase *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::PrimaryKeyBase_var
// *************************************************************

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (void)
  : ptr_ (0)
{}

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (PrimaryKeyBase* p)
  : ptr_ (p)
{}

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (const PrimaryKeyBase* p)
  : ptr_ (ACE_const_cast (PrimaryKeyBase *, p))
{}

Components::PrimaryKeyBase *
Components::PrimaryKeyBase_var::ptr (void) const
{
  return this->ptr_;
}

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (const PrimaryKeyBase_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::PrimaryKeyBase_var::~PrimaryKeyBase_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::PrimaryKeyBase_var &
Components::PrimaryKeyBase_var::operator= (PrimaryKeyBase *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::PrimaryKeyBase_var &
Components::PrimaryKeyBase_var::operator= (const PrimaryKeyBase_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    PrimaryKeyBase *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::PrimaryKeyBase_var::operator const Components::PrimaryKeyBase* () const // cast
{
  return this->ptr_;
}

Components::PrimaryKeyBase_var::operator Components::PrimaryKeyBase* () // cast 
{
  return this->ptr_;
}

Components::PrimaryKeyBase *
Components::PrimaryKeyBase_var::operator-> (void) const
{
  return this->ptr_;
}

Components::PrimaryKeyBase *
Components::PrimaryKeyBase_var::in (void) const
{
  return this->ptr_;
}

Components::PrimaryKeyBase *&
Components::PrimaryKeyBase_var::inout (void)
{
  return this->ptr_;
}

Components::PrimaryKeyBase *&
Components::PrimaryKeyBase_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::PrimaryKeyBase *
Components::PrimaryKeyBase_var::_retn (void)
{
  // yield ownership of managed obj reference
  PrimaryKeyBase* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::PrimaryKeyBase_var::tao_add_ref (
    PrimaryKeyBase *p
  )
{
  CORBA::add_ref (p);
}

void
Components::PrimaryKeyBase_var::tao_remove_ref (
    PrimaryKeyBase *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::PrimaryKeyBase_out
// *************************************************************

Components::PrimaryKeyBase_out::PrimaryKeyBase_out (PrimaryKeyBase *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::PrimaryKeyBase_out::PrimaryKeyBase_out (PrimaryKeyBase_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::PrimaryKeyBase_out::PrimaryKeyBase_out (const PrimaryKeyBase_out &p)
  : ptr_ (ACE_const_cast (PrimaryKeyBase_out&, p).ptr_)
{}

Components::PrimaryKeyBase_out &
Components::PrimaryKeyBase_out::operator= (const PrimaryKeyBase_out &p)
{
  this->ptr_ = ACE_const_cast (PrimaryKeyBase_out&, p).ptr_;
  return *this;
}

Components::PrimaryKeyBase_out &
Components::PrimaryKeyBase_out::operator= (const PrimaryKeyBase_var &p)
{
  PrimaryKeyBase *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::PrimaryKeyBase_out &
Components::PrimaryKeyBase_out::operator= (PrimaryKeyBase *p)
{
  this->ptr_ = p;
  return *this;
}

Components::PrimaryKeyBase_out::operator Components::PrimaryKeyBase*& () // cast
{
  return this->ptr_;
}

Components::PrimaryKeyBase *&
Components::PrimaryKeyBase_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::PrimaryKeyBase *
Components::PrimaryKeyBase_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::PrimaryKeyBase *
Components::PrimaryKeyBase::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (PrimaryKeyBase *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::PrimaryKeyBase::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::PrimaryKeyBase::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::PrimaryKeyBase::_tao_any_destructor (void *_tao_void_pointer)
{
  PrimaryKeyBase *tmp =
    ACE_static_cast (
        PrimaryKeyBase *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::PrimaryKeyBase::_tao_unmarshal (
    TAO_InputCDR &strm,
    PrimaryKeyBase *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        PrimaryKeyBase::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = PrimaryKeyBase::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::CCMHome::_tao_class_id = 0;

Components::CCMHome_ptr
tao_Components_CCMHome_duplicate (
    Components::CCMHome_ptr p
  )
{
  return Components::CCMHome::_duplicate (p);
}

void
tao_Components_CCMHome_release (
    Components::CCMHome_ptr p
  )
{
  CORBA::release (p);
}

Components::CCMHome_ptr
tao_Components_CCMHome_nil (
    void
  )
{
  return Components::CCMHome::_nil ();
}

Components::CCMHome_ptr
tao_Components_CCMHome_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::CCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_CCMHome_upcast (
    void *src
  )
{
  Components::CCMHome **tmp =
    ACE_static_cast (Components::CCMHome **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::CCMHome_var
// *************************************************************

Components::CCMHome_var::CCMHome_var (void)
  : ptr_ (CCMHome::_nil ())
{}

::Components::CCMHome_ptr
Components::CCMHome_var::ptr (void) const
{
  return this->ptr_;
}

Components::CCMHome_var::CCMHome_var (const ::Components::CCMHome_var &p)
  : TAO_Base_var (),
    ptr_ (CCMHome::_duplicate (p.ptr ()))
{}

Components::CCMHome_var::~CCMHome_var (void)
{
  CORBA::release (this->ptr_);
}

Components::CCMHome_var &
Components::CCMHome_var::operator= (CCMHome_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::CCMHome_var &
Components::CCMHome_var::operator= (const ::Components::CCMHome_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::CCMHome::_duplicate (p.ptr ());
  }
  return *this;
}

Components::CCMHome_var::operator const ::Components::CCMHome_ptr &() const // cast
{
  return this->ptr_;
}

Components::CCMHome_var::operator ::Components::CCMHome_ptr &() // cast 
{
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_var::in (void) const
{
  return this->ptr_;
}

::Components::CCMHome_ptr &
Components::CCMHome_var::inout (void)
{
  return this->ptr_;
}

::Components::CCMHome_ptr &
Components::CCMHome_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMHome::_nil ();
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::CCMHome_ptr val = this->ptr_;
  this->ptr_ = ::Components::CCMHome::_nil ();
  return val;
}

::Components::CCMHome_ptr
Components::CCMHome_var::tao_duplicate (CCMHome_ptr p)
{
  return ::Components::CCMHome::_duplicate (p);
}

void
Components::CCMHome_var::tao_release (CCMHome_ptr p)
{
  CORBA::release (p);
}

::Components::CCMHome_ptr
Components::CCMHome_var::tao_nil (void)
{
  return ::Components::CCMHome::_nil ();
}

::Components::CCMHome_ptr
Components::CCMHome_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::CCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::CCMHome_var::tao_upcast (void *src)
{
  CCMHome **tmp =
    ACE_static_cast (CCMHome **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::CCMHome_out
// *************************************************************

Components::CCMHome_out::CCMHome_out (CCMHome_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::CCMHome::_nil ();
}

Components::CCMHome_out::CCMHome_out (CCMHome_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMHome::_nil ();
}

Components::CCMHome_out::CCMHome_out (const ::Components::CCMHome_out &p)
  : ptr_ (ACE_const_cast (CCMHome_out &, p).ptr_)
{}

::Components::CCMHome_out &
Components::CCMHome_out::operator= (const ::Components::CCMHome_out &p)
{
  this->ptr_ = ACE_const_cast (CCMHome_out&, p).ptr_;
  return *this;
}

Components::CCMHome_out &
Components::CCMHome_out::operator= (const ::Components::CCMHome_var &p)
{
  this->ptr_ = ::Components::CCMHome::_duplicate (p.ptr ());
  return *this;
}

Components::CCMHome_out &
Components::CCMHome_out::operator= (CCMHome_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::CCMHome_out::operator ::Components::CCMHome_ptr &() // cast
{
  return this->ptr_;
}

::Components::CCMHome_ptr &
Components::CCMHome_out::ptr (void)
{
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMHome_get_component_def : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMHome_get_component_def (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IRObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMHome_get_component_def (const TAO_ClientRequestInfo_Components_CCMHome_get_component_def &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMHome_get_component_def &);
  
  CORBA::IRObject_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMHome_get_component_def::TAO_ClientRequestInfo_Components_CCMHome_get_component_def (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::result (::CORBA::IRObject_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMHome_get_home_def : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMHome_get_home_def (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IRObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMHome_get_home_def (const TAO_ClientRequestInfo_Components_CCMHome_get_home_def &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMHome_get_home_def &);
  
  CORBA::IRObject_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMHome_get_home_def::TAO_ClientRequestInfo_Components_CCMHome_get_home_def (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::result (::CORBA::IRObject_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMHome_remove_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMHome_remove_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::CCMObject_ptr comp);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_CCMHome_remove_component (const TAO_ClientRequestInfo_Components_CCMHome_remove_component &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMHome_remove_component &);
  Components::CCMObject_ptr comp_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMHome_remove_component::TAO_ClientRequestInfo_Components_CCMHome_remove_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::CCMObject_ptr comp    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    comp_ (comp)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMHome_remove_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->comp_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMHome_remove_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMHome_remove_component_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMHome_remove_component_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMHome_remove_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_CCMHome_Proxy_Impl::_TAO_CCMHome_Proxy_Impl (void)
{}

Components::_TAO_CCMHome_Remote_Proxy_Impl::_TAO_CCMHome_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IRObject_ptr Components::_TAO_CCMHome_Remote_Proxy_Impl::get_component_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::IRObject_var _tao_retval (CORBA::IRObject::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_component_def",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMHome_get_component_def _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IRObject_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IRObject_ptr Components::_TAO_CCMHome_Remote_Proxy_Impl::get_home_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::IRObject_var _tao_retval (CORBA::IRObject::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_home_def",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMHome_get_home_def _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IRObject_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_CCMHome_Remote_Proxy_Impl::remove_component (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_CCMHome_remove_component_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove_component",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMHome_remove_component _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          comp
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << comp)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMHome_remove_component_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_CCMHome_Proxy_Broker::_TAO_CCMHome_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Proxy_Broker::~_TAO_CCMHome_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Proxy_Broker * (*Components__TAO_CCMHome_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_CCMHome_Remote_Proxy_Broker *
Components::_TAO_CCMHome_Remote_Proxy_Broker::the_TAO_CCMHome_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_CCMHome_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_CCMHome_Remote_Proxy_Broker::_TAO_CCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Remote_Proxy_Broker::~_TAO_CCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Proxy_Impl&
Components::_TAO_CCMHome_Remote_Proxy_Broker::select_proxy (
    ::Components::CCMHome *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::CCMHome::CCMHome (int collocated)
{
  this->Components_CCMHome_setup_collocation (collocated);
}

void
Components::CCMHome::Components_CCMHome_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CCMHome_Proxy_Broker_ =
      ::Components__TAO_CCMHome_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CCMHome_Proxy_Broker_ =
      ::Components::_TAO_CCMHome_Remote_Proxy_Broker::the_TAO_CCMHome_Remote_Proxy_Broker ();
}

Components::CCMHome::~CCMHome (void)
{}

void 
Components::CCMHome::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMHome *tmp = ACE_static_cast (CCMHome *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::CCMHome_ptr
Components::CCMHome::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return CCMHome::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/CCMHome:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (CCMHome::_nil ());
      
      if (is_a == 0)
        {
          return CCMHome::_nil ();
        }
    }
  
  return CCMHome::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::CCMHome_ptr 
Components::CCMHome::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return CCMHome::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      CCMHome_ptr default_proxy = CCMHome::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_CCMHome_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMHome (
                  stub,
                  1,
                  obj->_servant ()
                ),
              CCMHome::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMHome (
                  stub,
                  0,
                  obj->_servant ()
                ),
              CCMHome::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          CCMHome_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &CCMHome::_tao_class_id
                )
            )
        );
}

Components::CCMHome_ptr
Components::CCMHome::_duplicate (CCMHome_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::CCMHome::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/CCMHome:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::CCMHome::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, CCMHome)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::CCMHome::_interface_repository_id (void) const
{
  return "IDL:Components/CCMHome:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::IRObject_ptr Components::CCMHome::get_component_def (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMHome_Proxy_Impl &proxy = 
    this->the_TAO_CCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_component_def (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::IRObject_ptr Components::CCMHome::get_home_def (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMHome_Proxy_Impl &proxy = 
    this->the_TAO_CCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_home_def (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::CCMHome::remove_component (
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMHome_Proxy_Impl &proxy = 
    this->the_TAO_CCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove_component (
      this,
      comp
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_CCMHome[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  27,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d486f), 
  ACE_NTOHL (0x6d653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/CCMHome:1.0
  8,
  ACE_NTOHL (0x43434d48), 
  ACE_NTOHL (0x6f6d6500),  // name = CCMHome
};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMHome (
    CORBA::tk_objref,
    sizeof (_oc_Components_CCMHome),
    (char *) &_oc_Components_CCMHome,
    0,
    sizeof (Components::CCMHome)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_CCMHome,
    &_tc_TAO_tc_Components_CCMHome
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMHOMES_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMHOMES_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_allocate_buffer (CORBA::ULong length)
{
  Components::CCMHome **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::CCMHome **old = ACE_reinterpret_cast (Components::CCMHome**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = Components::CCMHome::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::CCMHome **tmp = ACE_reinterpret_cast (Components::CCMHome**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMHome::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_Components_CCMHomes::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::~_TAO_Unbounded_Object_Sequence_Components_CCMHomes (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::CCMHome **tmp = ACE_reinterpret_cast (Components::CCMHome**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMHome::_nil ();
    }
}

void 
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  Components::CCMHome **tmp = ACE_static_cast (Components::CCMHome**, target);
  *tmp = Components::CCMHome::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_upcast (void *src) const
{
  Components::CCMHome **tmp = ACE_static_cast (Components::CCMHome**, src);
  return *tmp;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CCMHOMES_CS_)
#define _COMPONENTS_CCMHOMES_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::CCMHomes
// *************************************************************

Components::CCMHomes::CCMHomes (void)
{}

Components::CCMHomes::CCMHomes (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMHomes
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMHome,Components::CCMHome_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::CCMHomes::CCMHomes (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::CCMHome_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMHomes
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMHome,Components::CCMHome_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::CCMHomes::CCMHomes (const CCMHomes &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMHomes
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMHome,Components::CCMHome_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::CCMHomes::~CCMHomes (void) // dtor
{}

void Components::CCMHomes::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMHomes *tmp = ACE_static_cast (CCMHomes*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_CCMHomes[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  28,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d486f), 
  ACE_NTOHL (0x6d65733a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/CCMHomes:1.0
  9,
  ACE_NTOHL (0x43434d48), 
  ACE_NTOHL (0x6f6d6573), 
  ACE_NTOHL (0x0),  // name = CCMHomes
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x434d486f), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/CCMHome:1.0
      8,
      ACE_NTOHL (0x43434d48), 
      ACE_NTOHL (0x6f6d6500),  // name = CCMHome

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMHomes (
    CORBA::tk_alias,
    sizeof (_oc_Components_CCMHomes),
    (char *) &_oc_Components_CCMHomes,
    0,
    sizeof (Components::CCMHomes)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_CCMHomes,
    &_tc_TAO_tc_Components_CCMHomes
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::KeylessCCMHome::_tao_class_id = 0;

Components::KeylessCCMHome_ptr
tao_Components_KeylessCCMHome_duplicate (
    Components::KeylessCCMHome_ptr p
  )
{
  return Components::KeylessCCMHome::_duplicate (p);
}

void
tao_Components_KeylessCCMHome_release (
    Components::KeylessCCMHome_ptr p
  )
{
  CORBA::release (p);
}

Components::KeylessCCMHome_ptr
tao_Components_KeylessCCMHome_nil (
    void
  )
{
  return Components::KeylessCCMHome::_nil ();
}

Components::KeylessCCMHome_ptr
tao_Components_KeylessCCMHome_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::KeylessCCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_KeylessCCMHome_upcast (
    void *src
  )
{
  Components::KeylessCCMHome **tmp =
    ACE_static_cast (Components::KeylessCCMHome **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::KeylessCCMHome_var
// *************************************************************

Components::KeylessCCMHome_var::KeylessCCMHome_var (void)
  : ptr_ (KeylessCCMHome::_nil ())
{}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::ptr (void) const
{
  return this->ptr_;
}

Components::KeylessCCMHome_var::KeylessCCMHome_var (const ::Components::KeylessCCMHome_var &p)
  : TAO_Base_var (),
    ptr_ (KeylessCCMHome::_duplicate (p.ptr ()))
{}

Components::KeylessCCMHome_var::~KeylessCCMHome_var (void)
{
  CORBA::release (this->ptr_);
}

Components::KeylessCCMHome_var &
Components::KeylessCCMHome_var::operator= (KeylessCCMHome_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::KeylessCCMHome_var &
Components::KeylessCCMHome_var::operator= (const ::Components::KeylessCCMHome_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::KeylessCCMHome::_duplicate (p.ptr ());
  }
  return *this;
}

Components::KeylessCCMHome_var::operator const ::Components::KeylessCCMHome_ptr &() const // cast
{
  return this->ptr_;
}

Components::KeylessCCMHome_var::operator ::Components::KeylessCCMHome_ptr &() // cast 
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::in (void) const
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr &
Components::KeylessCCMHome_var::inout (void)
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr &
Components::KeylessCCMHome_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::KeylessCCMHome_ptr val = this->ptr_;
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
  return val;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::tao_duplicate (KeylessCCMHome_ptr p)
{
  return ::Components::KeylessCCMHome::_duplicate (p);
}

void
Components::KeylessCCMHome_var::tao_release (KeylessCCMHome_ptr p)
{
  CORBA::release (p);
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::tao_nil (void)
{
  return ::Components::KeylessCCMHome::_nil ();
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::KeylessCCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::KeylessCCMHome_var::tao_upcast (void *src)
{
  KeylessCCMHome **tmp =
    ACE_static_cast (KeylessCCMHome **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::KeylessCCMHome_out
// *************************************************************

Components::KeylessCCMHome_out::KeylessCCMHome_out (KeylessCCMHome_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
}

Components::KeylessCCMHome_out::KeylessCCMHome_out (KeylessCCMHome_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
}

Components::KeylessCCMHome_out::KeylessCCMHome_out (const ::Components::KeylessCCMHome_out &p)
  : ptr_ (ACE_const_cast (KeylessCCMHome_out &, p).ptr_)
{}

::Components::KeylessCCMHome_out &
Components::KeylessCCMHome_out::operator= (const ::Components::KeylessCCMHome_out &p)
{
  this->ptr_ = ACE_const_cast (KeylessCCMHome_out&, p).ptr_;
  return *this;
}

Components::KeylessCCMHome_out &
Components::KeylessCCMHome_out::operator= (const ::Components::KeylessCCMHome_var &p)
{
  this->ptr_ = ::Components::KeylessCCMHome::_duplicate (p.ptr ());
  return *this;
}

Components::KeylessCCMHome_out &
Components::KeylessCCMHome_out::operator= (KeylessCCMHome_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::KeylessCCMHome_out::operator ::Components::KeylessCCMHome_ptr &() // cast
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr &
Components::KeylessCCMHome_out::ptr (void)
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component (const TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component &);
  void operator= (const TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component &);
  
  Components::CCMObject_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_KeylessCCMHome_create_component_exceptiondata[] = 
  {
    Components::_tc_CreateFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_KeylessCCMHome_create_component_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::result (::Components::CCMObject_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_KeylessCCMHome_Proxy_Impl::_TAO_KeylessCCMHome_Proxy_Impl (void)
{}

Components::_TAO_KeylessCCMHome_Remote_Proxy_Impl::_TAO_KeylessCCMHome_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::CCMObject_ptr Components::_TAO_KeylessCCMHome_Remote_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_KeylessCCMHome_create_component_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/CreateFailure:1.0",
      Components::CreateFailure::_alloc
    }
  };

Components::CCMObject_var _tao_retval (Components::CCMObject::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component",
      16,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (_tao_Components_KeylessCCMHome_create_component_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMObject_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_KeylessCCMHome_Proxy_Broker::_TAO_KeylessCCMHome_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Proxy_Broker::~_TAO_KeylessCCMHome_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Proxy_Broker * (*Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker *
Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::the_TAO_KeylessCCMHome_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::_TAO_KeylessCCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::~_TAO_KeylessCCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Proxy_Impl&
Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::select_proxy (
    ::Components::KeylessCCMHome *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::KeylessCCMHome::KeylessCCMHome (int collocated)
{
  this->Components_KeylessCCMHome_setup_collocation (collocated);
}

void
Components::KeylessCCMHome::Components_KeylessCCMHome_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_KeylessCCMHome_Proxy_Broker_ =
      ::Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_KeylessCCMHome_Proxy_Broker_ =
      ::Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::the_TAO_KeylessCCMHome_Remote_Proxy_Broker ();
}

Components::KeylessCCMHome::~KeylessCCMHome (void)
{}

void 
Components::KeylessCCMHome::_tao_any_destructor (void *_tao_void_pointer)
{
  KeylessCCMHome *tmp = ACE_static_cast (KeylessCCMHome *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::KeylessCCMHome_ptr
Components::KeylessCCMHome::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return KeylessCCMHome::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/KeylessCCMHome:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (KeylessCCMHome::_nil ());
      
      if (is_a == 0)
        {
          return KeylessCCMHome::_nil ();
        }
    }
  
  return KeylessCCMHome::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::KeylessCCMHome_ptr 
Components::KeylessCCMHome::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return KeylessCCMHome::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      KeylessCCMHome_ptr default_proxy = KeylessCCMHome::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::KeylessCCMHome (
                  stub,
                  1,
                  obj->_servant ()
                ),
              KeylessCCMHome::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::KeylessCCMHome (
                  stub,
                  0,
                  obj->_servant ()
                ),
              KeylessCCMHome::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          KeylessCCMHome_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &KeylessCCMHome::_tao_class_id
                )
            )
        );
}

Components::KeylessCCMHome_ptr
Components::KeylessCCMHome::_duplicate (KeylessCCMHome_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::KeylessCCMHome::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/KeylessCCMHome:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::KeylessCCMHome::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, KeylessCCMHome)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::KeylessCCMHome::_interface_repository_id (void) const
{
  return "IDL:Components/KeylessCCMHome:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::CCMObject_ptr Components::KeylessCCMHome::create_component (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_KeylessCCMHome_Proxy_Impl &proxy = 
    this->the_TAO_KeylessCCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_component (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_KeylessCCMHome[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4b), 
  ACE_NTOHL (0x65796c65), 
  ACE_NTOHL (0x73734343), 
  ACE_NTOHL (0x4d486f6d), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/KeylessCCMHome:1.0
  15,
  ACE_NTOHL (0x4b65796c), 
  ACE_NTOHL (0x65737343), 
  ACE_NTOHL (0x434d486f), 
  ACE_NTOHL (0x6d650000),  // name = KeylessCCMHome
};

static CORBA::TypeCode _tc_TAO_tc_Components_KeylessCCMHome (
    CORBA::tk_objref,
    sizeof (_oc_Components_KeylessCCMHome),
    (char *) &_oc_Components_KeylessCCMHome,
    0,
    sizeof (Components::KeylessCCMHome)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_KeylessCCMHome,
    &_tc_TAO_tc_Components_KeylessCCMHome
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::HomeFinder::_tao_class_id = 0;

Components::HomeFinder_ptr
tao_Components_HomeFinder_duplicate (
    Components::HomeFinder_ptr p
  )
{
  return Components::HomeFinder::_duplicate (p);
}

void
tao_Components_HomeFinder_release (
    Components::HomeFinder_ptr p
  )
{
  CORBA::release (p);
}

Components::HomeFinder_ptr
tao_Components_HomeFinder_nil (
    void
  )
{
  return Components::HomeFinder::_nil ();
}

Components::HomeFinder_ptr
tao_Components_HomeFinder_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::HomeFinder::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_HomeFinder_upcast (
    void *src
  )
{
  Components::HomeFinder **tmp =
    ACE_static_cast (Components::HomeFinder **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::HomeFinder_var
// *************************************************************

Components::HomeFinder_var::HomeFinder_var (void)
  : ptr_ (HomeFinder::_nil ())
{}

::Components::HomeFinder_ptr
Components::HomeFinder_var::ptr (void) const
{
  return this->ptr_;
}

Components::HomeFinder_var::HomeFinder_var (const ::Components::HomeFinder_var &p)
  : TAO_Base_var (),
    ptr_ (HomeFinder::_duplicate (p.ptr ()))
{}

Components::HomeFinder_var::~HomeFinder_var (void)
{
  CORBA::release (this->ptr_);
}

Components::HomeFinder_var &
Components::HomeFinder_var::operator= (HomeFinder_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::HomeFinder_var &
Components::HomeFinder_var::operator= (const ::Components::HomeFinder_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::HomeFinder::_duplicate (p.ptr ());
  }
  return *this;
}

Components::HomeFinder_var::operator const ::Components::HomeFinder_ptr &() const // cast
{
  return this->ptr_;
}

Components::HomeFinder_var::operator ::Components::HomeFinder_ptr &() // cast 
{
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::in (void) const
{
  return this->ptr_;
}

::Components::HomeFinder_ptr &
Components::HomeFinder_var::inout (void)
{
  return this->ptr_;
}

::Components::HomeFinder_ptr &
Components::HomeFinder_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeFinder::_nil ();
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::HomeFinder_ptr val = this->ptr_;
  this->ptr_ = ::Components::HomeFinder::_nil ();
  return val;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::tao_duplicate (HomeFinder_ptr p)
{
  return ::Components::HomeFinder::_duplicate (p);
}

void
Components::HomeFinder_var::tao_release (HomeFinder_ptr p)
{
  CORBA::release (p);
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::tao_nil (void)
{
  return ::Components::HomeFinder::_nil ();
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::HomeFinder::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::HomeFinder_var::tao_upcast (void *src)
{
  HomeFinder **tmp =
    ACE_static_cast (HomeFinder **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::HomeFinder_out
// *************************************************************

Components::HomeFinder_out::HomeFinder_out (HomeFinder_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::HomeFinder::_nil ();
}

Components::HomeFinder_out::HomeFinder_out (HomeFinder_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeFinder::_nil ();
}

Components::HomeFinder_out::HomeFinder_out (const ::Components::HomeFinder_out &p)
  : ptr_ (ACE_const_cast (HomeFinder_out &, p).ptr_)
{}

::Components::HomeFinder_out &
Components::HomeFinder_out::operator= (const ::Components::HomeFinder_out &p)
{
  this->ptr_ = ACE_const_cast (HomeFinder_out&, p).ptr_;
  return *this;
}

Components::HomeFinder_out &
Components::HomeFinder_out::operator= (const ::Components::HomeFinder_var &p)
{
  this->ptr_ = ::Components::HomeFinder::_duplicate (p.ptr ());
  return *this;
}

Components::HomeFinder_out &
Components::HomeFinder_out::operator= (HomeFinder_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::HomeFinder_out::operator ::Components::HomeFinder_ptr &() // cast
{
  return this->ptr_;
}

::Components::HomeFinder_ptr &
Components::HomeFinder_out::ptr (void)
{
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * comp_repid);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type &);
  const char * comp_repid_;
  
  Components::CCMHome_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * comp_repid    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    comp_repid_ (comp_repid)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= comp_repid_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::result (::Components::CCMHome_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * home_repid);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type &);
  const char * home_repid_;
  
  Components::CCMHome_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * home_repid    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    home_repid_ (home_repid)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= home_repid_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::result (::Components::CCMHome_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * home_name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name &);
  const char * home_name_;
  
  Components::CCMHome_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * home_name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    home_name_ (home_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= home_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_name_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_name_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::result (::Components::CCMHome_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_HomeFinder_Proxy_Impl::_TAO_HomeFinder_Proxy_Impl (void)
{}

Components::_TAO_HomeFinder_Remote_Proxy_Impl::_TAO_HomeFinder_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::CCMHome_ptr Components::_TAO_HomeFinder_Remote_Proxy_Impl::find_home_by_component_type (
    CORBA_Object *_collocated_tao_target_,
    const char * comp_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/HomeNotFound:1.0",
      Components::HomeNotFound::_alloc
    }
  };

Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "find_home_by_component_type",
      27,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          comp_repid
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << comp_repid)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_HomeFinder_find_home_by_component_type_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::CCMHome_ptr Components::_TAO_HomeFinder_Remote_Proxy_Impl::find_home_by_home_type (
    CORBA_Object *_collocated_tao_target_,
    const char * home_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/HomeNotFound:1.0",
      Components::HomeNotFound::_alloc
    }
  };

Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "find_home_by_home_type",
      22,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          home_repid
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << home_repid)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_HomeFinder_find_home_by_home_type_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::CCMHome_ptr Components::_TAO_HomeFinder_Remote_Proxy_Impl::find_home_by_name (
    CORBA_Object *_collocated_tao_target_,
    const char * home_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_HomeFinder_find_home_by_name_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/HomeNotFound:1.0",
      Components::HomeNotFound::_alloc
    }
  };

Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "find_home_by_name",
      17,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          home_name
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << home_name)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_HomeFinder_find_home_by_name_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_HomeFinder_Proxy_Broker::_TAO_HomeFinder_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Proxy_Broker::~_TAO_HomeFinder_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Proxy_Broker * (*Components__TAO_HomeFinder_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_HomeFinder_Remote_Proxy_Broker *
Components::_TAO_HomeFinder_Remote_Proxy_Broker::the_TAO_HomeFinder_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_HomeFinder_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_HomeFinder_Remote_Proxy_Broker::_TAO_HomeFinder_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Remote_Proxy_Broker::~_TAO_HomeFinder_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Proxy_Impl&
Components::_TAO_HomeFinder_Remote_Proxy_Broker::select_proxy (
    ::Components::HomeFinder *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::HomeFinder::HomeFinder (int collocated)
{
  this->Components_HomeFinder_setup_collocation (collocated);
}

void
Components::HomeFinder::Components_HomeFinder_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeFinder_Proxy_Broker_ =
      ::Components__TAO_HomeFinder_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeFinder_Proxy_Broker_ =
      ::Components::_TAO_HomeFinder_Remote_Proxy_Broker::the_TAO_HomeFinder_Remote_Proxy_Broker ();
}

Components::HomeFinder::~HomeFinder (void)
{}

void 
Components::HomeFinder::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeFinder *tmp = ACE_static_cast (HomeFinder *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::HomeFinder_ptr
Components::HomeFinder::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return HomeFinder::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/HomeFinder:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (HomeFinder::_nil ());
      
      if (is_a == 0)
        {
          return HomeFinder::_nil ();
        }
    }
  
  return HomeFinder::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::HomeFinder_ptr 
Components::HomeFinder::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return HomeFinder::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      HomeFinder_ptr default_proxy = HomeFinder::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_HomeFinder_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeFinder (
                  stub,
                  1,
                  obj->_servant ()
                ),
              HomeFinder::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeFinder (
                  stub,
                  0,
                  obj->_servant ()
                ),
              HomeFinder::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          HomeFinder_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &HomeFinder::_tao_class_id
                )
            )
        );
}

Components::HomeFinder_ptr
Components::HomeFinder::_duplicate (HomeFinder_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::HomeFinder::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/HomeFinder:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::HomeFinder::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, HomeFinder)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::HomeFinder::_interface_repository_id (void) const
{
  return "IDL:Components/HomeFinder:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::CCMHome_ptr Components::HomeFinder::find_home_by_component_type (
    const char * comp_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeFinder_Proxy_Impl &proxy = 
    this->the_TAO_HomeFinder_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.find_home_by_component_type (
      this,
      comp_repid
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::CCMHome_ptr Components::HomeFinder::find_home_by_home_type (
    const char * home_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeFinder_Proxy_Impl &proxy = 
    this->the_TAO_HomeFinder_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.find_home_by_home_type (
      this,
      home_repid
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::CCMHome_ptr Components::HomeFinder::find_home_by_name (
    const char * home_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeFinder_Proxy_Impl &proxy = 
    this->the_TAO_HomeFinder_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.find_home_by_name (
      this,
      home_name
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_HomeFinder[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  30,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d6546), 
  ACE_NTOHL (0x696e6465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/HomeFinder:1.0
  11,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x46696e64), 
  ACE_NTOHL (0x65720000),  // name = HomeFinder
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeFinder (
    CORBA::tk_objref,
    sizeof (_oc_Components_HomeFinder),
    (char *) &_oc_Components_HomeFinder,
    0,
    sizeof (Components::HomeFinder)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_HomeFinder,
    &_tc_TAO_tc_Components_HomeFinder
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::Configurator::_tao_class_id = 0;

Components::Configurator_ptr
tao_Components_Configurator_duplicate (
    Components::Configurator_ptr p
  )
{
  return Components::Configurator::_duplicate (p);
}

void
tao_Components_Configurator_release (
    Components::Configurator_ptr p
  )
{
  CORBA::release (p);
}

Components::Configurator_ptr
tao_Components_Configurator_nil (
    void
  )
{
  return Components::Configurator::_nil ();
}

Components::Configurator_ptr
tao_Components_Configurator_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Configurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Configurator_upcast (
    void *src
  )
{
  Components::Configurator **tmp =
    ACE_static_cast (Components::Configurator **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::Configurator_var
// *************************************************************

Components::Configurator_var::Configurator_var (void)
  : ptr_ (Configurator::_nil ())
{}

::Components::Configurator_ptr
Components::Configurator_var::ptr (void) const
{
  return this->ptr_;
}

Components::Configurator_var::Configurator_var (const ::Components::Configurator_var &p)
  : TAO_Base_var (),
    ptr_ (Configurator::_duplicate (p.ptr ()))
{}

Components::Configurator_var::~Configurator_var (void)
{
  CORBA::release (this->ptr_);
}

Components::Configurator_var &
Components::Configurator_var::operator= (Configurator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Configurator_var &
Components::Configurator_var::operator= (const ::Components::Configurator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Configurator::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Configurator_var::operator const ::Components::Configurator_ptr &() const // cast
{
  return this->ptr_;
}

Components::Configurator_var::operator ::Components::Configurator_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_var::in (void) const
{
  return this->ptr_;
}

::Components::Configurator_ptr &
Components::Configurator_var::inout (void)
{
  return this->ptr_;
}

::Components::Configurator_ptr &
Components::Configurator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Configurator::_nil ();
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Configurator_ptr val = this->ptr_;
  this->ptr_ = ::Components::Configurator::_nil ();
  return val;
}

::Components::Configurator_ptr
Components::Configurator_var::tao_duplicate (Configurator_ptr p)
{
  return ::Components::Configurator::_duplicate (p);
}

void
Components::Configurator_var::tao_release (Configurator_ptr p)
{
  CORBA::release (p);
}

::Components::Configurator_ptr
Components::Configurator_var::tao_nil (void)
{
  return ::Components::Configurator::_nil ();
}

::Components::Configurator_ptr
Components::Configurator_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Configurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Configurator_var::tao_upcast (void *src)
{
  Configurator **tmp =
    ACE_static_cast (Configurator **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::Configurator_out
// *************************************************************

Components::Configurator_out::Configurator_out (Configurator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Configurator::_nil ();
}

Components::Configurator_out::Configurator_out (Configurator_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Configurator::_nil ();
}

Components::Configurator_out::Configurator_out (const ::Components::Configurator_out &p)
  : ptr_ (ACE_const_cast (Configurator_out &, p).ptr_)
{}

::Components::Configurator_out &
Components::Configurator_out::operator= (const ::Components::Configurator_out &p)
{
  this->ptr_ = ACE_const_cast (Configurator_out&, p).ptr_;
  return *this;
}

Components::Configurator_out &
Components::Configurator_out::operator= (const ::Components::Configurator_var &p)
{
  this->ptr_ = ::Components::Configurator::_duplicate (p.ptr ());
  return *this;
}

Components::Configurator_out &
Components::Configurator_out::operator= (Configurator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Configurator_out::operator ::Components::Configurator_ptr &() // cast
{
  return this->ptr_;
}

::Components::Configurator_ptr &
Components::Configurator_out::ptr (void)
{
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_Configurator_configure : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Configurator_configure (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::CCMObject_ptr comp);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Configurator_configure (const TAO_ClientRequestInfo_Components_Configurator_configure &);
  void operator= (const TAO_ClientRequestInfo_Components_Configurator_configure &);
  Components::CCMObject_ptr comp_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_Configurator_configure::TAO_ClientRequestInfo_Components_Configurator_configure (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::CCMObject_ptr comp    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    comp_ (comp)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Configurator_configure::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->comp_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Configurator_configure::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Configurator_configure_exceptiondata[] = 
  {
    Components::_tc_WrongComponentType
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Configurator_configure_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Configurator_configure::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Configurator_Proxy_Impl::_TAO_Configurator_Proxy_Impl (void)
{}

Components::_TAO_Configurator_Remote_Proxy_Impl::_TAO_Configurator_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_Configurator_Remote_Proxy_Impl::configure (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::WrongComponentType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_Configurator_configure_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/WrongComponentType:1.0",
      Components::WrongComponentType::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "configure",
      9,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Configurator_configure _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          comp
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << comp)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (_tao_Components_Configurator_configure_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Configurator_Proxy_Broker::_TAO_Configurator_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Proxy_Broker::~_TAO_Configurator_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Proxy_Broker * (*Components__TAO_Configurator_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Configurator_Remote_Proxy_Broker *
Components::_TAO_Configurator_Remote_Proxy_Broker::the_TAO_Configurator_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Configurator_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Configurator_Remote_Proxy_Broker::_TAO_Configurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Remote_Proxy_Broker::~_TAO_Configurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Proxy_Impl&
Components::_TAO_Configurator_Remote_Proxy_Broker::select_proxy (
    ::Components::Configurator *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::Configurator::Configurator (int collocated)
{
  this->Components_Configurator_setup_collocation (collocated);
}

void
Components::Configurator::Components_Configurator_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Configurator_Proxy_Broker_ =
      ::Components__TAO_Configurator_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Configurator_Proxy_Broker_ =
      ::Components::_TAO_Configurator_Remote_Proxy_Broker::the_TAO_Configurator_Remote_Proxy_Broker ();
}

Components::Configurator::~Configurator (void)
{}

void 
Components::Configurator::_tao_any_destructor (void *_tao_void_pointer)
{
  Configurator *tmp = ACE_static_cast (Configurator *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Configurator_ptr
Components::Configurator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Configurator::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/Configurator:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Configurator::_nil ());
      
      if (is_a == 0)
        {
          return Configurator::_nil ();
        }
    }
  
  return Configurator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Configurator_ptr 
Components::Configurator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Configurator::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Configurator_ptr default_proxy = Configurator::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Configurator_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Configurator (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Configurator::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Configurator (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Configurator::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Configurator_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Configurator::_tao_class_id
                )
            )
        );
}

Components::Configurator_ptr
Components::Configurator::_duplicate (Configurator_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::Configurator::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/Configurator:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::Configurator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, Configurator)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::Configurator::_interface_repository_id (void) const
{
  return "IDL:Components/Configurator:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::Configurator::configure (
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::WrongComponentType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Configurator_Proxy_Impl &proxy = 
    this->the_TAO_Configurator_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.configure (
      this,
      comp
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Configurator[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x746f723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/Configurator:1.0
  13,
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69677572), 
  ACE_NTOHL (0x61746f72), 
  ACE_NTOHL (0x0),  // name = Configurator
};

static CORBA::TypeCode _tc_TAO_tc_Components_Configurator (
    CORBA::tk_objref,
    sizeof (_oc_Components_Configurator),
    (char *) &_oc_Components_Configurator,
    0,
    sizeof (Components::Configurator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Configurator,
    &_tc_TAO_tc_Components_Configurator
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ConfigValue[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x6756616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/ConfigValue:1.0
  12,
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69675661), 
  ACE_NTOHL (0x6c756500),  // name = ConfigValue
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  2, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x65617475), 
    ACE_NTOHL (0x72654e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
    12,
    ACE_NTOHL (0x46656174), 
    ACE_NTOHL (0x7572654e), 
    ACE_NTOHL (0x616d6500),  // name = FeatureName
    CORBA::tk_string, 
    0U, // string length

  1, // data member visibility marker

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConfigValue (
    CORBA::tk_value,
    sizeof (_oc_Components_ConfigValue),
    (char *) &_oc_Components_ConfigValue,
    0,
    sizeof (Components::ConfigValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConfigValue,
    &_tc_TAO_tc_Components_ConfigValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_ConfigValue_add_ref (
    Components::ConfigValue *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_ConfigValue_remove_ref (
    Components::ConfigValue *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::ConfigValue_var
// *************************************************************

Components::ConfigValue_var::ConfigValue_var (void)
  : ptr_ (0)
{}

Components::ConfigValue_var::ConfigValue_var (ConfigValue* p)
  : ptr_ (p)
{}

Components::ConfigValue_var::ConfigValue_var (const ConfigValue* p)
  : ptr_ (ACE_const_cast (ConfigValue *, p))
{}

Components::ConfigValue *
Components::ConfigValue_var::ptr (void) const
{
  return this->ptr_;
}

Components::ConfigValue_var::ConfigValue_var (const ConfigValue_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ConfigValue_var::~ConfigValue_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ConfigValue_var &
Components::ConfigValue_var::operator= (ConfigValue *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ConfigValue_var &
Components::ConfigValue_var::operator= (const ConfigValue_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ConfigValue *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::ConfigValue_var::operator const Components::ConfigValue* () const // cast
{
  return this->ptr_;
}

Components::ConfigValue_var::operator Components::ConfigValue* () // cast 
{
  return this->ptr_;
}

Components::ConfigValue *
Components::ConfigValue_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ConfigValue *
Components::ConfigValue_var::in (void) const
{
  return this->ptr_;
}

Components::ConfigValue *&
Components::ConfigValue_var::inout (void)
{
  return this->ptr_;
}

Components::ConfigValue *&
Components::ConfigValue_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ConfigValue *
Components::ConfigValue_var::_retn (void)
{
  // yield ownership of managed obj reference
  ConfigValue* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::ConfigValue_var::tao_add_ref (
    ConfigValue *p
  )
{
  CORBA::add_ref (p);
}

void
Components::ConfigValue_var::tao_remove_ref (
    ConfigValue *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::ConfigValue_out
// *************************************************************

Components::ConfigValue_out::ConfigValue_out (ConfigValue *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ConfigValue_out::ConfigValue_out (ConfigValue_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ConfigValue_out::ConfigValue_out (const ConfigValue_out &p)
  : ptr_ (ACE_const_cast (ConfigValue_out&, p).ptr_)
{}

Components::ConfigValue_out &
Components::ConfigValue_out::operator= (const ConfigValue_out &p)
{
  this->ptr_ = ACE_const_cast (ConfigValue_out&, p).ptr_;
  return *this;
}

Components::ConfigValue_out &
Components::ConfigValue_out::operator= (const ConfigValue_var &p)
{
  ConfigValue *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ConfigValue_out &
Components::ConfigValue_out::operator= (ConfigValue *p)
{
  this->ptr_ = p;
  return *this;
}

Components::ConfigValue_out::operator Components::ConfigValue*& () // cast
{
  return this->ptr_;
}

Components::ConfigValue *&
Components::ConfigValue_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ConfigValue *
Components::ConfigValue_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::ConfigValue *
Components::ConfigValue::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (ConfigValue *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::ConfigValue::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::ConfigValue::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::ConfigValue::_tao_any_destructor (void *_tao_void_pointer)
{
  ConfigValue *tmp =
    ACE_static_cast (
        ConfigValue *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::ConfigValue::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ConfigValue (strm);
}

CORBA::Boolean Components::ConfigValue::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ConfigValue (strm);
}

CORBA::Boolean Components::ConfigValue::_tao_unmarshal (
    TAO_InputCDR &strm,
    ConfigValue *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        ConfigValue::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ConfigValue::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::ConfigValue_init::ConfigValue_init (void)
{
}

Components::ConfigValue_init::~ConfigValue_init (void)
{
}

const char* 
Components::ConfigValue_init::tao_repository_id (void)
{
  return Components::ConfigValue::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::ConfigValue_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::ConfigValue,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONFIGVALUES_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONFIGVALUES_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_allocate_buffer (CORBA::ULong length)
{
  Components::ConfigValue **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::ConfigValue **old = ACE_reinterpret_cast (Components::ConfigValue**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tao_Components_ConfigValue_add_ref (old[i]);
              tmp[i] = old[i];
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::ConfigValue **tmp = ACE_reinterpret_cast (Components::ConfigValue**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tao_Components_ConfigValue_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::~_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ConfigValue **tmp = ACE_reinterpret_cast (Components::ConfigValue**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      tao_Components_ConfigValue_remove_ref (tmp[i]);
      tmp[i] = 0;
    }
}



#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONFIGVALUES_CS_)
#define _COMPONENTS_CONFIGVALUES_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::ConfigValues
// *************************************************************

Components::ConfigValues::ConfigValues (void)
{}

Components::ConfigValues::ConfigValues (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConfigValue,Components::ConfigValue_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::ConfigValues::ConfigValues (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::ConfigValue_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConfigValue,Components::ConfigValue_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::ConfigValues::ConfigValues (const ConfigValues &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConfigValue,Components::ConfigValue_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::ConfigValues::~ConfigValues (void) // dtor
{}

void Components::ConfigValues::_tao_any_destructor (void *_tao_void_pointer)
{
  ConfigValues *tmp = ACE_static_cast (ConfigValues*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ConfigValues[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x6756616c), 
  ACE_NTOHL (0x7565733a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/ConfigValues:1.0
  13,
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69675661), 
  ACE_NTOHL (0x6c756573), 
  ACE_NTOHL (0x0),  // name = ConfigValues
  CORBA::tk_sequence, // typecode kind
  200, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    184, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x6f6e6669), 
      ACE_NTOHL (0x6756616c), 
      ACE_NTOHL (0x75653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/ConfigValue:1.0
      12,
      ACE_NTOHL (0x436f6e66), 
      ACE_NTOHL (0x69675661), 
      ACE_NTOHL (0x6c756500),  // name = ConfigValue
      0, // value modifier
      CORBA::tk_null, // no stateful base valuetype

      2, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        39,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f46), 
        ACE_NTOHL (0x65617475), 
        ACE_NTOHL (0x72654e61), 
        ACE_NTOHL (0x6d653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
        12,
        ACE_NTOHL (0x46656174), 
        ACE_NTOHL (0x7572654e), 
        ACE_NTOHL (0x616d6500),  // name = FeatureName
        CORBA::tk_string, 
        0U, // string length

      1, // data member visibility marker

      6,
      ACE_NTOHL (0x76616c75), 
      ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,

      1, // data member visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConfigValues (
    CORBA::tk_alias,
    sizeof (_oc_Components_ConfigValues),
    (char *) &_oc_Components_ConfigValues,
    0,
    sizeof (Components::ConfigValues)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConfigValues,
    &_tc_TAO_tc_Components_ConfigValues
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::StandardConfigurator::_tao_class_id = 0;

Components::StandardConfigurator_ptr
tao_Components_StandardConfigurator_duplicate (
    Components::StandardConfigurator_ptr p
  )
{
  return Components::StandardConfigurator::_duplicate (p);
}

void
tao_Components_StandardConfigurator_release (
    Components::StandardConfigurator_ptr p
  )
{
  CORBA::release (p);
}

Components::StandardConfigurator_ptr
tao_Components_StandardConfigurator_nil (
    void
  )
{
  return Components::StandardConfigurator::_nil ();
}

Components::StandardConfigurator_ptr
tao_Components_StandardConfigurator_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::StandardConfigurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_StandardConfigurator_upcast (
    void *src
  )
{
  Components::StandardConfigurator **tmp =
    ACE_static_cast (Components::StandardConfigurator **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::StandardConfigurator_var
// *************************************************************

Components::StandardConfigurator_var::StandardConfigurator_var (void)
  : ptr_ (StandardConfigurator::_nil ())
{}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::ptr (void) const
{
  return this->ptr_;
}

Components::StandardConfigurator_var::StandardConfigurator_var (const ::Components::StandardConfigurator_var &p)
  : TAO_Base_var (),
    ptr_ (StandardConfigurator::_duplicate (p.ptr ()))
{}

Components::StandardConfigurator_var::~StandardConfigurator_var (void)
{
  CORBA::release (this->ptr_);
}

Components::StandardConfigurator_var &
Components::StandardConfigurator_var::operator= (StandardConfigurator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::StandardConfigurator_var &
Components::StandardConfigurator_var::operator= (const ::Components::StandardConfigurator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::StandardConfigurator::_duplicate (p.ptr ());
  }
  return *this;
}

Components::StandardConfigurator_var::operator const ::Components::StandardConfigurator_ptr &() const // cast
{
  return this->ptr_;
}

Components::StandardConfigurator_var::operator ::Components::StandardConfigurator_ptr &() // cast 
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::in (void) const
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr &
Components::StandardConfigurator_var::inout (void)
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr &
Components::StandardConfigurator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::StandardConfigurator_ptr val = this->ptr_;
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
  return val;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::tao_duplicate (StandardConfigurator_ptr p)
{
  return ::Components::StandardConfigurator::_duplicate (p);
}

void
Components::StandardConfigurator_var::tao_release (StandardConfigurator_ptr p)
{
  CORBA::release (p);
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::tao_nil (void)
{
  return ::Components::StandardConfigurator::_nil ();
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::StandardConfigurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::StandardConfigurator_var::tao_upcast (void *src)
{
  StandardConfigurator **tmp =
    ACE_static_cast (StandardConfigurator **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::StandardConfigurator_out
// *************************************************************

Components::StandardConfigurator_out::StandardConfigurator_out (StandardConfigurator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
}

Components::StandardConfigurator_out::StandardConfigurator_out (StandardConfigurator_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
}

Components::StandardConfigurator_out::StandardConfigurator_out (const ::Components::StandardConfigurator_out &p)
  : ptr_ (ACE_const_cast (StandardConfigurator_out &, p).ptr_)
{}

::Components::StandardConfigurator_out &
Components::StandardConfigurator_out::operator= (const ::Components::StandardConfigurator_out &p)
{
  this->ptr_ = ACE_const_cast (StandardConfigurator_out&, p).ptr_;
  return *this;
}

Components::StandardConfigurator_out &
Components::StandardConfigurator_out::operator= (const ::Components::StandardConfigurator_var &p)
{
  this->ptr_ = ::Components::StandardConfigurator::_duplicate (p.ptr ());
  return *this;
}

Components::StandardConfigurator_out &
Components::StandardConfigurator_out::operator= (StandardConfigurator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::StandardConfigurator_out::operator ::Components::StandardConfigurator_ptr &() // cast
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr &
Components::StandardConfigurator_out::ptr (void)
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::ConfigValues & descr);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration (const TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration &);
  void operator= (const TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration &);
  const Components::ConfigValues & descr_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::ConfigValues & descr    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    descr_ (descr)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->descr_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_StandardConfigurator_Proxy_Impl::_TAO_StandardConfigurator_Proxy_Impl (void)
{}

Components::_TAO_StandardConfigurator_Remote_Proxy_Impl::_TAO_StandardConfigurator_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_StandardConfigurator_Remote_Proxy_Impl::set_configuration (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & descr
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_configuration",
      17,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          descr
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << descr)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_StandardConfigurator_Proxy_Broker::_TAO_StandardConfigurator_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Proxy_Broker::~_TAO_StandardConfigurator_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Proxy_Broker * (*Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_StandardConfigurator_Remote_Proxy_Broker *
Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::the_TAO_StandardConfigurator_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_StandardConfigurator_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::_TAO_StandardConfigurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::~_TAO_StandardConfigurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Proxy_Impl&
Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::select_proxy (
    ::Components::StandardConfigurator *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::StandardConfigurator::StandardConfigurator (int collocated)
{
  this->Components_StandardConfigurator_setup_collocation (collocated);
}

void
Components::StandardConfigurator::Components_StandardConfigurator_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_StandardConfigurator_Proxy_Broker_ =
      ::Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_StandardConfigurator_Proxy_Broker_ =
      ::Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::the_TAO_StandardConfigurator_Remote_Proxy_Broker ();
  
  this->Components_Configurator_setup_collocation (collocated);
}

Components::StandardConfigurator::~StandardConfigurator (void)
{}

void 
Components::StandardConfigurator::_tao_any_destructor (void *_tao_void_pointer)
{
  StandardConfigurator *tmp = ACE_static_cast (StandardConfigurator *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::StandardConfigurator_ptr
Components::StandardConfigurator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return StandardConfigurator::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/StandardConfigurator:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (StandardConfigurator::_nil ());
      
      if (is_a == 0)
        {
          return StandardConfigurator::_nil ();
        }
    }
  
  return StandardConfigurator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::StandardConfigurator_ptr 
Components::StandardConfigurator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return StandardConfigurator::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      StandardConfigurator_ptr default_proxy = StandardConfigurator::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::StandardConfigurator (
                  stub,
                  1,
                  obj->_servant ()
                ),
              StandardConfigurator::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::StandardConfigurator (
                  stub,
                  0,
                  obj->_servant ()
                ),
              StandardConfigurator::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          StandardConfigurator_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &StandardConfigurator::_tao_class_id
                )
            )
        );
}

Components::StandardConfigurator_ptr
Components::StandardConfigurator::_duplicate (StandardConfigurator_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::StandardConfigurator::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/StandardConfigurator:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/Configurator:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::StandardConfigurator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, StandardConfigurator)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, Configurator)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                Components::Configurator_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::StandardConfigurator::_interface_repository_id (void) const
{
  return "IDL:Components/StandardConfigurator:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::StandardConfigurator::set_configuration (
    const Components::ConfigValues & descr
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_StandardConfigurator_Proxy_Impl &proxy = 
    this->the_TAO_StandardConfigurator_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.set_configuration (
      this,
      descr
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_StandardConfigurator[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x74616e64), 
  ACE_NTOHL (0x61726443), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x746f723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/StandardConfigurator:1.0
  21,
  ACE_NTOHL (0x5374616e), 
  ACE_NTOHL (0x64617264), 
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69677572), 
  ACE_NTOHL (0x61746f72), 
  ACE_NTOHL (0x0),  // name = StandardConfigurator
};

static CORBA::TypeCode _tc_TAO_tc_Components_StandardConfigurator (
    CORBA::tk_objref,
    sizeof (_oc_Components_StandardConfigurator),
    (char *) &_oc_Components_StandardConfigurator,
    0,
    sizeof (Components::StandardConfigurator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_StandardConfigurator,
    &_tc_TAO_tc_Components_StandardConfigurator
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::HomeConfiguration::_tao_class_id = 0;

Components::HomeConfiguration_ptr
tao_Components_HomeConfiguration_duplicate (
    Components::HomeConfiguration_ptr p
  )
{
  return Components::HomeConfiguration::_duplicate (p);
}

void
tao_Components_HomeConfiguration_release (
    Components::HomeConfiguration_ptr p
  )
{
  CORBA::release (p);
}

Components::HomeConfiguration_ptr
tao_Components_HomeConfiguration_nil (
    void
  )
{
  return Components::HomeConfiguration::_nil ();
}

Components::HomeConfiguration_ptr
tao_Components_HomeConfiguration_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::HomeConfiguration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_HomeConfiguration_upcast (
    void *src
  )
{
  Components::HomeConfiguration **tmp =
    ACE_static_cast (Components::HomeConfiguration **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::HomeConfiguration_var
// *************************************************************

Components::HomeConfiguration_var::HomeConfiguration_var (void)
  : ptr_ (HomeConfiguration::_nil ())
{}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::ptr (void) const
{
  return this->ptr_;
}

Components::HomeConfiguration_var::HomeConfiguration_var (const ::Components::HomeConfiguration_var &p)
  : TAO_Base_var (),
    ptr_ (HomeConfiguration::_duplicate (p.ptr ()))
{}

Components::HomeConfiguration_var::~HomeConfiguration_var (void)
{
  CORBA::release (this->ptr_);
}

Components::HomeConfiguration_var &
Components::HomeConfiguration_var::operator= (HomeConfiguration_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::HomeConfiguration_var &
Components::HomeConfiguration_var::operator= (const ::Components::HomeConfiguration_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::HomeConfiguration::_duplicate (p.ptr ());
  }
  return *this;
}

Components::HomeConfiguration_var::operator const ::Components::HomeConfiguration_ptr &() const // cast
{
  return this->ptr_;
}

Components::HomeConfiguration_var::operator ::Components::HomeConfiguration_ptr &() // cast 
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::in (void) const
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr &
Components::HomeConfiguration_var::inout (void)
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr &
Components::HomeConfiguration_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::HomeConfiguration_ptr val = this->ptr_;
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
  return val;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::tao_duplicate (HomeConfiguration_ptr p)
{
  return ::Components::HomeConfiguration::_duplicate (p);
}

void
Components::HomeConfiguration_var::tao_release (HomeConfiguration_ptr p)
{
  CORBA::release (p);
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::tao_nil (void)
{
  return ::Components::HomeConfiguration::_nil ();
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::HomeConfiguration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::HomeConfiguration_var::tao_upcast (void *src)
{
  HomeConfiguration **tmp =
    ACE_static_cast (HomeConfiguration **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::HomeConfiguration_out
// *************************************************************

Components::HomeConfiguration_out::HomeConfiguration_out (HomeConfiguration_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
}

Components::HomeConfiguration_out::HomeConfiguration_out (HomeConfiguration_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
}

Components::HomeConfiguration_out::HomeConfiguration_out (const ::Components::HomeConfiguration_out &p)
  : ptr_ (ACE_const_cast (HomeConfiguration_out &, p).ptr_)
{}

::Components::HomeConfiguration_out &
Components::HomeConfiguration_out::operator= (const ::Components::HomeConfiguration_out &p)
{
  this->ptr_ = ACE_const_cast (HomeConfiguration_out&, p).ptr_;
  return *this;
}

Components::HomeConfiguration_out &
Components::HomeConfiguration_out::operator= (const ::Components::HomeConfiguration_var &p)
{
  this->ptr_ = ::Components::HomeConfiguration::_duplicate (p.ptr ());
  return *this;
}

Components::HomeConfiguration_out &
Components::HomeConfiguration_out::operator= (HomeConfiguration_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::HomeConfiguration_out::operator ::Components::HomeConfiguration_ptr &() // cast
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr &
Components::HomeConfiguration_out::ptr (void)
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::Configurator_ptr cfg);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator &);
  Components::Configurator_ptr cfg_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::Configurator_ptr cfg    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    cfg_ (cfg)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->cfg_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::ConfigValues & config);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values &);
  const Components::ConfigValues & config_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::ConfigValues & config    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    config_ (config)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->config_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & b);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration (const TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration &);
  const CORBA::Boolean & b_;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Boolean & b    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    b_ (b)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->b_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration (const TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration &);
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_HomeConfiguration_Proxy_Impl::_TAO_HomeConfiguration_Proxy_Impl (void)
{}

Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::_TAO_HomeConfiguration_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::set_configurator (
    CORBA_Object *_collocated_tao_target_,
    Components::Configurator_ptr cfg
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_configurator",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          cfg
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << cfg)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::set_configuration_values (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_configuration_values",
      24,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          config
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << config)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::complete_component_configuration (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean b
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "complete_component_configuration",
      32,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          b
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << CORBA::Any::from_boolean (b))
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::disable_home_configuration (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "disable_home_configuration",
      26,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_HomeConfiguration_Proxy_Broker::_TAO_HomeConfiguration_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Proxy_Broker::~_TAO_HomeConfiguration_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Proxy_Broker * (*Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_HomeConfiguration_Remote_Proxy_Broker *
Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::the_TAO_HomeConfiguration_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_HomeConfiguration_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::_TAO_HomeConfiguration_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::~_TAO_HomeConfiguration_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Proxy_Impl&
Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::select_proxy (
    ::Components::HomeConfiguration *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::HomeConfiguration::HomeConfiguration (int collocated)
{
  this->Components_HomeConfiguration_setup_collocation (collocated);
}

void
Components::HomeConfiguration::Components_HomeConfiguration_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeConfiguration_Proxy_Broker_ =
      ::Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeConfiguration_Proxy_Broker_ =
      ::Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::the_TAO_HomeConfiguration_Remote_Proxy_Broker ();
  
  this->Components_CCMHome_setup_collocation (collocated);
}

Components::HomeConfiguration::~HomeConfiguration (void)
{}

void 
Components::HomeConfiguration::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeConfiguration *tmp = ACE_static_cast (HomeConfiguration *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::HomeConfiguration_ptr
Components::HomeConfiguration::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return HomeConfiguration::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/HomeConfiguration:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (HomeConfiguration::_nil ());
      
      if (is_a == 0)
        {
          return HomeConfiguration::_nil ();
        }
    }
  
  return HomeConfiguration::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::HomeConfiguration_ptr 
Components::HomeConfiguration::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return HomeConfiguration::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      HomeConfiguration_ptr default_proxy = HomeConfiguration::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeConfiguration (
                  stub,
                  1,
                  obj->_servant ()
                ),
              HomeConfiguration::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeConfiguration (
                  stub,
                  0,
                  obj->_servant ()
                ),
              HomeConfiguration::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          HomeConfiguration_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &HomeConfiguration::_tao_class_id
                )
            )
        );
}

Components::HomeConfiguration_ptr
Components::HomeConfiguration::_duplicate (HomeConfiguration_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::HomeConfiguration::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/HomeConfiguration:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/CCMHome:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::HomeConfiguration::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, HomeConfiguration)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, CCMHome)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                Components::CCMHome_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::HomeConfiguration::_interface_repository_id (void) const
{
  return "IDL:Components/HomeConfiguration:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::HomeConfiguration::set_configurator (
    Components::Configurator_ptr cfg
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.set_configurator (
      this,
      cfg
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::HomeConfiguration::set_configuration_values (
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.set_configuration_values (
      this,
      config
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::HomeConfiguration::complete_component_configuration (
    CORBA::Boolean b
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.complete_component_configuration (
      this,
      b
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::HomeConfiguration::disable_home_configuration (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.disable_home_configuration (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_HomeConfiguration[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d6543), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/HomeConfiguration:1.0
  18,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69677572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e000000),  // name = HomeConfiguration
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeConfiguration (
    CORBA::tk_objref,
    sizeof (_oc_Components_HomeConfiguration),
    (char *) &_oc_Components_HomeConfiguration,
    0,
    sizeof (Components::HomeConfiguration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_HomeConfiguration,
    &_tc_TAO_tc_Components_HomeConfiguration
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_ComponentPortDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/ComponentPortDescription:1.0
  25,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74506f72), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ComponentPortDescription
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  5, // member count
  7,
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x74730000),  // name = facets
  CORBA::tk_alias, // typecode kind for typedefs
  544, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    45,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61636574), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e73), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FacetDescriptions:1.0
    18,
    ACE_NTOHL (0x46616365), 
    ACE_NTOHL (0x74446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x73000000),  // name = FacetDescriptions
    CORBA::tk_sequence, // typecode kind
    456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      440, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        44,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f46), 
        ACE_NTOHL (0x61636574), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e3a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/FacetDescription:1.0
        17,
        ACE_NTOHL (0x46616365), 
        ACE_NTOHL (0x74446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = FacetDescription
        0, // value modifier
        CORBA::tk_value, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          43,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f50), 
          ACE_NTOHL (0x6f727444), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e3a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
          16,
          ACE_NTOHL (0x506f7274), 
          ACE_NTOHL (0x44657363), 
          ACE_NTOHL (0x72697074), 
          ACE_NTOHL (0x696f6e00),  // name = PortDescription
          0, // value modifier
          CORBA::tk_null, // no stateful base valuetype

          2, // member count
          5,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x0),  // name = Name
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            39,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f6d70), 
            ACE_NTOHL (0x6f6e656e), 
            ACE_NTOHL (0x74732f46), 
            ACE_NTOHL (0x65617475), 
            ACE_NTOHL (0x72654e61), 
            ACE_NTOHL (0x6d653a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
            12,
            ACE_NTOHL (0x46656174), 
            ACE_NTOHL (0x7572654e), 
            ACE_NTOHL (0x616d6500),  // name = FeatureName
            CORBA::tk_string, 
            0U, // string length

          1, // data member visibility marker

          8,
          ACE_NTOHL (0x74797065), 
          ACE_NTOHL (0x5f696400),  // name = type_id
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f5265), 
            ACE_NTOHL (0x706f7369), 
            ACE_NTOHL (0x746f7279), 
            ACE_NTOHL (0x49643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13,
            ACE_NTOHL (0x5265706f), 
            ACE_NTOHL (0x7369746f), 
            ACE_NTOHL (0x72794964), 
            ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length

          1, // data member visibility marker


        1, // member count
        10,
        ACE_NTOHL (0x66616365), 
        ACE_NTOHL (0x745f7265), 
        ACE_NTOHL (0x66000000),  // name = facet_ref
                1, // data member visibility marker


      0U,


  1, // data member visibility marker

  12,
  ACE_NTOHL (0x72656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c657300),  // name = receptacles
  CORBA::tk_alias, // typecode kind for typedefs
  740, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    50,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f52), 
    ACE_NTOHL (0x65636570), 
    ACE_NTOHL (0x7461636c), 
    ACE_NTOHL (0x65446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x733a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ReceptacleDescriptions:1.0
    23,
    ACE_NTOHL (0x52656365), 
    ACE_NTOHL (0x70746163), 
    ACE_NTOHL (0x6c654465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e730000),  // name = ReceptacleDescriptions
    CORBA::tk_sequence, // typecode kind
    644, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      628, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        49,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f52), 
        ACE_NTOHL (0x65636570), 
        ACE_NTOHL (0x7461636c), 
        ACE_NTOHL (0x65446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ReceptacleDescription:1.0
        22,
        ACE_NTOHL (0x52656365), 
        ACE_NTOHL (0x70746163), 
        ACE_NTOHL (0x6c654465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e000000),  // name = ReceptacleDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffffddc, // negative offset (-548)
        2, // member count
        12,
        ACE_NTOHL (0x69735f6d), 
        ACE_NTOHL (0x756c7469), 
        ACE_NTOHL (0x706c6500),  // name = is_multiple
        CORBA::tk_boolean,

        1, // data member visibility marker

        12,
        ACE_NTOHL (0x636f6e6e), 
        ACE_NTOHL (0x65637469), 
        ACE_NTOHL (0x6f6e7300),  // name = connections
        CORBA::tk_alias, // typecode kind for typedefs
        472, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          50,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f43), 
          ACE_NTOHL (0x6f6e6e65), 
          ACE_NTOHL (0x6374696f), 
          ACE_NTOHL (0x6e446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x733a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
          23,
          ACE_NTOHL (0x436f6e6e), 
          ACE_NTOHL (0x65637469), 
          ACE_NTOHL (0x6f6e4465), 
          ACE_NTOHL (0x73637269), 
          ACE_NTOHL (0x7074696f), 
          ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
          CORBA::tk_sequence, // typecode kind
          376, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_value, // typecode kind
            360, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              49,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f43), 
              ACE_NTOHL (0x6f6e6e65), 
              ACE_NTOHL (0x6374696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
              22,
              ACE_NTOHL (0x436f6e6e), 
              ACE_NTOHL (0x65637469), 
              ACE_NTOHL (0x6f6e4465), 
              ACE_NTOHL (0x73637269), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
              0, // value modifier
              CORBA::tk_null, // no stateful base valuetype

              2, // member count
              3,
              ACE_NTOHL (0x636b0000),  // name = ck
              CORBA::tk_value, // typecode kind
              172, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x436f6d70), 
                ACE_NTOHL (0x6f6e656e), 
                ACE_NTOHL (0x74732f43), 
                ACE_NTOHL (0x6f6f6b69), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
                7,
                ACE_NTOHL (0x436f6f6b), 
                ACE_NTOHL (0x69650000),  // name = Cookie
                0, // value modifier
                CORBA::tk_null, // no stateful base valuetype

                1, // member count
                12,
                ACE_NTOHL (0x636f6f6b), 
                ACE_NTOHL (0x69655661), 
                ACE_NTOHL (0x6c756500),  // name = cookieValue
                CORBA::tk_alias, // typecode kind for typedefs
                76, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  31,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x6f6d672e), 
                  ACE_NTOHL (0x6f72672f), 
                  ACE_NTOHL (0x434f5242), 
                  ACE_NTOHL (0x412f4f63), 
                  ACE_NTOHL (0x74657453), 
                  ACE_NTOHL (0x65713a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
                  9,
                  ACE_NTOHL (0x4f637465), 
                  ACE_NTOHL (0x74536571), 
                  ACE_NTOHL (0x0),  // name = OctetSeq
                  CORBA::tk_sequence, // typecode kind
                  12, // encapsulation length
                    TAO_ENCAP_BYTE_ORDER, // byte order
                    CORBA::tk_octet,

                    0U,


                0, // data member visibility marker


              1, // data member visibility marker

              7,
              ACE_NTOHL (0x6f626a72), 
              ACE_NTOHL (0x65660000),  // name = objref
                            1, // data member visibility marker


            0U,


        1, // data member visibility marker


      0U,


  1, // data member visibility marker

  10,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x73000000),  // name = consumers
  CORBA::tk_alias, // typecode kind for typedefs
  312, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    48,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6e7375), 
    ACE_NTOHL (0x6d657244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e733a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/ConsumerDescriptions:1.0
    21,
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e73), 
    ACE_NTOHL (0x0),  // name = ConsumerDescriptions
    CORBA::tk_sequence, // typecode kind
    220, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      204, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        47,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6e7375), 
        ACE_NTOHL (0x6d657244), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ConsumerDescription:1.0
        20,
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = ConsumerDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffffb18, // negative offset (-1256)
        1, // member count
        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        CORBA::tk_objref, // typecode kind
        80, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          45,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f45), 
          ACE_NTOHL (0x76656e74), 
          ACE_NTOHL (0x436f6e73), 
          ACE_NTOHL (0x756d6572), 
          ACE_NTOHL (0x42617365), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
          18,
          ACE_NTOHL (0x4576656e), 
          ACE_NTOHL (0x74436f6e), 
          ACE_NTOHL (0x73756d65), 
          ACE_NTOHL (0x72426173), 
          ACE_NTOHL (0x65000000),  // name = EventConsumerBase

        1, // data member visibility marker


      0U,


  1, // data member visibility marker

  9,
  ACE_NTOHL (0x656d6974), 
  ACE_NTOHL (0x74657273), 
  ACE_NTOHL (0x0),  // name = emitters
  CORBA::tk_alias, // typecode kind for typedefs
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    47,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x6d697474), 
    ACE_NTOHL (0x65724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e733a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/EmitterDescriptions:1.0
    20,
    ACE_NTOHL (0x456d6974), 
    ACE_NTOHL (0x74657244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e7300),  // name = EmitterDescriptions
    CORBA::tk_sequence, // typecode kind
    140, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      124, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        46,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x6d697474), 
        ACE_NTOHL (0x65724465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/EmitterDescription:1.0
        19,
        ACE_NTOHL (0x456d6974), 
        ACE_NTOHL (0x74657244), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e0000),  // name = EmitterDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffff9c8, // negative offset (-1592)
        1, // member count
        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        0xffffffff, // indirection
        0xfffffeac, // negative offset (-340)
        1, // data member visibility marker


      0U,


  1, // data member visibility marker

  11,
  ACE_NTOHL (0x7075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x72730000),  // name = publishers
  CORBA::tk_alias, // typecode kind for typedefs
  504, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    49,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x75626c69), 
    ACE_NTOHL (0x73686572), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e73), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/PublisherDescriptions:1.0
    22,
    ACE_NTOHL (0x5075626c), 
    ACE_NTOHL (0x69736865), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x73000000),  // name = PublisherDescriptions
    CORBA::tk_sequence, // typecode kind
    408, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      392, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        48,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x75626c69), 
        ACE_NTOHL (0x73686572), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e3a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/PublisherDescription:1.0
        21,
        ACE_NTOHL (0x5075626c), 
        ACE_NTOHL (0x69736865), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = PublisherDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffff8bc, // negative offset (-1860)
        1, // member count
        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        CORBA::tk_alias, // typecode kind for typedefs
        264, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          50,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f53), 
          ACE_NTOHL (0x75627363), 
          ACE_NTOHL (0x72696265), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x733a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/SubscriberDescriptions:1.0
          23,
          ACE_NTOHL (0x53756273), 
          ACE_NTOHL (0x63726962), 
          ACE_NTOHL (0x65724465), 
          ACE_NTOHL (0x73637269), 
          ACE_NTOHL (0x7074696f), 
          ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
          CORBA::tk_sequence, // typecode kind
          168, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_value, // typecode kind
            152, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              49,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f53), 
              ACE_NTOHL (0x75627363), 
              ACE_NTOHL (0x72696265), 
              ACE_NTOHL (0x72446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SubscriberDescription:1.0
              22,
              ACE_NTOHL (0x53756273), 
              ACE_NTOHL (0x63726962), 
              ACE_NTOHL (0x65724465), 
              ACE_NTOHL (0x73637269), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
              0, // value modifier
              0xffffffff, // indirection
              0xfffff7d0, // negative offset (-2096)
              2, // member count
              3,
              ACE_NTOHL (0x636b0000),  // name = ck
              0xffffffff, // indirection
              0xfffffaf0, // negative offset (-1296)
              1, // data member visibility marker

              9,
              ACE_NTOHL (0x636f6e73), 
              ACE_NTOHL (0x756d6572), 
              ACE_NTOHL (0x0),  // name = consumer
              0xffffffff, // indirection
              0xfffffca0, // negative offset (-864)
              1, // data member visibility marker


            0U,


        1, // data member visibility marker


      0U,


  1, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ComponentPortDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ComponentPortDescription),
    (char *) &_oc_Components_ComponentPortDescription,
    0,
    sizeof (Components::ComponentPortDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ComponentPortDescription,
    &_tc_TAO_tc_Components_ComponentPortDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_ComponentPortDescription_add_ref (
    Components::ComponentPortDescription *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_ComponentPortDescription_remove_ref (
    Components::ComponentPortDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::ComponentPortDescription_var
// *************************************************************

Components::ComponentPortDescription_var::ComponentPortDescription_var (void)
  : ptr_ (0)
{}

Components::ComponentPortDescription_var::ComponentPortDescription_var (ComponentPortDescription* p)
  : ptr_ (p)
{}

Components::ComponentPortDescription_var::ComponentPortDescription_var (const ComponentPortDescription* p)
  : ptr_ (ACE_const_cast (ComponentPortDescription *, p))
{}

Components::ComponentPortDescription *
Components::ComponentPortDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ComponentPortDescription_var::ComponentPortDescription_var (const ComponentPortDescription_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ComponentPortDescription_var::~ComponentPortDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ComponentPortDescription_var &
Components::ComponentPortDescription_var::operator= (ComponentPortDescription *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ComponentPortDescription_var &
Components::ComponentPortDescription_var::operator= (const ComponentPortDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ComponentPortDescription *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::ComponentPortDescription_var::operator const Components::ComponentPortDescription* () const // cast
{
  return this->ptr_;
}

Components::ComponentPortDescription_var::operator Components::ComponentPortDescription* () // cast 
{
  return this->ptr_;
}

Components::ComponentPortDescription *
Components::ComponentPortDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ComponentPortDescription *
Components::ComponentPortDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ComponentPortDescription *&
Components::ComponentPortDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ComponentPortDescription *&
Components::ComponentPortDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ComponentPortDescription *
Components::ComponentPortDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ComponentPortDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::ComponentPortDescription_var::tao_add_ref (
    ComponentPortDescription *p
  )
{
  CORBA::add_ref (p);
}

void
Components::ComponentPortDescription_var::tao_remove_ref (
    ComponentPortDescription *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::ComponentPortDescription_out
// *************************************************************

Components::ComponentPortDescription_out::ComponentPortDescription_out (ComponentPortDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ComponentPortDescription_out::ComponentPortDescription_out (ComponentPortDescription_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ComponentPortDescription_out::ComponentPortDescription_out (const ComponentPortDescription_out &p)
  : ptr_ (ACE_const_cast (ComponentPortDescription_out&, p).ptr_)
{}

Components::ComponentPortDescription_out &
Components::ComponentPortDescription_out::operator= (const ComponentPortDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentPortDescription_out&, p).ptr_;
  return *this;
}

Components::ComponentPortDescription_out &
Components::ComponentPortDescription_out::operator= (const ComponentPortDescription_var &p)
{
  ComponentPortDescription *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ComponentPortDescription_out &
Components::ComponentPortDescription_out::operator= (ComponentPortDescription *p)
{
  this->ptr_ = p;
  return *this;
}

Components::ComponentPortDescription_out::operator Components::ComponentPortDescription*& () // cast
{
  return this->ptr_;
}

Components::ComponentPortDescription *&
Components::ComponentPortDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ComponentPortDescription *
Components::ComponentPortDescription_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::ComponentPortDescription *
Components::ComponentPortDescription::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (ComponentPortDescription *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::ComponentPortDescription::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::ComponentPortDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::ComponentPortDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentPortDescription *tmp =
    ACE_static_cast (
        ComponentPortDescription *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::ComponentPortDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ComponentPortDescription (strm);
}

CORBA::Boolean Components::ComponentPortDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ComponentPortDescription (strm);
}

CORBA::Boolean Components::ComponentPortDescription::_tao_unmarshal (
    TAO_InputCDR &strm,
    ComponentPortDescription *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        ComponentPortDescription::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ComponentPortDescription::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_init_cs.cpp:84

Components::ComponentPortDescription_init::ComponentPortDescription_init (void)
{
}

Components::ComponentPortDescription_init::~ComponentPortDescription_init (void)
{
}

const char* 
Components::ComponentPortDescription_init::tao_repository_id (void)
{
  return Components::ComponentPortDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase *
Components::ComponentPortDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase *ret_val = 0;
  ACE_NEW_RETURN (
      ret_val,
      OBV_Components::ComponentPortDescription,
      0
    );
  return ret_val;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::CCMObject::_tao_class_id = 0;

Components::CCMObject_ptr
tao_Components_CCMObject_duplicate (
    Components::CCMObject_ptr p
  )
{
  return Components::CCMObject::_duplicate (p);
}

void
tao_Components_CCMObject_release (
    Components::CCMObject_ptr p
  )
{
  CORBA::release (p);
}

Components::CCMObject_ptr
tao_Components_CCMObject_nil (
    void
  )
{
  return Components::CCMObject::_nil ();
}

Components::CCMObject_ptr
tao_Components_CCMObject_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::CCMObject::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_CCMObject_upcast (
    void *src
  )
{
  Components::CCMObject **tmp =
    ACE_static_cast (Components::CCMObject **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::CCMObject_var
// *************************************************************

Components::CCMObject_var::CCMObject_var (void)
  : ptr_ (CCMObject::_nil ())
{}

::Components::CCMObject_ptr
Components::CCMObject_var::ptr (void) const
{
  return this->ptr_;
}

Components::CCMObject_var::CCMObject_var (const ::Components::CCMObject_var &p)
  : TAO_Base_var (),
    ptr_ (CCMObject::_duplicate (p.ptr ()))
{}

Components::CCMObject_var::~CCMObject_var (void)
{
  CORBA::release (this->ptr_);
}

Components::CCMObject_var &
Components::CCMObject_var::operator= (CCMObject_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::CCMObject_var &
Components::CCMObject_var::operator= (const ::Components::CCMObject_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::CCMObject::_duplicate (p.ptr ());
  }
  return *this;
}

Components::CCMObject_var::operator const ::Components::CCMObject_ptr &() const // cast
{
  return this->ptr_;
}

Components::CCMObject_var::operator ::Components::CCMObject_ptr &() // cast 
{
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_var::in (void) const
{
  return this->ptr_;
}

::Components::CCMObject_ptr &
Components::CCMObject_var::inout (void)
{
  return this->ptr_;
}

::Components::CCMObject_ptr &
Components::CCMObject_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMObject::_nil ();
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::CCMObject_ptr val = this->ptr_;
  this->ptr_ = ::Components::CCMObject::_nil ();
  return val;
}

::Components::CCMObject_ptr
Components::CCMObject_var::tao_duplicate (CCMObject_ptr p)
{
  return ::Components::CCMObject::_duplicate (p);
}

void
Components::CCMObject_var::tao_release (CCMObject_ptr p)
{
  CORBA::release (p);
}

::Components::CCMObject_ptr
Components::CCMObject_var::tao_nil (void)
{
  return ::Components::CCMObject::_nil ();
}

::Components::CCMObject_ptr
Components::CCMObject_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::CCMObject::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::CCMObject_var::tao_upcast (void *src)
{
  CCMObject **tmp =
    ACE_static_cast (CCMObject **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::CCMObject_out
// *************************************************************

Components::CCMObject_out::CCMObject_out (CCMObject_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::CCMObject::_nil ();
}

Components::CCMObject_out::CCMObject_out (CCMObject_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMObject::_nil ();
}

Components::CCMObject_out::CCMObject_out (const ::Components::CCMObject_out &p)
  : ptr_ (ACE_const_cast (CCMObject_out &, p).ptr_)
{}

::Components::CCMObject_out &
Components::CCMObject_out::operator= (const ::Components::CCMObject_out &p)
{
  this->ptr_ = ACE_const_cast (CCMObject_out&, p).ptr_;
  return *this;
}

Components::CCMObject_out &
Components::CCMObject_out::operator= (const ::Components::CCMObject_var &p)
{
  this->ptr_ = ::Components::CCMObject::_duplicate (p.ptr ());
  return *this;
}

Components::CCMObject_out &
Components::CCMObject_out::operator= (CCMObject_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::CCMObject_out::operator ::Components::CCMObject_ptr &() // cast
{
  return this->ptr_;
}

::Components::CCMObject_ptr &
Components::CCMObject_out::ptr (void)
{
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMObject_get_component_def : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_component_def (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IRObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_component_def (const TAO_ClientRequestInfo_Components_CCMObject_get_component_def &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_component_def &);
  
  CORBA::IRObject_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMObject_get_component_def::TAO_ClientRequestInfo_Components_CCMObject_get_component_def (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::result (::CORBA::IRObject_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home (const TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home &);
  
  Components::CCMHome_ptr _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::result (::Components::CCMHome_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMObject_get_primary_key : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_primary_key (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::PrimaryKeyBase * result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_primary_key (const TAO_ClientRequestInfo_Components_CCMObject_get_primary_key &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_primary_key &);
  
  Components::PrimaryKeyBase * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::TAO_ClientRequestInfo_Components_CCMObject_get_primary_key (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_get_primary_key_exceptiondata[] = 
  {
    Components::_tc_NoKeyAvailable
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_get_primary_key_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::result (::Components::PrimaryKeyBase * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMObject_configuration_complete : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_configuration_complete (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_CCMObject_configuration_complete (const TAO_ClientRequestInfo_Components_CCMObject_configuration_complete &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_configuration_complete &);
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::TAO_ClientRequestInfo_Components_CCMObject_configuration_complete (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_configuration_complete_exceptiondata[] = 
  {
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_configuration_complete_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMObject_remove : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_remove (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_CCMObject_remove (const TAO_ClientRequestInfo_Components_CCMObject_remove &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_remove &);
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMObject_remove::TAO_ClientRequestInfo_Components_CCMObject_remove (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_remove_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_Components_CCMObject_get_all_ports : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_all_ports (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ComponentPortDescription * result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_all_ports (const TAO_ClientRequestInfo_Components_CCMObject_get_all_ports &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_all_ports &);
  
  Components::ComponentPortDescription * _result;
};

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:401

TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::TAO_ClientRequestInfo_Components_CCMObject_get_all_ports (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::result (::Components::ComponentPortDescription * result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_CCMObject_Proxy_Impl::_TAO_CCMObject_Proxy_Impl (void)
{}

Components::_TAO_CCMObject_Remote_Proxy_Impl::_TAO_CCMObject_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IRObject_ptr Components::_TAO_CCMObject_Remote_Proxy_Impl::get_component_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::IRObject_var _tao_retval (CORBA::IRObject::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_component_def",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_component_def _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IRObject_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::CCMHome_ptr Components::_TAO_CCMObject_Remote_Proxy_Impl::get_ccm_home (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_ccm_home",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::PrimaryKeyBase * Components::_TAO_CCMObject_Remote_Proxy_Impl::get_primary_key (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::NoKeyAvailable
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_CCMObject_get_primary_key_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/NoKeyAvailable:1.0",
      Components::NoKeyAvailable::_alloc
    }
  };

::Components::PrimaryKeyBase_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primary_key",
      15,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_primary_key _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMObject_get_primary_key_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::PrimaryKeyBase * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_CCMObject_Remote_Proxy_Impl::configuration_complete (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_CCMObject_configuration_complete_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidConfiguration:1.0",
      Components::InvalidConfiguration::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "configuration_complete",
      22,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_configuration_complete _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          
          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMObject_configuration_complete_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void Components::_TAO_CCMObject_Remote_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
    static TAO_Exception_Data _tao_Components_CCMObject_remove_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove",
      6,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_remove _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          
          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMObject_remove_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::Components::ComponentPortDescription * Components::_TAO_CCMObject_Remote_Proxy_Impl::get_all_ports (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  ::Components::ComponentPortDescription_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_ports",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_all_ports _tao_ri (
          &_tao_call,
          _collocated_tao_target_
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ComponentPortDescription * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_CCMObject_Proxy_Broker::_TAO_CCMObject_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Proxy_Broker::~_TAO_CCMObject_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Proxy_Broker * (*Components__TAO_CCMObject_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_CCMObject_Remote_Proxy_Broker *
Components::_TAO_CCMObject_Remote_Proxy_Broker::the_TAO_CCMObject_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_CCMObject_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_CCMObject_Remote_Proxy_Broker::_TAO_CCMObject_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Remote_Proxy_Broker::~_TAO_CCMObject_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Proxy_Impl&
Components::_TAO_CCMObject_Remote_Proxy_Broker::select_proxy (
    ::Components::CCMObject *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::CCMObject::CCMObject (int collocated)
{
  this->Components_CCMObject_setup_collocation (collocated);
}

void
Components::CCMObject::Components_CCMObject_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CCMObject_Proxy_Broker_ =
      ::Components__TAO_CCMObject_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CCMObject_Proxy_Broker_ =
      ::Components::_TAO_CCMObject_Remote_Proxy_Broker::the_TAO_CCMObject_Remote_Proxy_Broker ();
  
  this->Components_Navigation_setup_collocation (collocated);
  this->Components_Receptacles_setup_collocation (collocated);
  this->Components_Events_setup_collocation (collocated);
}

Components::CCMObject::~CCMObject (void)
{}

void 
Components::CCMObject::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMObject *tmp = ACE_static_cast (CCMObject *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::CCMObject_ptr
Components::CCMObject::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return CCMObject::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:Components/CCMObject:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (CCMObject::_nil ());
      
      if (is_a == 0)
        {
          return CCMObject::_nil ();
        }
    }
  
  return CCMObject::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::CCMObject_ptr 
Components::CCMObject::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return CCMObject::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      CCMObject_ptr default_proxy = CCMObject::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_CCMObject_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMObject (
                  stub,
                  1,
                  obj->_servant ()
                ),
              CCMObject::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMObject (
                  stub,
                  0,
                  obj->_servant ()
                ),
              CCMObject::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          CCMObject_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &CCMObject::_tao_class_id
                )
            )
        );
}

Components::CCMObject_ptr
Components::CCMObject::_duplicate (CCMObject_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
Components::CCMObject::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:Components/CCMObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/Components/Navigation:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/Components/Receptacles:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/Components/Events:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *Components::CCMObject::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components, CCMObject)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::Components::Navigation::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                Components::Navigation_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::Components::Receptacles::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                Components::Receptacles_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::Components::Events::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                Components::Events_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::CCMObject::_interface_repository_id (void) const
{
  return "IDL:Components/CCMObject:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::IRObject_ptr Components::CCMObject::get_component_def (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_component_def (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::CCMHome_ptr Components::CCMObject::get_ccm_home (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_ccm_home (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::PrimaryKeyBase * Components::CCMObject::get_primary_key (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::NoKeyAvailable
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_primary_key (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::CCMObject::configuration_complete (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.configuration_complete (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void Components::CCMObject::remove (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::Components::ComponentPortDescription * Components::CCMObject::get_all_ports (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_ports (
      this
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_CCMObject[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/CCMObject:1.0
  10,
  ACE_NTOHL (0x43434d4f), 
  ACE_NTOHL (0x626a6563), 
  ACE_NTOHL (0x74000000),  // name = CCMObject
};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMObject (
    CORBA::tk_objref,
    sizeof (_oc_Components_CCMObject),
    (char *) &_oc_Components_CCMObject,
    0,
    sizeof (Components::CCMObject)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_CCMObject,
    &_tc_TAO_tc_Components_CCMObject
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Enumeration[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6e756d65), 
  ACE_NTOHL (0x72617469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/Enumeration:1.0
  12,
  ACE_NTOHL (0x456e756d), 
  ACE_NTOHL (0x65726174), 
  ACE_NTOHL (0x696f6e00),  // name = Enumeration
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Enumeration (
    CORBA::tk_value,
    sizeof (_oc_Components_Enumeration),
    (char *) &_oc_Components_Enumeration,
    0,
    sizeof (Components::Enumeration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Enumeration,
    &_tc_TAO_tc_Components_Enumeration
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_Enumeration_add_ref (
    Components::Enumeration *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_Enumeration_remove_ref (
    Components::Enumeration *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::Enumeration_var
// *************************************************************

Components::Enumeration_var::Enumeration_var (void)
  : ptr_ (0)
{}

Components::Enumeration_var::Enumeration_var (Enumeration* p)
  : ptr_ (p)
{}

Components::Enumeration_var::Enumeration_var (const Enumeration* p)
  : ptr_ (ACE_const_cast (Enumeration *, p))
{}

Components::Enumeration *
Components::Enumeration_var::ptr (void) const
{
  return this->ptr_;
}

Components::Enumeration_var::Enumeration_var (const Enumeration_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::Enumeration_var::~Enumeration_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::Enumeration_var &
Components::Enumeration_var::operator= (Enumeration *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Enumeration_var &
Components::Enumeration_var::operator= (const Enumeration_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    Enumeration *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::Enumeration_var::operator const Components::Enumeration* () const // cast
{
  return this->ptr_;
}

Components::Enumeration_var::operator Components::Enumeration* () // cast 
{
  return this->ptr_;
}

Components::Enumeration *
Components::Enumeration_var::operator-> (void) const
{
  return this->ptr_;
}

Components::Enumeration *
Components::Enumeration_var::in (void) const
{
  return this->ptr_;
}

Components::Enumeration *&
Components::Enumeration_var::inout (void)
{
  return this->ptr_;
}

Components::Enumeration *&
Components::Enumeration_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::Enumeration *
Components::Enumeration_var::_retn (void)
{
  // yield ownership of managed obj reference
  Enumeration* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::Enumeration_var::tao_add_ref (
    Enumeration *p
  )
{
  CORBA::add_ref (p);
}

void
Components::Enumeration_var::tao_remove_ref (
    Enumeration *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::Enumeration_out
// *************************************************************

Components::Enumeration_out::Enumeration_out (Enumeration *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::Enumeration_out::Enumeration_out (Enumeration_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::Enumeration_out::Enumeration_out (const Enumeration_out &p)
  : ptr_ (ACE_const_cast (Enumeration_out&, p).ptr_)
{}

Components::Enumeration_out &
Components::Enumeration_out::operator= (const Enumeration_out &p)
{
  this->ptr_ = ACE_const_cast (Enumeration_out&, p).ptr_;
  return *this;
}

Components::Enumeration_out &
Components::Enumeration_out::operator= (const Enumeration_var &p)
{
  Enumeration *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::Enumeration_out &
Components::Enumeration_out::operator= (Enumeration *p)
{
  this->ptr_ = p;
  return *this;
}

Components::Enumeration_out::operator Components::Enumeration*& () // cast
{
  return this->ptr_;
}

Components::Enumeration *&
Components::Enumeration_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::Enumeration *
Components::Enumeration_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::Enumeration *
Components::Enumeration::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (Enumeration *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::Enumeration::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::Enumeration::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  return rval;
}

void
Components::Enumeration::_tao_any_destructor (void *_tao_void_pointer)
{
  Enumeration *tmp =
    ACE_static_cast (
        Enumeration *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::Enumeration::_tao_unmarshal (
    TAO_InputCDR &strm,
    Enumeration *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        Enumeration::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Enumeration::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_cs.cpp:103

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMOBJECTSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMOBJECTSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_allocate_buffer (CORBA::ULong length)
{
  Components::CCMObject **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      Components::CCMObject **old = ACE_reinterpret_cast (Components::CCMObject**, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (!this->release_)
            {
              tmp[i] = Components::CCMObject::_duplicate (old[i]);
            }
          else
            {
              tmp[i] = old[i];
            }
        }
      
      if (this->release_)
        {
          delete [] old;
        }
    }
  
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  Components::CCMObject **tmp = ACE_reinterpret_cast (Components::CCMObject**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMObject::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::~_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::CCMObject **tmp = ACE_reinterpret_cast (Components::CCMObject**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMObject::_nil ();
    }
}

void 
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  Components::CCMObject **tmp = ACE_static_cast (Components::CCMObject**, target);
  *tmp = Components::CCMObject::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_upcast (void *src) const
{
  Components::CCMObject **tmp = ACE_static_cast (Components::CCMObject**, src);
  return *tmp;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CCMOBJECTSEQ_CS_)
#define _COMPONENTS_CCMOBJECTSEQ_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::CCMObjectSeq
// *************************************************************

Components::CCMObjectSeq::CCMObjectSeq (void)
{}

Components::CCMObjectSeq::CCMObjectSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMObject,Components::CCMObject_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::CCMObjectSeq::CCMObjectSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    Components::CCMObject_ptr *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMObject,Components::CCMObject_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::CCMObjectSeq::CCMObjectSeq (const CCMObjectSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMObject,Components::CCMObject_var>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::CCMObjectSeq::~CCMObjectSeq (void) // dtor
{}

void Components::CCMObjectSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMObjectSeq *tmp = ACE_static_cast (CCMObjectSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_CCMObjectSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  32,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/CCMObjectSeq:1.0
  13,
  ACE_NTOHL (0x43434d4f), 
  ACE_NTOHL (0x626a6563), 
  ACE_NTOHL (0x74536571), 
  ACE_NTOHL (0x0),  // name = CCMObjectSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x434d4f62), 
      ACE_NTOHL (0x6a656374), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:Components/CCMObject:1.0
      10,
      ACE_NTOHL (0x43434d4f), 
      ACE_NTOHL (0x626a6563), 
      ACE_NTOHL (0x74000000),  // name = CCMObject

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMObjectSeq (
    CORBA::tk_alias,
    sizeof (_oc_Components_CCMObjectSeq),
    (char *) &_oc_Components_CCMObjectSeq,
    0,
    sizeof (Components::CCMObjectSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_CCMObjectSeq,
    &_tc_TAO_tc_Components_CCMObjectSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_DefaultEnumeration[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65666175), 
  ACE_NTOHL (0x6c74456e), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/DefaultEnumeration:1.0
  19,
  ACE_NTOHL (0x44656661), 
  ACE_NTOHL (0x756c7445), 
  ACE_NTOHL (0x6e756d65), 
  ACE_NTOHL (0x72617469), 
  ACE_NTOHL (0x6f6e0000),  // name = DefaultEnumeration
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  1, // member count
  8,
  ACE_NTOHL (0x6f626a65), 
  ACE_NTOHL (0x63747300),  // name = objects
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x434d4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/CCMObjectSeq:1.0
    13,
    ACE_NTOHL (0x43434d4f), 
    ACE_NTOHL (0x626a6563), 
    ACE_NTOHL (0x74536571), 
    ACE_NTOHL (0x0),  // name = CCMObjectSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x434d4f62), 
        ACE_NTOHL (0x6a656374), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:Components/CCMObject:1.0
        10,
        ACE_NTOHL (0x43434d4f), 
        ACE_NTOHL (0x626a6563), 
        ACE_NTOHL (0x74000000),  // name = CCMObject

      0U,


  0, // data member visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_DefaultEnumeration (
    CORBA::tk_value,
    sizeof (_oc_Components_DefaultEnumeration),
    (char *) &_oc_Components_DefaultEnumeration,
    0,
    sizeof (Components::DefaultEnumeration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_DefaultEnumeration,
    &_tc_TAO_tc_Components_DefaultEnumeration
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:95

void
tao_Components_DefaultEnumeration_add_ref (
    Components::DefaultEnumeration *p
  )
{
  CORBA::add_ref (p);
}

void
tao_Components_DefaultEnumeration_remove_ref (
    Components::DefaultEnumeration *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:298

// *************************************************************
// Operations for class Components::DefaultEnumeration_var
// *************************************************************

Components::DefaultEnumeration_var::DefaultEnumeration_var (void)
  : ptr_ (0)
{}

Components::DefaultEnumeration_var::DefaultEnumeration_var (DefaultEnumeration* p)
  : ptr_ (p)
{}

Components::DefaultEnumeration_var::DefaultEnumeration_var (const DefaultEnumeration* p)
  : ptr_ (ACE_const_cast (DefaultEnumeration *, p))
{}

Components::DefaultEnumeration *
Components::DefaultEnumeration_var::ptr (void) const
{
  return this->ptr_;
}

Components::DefaultEnumeration_var::DefaultEnumeration_var (const DefaultEnumeration_var &p)
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::DefaultEnumeration_var::~DefaultEnumeration_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::DefaultEnumeration_var &
Components::DefaultEnumeration_var::operator= (DefaultEnumeration *p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::DefaultEnumeration_var &
Components::DefaultEnumeration_var::operator= (const DefaultEnumeration_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    DefaultEnumeration *tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  
  return *this;
}

Components::DefaultEnumeration_var::operator const Components::DefaultEnumeration* () const // cast
{
  return this->ptr_;
}

Components::DefaultEnumeration_var::operator Components::DefaultEnumeration* () // cast 
{
  return this->ptr_;
}

Components::DefaultEnumeration *
Components::DefaultEnumeration_var::operator-> (void) const
{
  return this->ptr_;
}

Components::DefaultEnumeration *
Components::DefaultEnumeration_var::in (void) const
{
  return this->ptr_;
}

Components::DefaultEnumeration *&
Components::DefaultEnumeration_var::inout (void)
{
  return this->ptr_;
}

Components::DefaultEnumeration *&
Components::DefaultEnumeration_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::DefaultEnumeration *
Components::DefaultEnumeration_var::_retn (void)
{
  // yield ownership of managed obj reference
  DefaultEnumeration* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

void
Components::DefaultEnumeration_var::tao_add_ref (
    DefaultEnumeration *p
  )
{
  CORBA::add_ref (p);
}

void
Components::DefaultEnumeration_var::tao_remove_ref (
    DefaultEnumeration *p
  )
{
  CORBA::remove_ref (p);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:568

// *************************************************************
// Operations for class Components::DefaultEnumeration_out
// *************************************************************

Components::DefaultEnumeration_out::DefaultEnumeration_out (DefaultEnumeration *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::DefaultEnumeration_out::DefaultEnumeration_out (DefaultEnumeration_var &p)
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::DefaultEnumeration_out::DefaultEnumeration_out (const DefaultEnumeration_out &p)
  : ptr_ (ACE_const_cast (DefaultEnumeration_out&, p).ptr_)
{}

Components::DefaultEnumeration_out &
Components::DefaultEnumeration_out::operator= (const DefaultEnumeration_out &p)
{
  this->ptr_ = ACE_const_cast (DefaultEnumeration_out&, p).ptr_;
  return *this;
}

Components::DefaultEnumeration_out &
Components::DefaultEnumeration_out::operator= (const DefaultEnumeration_var &p)
{
  DefaultEnumeration *tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::DefaultEnumeration_out &
Components::DefaultEnumeration_out::operator= (DefaultEnumeration *p)
{
  this->ptr_ = p;
  return *this;
}

Components::DefaultEnumeration_out::operator Components::DefaultEnumeration*& () // cast
{
  return this->ptr_;
}

Components::DefaultEnumeration *&
Components::DefaultEnumeration_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::DefaultEnumeration *
Components::DefaultEnumeration_out::operator-> (void)
{
  return this->ptr_;
}

// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_cs.cpp:138

Components::DefaultEnumeration *
Components::DefaultEnumeration::_downcast (CORBA::ValueBase *v)
{
  if (v == 0)
    {
      return 0;
    }
  
  return (DefaultEnumeration *) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char *
Components::DefaultEnumeration::_tao_obv_repository_id (void) const
{
  return this->_tao_obv_static_repository_id ();
}

void *
Components::DefaultEnumeration::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    {
      return this;
    }
  
  void *rval = 0;
  
  if (rval == 0)
    {
      rval = ACE_NESTED_CLASS (Components,Enumeration)::_tao_obv_narrow (type_id);
    }
  
  return rval;
}

void
Components::DefaultEnumeration::_tao_any_destructor (void *_tao_void_pointer)
{
  DefaultEnumeration *tmp =
    ACE_static_cast (
        DefaultEnumeration *,
        _tao_void_pointer
      );
  delete tmp;
}

CORBA::Boolean Components::DefaultEnumeration::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_DefaultEnumeration (strm);
}

CORBA::Boolean Components::DefaultEnumeration::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_DefaultEnumeration (strm);
}

CORBA::Boolean Components::DefaultEnumeration::_tao_unmarshal (
    TAO_InputCDR &strm,
    DefaultEnumeration *&new_object
  )
{
  CORBA::ValueBase *base = 0;
  CORBA::ValueFactory_var factory;
  CORBA::Boolean retval =
    CORBA::ValueBase::_tao_unmarshal_pre (
        strm,
        factory,
        base,
        DefaultEnumeration::_tao_obv_static_repository_id ()
      );
  
  if (retval == 0)
    {
      return 0;
    }
  
  if (factory.in () != 0)
    {
      base = factory->create_for_unmarshal ();
      
      if (base == 0)
        {
          return 0;  // %! except.?
        }
      
      retval = base->_tao_unmarshal_v (strm);
      
      if (retval == 0)
        {
          return 0;
        }
    }
  
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = DefaultEnumeration::_downcast (base);
  return retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::ConfigValue::_tao_marshal__Components_ConfigValue (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::ConfigValue::_tao_unmarshal__Components_ConfigValue (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:815

// Accessor to set the member.
void
OBV_Components::ConfigValue::name (char *val)
{
  this->_pd_name = val;
}

// Accessor to set the member.
void
OBV_Components::ConfigValue::name (const char *val)
{
  // Set the value.
  this->_pd_name = CORBA::string_dup (val);
}

// Accessor to set the member.
void
OBV_Components::ConfigValue::name (const CORBA::String_var &val)
{
  CORBA::String_var name_var = val;
  this->_pd_name = name_var._retn ();
}

const char *
OBV_Components::ConfigValue::name (void) const // get method
{
  return this->_pd_name;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:568

// Accessor to set the member.
void
OBV_Components::ConfigValue::value (CORBA::Any & val)
{
  this->_pd_value = val;
}

// Retrieve the member.
const CORBA::Any &
OBV_Components::ConfigValue::value (void) const
{
  return this->_pd_value;
}

// Retrieve the member
CORBA::Any &
OBV_Components::ConfigValue::value (void)
{
  return this->_pd_value;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::ComponentPortDescription::_tao_marshal__Components_ComponentPortDescription (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::ComponentPortDescription::_tao_unmarshal__Components_ComponentPortDescription (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::ComponentPortDescription::facets (const Components::FacetDescriptions &val)
{
  this->_pd_facets = val;
}

// Readonly get method.
const Components::FacetDescriptions &
OBV_Components::ComponentPortDescription::facets (void) const
{
  return this->_pd_facets;
}

// Read/write get method.
Components::FacetDescriptions &
OBV_Components::ComponentPortDescription::facets (void)
{
  return this->_pd_facets;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::ComponentPortDescription::receptacles (const Components::ReceptacleDescriptions &val)
{
  this->_pd_receptacles = val;
}

// Readonly get method.
const Components::ReceptacleDescriptions &
OBV_Components::ComponentPortDescription::receptacles (void) const
{
  return this->_pd_receptacles;
}

// Read/write get method.
Components::ReceptacleDescriptions &
OBV_Components::ComponentPortDescription::receptacles (void)
{
  return this->_pd_receptacles;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::ComponentPortDescription::consumers (const Components::ConsumerDescriptions &val)
{
  this->_pd_consumers = val;
}

// Readonly get method.
const Components::ConsumerDescriptions &
OBV_Components::ComponentPortDescription::consumers (void) const
{
  return this->_pd_consumers;
}

// Read/write get method.
Components::ConsumerDescriptions &
OBV_Components::ComponentPortDescription::consumers (void)
{
  return this->_pd_consumers;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::ComponentPortDescription::emitters (const Components::EmitterDescriptions &val)
{
  this->_pd_emitters = val;
}

// Readonly get method.
const Components::EmitterDescriptions &
OBV_Components::ComponentPortDescription::emitters (void) const
{
  return this->_pd_emitters;
}

// Read/write get method.
Components::EmitterDescriptions &
OBV_Components::ComponentPortDescription::emitters (void)
{
  return this->_pd_emitters;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::ComponentPortDescription::publishers (const Components::PublisherDescriptions &val)
{
  this->_pd_publishers = val;
}

// Readonly get method.
const Components::PublisherDescriptions &
OBV_Components::ComponentPortDescription::publishers (void) const
{
  return this->_pd_publishers;
}

// Read/write get method.
Components::PublisherDescriptions &
OBV_Components::ComponentPortDescription::publishers (void)
{
  return this->_pd_publishers;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_obv_cs.cpp:58

CORBA::Boolean
OBV_Components::DefaultEnumeration::_tao_marshal__Components_DefaultEnumeration (TAO_OutputCDR &strm)
{
  return _tao_marshal_state (strm);
}

CORBA::Boolean
OBV_Components::DefaultEnumeration::_tao_unmarshal__Components_DefaultEnumeration (TAO_InputCDR &strm)
{
  return _tao_unmarshal_state (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/field_cs.cpp:744

// Accessor to set the member.
void
OBV_Components::DefaultEnumeration::objects (const Components::CCMObjectSeq &val)
{
  this->_pd_objects = val;
}

// Readonly get method.
const Components::CCMObjectSeq &
OBV_Components::DefaultEnumeration::objects (void) const
{
  return this->_pd_objects;
}

// Read/write get method.
Components::CCMObjectSeq &
OBV_Components::DefaultEnumeration::objects (void)
{
  return this->_pd_objects;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::PrimaryKeyBase *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_PrimaryKeyBase, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::PrimaryKeyBase **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_PrimaryKeyBase, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::PrimaryKeyBase::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::PrimaryKeyBase *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_PrimaryKeyBase
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::PrimaryKeyBase *const_holder =
          ACE_static_cast (
              const Components::PrimaryKeyBase *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::PrimaryKeyBase *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::PrimaryKeyBase *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_PrimaryKeyBase,
                1,
                ACE_static_cast (void *, tmp),
                Components::PrimaryKeyBase::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::PrimaryKeyBase, Components::PrimaryKeyBase_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::PrimaryKeyBase, Components::PrimaryKeyBase_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMHome_ptr _tao_elem
  )
{
  Components::CCMHome_ptr _tao_objptr =
    Components::CCMHome::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMHome_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMHome, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::CCMHome::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMHome_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::CCMHome::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMHome
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_CCMHome,
            1,
            _tao_elem,
            Components::CCMHome::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::CCMHome::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::CCMHome::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::CCMHome,Components::CCMHome_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::CCMHome,Components::CCMHome_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CCMHomes &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMHomes,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMHomes *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMHomes,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CCMHomes::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMHomes *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CCMHomes*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CCMHomes *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMHomes
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::CCMHomes*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::CCMHomes *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CCMHomes,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CCMHomes,
                1,
                ACE_static_cast (void *, tmp),
                Components::CCMHomes::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::KeylessCCMHome_ptr _tao_elem
  )
{
  Components::KeylessCCMHome_ptr _tao_objptr =
    Components::KeylessCCMHome::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::KeylessCCMHome_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_KeylessCCMHome, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::KeylessCCMHome::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::KeylessCCMHome_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::KeylessCCMHome::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_KeylessCCMHome
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_KeylessCCMHome,
            1,
            _tao_elem,
            Components::KeylessCCMHome::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::KeylessCCMHome::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::KeylessCCMHome::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::KeylessCCMHome,Components::KeylessCCMHome_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::KeylessCCMHome,Components::KeylessCCMHome_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeFinder_ptr _tao_elem
  )
{
  Components::HomeFinder_ptr _tao_objptr =
    Components::HomeFinder::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeFinder_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeFinder, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::HomeFinder::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::HomeFinder_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::HomeFinder::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeFinder
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_HomeFinder,
            1,
            _tao_elem,
            Components::HomeFinder::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::HomeFinder::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::HomeFinder::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::HomeFinder,Components::HomeFinder_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::HomeFinder,Components::HomeFinder_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Configurator_ptr _tao_elem
  )
{
  Components::Configurator_ptr _tao_objptr =
    Components::Configurator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Configurator_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Configurator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Configurator::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::Configurator_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Configurator::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Configurator
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Configurator,
            1,
            _tao_elem,
            Components::Configurator::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::Configurator::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Configurator::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Configurator,Components::Configurator_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::Configurator,Components::Configurator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ConfigValue *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_ConfigValue, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ConfigValue **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_ConfigValue, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::ConfigValue::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::ConfigValue *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConfigValue
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::ConfigValue *const_holder =
          ACE_static_cast (
              const Components::ConfigValue *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::ConfigValue *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::ConfigValue *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_ConfigValue,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConfigValue::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ConfigValue, Components::ConfigValue_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ConfigValue, Components::ConfigValue_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ConfigValues &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConfigValues,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ConfigValues *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConfigValues,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ConfigValues::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ConfigValues *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ConfigValues*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ConfigValues *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConfigValues
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ConfigValues*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ConfigValues *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ConfigValues,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ConfigValues,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConfigValues::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::StandardConfigurator_ptr _tao_elem
  )
{
  Components::StandardConfigurator_ptr _tao_objptr =
    Components::StandardConfigurator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::StandardConfigurator_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_StandardConfigurator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::StandardConfigurator::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::StandardConfigurator_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::StandardConfigurator::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_StandardConfigurator
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_StandardConfigurator,
            1,
            _tao_elem,
            Components::StandardConfigurator::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::StandardConfigurator::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::StandardConfigurator::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::StandardConfigurator,Components::StandardConfigurator_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::StandardConfigurator,Components::StandardConfigurator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeConfiguration_ptr _tao_elem
  )
{
  Components::HomeConfiguration_ptr _tao_objptr =
    Components::HomeConfiguration::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeConfiguration_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeConfiguration, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::HomeConfiguration::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::HomeConfiguration_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::HomeConfiguration::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeConfiguration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_HomeConfiguration,
            1,
            _tao_elem,
            Components::HomeConfiguration::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::HomeConfiguration::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::HomeConfiguration::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::HomeConfiguration,Components::HomeConfiguration_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::HomeConfiguration,Components::HomeConfiguration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ComponentPortDescription *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_ComponentPortDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::ComponentPortDescription **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_ComponentPortDescription, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::ComponentPortDescription::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::ComponentPortDescription *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ComponentPortDescription
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::ComponentPortDescription *const_holder =
          ACE_static_cast (
              const Components::ComponentPortDescription *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::ComponentPortDescription *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::ComponentPortDescription *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_ComponentPortDescription,
                1,
                ACE_static_cast (void *, tmp),
                Components::ComponentPortDescription::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ComponentPortDescription, Components::ComponentPortDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ComponentPortDescription, Components::ComponentPortDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMObject_ptr _tao_elem
  )
{
  Components::CCMObject_ptr _tao_objptr =
    Components::CCMObject::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMObject_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMObject, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::CCMObject::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMObject_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::CCMObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMObject
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_CCMObject,
            1,
            _tao_elem,
            Components::CCMObject::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
    _tao_elem = Components::CCMObject::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::CCMObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::CCMObject,Components::CCMObject_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::CCMObject,Components::CCMObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::Enumeration *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_Enumeration, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::Enumeration **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_Enumeration, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::Enumeration::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::Enumeration *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Enumeration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::Enumeration *const_holder =
          ACE_static_cast (
              const Components::Enumeration *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::Enumeration *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::Enumeration *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_Enumeration,
                1,
                ACE_static_cast (void *, tmp),
                Components::Enumeration::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::Enumeration, Components::Enumeration_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::Enumeration, Components::Enumeration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CCMObjectSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMObjectSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMObjectSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMObjectSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CCMObjectSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMObjectSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CCMObjectSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CCMObjectSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMObjectSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::CCMObjectSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::CCMObjectSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CCMObjectSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CCMObjectSeq,
                1,
                ACE_static_cast (void *, tmp),
                Components::CCMObjectSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/any_op_cs.cpp:56

// Copying.
void
operator<<= (
    CORBA::Any &any,
    Components::DefaultEnumeration *value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << value)
    {
      any._tao_replace (
          Components::_tc_DefaultEnumeration, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying.
void
operator<<= (
    CORBA::Any &any,
    Components::DefaultEnumeration **value
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *value)
    {
      any._tao_replace (
          Components::_tc_DefaultEnumeration, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *value,
          Components::DefaultEnumeration::_tao_any_destructor
        );
    }
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &any,
    Components::DefaultEnumeration *&value
  )
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_DefaultEnumeration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (any.any_owns_data ())
      {
        const Components::DefaultEnumeration *const_holder =
          ACE_static_cast (
              const Components::DefaultEnumeration *,
              any.value ()
            );
        value =
          ACE_const_cast (
              Components::DefaultEnumeration *,
              const_holder
            );
        return 1;
      }
    else
      {
        Components::DefaultEnumeration *tmp;
        TAO_InputCDR stream (
            any._tao_get_cdr (),
            any._tao_byte_order ()
          );
        
        if (stream >> tmp)
          {
            ((CORBA::Any *)&any)->_tao_replace (
                Components::_tc_DefaultEnumeration,
                1,
                ACE_static_cast (void *, tmp),
                Components::DefaultEnumeration::_tao_any_destructor
              );
            value = tmp;
            return 1;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::DefaultEnumeration, Components::DefaultEnumeration_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::DefaultEnumeration, Components::DefaultEnumeration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::PrimaryKeyBase * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::PrimaryKeyBase * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::PrimaryKeyBase *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::PrimaryKeyBase *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::PrimaryKeyBase::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::PrimaryKeyBase *&_tao_valuetype
  )
{
  return Components::PrimaryKeyBase::_tao_unmarshal (strm, _tao_valuetype);
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMHome_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMHome_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::CCMHome::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMHomes &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMHomes &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::KeylessCCMHome_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::KeylessCCMHome_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::KeylessCCMHome::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::HomeFinder_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::HomeFinder_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::HomeFinder::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Configurator_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Configurator_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::Configurator::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::ConfigValue * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::ConfigValue * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::ConfigValue *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::ConfigValue *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::ConfigValue::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::ConfigValue *&_tao_valuetype
  )
{
  return Components::ConfigValue::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::ConfigValue::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_name.in ()) &&
    (strm << _pd_value)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::ConfigValue::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_name.out ()) &&
    (strm >> _pd_value)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ConfigValues &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ConfigValues &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::StandardConfigurator_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::StandardConfigurator_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::StandardConfigurator::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::HomeConfiguration_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::HomeConfiguration_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::HomeConfiguration::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::ComponentPortDescription * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::ComponentPortDescription * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::ComponentPortDescription *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::ComponentPortDescription *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::ComponentPortDescription::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::ComponentPortDescription *&_tao_valuetype
  )
{
  return Components::ComponentPortDescription::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::ComponentPortDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_facets) &&
    (strm << _pd_receptacles) &&
    (strm << _pd_consumers) &&
    (strm << _pd_emitters) &&
    (strm << _pd_publishers)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::ComponentPortDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_facets) &&
    (strm >> _pd_receptacles) &&
    (strm >> _pd_consumers) &&
    (strm >> _pd_emitters) &&
    (strm >> _pd_publishers)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:63

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMObject_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMObject_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      Components::CCMObject::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::Enumeration * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::Enumeration * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::Enumeration *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::Enumeration *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::Enumeration::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::Enumeration *&_tao_valuetype
  )
{
  return Components::Enumeration::_tao_unmarshal (strm, _tao_valuetype);
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMObjectSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i].in ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMObjectSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:740

void
CORBA::add_ref (Components::DefaultEnumeration * vt)
{
  if (vt != 0)
    {
      vt->_add_ref ();
    }
}

void
CORBA::remove_ref (Components::DefaultEnumeration * vt)
{
  if (vt != 0)
    {
      vt->_remove_ref ();
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_cs.cpp:73

CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const Components::DefaultEnumeration *_tao_valuetype
  )
{
  return
    CORBA_ValueBase::_tao_marshal (
        strm,
        ACE_const_cast (
            Components::DefaultEnumeration *,
            _tao_valuetype
          ),
        (ptr_arith_t) &Components::DefaultEnumeration::_downcast
      );
}

CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    Components::DefaultEnumeration *&_tao_valuetype
  )
{
  return Components::DefaultEnumeration::_tao_unmarshal (strm, _tao_valuetype);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/marshal_cs.cpp:44

CORBA::Boolean
OBV_Components::DefaultEnumeration::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_objects)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

CORBA::Boolean
OBV_Components::DefaultEnumeration::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_objects)
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

