// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


#if !defined (_COMPONENTS_NAMELIST_CI_)
#define _COMPONENTS_NAMELIST_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::NameList_var
// *************************************************************

ACE_INLINE
Components::NameList_var::NameList_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::NameList_var::NameList_var (NameList *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::NameList_var::NameList_var (const ::Components::NameList_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::NameList (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::NameList_var::~NameList_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::NameList_var &
Components::NameList_var::operator= (NameList *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::NameList_var &
Components::NameList_var::operator= (const ::Components::NameList_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          NameList *deep_copy =
            new NameList (*p.ptr_);
          
          if (deep_copy != 0)
            {
              NameList *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::NameList *
Components::NameList_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::NameList *
Components::NameList_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::NameList_var::operator const ::Components::NameList &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::NameList_var::operator ::Components::NameList &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::NameList_var::operator ::Components::NameList &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::NameList_var::operator ::Components::NameList *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
Components::NameList_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::NameList &
Components::NameList_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::NameList &
Components::NameList_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::NameList *&
Components::NameList_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::NameList *
Components::NameList_var::_retn (void)
{
  ::Components::NameList *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::NameList *
Components::NameList_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::NameList_out
// *************************************************************

ACE_INLINE
Components::NameList_out::NameList_out (NameList *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::NameList_out::NameList_out (NameList_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::NameList_out::NameList_out (const ::Components::NameList_out &p) // copy constructor
  : ptr_ (ACE_const_cast (NameList_out&, p).ptr_)
{}

ACE_INLINE ::Components::NameList_out &
Components::NameList_out::operator= (const ::Components::NameList_out &p)
{
  this->ptr_ = ACE_const_cast (NameList_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::NameList_out &
Components::NameList_out::operator= (NameList *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::NameList_out::operator ::Components::NameList *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::NameList *&
Components::NameList_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::NameList *
Components::NameList_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
Components::NameList_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::Cookie::Cookie (void)
{}

ACE_INLINE
Components::Cookie::~Cookie (void)
{}

ACE_INLINE const char* 
Components::Cookie::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/Cookie:1.0";
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::PortDescription::PortDescription (void)
{}

ACE_INLINE
Components::PortDescription::~PortDescription (void)
{}

ACE_INLINE const char* 
Components::PortDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/PortDescription:1.0";
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::FacetDescription::FacetDescription (void)
{}

ACE_INLINE
Components::FacetDescription::~FacetDescription (void)
{}

ACE_INLINE const char* 
Components::FacetDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/FacetDescription:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_FACETDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_FACETDESCRIPTIONS_CI_

ACE_INLINE Components::FacetDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::FacetDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::FacetDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::freebuf (Components::FacetDescription **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::FacetDescription* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions(const _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::FacetDescription **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (this->maximum_);
    Components::FacetDescription ** const tmp2 = ACE_reinterpret_cast (Components::FacetDescription ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::FacetDescription **tmp = ACE_reinterpret_cast (Components::FacetDescription **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::FacetDescription **tmp1 = ACE_reinterpret_cast (Components::FacetDescription **, this->buffer_);
  Components::FacetDescription ** const tmp2 = ACE_reinterpret_cast (Components::FacetDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::FacetDescription,Components::FacetDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::FacetDescription ** const tmp = ACE_reinterpret_cast (Components::FacetDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::FacetDescription,Components::FacetDescription_var> (tmp + index, this->release_);
}

ACE_INLINE Components::FacetDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::FacetDescription **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::FacetDescription**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::FacetDescription**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::FacetDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::FacetDescription ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_FACETDESCRIPTIONS_CI_)
#define _COMPONENTS_FACETDESCRIPTIONS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::FacetDescriptions_var
// *************************************************************

ACE_INLINE
Components::FacetDescriptions_var::FacetDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::FacetDescriptions_var::FacetDescriptions_var (FacetDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::FacetDescriptions_var::FacetDescriptions_var (const ::Components::FacetDescriptions_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::FacetDescriptions (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::FacetDescriptions_var::~FacetDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::FacetDescriptions_var &
Components::FacetDescriptions_var::operator= (FacetDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::FacetDescriptions_var &
Components::FacetDescriptions_var::operator= (const ::Components::FacetDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          FacetDescriptions *deep_copy =
            new FacetDescriptions (*p.ptr_);
          
          if (deep_copy != 0)
            {
              FacetDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::FacetDescriptions *
Components::FacetDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::FacetDescriptions *
Components::FacetDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::FacetDescriptions_var::operator const ::Components::FacetDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::FacetDescriptions_var::operator ::Components::FacetDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::FacetDescriptions_var::operator ::Components::FacetDescriptions &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::FacetDescriptions_var::operator ::Components::FacetDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::FacetDescription, Components::FacetDescription_var>
Components::FacetDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::FacetDescriptions &
Components::FacetDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::FacetDescriptions &
Components::FacetDescriptions_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::FacetDescriptions *&
Components::FacetDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::FacetDescriptions *
Components::FacetDescriptions_var::_retn (void)
{
  ::Components::FacetDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::FacetDescriptions *
Components::FacetDescriptions_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::FacetDescriptions_out
// *************************************************************

ACE_INLINE
Components::FacetDescriptions_out::FacetDescriptions_out (FacetDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::FacetDescriptions_out::FacetDescriptions_out (FacetDescriptions_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::FacetDescriptions_out::FacetDescriptions_out (const ::Components::FacetDescriptions_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FacetDescriptions_out&, p).ptr_)
{}

ACE_INLINE ::Components::FacetDescriptions_out &
Components::FacetDescriptions_out::operator= (const ::Components::FacetDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (FacetDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::FacetDescriptions_out &
Components::FacetDescriptions_out::operator= (FacetDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::FacetDescriptions_out::operator ::Components::FacetDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::FacetDescriptions *&
Components::FacetDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::FacetDescriptions *
Components::FacetDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::FacetDescription, Components::FacetDescription_var>
Components::FacetDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception Components::InvalidName
// *************************************************************

// *************************************************************
// Inline operations for exception Components::InvalidConnection
// *************************************************************

// *************************************************************
// Inline operations for exception Components::ExceededConnectionLimit
// *************************************************************

// *************************************************************
// Inline operations for exception Components::AlreadyConnected
// *************************************************************

// *************************************************************
// Inline operations for exception Components::NoConnection
// *************************************************************

// *************************************************************
// Inline operations for exception Components::CookieRequired
// *************************************************************

// *************************************************************
// Inline operations for exception Components::CreateFailure
// *************************************************************

// *************************************************************
// Inline operations for exception Components::FinderFailure
// *************************************************************

// *************************************************************
// Inline operations for exception Components::RemoveFailure
// *************************************************************

// *************************************************************
// Inline operations for exception Components::DuplicateKeyValue
// *************************************************************

// *************************************************************
// Inline operations for exception Components::InvalidKey
// *************************************************************

// *************************************************************
// Inline operations for exception Components::UnknownKeyValue
// *************************************************************

// *************************************************************
// Inline operations for exception Components::NoKeyAvailable
// *************************************************************

// *************************************************************
// Inline operations for exception Components::BadEventType
// *************************************************************

// *************************************************************
// Inline operations for exception Components::HomeNotFound
// *************************************************************

// *************************************************************
// Inline operations for exception Components::WrongComponentType
// *************************************************************

// *************************************************************
// Inline operations for exception Components::InvalidConfiguration
// *************************************************************

// *************************************************************
// Inline operations for exception Components::IllegalState
// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_NAVIGATION___CI_)
#define _COMPONENTS_NAVIGATION___CI_

ACE_INLINE
Components::Navigation::Navigation (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Navigation_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::ConnectionDescription::ConnectionDescription (void)
{}

ACE_INLINE
Components::ConnectionDescription::~ConnectionDescription (void)
{}

ACE_INLINE const char* 
Components::ConnectionDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/ConnectionDescription:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONNECTIONDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONNECTIONDESCRIPTIONS_CI_

ACE_INLINE Components::ConnectionDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::ConnectionDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::ConnectionDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::freebuf (Components::ConnectionDescription **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::ConnectionDescription* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions(const _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::ConnectionDescription **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (this->maximum_);
    Components::ConnectionDescription ** const tmp2 = ACE_reinterpret_cast (Components::ConnectionDescription ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::ConnectionDescription **tmp = ACE_reinterpret_cast (Components::ConnectionDescription **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::ConnectionDescription **tmp1 = ACE_reinterpret_cast (Components::ConnectionDescription **, this->buffer_);
  Components::ConnectionDescription ** const tmp2 = ACE_reinterpret_cast (Components::ConnectionDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConnectionDescription,Components::ConnectionDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::ConnectionDescription ** const tmp = ACE_reinterpret_cast (Components::ConnectionDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::ConnectionDescription,Components::ConnectionDescription_var> (tmp + index, this->release_);
}

ACE_INLINE Components::ConnectionDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::ConnectionDescription **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::ConnectionDescription**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::ConnectionDescription**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::ConnectionDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::ConnectionDescription ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONNECTIONDESCRIPTIONS_CI_)
#define _COMPONENTS_CONNECTIONDESCRIPTIONS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::ConnectionDescriptions_var
// *************************************************************

ACE_INLINE
Components::ConnectionDescriptions_var::ConnectionDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::ConnectionDescriptions_var::ConnectionDescriptions_var (ConnectionDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::ConnectionDescriptions_var::ConnectionDescriptions_var (const ::Components::ConnectionDescriptions_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::ConnectionDescriptions (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::ConnectionDescriptions_var::~ConnectionDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::ConnectionDescriptions_var &
Components::ConnectionDescriptions_var::operator= (ConnectionDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::ConnectionDescriptions_var &
Components::ConnectionDescriptions_var::operator= (const ::Components::ConnectionDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ConnectionDescriptions *deep_copy =
            new ConnectionDescriptions (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ConnectionDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::ConnectionDescriptions *
Components::ConnectionDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConnectionDescriptions *
Components::ConnectionDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::ConnectionDescriptions_var::operator const ::Components::ConnectionDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ConnectionDescriptions_var::operator ::Components::ConnectionDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ConnectionDescriptions_var::operator ::Components::ConnectionDescriptions &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::ConnectionDescriptions_var::operator ::Components::ConnectionDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConnectionDescription, Components::ConnectionDescription_var>
Components::ConnectionDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::ConnectionDescriptions &
Components::ConnectionDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::ConnectionDescriptions &
Components::ConnectionDescriptions_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::ConnectionDescriptions *&
Components::ConnectionDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::ConnectionDescriptions *
Components::ConnectionDescriptions_var::_retn (void)
{
  ::Components::ConnectionDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::ConnectionDescriptions *
Components::ConnectionDescriptions_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::ConnectionDescriptions_out
// *************************************************************

ACE_INLINE
Components::ConnectionDescriptions_out::ConnectionDescriptions_out (ConnectionDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConnectionDescriptions_out::ConnectionDescriptions_out (ConnectionDescriptions_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConnectionDescriptions_out::ConnectionDescriptions_out (const ::Components::ConnectionDescriptions_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConnectionDescriptions_out&, p).ptr_)
{}

ACE_INLINE ::Components::ConnectionDescriptions_out &
Components::ConnectionDescriptions_out::operator= (const ::Components::ConnectionDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (ConnectionDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::ConnectionDescriptions_out &
Components::ConnectionDescriptions_out::operator= (ConnectionDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::ConnectionDescriptions_out::operator ::Components::ConnectionDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConnectionDescriptions *&
Components::ConnectionDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConnectionDescriptions *
Components::ConnectionDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConnectionDescription, Components::ConnectionDescription_var>
Components::ConnectionDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::ReceptacleDescription::ReceptacleDescription (void)
{}

ACE_INLINE
Components::ReceptacleDescription::~ReceptacleDescription (void)
{}

ACE_INLINE const char* 
Components::ReceptacleDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/ReceptacleDescription:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_RECEPTACLEDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_RECEPTACLEDESCRIPTIONS_CI_

ACE_INLINE Components::ReceptacleDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::ReceptacleDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::ReceptacleDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::freebuf (Components::ReceptacleDescription **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::ReceptacleDescription* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions(const _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::ReceptacleDescription **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (this->maximum_);
    Components::ReceptacleDescription ** const tmp2 = ACE_reinterpret_cast (Components::ReceptacleDescription ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::ReceptacleDescription **tmp = ACE_reinterpret_cast (Components::ReceptacleDescription **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::ReceptacleDescription **tmp1 = ACE_reinterpret_cast (Components::ReceptacleDescription **, this->buffer_);
  Components::ReceptacleDescription ** const tmp2 = ACE_reinterpret_cast (Components::ReceptacleDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ReceptacleDescription,Components::ReceptacleDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::ReceptacleDescription ** const tmp = ACE_reinterpret_cast (Components::ReceptacleDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::ReceptacleDescription,Components::ReceptacleDescription_var> (tmp + index, this->release_);
}

ACE_INLINE Components::ReceptacleDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::ReceptacleDescription **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::ReceptacleDescription**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::ReceptacleDescription**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::ReceptacleDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::ReceptacleDescription ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_RECEPTACLEDESCRIPTIONS_CI_)
#define _COMPONENTS_RECEPTACLEDESCRIPTIONS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::ReceptacleDescriptions_var
// *************************************************************

ACE_INLINE
Components::ReceptacleDescriptions_var::ReceptacleDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::ReceptacleDescriptions_var::ReceptacleDescriptions_var (ReceptacleDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::ReceptacleDescriptions_var::ReceptacleDescriptions_var (const ::Components::ReceptacleDescriptions_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::ReceptacleDescriptions (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::ReceptacleDescriptions_var::~ReceptacleDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::ReceptacleDescriptions_var &
Components::ReceptacleDescriptions_var::operator= (ReceptacleDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::ReceptacleDescriptions_var &
Components::ReceptacleDescriptions_var::operator= (const ::Components::ReceptacleDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ReceptacleDescriptions *deep_copy =
            new ReceptacleDescriptions (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ReceptacleDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::ReceptacleDescriptions *
Components::ReceptacleDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::ReceptacleDescriptions *
Components::ReceptacleDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::ReceptacleDescriptions_var::operator const ::Components::ReceptacleDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ReceptacleDescriptions_var::operator ::Components::ReceptacleDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ReceptacleDescriptions_var::operator ::Components::ReceptacleDescriptions &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::ReceptacleDescriptions_var::operator ::Components::ReceptacleDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ReceptacleDescription, Components::ReceptacleDescription_var>
Components::ReceptacleDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::ReceptacleDescriptions &
Components::ReceptacleDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::ReceptacleDescriptions &
Components::ReceptacleDescriptions_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::ReceptacleDescriptions *&
Components::ReceptacleDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::ReceptacleDescriptions *
Components::ReceptacleDescriptions_var::_retn (void)
{
  ::Components::ReceptacleDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::ReceptacleDescriptions *
Components::ReceptacleDescriptions_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::ReceptacleDescriptions_out
// *************************************************************

ACE_INLINE
Components::ReceptacleDescriptions_out::ReceptacleDescriptions_out (ReceptacleDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::ReceptacleDescriptions_out::ReceptacleDescriptions_out (ReceptacleDescriptions_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::ReceptacleDescriptions_out::ReceptacleDescriptions_out (const ::Components::ReceptacleDescriptions_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ReceptacleDescriptions_out&, p).ptr_)
{}

ACE_INLINE ::Components::ReceptacleDescriptions_out &
Components::ReceptacleDescriptions_out::operator= (const ::Components::ReceptacleDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (ReceptacleDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::ReceptacleDescriptions_out &
Components::ReceptacleDescriptions_out::operator= (ReceptacleDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::ReceptacleDescriptions_out::operator ::Components::ReceptacleDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::ReceptacleDescriptions *&
Components::ReceptacleDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::ReceptacleDescriptions *
Components::ReceptacleDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ReceptacleDescription, Components::ReceptacleDescription_var>
Components::ReceptacleDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_RECEPTACLES___CI_)
#define _COMPONENTS_RECEPTACLES___CI_

ACE_INLINE
Components::Receptacles::Receptacles (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Receptacles_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::EventBase::EventBase (void)
{}

ACE_INLINE
Components::EventBase::~EventBase (void)
{}

ACE_INLINE const char* 
Components::EventBase::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/EventBase:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_EVENTCONSUMERBASE___CI_)
#define _COMPONENTS_EVENTCONSUMERBASE___CI_

ACE_INLINE
Components::EventConsumerBase::EventConsumerBase (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_EventConsumerBase_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::ConsumerDescription::ConsumerDescription (void)
{}

ACE_INLINE
Components::ConsumerDescription::~ConsumerDescription (void)
{}

ACE_INLINE const char* 
Components::ConsumerDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/ConsumerDescription:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CI_

ACE_INLINE Components::ConsumerDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::ConsumerDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::ConsumerDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::freebuf (Components::ConsumerDescription **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::ConsumerDescription* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions(const _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::ConsumerDescription **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (this->maximum_);
    Components::ConsumerDescription ** const tmp2 = ACE_reinterpret_cast (Components::ConsumerDescription ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::ConsumerDescription **tmp = ACE_reinterpret_cast (Components::ConsumerDescription **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::ConsumerDescription **tmp1 = ACE_reinterpret_cast (Components::ConsumerDescription **, this->buffer_);
  Components::ConsumerDescription ** const tmp2 = ACE_reinterpret_cast (Components::ConsumerDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConsumerDescription,Components::ConsumerDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::ConsumerDescription ** const tmp = ACE_reinterpret_cast (Components::ConsumerDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::ConsumerDescription,Components::ConsumerDescription_var> (tmp + index, this->release_);
}

ACE_INLINE Components::ConsumerDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::ConsumerDescription **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::ConsumerDescription**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::ConsumerDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::ConsumerDescription ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONSUMERDESCRIPTIONS_CI_)
#define _COMPONENTS_CONSUMERDESCRIPTIONS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::ConsumerDescriptions_var
// *************************************************************

ACE_INLINE
Components::ConsumerDescriptions_var::ConsumerDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::ConsumerDescriptions_var::ConsumerDescriptions_var (ConsumerDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::ConsumerDescriptions_var::ConsumerDescriptions_var (const ::Components::ConsumerDescriptions_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::ConsumerDescriptions (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::ConsumerDescriptions_var::~ConsumerDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::ConsumerDescriptions_var &
Components::ConsumerDescriptions_var::operator= (ConsumerDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::ConsumerDescriptions_var &
Components::ConsumerDescriptions_var::operator= (const ::Components::ConsumerDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ConsumerDescriptions *deep_copy =
            new ConsumerDescriptions (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ConsumerDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::ConsumerDescriptions_var::operator const ::Components::ConsumerDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ConsumerDescriptions_var::operator ::Components::ConsumerDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ConsumerDescriptions_var::operator ::Components::ConsumerDescriptions &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::ConsumerDescriptions_var::operator ::Components::ConsumerDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>
Components::ConsumerDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::ConsumerDescriptions &
Components::ConsumerDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::ConsumerDescriptions &
Components::ConsumerDescriptions_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::ConsumerDescriptions *&
Components::ConsumerDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::_retn (void)
{
  ::Components::ConsumerDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::ConsumerDescriptions_out
// *************************************************************

ACE_INLINE
Components::ConsumerDescriptions_out::ConsumerDescriptions_out (ConsumerDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConsumerDescriptions_out::ConsumerDescriptions_out (ConsumerDescriptions_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConsumerDescriptions_out::ConsumerDescriptions_out (const ::Components::ConsumerDescriptions_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConsumerDescriptions_out&, p).ptr_)
{}

ACE_INLINE ::Components::ConsumerDescriptions_out &
Components::ConsumerDescriptions_out::operator= (const ::Components::ConsumerDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumerDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::ConsumerDescriptions_out &
Components::ConsumerDescriptions_out::operator= (ConsumerDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::ConsumerDescriptions_out::operator ::Components::ConsumerDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConsumerDescriptions *&
Components::ConsumerDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>
Components::ConsumerDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::EmitterDescription::EmitterDescription (void)
{}

ACE_INLINE
Components::EmitterDescription::~EmitterDescription (void)
{}

ACE_INLINE const char* 
Components::EmitterDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/EmitterDescription:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CI_

ACE_INLINE Components::EmitterDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::EmitterDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::EmitterDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::freebuf (Components::EmitterDescription **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::EmitterDescription* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions(const _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::EmitterDescription **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (this->maximum_);
    Components::EmitterDescription ** const tmp2 = ACE_reinterpret_cast (Components::EmitterDescription ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::EmitterDescription **tmp = ACE_reinterpret_cast (Components::EmitterDescription **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::EmitterDescription **tmp1 = ACE_reinterpret_cast (Components::EmitterDescription **, this->buffer_);
  Components::EmitterDescription ** const tmp2 = ACE_reinterpret_cast (Components::EmitterDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::EmitterDescription,Components::EmitterDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::EmitterDescription ** const tmp = ACE_reinterpret_cast (Components::EmitterDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::EmitterDescription,Components::EmitterDescription_var> (tmp + index, this->release_);
}

ACE_INLINE Components::EmitterDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::EmitterDescription **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::EmitterDescription**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::EmitterDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::EmitterDescription ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_EMITTERDESCRIPTIONS_CI_)
#define _COMPONENTS_EMITTERDESCRIPTIONS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::EmitterDescriptions_var
// *************************************************************

ACE_INLINE
Components::EmitterDescriptions_var::EmitterDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::EmitterDescriptions_var::EmitterDescriptions_var (EmitterDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::EmitterDescriptions_var::EmitterDescriptions_var (const ::Components::EmitterDescriptions_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::EmitterDescriptions (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::EmitterDescriptions_var::~EmitterDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::EmitterDescriptions_var &
Components::EmitterDescriptions_var::operator= (EmitterDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::EmitterDescriptions_var &
Components::EmitterDescriptions_var::operator= (const ::Components::EmitterDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          EmitterDescriptions *deep_copy =
            new EmitterDescriptions (*p.ptr_);
          
          if (deep_copy != 0)
            {
              EmitterDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::EmitterDescriptions_var::operator const ::Components::EmitterDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::EmitterDescriptions_var::operator ::Components::EmitterDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::EmitterDescriptions_var::operator ::Components::EmitterDescriptions &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::EmitterDescriptions_var::operator ::Components::EmitterDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>
Components::EmitterDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::EmitterDescriptions &
Components::EmitterDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::EmitterDescriptions &
Components::EmitterDescriptions_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::EmitterDescriptions *&
Components::EmitterDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::_retn (void)
{
  ::Components::EmitterDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::EmitterDescriptions_out
// *************************************************************

ACE_INLINE
Components::EmitterDescriptions_out::EmitterDescriptions_out (EmitterDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::EmitterDescriptions_out::EmitterDescriptions_out (EmitterDescriptions_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::EmitterDescriptions_out::EmitterDescriptions_out (const ::Components::EmitterDescriptions_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EmitterDescriptions_out&, p).ptr_)
{}

ACE_INLINE ::Components::EmitterDescriptions_out &
Components::EmitterDescriptions_out::operator= (const ::Components::EmitterDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (EmitterDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::EmitterDescriptions_out &
Components::EmitterDescriptions_out::operator= (EmitterDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::EmitterDescriptions_out::operator ::Components::EmitterDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::EmitterDescriptions *&
Components::EmitterDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::EmitterDescriptions *
Components::EmitterDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>
Components::EmitterDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::SubscriberDescription::SubscriberDescription (void)
{}

ACE_INLINE
Components::SubscriberDescription::~SubscriberDescription (void)
{}

ACE_INLINE const char* 
Components::SubscriberDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/SubscriberDescription:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_

ACE_INLINE Components::SubscriberDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::SubscriberDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::SubscriberDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::freebuf (Components::SubscriberDescription **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::SubscriberDescription* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions(const _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::SubscriberDescription **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (this->maximum_);
    Components::SubscriberDescription ** const tmp2 = ACE_reinterpret_cast (Components::SubscriberDescription ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::SubscriberDescription **tmp = ACE_reinterpret_cast (Components::SubscriberDescription **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::SubscriberDescription **tmp1 = ACE_reinterpret_cast (Components::SubscriberDescription **, this->buffer_);
  Components::SubscriberDescription ** const tmp2 = ACE_reinterpret_cast (Components::SubscriberDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::SubscriberDescription,Components::SubscriberDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::SubscriberDescription ** const tmp = ACE_reinterpret_cast (Components::SubscriberDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::SubscriberDescription,Components::SubscriberDescription_var> (tmp + index, this->release_);
}

ACE_INLINE Components::SubscriberDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::SubscriberDescription **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::SubscriberDescription**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::SubscriberDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::SubscriberDescription ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_)
#define _COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::SubscriberDescriptions_var
// *************************************************************

ACE_INLINE
Components::SubscriberDescriptions_var::SubscriberDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::SubscriberDescriptions_var::SubscriberDescriptions_var (SubscriberDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::SubscriberDescriptions_var::SubscriberDescriptions_var (const ::Components::SubscriberDescriptions_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::SubscriberDescriptions (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::SubscriberDescriptions_var::~SubscriberDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::SubscriberDescriptions_var &
Components::SubscriberDescriptions_var::operator= (SubscriberDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::SubscriberDescriptions_var &
Components::SubscriberDescriptions_var::operator= (const ::Components::SubscriberDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          SubscriberDescriptions *deep_copy =
            new SubscriberDescriptions (*p.ptr_);
          
          if (deep_copy != 0)
            {
              SubscriberDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::SubscriberDescriptions_var::operator const ::Components::SubscriberDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::SubscriberDescriptions_var::operator ::Components::SubscriberDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::SubscriberDescriptions_var::operator ::Components::SubscriberDescriptions &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::SubscriberDescriptions_var::operator ::Components::SubscriberDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>
Components::SubscriberDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::SubscriberDescriptions &
Components::SubscriberDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::SubscriberDescriptions &
Components::SubscriberDescriptions_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::SubscriberDescriptions *&
Components::SubscriberDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::_retn (void)
{
  ::Components::SubscriberDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::SubscriberDescriptions_out
// *************************************************************

ACE_INLINE
Components::SubscriberDescriptions_out::SubscriberDescriptions_out (SubscriberDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::SubscriberDescriptions_out::SubscriberDescriptions_out (SubscriberDescriptions_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::SubscriberDescriptions_out::SubscriberDescriptions_out (const ::Components::SubscriberDescriptions_out &p) // copy constructor
  : ptr_ (ACE_const_cast (SubscriberDescriptions_out&, p).ptr_)
{}

ACE_INLINE ::Components::SubscriberDescriptions_out &
Components::SubscriberDescriptions_out::operator= (const ::Components::SubscriberDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (SubscriberDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::SubscriberDescriptions_out &
Components::SubscriberDescriptions_out::operator= (SubscriberDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::SubscriberDescriptions_out::operator ::Components::SubscriberDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::SubscriberDescriptions *&
Components::SubscriberDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>
Components::SubscriberDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::PublisherDescription::PublisherDescription (void)
{}

ACE_INLINE
Components::PublisherDescription::~PublisherDescription (void)
{}

ACE_INLINE const char* 
Components::PublisherDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/PublisherDescription:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CI_

ACE_INLINE Components::PublisherDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::PublisherDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::PublisherDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::freebuf (Components::PublisherDescription **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::PublisherDescription* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions(const _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::PublisherDescription **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (this->maximum_);
    Components::PublisherDescription ** const tmp2 = ACE_reinterpret_cast (Components::PublisherDescription ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::PublisherDescription **tmp = ACE_reinterpret_cast (Components::PublisherDescription **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::PublisherDescription **tmp1 = ACE_reinterpret_cast (Components::PublisherDescription **, this->buffer_);
  Components::PublisherDescription ** const tmp2 = ACE_reinterpret_cast (Components::PublisherDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::PublisherDescription,Components::PublisherDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::PublisherDescription ** const tmp = ACE_reinterpret_cast (Components::PublisherDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::PublisherDescription,Components::PublisherDescription_var> (tmp + index, this->release_);
}

ACE_INLINE Components::PublisherDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::PublisherDescription **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::PublisherDescription**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::PublisherDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::PublisherDescription ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_PUBLISHERDESCRIPTIONS_CI_)
#define _COMPONENTS_PUBLISHERDESCRIPTIONS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::PublisherDescriptions_var
// *************************************************************

ACE_INLINE
Components::PublisherDescriptions_var::PublisherDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::PublisherDescriptions_var::PublisherDescriptions_var (PublisherDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::PublisherDescriptions_var::PublisherDescriptions_var (const ::Components::PublisherDescriptions_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::PublisherDescriptions (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::PublisherDescriptions_var::~PublisherDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::PublisherDescriptions_var &
Components::PublisherDescriptions_var::operator= (PublisherDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::PublisherDescriptions_var &
Components::PublisherDescriptions_var::operator= (const ::Components::PublisherDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          PublisherDescriptions *deep_copy =
            new PublisherDescriptions (*p.ptr_);
          
          if (deep_copy != 0)
            {
              PublisherDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::PublisherDescriptions_var::operator const ::Components::PublisherDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::PublisherDescriptions_var::operator ::Components::PublisherDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::PublisherDescriptions_var::operator ::Components::PublisherDescriptions &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::PublisherDescriptions_var::operator ::Components::PublisherDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>
Components::PublisherDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::PublisherDescriptions &
Components::PublisherDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::PublisherDescriptions &
Components::PublisherDescriptions_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::PublisherDescriptions *&
Components::PublisherDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::_retn (void)
{
  ::Components::PublisherDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::PublisherDescriptions_out
// *************************************************************

ACE_INLINE
Components::PublisherDescriptions_out::PublisherDescriptions_out (PublisherDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::PublisherDescriptions_out::PublisherDescriptions_out (PublisherDescriptions_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::PublisherDescriptions_out::PublisherDescriptions_out (const ::Components::PublisherDescriptions_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PublisherDescriptions_out&, p).ptr_)
{}

ACE_INLINE ::Components::PublisherDescriptions_out &
Components::PublisherDescriptions_out::operator= (const ::Components::PublisherDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (PublisherDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::PublisherDescriptions_out &
Components::PublisherDescriptions_out::operator= (PublisherDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::PublisherDescriptions_out::operator ::Components::PublisherDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::PublisherDescriptions *&
Components::PublisherDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::PublisherDescriptions *
Components::PublisherDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>
Components::PublisherDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_EVENTS___CI_)
#define _COMPONENTS_EVENTS___CI_

ACE_INLINE
Components::Events::Events (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Events_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::PrimaryKeyBase::PrimaryKeyBase (void)
{}

ACE_INLINE
Components::PrimaryKeyBase::~PrimaryKeyBase (void)
{}

ACE_INLINE const char* 
Components::PrimaryKeyBase::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/PrimaryKeyBase:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_CCMHOME___CI_)
#define _COMPONENTS_CCMHOME___CI_

ACE_INLINE
Components::CCMHome::CCMHome (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_CCMHome_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMHOMES_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMHOMES_CI_

ACE_INLINE Components::CCMHome **
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (CORBA::ULong nelems)
{
  Components::CCMHome **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::CCMHome*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = Components::CCMHome::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::freebuf (Components::CCMHome **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_TAO_Unbounded_Object_Sequence_Components_CCMHomes (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_TAO_Unbounded_Object_Sequence_Components_CCMHomes (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_TAO_Unbounded_Object_Sequence_Components_CCMHomes (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::CCMHome* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_TAO_Unbounded_Object_Sequence_Components_CCMHomes(const _TAO_Unbounded_Object_Sequence_Components_CCMHomes &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::CCMHome **tmp1 = _TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (this->maximum_);
    Components::CCMHome ** const tmp2 = ACE_reinterpret_cast (Components::CCMHome ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = Components::CCMHome::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes &
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::operator= (const _TAO_Unbounded_Object_Sequence_Components_CCMHomes &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::CCMHome **tmp = ACE_reinterpret_cast (Components::CCMHome **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMHome::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_Components_CCMHomes::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::CCMHome **tmp1 = ACE_reinterpret_cast (Components::CCMHome **, this->buffer_);
  Components::CCMHome ** const tmp2 = ACE_reinterpret_cast (Components::CCMHome ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = Components::CCMHome::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<Components::CCMHome,Components::CCMHome_var>
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::CCMHome ** const tmp = ACE_reinterpret_cast (Components::CCMHome ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<Components::CCMHome,Components::CCMHome_var> (tmp + index, this->release_);
}

ACE_INLINE Components::CCMHome* *
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::get_buffer (CORBA::Boolean orphan)
{
  Components::CCMHome **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::CCMHome**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::CCMHome**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::CCMHome* *
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::CCMHome ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CCMHOMES_CI_)
#define _COMPONENTS_CCMHOMES_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::CCMHomes_var
// *************************************************************

ACE_INLINE
Components::CCMHomes_var::CCMHomes_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::CCMHomes_var::CCMHomes_var (CCMHomes *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::CCMHomes_var::CCMHomes_var (const ::Components::CCMHomes_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::CCMHomes (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::CCMHomes_var::~CCMHomes_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::CCMHomes_var &
Components::CCMHomes_var::operator= (CCMHomes *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::CCMHomes_var &
Components::CCMHomes_var::operator= (const ::Components::CCMHomes_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          CCMHomes *deep_copy =
            new CCMHomes (*p.ptr_);
          
          if (deep_copy != 0)
            {
              CCMHomes *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::CCMHomes *
Components::CCMHomes_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::CCMHomes *
Components::CCMHomes_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::CCMHomes_var::operator const ::Components::CCMHomes &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::CCMHomes_var::operator ::Components::CCMHomes &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::CCMHomes_var::operator ::Components::CCMHomes &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::CCMHomes_var::operator ::Components::CCMHomes *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::CCMHome, Components::CCMHome_var>
Components::CCMHomes_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::CCMHomes &
Components::CCMHomes_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::CCMHomes &
Components::CCMHomes_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::CCMHomes *&
Components::CCMHomes_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::CCMHomes *
Components::CCMHomes_var::_retn (void)
{
  ::Components::CCMHomes *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::CCMHomes *
Components::CCMHomes_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::CCMHomes_out
// *************************************************************

ACE_INLINE
Components::CCMHomes_out::CCMHomes_out (CCMHomes *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::CCMHomes_out::CCMHomes_out (CCMHomes_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::CCMHomes_out::CCMHomes_out (const ::Components::CCMHomes_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CCMHomes_out&, p).ptr_)
{}

ACE_INLINE ::Components::CCMHomes_out &
Components::CCMHomes_out::operator= (const ::Components::CCMHomes_out &p)
{
  this->ptr_ = ACE_const_cast (CCMHomes_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::CCMHomes_out &
Components::CCMHomes_out::operator= (CCMHomes *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::CCMHomes_out::operator ::Components::CCMHomes *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::CCMHomes *&
Components::CCMHomes_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::CCMHomes *
Components::CCMHomes_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::CCMHome, Components::CCMHome_var>
Components::CCMHomes_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_KEYLESSCCMHOME___CI_)
#define _COMPONENTS_KEYLESSCCMHOME___CI_

ACE_INLINE
Components::KeylessCCMHome::KeylessCCMHome (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_KeylessCCMHome_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_HOMEFINDER___CI_)
#define _COMPONENTS_HOMEFINDER___CI_

ACE_INLINE
Components::HomeFinder::HomeFinder (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_HomeFinder_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_CONFIGURATOR___CI_)
#define _COMPONENTS_CONFIGURATOR___CI_

ACE_INLINE
Components::Configurator::Configurator (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Configurator_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::ConfigValue::ConfigValue (void)
{}

ACE_INLINE
Components::ConfigValue::~ConfigValue (void)
{}

ACE_INLINE const char* 
Components::ConfigValue::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/ConfigValue:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONFIGVALUES_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONFIGVALUES_CI_

ACE_INLINE Components::ConfigValue **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (CORBA::ULong nelems)
{
  Components::ConfigValue **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::ConfigValue*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::freebuf (Components::ConfigValue **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::ConfigValue* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues(const _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::ConfigValue **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (this->maximum_);
    Components::ConfigValue ** const tmp2 = ACE_reinterpret_cast (Components::ConfigValue ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::ConfigValue **tmp = ACE_reinterpret_cast (Components::ConfigValue **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::ConfigValue **tmp1 = ACE_reinterpret_cast (Components::ConfigValue **, this->buffer_);
  Components::ConfigValue ** const tmp2 = ACE_reinterpret_cast (Components::ConfigValue ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConfigValue,Components::ConfigValue_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::ConfigValue ** const tmp = ACE_reinterpret_cast (Components::ConfigValue ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::ConfigValue,Components::ConfigValue_var> (tmp + index, this->release_);
}

ACE_INLINE Components::ConfigValue* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::get_buffer (CORBA::Boolean orphan)
{
  Components::ConfigValue **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::ConfigValue**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::ConfigValue**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::ConfigValue* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::ConfigValue ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONFIGVALUES_CI_)
#define _COMPONENTS_CONFIGVALUES_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::ConfigValues_var
// *************************************************************

ACE_INLINE
Components::ConfigValues_var::ConfigValues_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::ConfigValues_var::ConfigValues_var (ConfigValues *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::ConfigValues_var::ConfigValues_var (const ::Components::ConfigValues_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::ConfigValues (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::ConfigValues_var::~ConfigValues_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::ConfigValues_var &
Components::ConfigValues_var::operator= (ConfigValues *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::ConfigValues_var &
Components::ConfigValues_var::operator= (const ::Components::ConfigValues_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ConfigValues *deep_copy =
            new ConfigValues (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ConfigValues *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::ConfigValues *
Components::ConfigValues_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConfigValues *
Components::ConfigValues_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::ConfigValues_var::operator const ::Components::ConfigValues &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ConfigValues_var::operator ::Components::ConfigValues &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::ConfigValues_var::operator ::Components::ConfigValues &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::ConfigValues_var::operator ::Components::ConfigValues *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConfigValue, Components::ConfigValue_var>
Components::ConfigValues_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::ConfigValues &
Components::ConfigValues_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::ConfigValues &
Components::ConfigValues_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::ConfigValues *&
Components::ConfigValues_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::ConfigValues *
Components::ConfigValues_var::_retn (void)
{
  ::Components::ConfigValues *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::ConfigValues *
Components::ConfigValues_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::ConfigValues_out
// *************************************************************

ACE_INLINE
Components::ConfigValues_out::ConfigValues_out (ConfigValues *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConfigValues_out::ConfigValues_out (ConfigValues_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConfigValues_out::ConfigValues_out (const ::Components::ConfigValues_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConfigValues_out&, p).ptr_)
{}

ACE_INLINE ::Components::ConfigValues_out &
Components::ConfigValues_out::operator= (const ::Components::ConfigValues_out &p)
{
  this->ptr_ = ACE_const_cast (ConfigValues_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::ConfigValues_out &
Components::ConfigValues_out::operator= (ConfigValues *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::ConfigValues_out::operator ::Components::ConfigValues *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConfigValues *&
Components::ConfigValues_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::ConfigValues *
Components::ConfigValues_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::ConfigValue, Components::ConfigValue_var>
Components::ConfigValues_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_STANDARDCONFIGURATOR___CI_)
#define _COMPONENTS_STANDARDCONFIGURATOR___CI_

ACE_INLINE
Components::StandardConfigurator::StandardConfigurator (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_StandardConfigurator_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_HOMECONFIGURATION___CI_)
#define _COMPONENTS_HOMECONFIGURATION___CI_

ACE_INLINE
Components::HomeConfiguration::HomeConfiguration (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_HomeConfiguration_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::ComponentPortDescription::ComponentPortDescription (void)
{}

ACE_INLINE
Components::ComponentPortDescription::~ComponentPortDescription (void)
{}

ACE_INLINE const char* 
Components::ComponentPortDescription::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/ComponentPortDescription:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_CCMOBJECT___CI_)
#define _COMPONENTS_CCMOBJECT___CI_

ACE_INLINE
Components::CCMObject::CCMObject (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_CCMObject_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::Enumeration::Enumeration (void)
{}

ACE_INLINE
Components::Enumeration::~Enumeration (void)
{}

ACE_INLINE const char* 
Components::Enumeration::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/Enumeration:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMOBJECTSEQ_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMOBJECTSEQ_CI_

ACE_INLINE Components::CCMObject **
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (CORBA::ULong nelems)
{
  Components::CCMObject **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::CCMObject*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = Components::CCMObject::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::freebuf (Components::CCMObject **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::CCMObject* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq(const _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::CCMObject **tmp1 = _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (this->maximum_);
    Components::CCMObject ** const tmp2 = ACE_reinterpret_cast (Components::CCMObject ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = Components::CCMObject::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq &
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::operator= (const _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::CCMObject **tmp = ACE_reinterpret_cast (Components::CCMObject **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMObject::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::CCMObject **tmp1 = ACE_reinterpret_cast (Components::CCMObject **, this->buffer_);
  Components::CCMObject ** const tmp2 = ACE_reinterpret_cast (Components::CCMObject ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = Components::CCMObject::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<Components::CCMObject,Components::CCMObject_var>
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::CCMObject ** const tmp = ACE_reinterpret_cast (Components::CCMObject ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<Components::CCMObject,Components::CCMObject_var> (tmp + index, this->release_);
}

ACE_INLINE Components::CCMObject* *
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::get_buffer (CORBA::Boolean orphan)
{
  Components::CCMObject **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::CCMObject**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::CCMObject**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::CCMObject* *
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::CCMObject ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CCMOBJECTSEQ_CI_)
#define _COMPONENTS_CCMOBJECTSEQ_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::CCMObjectSeq_var
// *************************************************************

ACE_INLINE
Components::CCMObjectSeq_var::CCMObjectSeq_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::CCMObjectSeq_var::CCMObjectSeq_var (CCMObjectSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::CCMObjectSeq_var::CCMObjectSeq_var (const ::Components::CCMObjectSeq_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::CCMObjectSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::CCMObjectSeq_var::~CCMObjectSeq_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::CCMObjectSeq_var &
Components::CCMObjectSeq_var::operator= (CCMObjectSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::CCMObjectSeq_var &
Components::CCMObjectSeq_var::operator= (const ::Components::CCMObjectSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          CCMObjectSeq *deep_copy =
            new CCMObjectSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              CCMObjectSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::CCMObjectSeq *
Components::CCMObjectSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::CCMObjectSeq *
Components::CCMObjectSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::CCMObjectSeq_var::operator const ::Components::CCMObjectSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::CCMObjectSeq_var::operator ::Components::CCMObjectSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::CCMObjectSeq_var::operator ::Components::CCMObjectSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::CCMObjectSeq_var::operator ::Components::CCMObjectSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::CCMObject, Components::CCMObject_var>
Components::CCMObjectSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::CCMObjectSeq &
Components::CCMObjectSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::CCMObjectSeq &
Components::CCMObjectSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::CCMObjectSeq *&
Components::CCMObjectSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::CCMObjectSeq *
Components::CCMObjectSeq_var::_retn (void)
{
  ::Components::CCMObjectSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::CCMObjectSeq *
Components::CCMObjectSeq_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::CCMObjectSeq_out
// *************************************************************

ACE_INLINE
Components::CCMObjectSeq_out::CCMObjectSeq_out (CCMObjectSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::CCMObjectSeq_out::CCMObjectSeq_out (CCMObjectSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::CCMObjectSeq_out::CCMObjectSeq_out (const ::Components::CCMObjectSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CCMObjectSeq_out&, p).ptr_)
{}

ACE_INLINE ::Components::CCMObjectSeq_out &
Components::CCMObjectSeq_out::operator= (const ::Components::CCMObjectSeq_out &p)
{
  this->ptr_ = ACE_const_cast (CCMObjectSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::CCMObjectSeq_out &
Components::CCMObjectSeq_out::operator= (CCMObjectSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::CCMObjectSeq_out::operator ::Components::CCMObjectSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::CCMObjectSeq *&
Components::CCMObjectSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::CCMObjectSeq *
Components::CCMObjectSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::CCMObject, Components::CCMObject_var>
Components::CCMObjectSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::DefaultEnumeration::DefaultEnumeration (void)
{}

ACE_INLINE
Components::DefaultEnumeration::~DefaultEnumeration (void)
{}

ACE_INLINE const char* 
Components::DefaultEnumeration::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/DefaultEnumeration:1.0";
}


#if !defined (_COMPONENTS_TRANSACTION_TRANTOKEN_CI_)
#define _COMPONENTS_TRANSACTION_TRANTOKEN_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::Transaction::TranToken_var
// *************************************************************

ACE_INLINE
Components::Transaction::TranToken_var::TranToken_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::Transaction::TranToken_var::TranToken_var (TranToken *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::Transaction::TranToken_var::TranToken_var (const ::Components::Transaction::TranToken_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::Transaction::TranToken (*p.ptr_));
  else
    this->ptr_ = 0;
}

// fixed-size base types only
ACE_INLINE
Components::Transaction::TranToken_var::TranToken_var (const ::Components::Transaction::TranToken &p)
{
  ACE_NEW (this->ptr_, ::Components::Transaction::TranToken (p));
}

ACE_INLINE
Components::Transaction::TranToken_var::~TranToken_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::Transaction::TranToken_var &
Components::Transaction::TranToken_var::operator= (TranToken *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::Transaction::TranToken_var &
Components::Transaction::TranToken_var::operator= (const ::Components::Transaction::TranToken_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          TranToken *deep_copy =
            new TranToken (*p.ptr_);
          
          if (deep_copy != 0)
            {
              TranToken *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

// fixed-size types only
ACE_INLINE ::Components::Transaction::TranToken_var &
Components::Transaction::TranToken_var::operator= (const ::Components::Transaction::TranToken &p)
{
  if (this->ptr_ != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::Components::Transaction::TranToken (p), *this);
  }
  return *this;
}

ACE_INLINE const ::Components::Transaction::TranToken *
Components::Transaction::TranToken_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::Transaction::TranToken *
Components::Transaction::TranToken_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::Transaction::TranToken_var::operator const ::Components::Transaction::TranToken &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::Transaction::TranToken_var::operator ::Components::Transaction::TranToken &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::Transaction::TranToken_var::operator ::Components::Transaction::TranToken &() const // cast 
{
  return *this->ptr_;
}

ACE_INLINE CORBA::Octet &
Components::Transaction::TranToken_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const CORBA::Octet &
Components::Transaction::TranToken_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const CORBA::Octet &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::Components::Transaction::TranToken &
Components::Transaction::TranToken_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::Transaction::TranToken &
Components::Transaction::TranToken_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::Transaction::TranToken *&
Components::Transaction::TranToken_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::Transaction::TranToken *
Components::Transaction::TranToken_var::_retn (void)
{
  ::Components::Transaction::TranToken *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::Transaction::TranToken *
Components::Transaction::TranToken_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::Transaction::TranToken_out
// *************************************************************

ACE_INLINE
Components::Transaction::TranToken_out::TranToken_out (TranToken *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::Transaction::TranToken_out::TranToken_out (TranToken_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::Transaction::TranToken_out::TranToken_out (const ::Components::Transaction::TranToken_out &p) // copy constructor
  : ptr_ (ACE_const_cast (TranToken_out&, p).ptr_)
{}

ACE_INLINE ::Components::Transaction::TranToken_out &
Components::Transaction::TranToken_out::operator= (const ::Components::Transaction::TranToken_out &p)
{
  this->ptr_ = ACE_const_cast (TranToken_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::Transaction::TranToken_out &
Components::Transaction::TranToken_out::operator= (TranToken *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::Transaction::TranToken_out::operator ::Components::Transaction::TranToken *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::Transaction::TranToken *&
Components::Transaction::TranToken_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::Transaction::TranToken *
Components::Transaction::TranToken_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE CORBA::Octet &
Components::Transaction::TranToken_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception Components::Transaction::NoTransaction
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Transaction::NotSupported
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Transaction::SystemError
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Transaction::RollbackError
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Transaction::HeuristicMixed
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Transaction::HeuristicRollback
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Transaction::Security
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Transaction::InvalidToken
// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_TRANSACTION_USERTRANSACTION___CI_)
#define _COMPONENTS_TRANSACTION_USERTRANSACTION___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_CCMCONTEXT___CI_)
#define _COMPONENTS_CCMCONTEXT___CI_


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception Components::CCMException
// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_ENTERPRISECOMPONENT___CI_)
#define _COMPONENTS_ENTERPRISECOMPONENT___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_SESSIONCONTEXT___CI_)
#define _COMPONENTS_SESSIONCONTEXT___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_SESSIONCOMPONENT___CI_)
#define _COMPONENTS_SESSIONCOMPONENT___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_SESSIONSYNCHRONIZATION___CI_)
#define _COMPONENTS_SESSIONSYNCHRONIZATION___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_ENTITYCONTEXT___CI_)
#define _COMPONENTS_ENTITYCONTEXT___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_ENTITYCOMPONENT___CI_)
#define _COMPONENTS_ENTITYCOMPONENT___CI_


#endif /* end #if !defined */


#if !defined (_COMPONENTS_IDDATA_CI_)
#define _COMPONENTS_IDDATA_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::IdData_var
// *************************************************************

ACE_INLINE
Components::IdData_var::IdData_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::IdData_var::IdData_var (IdData *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::IdData_var::IdData_var (const ::Components::IdData_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::IdData (*p.ptr_));
  else
    this->ptr_ = 0;
}

// fixed-size base types only
ACE_INLINE
Components::IdData_var::IdData_var (const ::Components::IdData &p)
{
  ACE_NEW (this->ptr_, ::Components::IdData (p));
}

ACE_INLINE
Components::IdData_var::~IdData_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::IdData_var &
Components::IdData_var::operator= (IdData *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::IdData_var &
Components::IdData_var::operator= (const ::Components::IdData_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          IdData *deep_copy =
            new IdData (*p.ptr_);
          
          if (deep_copy != 0)
            {
              IdData *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

// fixed-size types only
ACE_INLINE ::Components::IdData_var &
Components::IdData_var::operator= (const ::Components::IdData &p)
{
  if (this->ptr_ != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::Components::IdData (p), *this);
  }
  return *this;
}

ACE_INLINE const ::Components::IdData *
Components::IdData_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::IdData *
Components::IdData_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::IdData_var::operator const ::Components::IdData &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::IdData_var::operator ::Components::IdData &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::IdData_var::operator ::Components::IdData &() const // cast 
{
  return *this->ptr_;
}

ACE_INLINE CORBA::Octet &
Components::IdData_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const CORBA::Octet &
Components::IdData_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const CORBA::Octet &, this->ptr_->operator[] (index));
}

ACE_INLINE const ::Components::IdData &
Components::IdData_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::IdData &
Components::IdData_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::IdData *&
Components::IdData_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::IdData *
Components::IdData_var::_retn (void)
{
  ::Components::IdData *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::IdData *
Components::IdData_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::IdData_out
// *************************************************************

ACE_INLINE
Components::IdData_out::IdData_out (IdData *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::IdData_out::IdData_out (IdData_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::IdData_out::IdData_out (const ::Components::IdData_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IdData_out&, p).ptr_)
{}

ACE_INLINE ::Components::IdData_out &
Components::IdData_out::operator= (const ::Components::IdData_out &p)
{
  this->ptr_ = ACE_const_cast (IdData_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::IdData_out &
Components::IdData_out::operator= (IdData *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::IdData_out::operator ::Components::IdData *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::IdData *&
Components::IdData_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::IdData *
Components::IdData_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE CORBA::Octet &
Components::IdData_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception Components::BadComponentReference
// *************************************************************

// *************************************************************
// Inline operations for exception Components::PolicyMismatch
// *************************************************************

// *************************************************************
// Inline operations for exception Components::PersistenceNotAvailable
// *************************************************************

// *************************************************************
// Inline operations for exception Components::UnknownActualHome
// *************************************************************

// *************************************************************
// Inline operations for exception Components::ProxyHomeNotSupported
// *************************************************************

// *************************************************************
// Inline operations for exception Components::InvalidStateIdData
// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_HOMEREGISTRATION___CI_)
#define _COMPONENTS_HOMEREGISTRATION___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_CCM2CONTEXT___CI_)
#define _COMPONENTS_CCM2CONTEXT___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_PROXYHOMEREGISTRATION___CI_)
#define _COMPONENTS_PROXYHOMEREGISTRATION___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_SESSION2CONTEXT___CI_)
#define _COMPONENTS_SESSION2CONTEXT___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::StateIdValue::StateIdValue (void)
{}

ACE_INLINE
Components::StateIdValue::~StateIdValue (void)
{}

ACE_INLINE const char* 
Components::StateIdValue::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/StateIdValue:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_STATEIDFACTORY___CI_)
#define _COMPONENTS_STATEIDFACTORY___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::PersistentIdValue::PersistentIdValue (void)
{}

ACE_INLINE
Components::PersistentIdValue::~PersistentIdValue (void)
{}

ACE_INLINE const char* 
Components::PersistentIdValue::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/PersistentIdValue:1.0";
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:58

ACE_INLINE
Components::SegmentDescr::SegmentDescr (void)
{}

ACE_INLINE
Components::SegmentDescr::~SegmentDescr (void)
{}

ACE_INLINE const char* 
Components::SegmentDescr::_tao_obv_static_repository_id ()
{
  return "IDL:omg.org/Components/SegmentDescr:1.0";
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SEGMENTDESCRSEQ_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SEGMENTDESCRSEQ_CI_

ACE_INLINE Components::SegmentDescr **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::allocbuf (CORBA::ULong nelems)
{
  Components::SegmentDescr **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::SegmentDescr*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::freebuf (Components::SegmentDescr **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::SegmentDescr* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq(const _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::SegmentDescr **tmp1 = _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::allocbuf (this->maximum_);
    Components::SegmentDescr ** const tmp2 = ACE_reinterpret_cast (Components::SegmentDescr ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        if (tmp2[i] != 0)
          tmp2[i]->_add_ref ();
        tmp1[i] = tmp2 [i];
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::operator= (const _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::SegmentDescr **tmp = ACE_reinterpret_cast (Components::SegmentDescr **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::SegmentDescr **tmp1 = ACE_reinterpret_cast (Components::SegmentDescr **, this->buffer_);
  Components::SegmentDescr ** const tmp2 = ACE_reinterpret_cast (Components::SegmentDescr ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        tmp2[i]->_add_ref ();
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE TAO_Valuetype_Manager<Components::SegmentDescr,Components::SegmentDescr_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::SegmentDescr ** const tmp = ACE_reinterpret_cast (Components::SegmentDescr ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::SegmentDescr,Components::SegmentDescr_var> (tmp + index, this->release_);
}

ACE_INLINE Components::SegmentDescr* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::get_buffer (CORBA::Boolean orphan)
{
  Components::SegmentDescr **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::SegmentDescr**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::SegmentDescr**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::SegmentDescr* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::SegmentDescr ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_SEGMENTDESCRSEQ_CI_)
#define _COMPONENTS_SEGMENTDESCRSEQ_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::SegmentDescrSeq_var
// *************************************************************

ACE_INLINE
Components::SegmentDescrSeq_var::SegmentDescrSeq_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::SegmentDescrSeq_var::SegmentDescrSeq_var (SegmentDescrSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::SegmentDescrSeq_var::SegmentDescrSeq_var (const ::Components::SegmentDescrSeq_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::SegmentDescrSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::SegmentDescrSeq_var::~SegmentDescrSeq_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::SegmentDescrSeq_var &
Components::SegmentDescrSeq_var::operator= (SegmentDescrSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::SegmentDescrSeq_var &
Components::SegmentDescrSeq_var::operator= (const ::Components::SegmentDescrSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          SegmentDescrSeq *deep_copy =
            new SegmentDescrSeq (*p.ptr_);
          
          if (deep_copy != 0)
            {
              SegmentDescrSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::SegmentDescrSeq *
Components::SegmentDescrSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::SegmentDescrSeq *
Components::SegmentDescrSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::SegmentDescrSeq_var::operator const ::Components::SegmentDescrSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::SegmentDescrSeq_var::operator ::Components::SegmentDescrSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::SegmentDescrSeq_var::operator ::Components::SegmentDescrSeq &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::SegmentDescrSeq_var::operator ::Components::SegmentDescrSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::SegmentDescr, Components::SegmentDescr_var>
Components::SegmentDescrSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::SegmentDescrSeq &
Components::SegmentDescrSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::SegmentDescrSeq &
Components::SegmentDescrSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::SegmentDescrSeq *&
Components::SegmentDescrSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::SegmentDescrSeq *
Components::SegmentDescrSeq_var::_retn (void)
{
  ::Components::SegmentDescrSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::SegmentDescrSeq *
Components::SegmentDescrSeq_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::SegmentDescrSeq_out
// *************************************************************

ACE_INLINE
Components::SegmentDescrSeq_out::SegmentDescrSeq_out (SegmentDescrSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::SegmentDescrSeq_out::SegmentDescrSeq_out (SegmentDescrSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::SegmentDescrSeq_out::SegmentDescrSeq_out (const ::Components::SegmentDescrSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (SegmentDescrSeq_out&, p).ptr_)
{}

ACE_INLINE ::Components::SegmentDescrSeq_out &
Components::SegmentDescrSeq_out::operator= (const ::Components::SegmentDescrSeq_out &p)
{
  this->ptr_ = ACE_const_cast (SegmentDescrSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::SegmentDescrSeq_out &
Components::SegmentDescrSeq_out::operator= (SegmentDescrSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::SegmentDescrSeq_out::operator ::Components::SegmentDescrSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::SegmentDescrSeq *&
Components::SegmentDescrSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::SegmentDescrSeq *
Components::SegmentDescrSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Valuetype_Manager<Components::SegmentDescr, Components::SegmentDescr_var>
Components::SegmentDescrSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_COMPONENTID___CI_)
#define _COMPONENTS_COMPONENTID___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_ENTITY2CONTEXT___CI_)
#define _COMPONENTS_ENTITY2CONTEXT___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_EXECUTORLOCATOR___CI_)
#define _COMPONENTS_EXECUTORLOCATOR___CI_


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_HOMEEXECUTORBASE___CI_)
#define _COMPONENTS_HOMEEXECUTORBASE___CI_


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception Components::Deployment::UnknownImplId
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Deployment::InvalidLocation
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Deployment::InstallationFailure
// *************************************************************

// *************************************************************
// Inline operations for exception Components::Deployment::InvalidAssembly
// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_DEPLOYMENT_COMPONENTINSTALLATION___CI_)
#define _COMPONENTS_DEPLOYMENT_COMPONENTINSTALLATION___CI_

ACE_INLINE
Components::Deployment::ComponentInstallation::ComponentInstallation (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Deployment_ComponentInstallation_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_DEPLOYMENT_ASSEMBLY___CI_)
#define _COMPONENTS_DEPLOYMENT_ASSEMBLY___CI_

ACE_INLINE
Components::Deployment::Assembly::Assembly (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Deployment_Assembly_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_DEPLOYMENT_ASSEMBLYFACTORY___CI_)
#define _COMPONENTS_DEPLOYMENT_ASSEMBLYFACTORY___CI_

ACE_INLINE
Components::Deployment::AssemblyFactory::AssemblyFactory (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Deployment_AssemblyFactory_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CI_

ACE_INLINE Components::Deployment::ComponentServer **
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::allocbuf (CORBA::ULong nelems)
{
  Components::Deployment::ComponentServer **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::Deployment::ComponentServer*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = Components::Deployment::ComponentServer::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::freebuf (Components::Deployment::ComponentServer **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers (void)
{
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::allocbuf (maximum))
{
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::Deployment::ComponentServer* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers(const _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::Deployment::ComponentServer **tmp1 = _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::allocbuf (this->maximum_);
    Components::Deployment::ComponentServer ** const tmp2 = ACE_reinterpret_cast (Components::Deployment::ComponentServer ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = Components::Deployment::ComponentServer::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers &
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::operator= (const _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::Deployment::ComponentServer **tmp = ACE_reinterpret_cast (Components::Deployment::ComponentServer **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::Deployment::ComponentServer::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::Deployment::ComponentServer **tmp1 = ACE_reinterpret_cast (Components::Deployment::ComponentServer **, this->buffer_);
  Components::Deployment::ComponentServer ** const tmp2 = ACE_reinterpret_cast (Components::Deployment::ComponentServer ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = Components::Deployment::ComponentServer::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<Components::Deployment::ComponentServer,Components::Deployment::ComponentServer_var>
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::Deployment::ComponentServer ** const tmp = ACE_reinterpret_cast (Components::Deployment::ComponentServer ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<Components::Deployment::ComponentServer,Components::Deployment::ComponentServer_var> (tmp + index, this->release_);
}

ACE_INLINE Components::Deployment::ComponentServer* *
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::get_buffer (CORBA::Boolean orphan)
{
  Components::Deployment::ComponentServer **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::Deployment::ComponentServer**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::Deployment::ComponentServer**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::Deployment::ComponentServer* *
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::Deployment::ComponentServer ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CI_)
#define _COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::Deployment::ComponentServers_var
// *************************************************************

ACE_INLINE
Components::Deployment::ComponentServers_var::ComponentServers_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::Deployment::ComponentServers_var::ComponentServers_var (ComponentServers *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::Deployment::ComponentServers_var::ComponentServers_var (const ::Components::Deployment::ComponentServers_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::Deployment::ComponentServers (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::Deployment::ComponentServers_var::~ComponentServers_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::Deployment::ComponentServers_var &
Components::Deployment::ComponentServers_var::operator= (ComponentServers *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::Deployment::ComponentServers_var &
Components::Deployment::ComponentServers_var::operator= (const ::Components::Deployment::ComponentServers_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ComponentServers *deep_copy =
            new ComponentServers (*p.ptr_);
          
          if (deep_copy != 0)
            {
              ComponentServers *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::Deployment::ComponentServers *
Components::Deployment::ComponentServers_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::ComponentServers *
Components::Deployment::ComponentServers_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::Deployment::ComponentServers_var::operator const ::Components::Deployment::ComponentServers &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::Deployment::ComponentServers_var::operator ::Components::Deployment::ComponentServers &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::Deployment::ComponentServers_var::operator ::Components::Deployment::ComponentServers &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::Deployment::ComponentServers_var::operator ::Components::Deployment::ComponentServers *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::Deployment::ComponentServer, Components::Deployment::ComponentServer_var>
Components::Deployment::ComponentServers_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::Deployment::ComponentServers &
Components::Deployment::ComponentServers_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::Deployment::ComponentServers &
Components::Deployment::ComponentServers_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::Deployment::ComponentServers *&
Components::Deployment::ComponentServers_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::ComponentServers *
Components::Deployment::ComponentServers_var::_retn (void)
{
  ::Components::Deployment::ComponentServers *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::Deployment::ComponentServers *
Components::Deployment::ComponentServers_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::Deployment::ComponentServers_out
// *************************************************************

ACE_INLINE
Components::Deployment::ComponentServers_out::ComponentServers_out (ComponentServers *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::Deployment::ComponentServers_out::ComponentServers_out (ComponentServers_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::Deployment::ComponentServers_out::ComponentServers_out (const ::Components::Deployment::ComponentServers_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentServers_out&, p).ptr_)
{}

ACE_INLINE ::Components::Deployment::ComponentServers_out &
Components::Deployment::ComponentServers_out::operator= (const ::Components::Deployment::ComponentServers_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentServers_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::Deployment::ComponentServers_out &
Components::Deployment::ComponentServers_out::operator= (ComponentServers *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::Deployment::ComponentServers_out::operator ::Components::Deployment::ComponentServers *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::ComponentServers *&
Components::Deployment::ComponentServers_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::ComponentServers *
Components::Deployment::ComponentServers_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::Deployment::ComponentServer, Components::Deployment::ComponentServer_var>
Components::Deployment::ComponentServers_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_DEPLOYMENT_SERVERACTIVATOR___CI_)
#define _COMPONENTS_DEPLOYMENT_SERVERACTIVATOR___CI_

ACE_INLINE
Components::Deployment::ServerActivator::ServerActivator (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Deployment_ServerActivator_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_CONTAINERS_CI_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_CONTAINERS_CI_

ACE_INLINE Components::Deployment::Container **
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::allocbuf (CORBA::ULong nelems)
{
  Components::Deployment::Container **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::Deployment::Container*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = Components::Deployment::Container::_nil ();
    }
  
  return buf;
}

ACE_INLINE void 
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::freebuf (Components::Deployment::Container **buffer)
{
  if (buffer == 0)
    return;
  delete[] buffer;
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers (void)
{
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::allocbuf (maximum))
{
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers (CORBA::ULong maximum,
  CORBA::ULong length,
  Components::Deployment::Container* *value,
  CORBA::Boolean release)
: TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers(const _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers &rhs)
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
  {
    Components::Deployment::Container **tmp1 = _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::allocbuf (this->maximum_);
    Components::Deployment::Container ** const tmp2 = ACE_reinterpret_cast (Components::Deployment::Container ** ACE_CAST_CONST, rhs.buffer_);
    
    for (CORBA::ULong i = 0; i < rhs.length_; ++i)
      {
        tmp1[i] = Components::Deployment::Container::_duplicate (tmp2[i]);
      }
    
    this->buffer_ = tmp1;
  }
  else
  {
    this->buffer_ = 0;
  }
}

ACE_INLINE Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers &
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::operator= (const _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers &rhs)
{
  if (this == &rhs)
    return *this;
  
  if (this->release_)
  {
    Components::Deployment::Container **tmp = ACE_reinterpret_cast (Components::Deployment::Container **, this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::Deployment::Container::_nil ();
    }
    if (this->maximum_ < rhs.maximum_)
    {
      _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::freebuf (tmp);
      this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::allocbuf (rhs.maximum_);
    }
  }
  else
    this->buffer_ = _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::allocbuf (rhs.maximum_);
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::Deployment::Container **tmp1 = ACE_reinterpret_cast (Components::Deployment::Container **, this->buffer_);
  Components::Deployment::Container ** const tmp2 = ACE_reinterpret_cast (Components::Deployment::Container ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      tmp1[i] = Components::Deployment::Container::_duplicate (tmp2[i]);
    }
  
  return *this;
}

ACE_INLINE TAO_Object_Manager<Components::Deployment::Container,Components::Deployment::Container_var>
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::operator[] (CORBA::ULong index) const
// read-write accessor
{
  ACE_ASSERT (index < this->maximum_);
  Components::Deployment::Container ** const tmp = ACE_reinterpret_cast (Components::Deployment::Container ** ACE_CAST_CONST, this->buffer_);
  return TAO_Object_Manager<Components::Deployment::Container,Components::Deployment::Container_var> (tmp + index, this->release_);
}

ACE_INLINE Components::Deployment::Container* *
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::get_buffer (CORBA::Boolean orphan)
{
  Components::Deployment::Container **result = 0;
  if (orphan == 0)
  {
    // We retain ownership.
    if (this->buffer_ == 0)
    {
      result = _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::allocbuf (this->maximum_);
      this->buffer_ = result;
      this->release_ = 1;
    }
    else
    {
      result = ACE_reinterpret_cast (Components::Deployment::Container**, this->buffer_);
    }
  }
  else // if (orphan == 1)
  {
    if (this->release_ != 0)
    {
      // We set the state back to default and relinquish
      // ownership.
      result = ACE_reinterpret_cast(Components::Deployment::Container**,this->buffer_);
      this->maximum_ = 0;
      this->length_ = 0;
      this->buffer_ = 0;
      this->release_ = 0;
    }
  }
  return result;
}

ACE_INLINE const Components::Deployment::Container* *
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::get_buffer (void) const
{
  return ACE_reinterpret_cast(const Components::Deployment::Container ** ACE_CAST_CONST, this->buffer_);
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_DEPLOYMENT_CONTAINERS_CI_)
#define _COMPONENTS_DEPLOYMENT_CONTAINERS_CI_


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:229

// *************************************************************
// Inline operations for class Components::Deployment::Containers_var
// *************************************************************

ACE_INLINE
Components::Deployment::Containers_var::Containers_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::Deployment::Containers_var::Containers_var (Containers *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::Deployment::Containers_var::Containers_var (const ::Components::Deployment::Containers_var &p)
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::Components::Deployment::Containers (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
Components::Deployment::Containers_var::~Containers_var (void)
{
  delete this->ptr_;
}

ACE_INLINE Components::Deployment::Containers_var &
Components::Deployment::Containers_var::operator= (Containers *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE ::Components::Deployment::Containers_var &
Components::Deployment::Containers_var::operator= (const ::Components::Deployment::Containers_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          Containers *deep_copy =
            new Containers (*p.ptr_);
          
          if (deep_copy != 0)
            {
              Containers *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::Components::Deployment::Containers *
Components::Deployment::Containers_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::Containers *
Components::Deployment::Containers_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE 
Components::Deployment::Containers_var::operator const ::Components::Deployment::Containers &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE 
Components::Deployment::Containers_var::operator ::Components::Deployment::Containers &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE 
Components::Deployment::Containers_var::operator ::Components::Deployment::Containers &() const // cast 
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
Components::Deployment::Containers_var::operator ::Components::Deployment::Containers *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::Deployment::Container, Components::Deployment::Container_var>
Components::Deployment::Containers_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::Components::Deployment::Containers &
Components::Deployment::Containers_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::Components::Deployment::Containers &
Components::Deployment::Containers_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size 
ACE_INLINE ::Components::Deployment::Containers *&
Components::Deployment::Containers_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::Containers *
Components::Deployment::Containers_var::_retn (void)
{
  ::Components::Deployment::Containers *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::Components::Deployment::Containers *
Components::Deployment::Containers_var::ptr (void) const
{
  return this->ptr_;
}


// TAO_IDL - Generated from W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:557

// *************************************************************
// Inline operations for class Components::Deployment::Containers_out
// *************************************************************

ACE_INLINE
Components::Deployment::Containers_out::Containers_out (Containers *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::Deployment::Containers_out::Containers_out (Containers_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::Deployment::Containers_out::Containers_out (const ::Components::Deployment::Containers_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Containers_out&, p).ptr_)
{}

ACE_INLINE ::Components::Deployment::Containers_out &
Components::Deployment::Containers_out::operator= (const ::Components::Deployment::Containers_out &p)
{
  this->ptr_ = ACE_const_cast (Containers_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::Components::Deployment::Containers_out &
Components::Deployment::Containers_out::operator= (Containers *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE 
Components::Deployment::Containers_out::operator ::Components::Deployment::Containers *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::Containers *&
Components::Deployment::Containers_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::Components::Deployment::Containers *
Components::Deployment::Containers_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_Object_Manager<Components::Deployment::Container, Components::Deployment::Container_var>
Components::Deployment::Containers_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_DEPLOYMENT_COMPONENTSERVER___CI_)
#define _COMPONENTS_DEPLOYMENT_COMPONENTSERVER___CI_

ACE_INLINE
Components::Deployment::ComponentServer::ComponentServer (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Deployment_ComponentServer_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception Components::Deployment::ImplEntryPointNotFound
// *************************************************************

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_DEPLOYMENT_CONTAINER___CI_)
#define _COMPONENTS_DEPLOYMENT_CONTAINER___CI_

ACE_INLINE
Components::Deployment::Container::Container (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Deployment_Container_setup_collocation (_tao_collocated);
}


#endif /* end #if !defined */


#if !defined _TAO_CDR_OP_Components_NameList_I_
#define _TAO_CDR_OP_Components_NameList_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::NameList &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::NameList &
  );

#endif /* _TAO_CDR_OP_Components_NameList_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::Cookie *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::Cookie *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::Cookie *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::Cookie *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::PortDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::PortDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::PortDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::PortDescription *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::FacetDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::FacetDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::FacetDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::FacetDescription *&);


#if !defined _TAO_CDR_OP_Components_FacetDescriptions_I_
#define _TAO_CDR_OP_Components_FacetDescriptions_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::FacetDescriptions &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::FacetDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_FacetDescriptions_I_ */

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::InvalidName &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::InvalidName&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::InvalidConnection &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::InvalidConnection&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ExceededConnectionLimit &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::ExceededConnectionLimit&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::AlreadyConnected &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::AlreadyConnected&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::NoConnection &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::NoConnection&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CookieRequired &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::CookieRequired&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CreateFailure &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.reason)
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CreateFailure &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.reason)
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::FinderFailure &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.reason)
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::FinderFailure &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.reason)
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::RemoveFailure &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.reason)
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::RemoveFailure &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.reason)
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::DuplicateKeyValue &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::DuplicateKeyValue&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::InvalidKey &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::InvalidKey&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::UnknownKeyValue &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::UnknownKeyValue&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::NoKeyAvailable &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::NoKeyAvailable&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::BadEventType &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.expected_event_type.in ())
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::BadEventType &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.expected_event_type.out ())
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::HomeNotFound &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::HomeNotFound&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::WrongComponentType &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::WrongComponentType&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::InvalidConfiguration &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.reason) &&
        (strm << _tao_aggregate.name.in ())
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::InvalidConfiguration &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.reason) &&
    (strm >> _tao_aggregate.name.out ())
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::IllegalState &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::IllegalState&
  )
{
  return 1;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Navigation_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Navigation_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::ConnectionDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::ConnectionDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::ConnectionDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::ConnectionDescription *&);


#if !defined _TAO_CDR_OP_Components_ConnectionDescriptions_I_
#define _TAO_CDR_OP_Components_ConnectionDescriptions_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::ConnectionDescriptions &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::ConnectionDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_ConnectionDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::ReceptacleDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::ReceptacleDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::ReceptacleDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::ReceptacleDescription *&);


#if !defined _TAO_CDR_OP_Components_ReceptacleDescriptions_I_
#define _TAO_CDR_OP_Components_ReceptacleDescriptions_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::ReceptacleDescriptions &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::ReceptacleDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_ReceptacleDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Receptacles_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Receptacles_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::EventBase *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::EventBase *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::EventBase *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::EventBase *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::EventConsumerBase_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::EventConsumerBase_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::ConsumerDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::ConsumerDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::ConsumerDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::ConsumerDescription *&);


#if !defined _TAO_CDR_OP_Components_ConsumerDescriptions_I_
#define _TAO_CDR_OP_Components_ConsumerDescriptions_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::ConsumerDescriptions &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::ConsumerDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_ConsumerDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::EmitterDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::EmitterDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::EmitterDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::EmitterDescription *&);


#if !defined _TAO_CDR_OP_Components_EmitterDescriptions_I_
#define _TAO_CDR_OP_Components_EmitterDescriptions_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::EmitterDescriptions &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::EmitterDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_EmitterDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::SubscriberDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::SubscriberDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::SubscriberDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::SubscriberDescription *&);


#if !defined _TAO_CDR_OP_Components_SubscriberDescriptions_I_
#define _TAO_CDR_OP_Components_SubscriberDescriptions_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::SubscriberDescriptions &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::SubscriberDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_SubscriberDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::PublisherDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::PublisherDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::PublisherDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::PublisherDescription *&);


#if !defined _TAO_CDR_OP_Components_PublisherDescriptions_I_
#define _TAO_CDR_OP_Components_PublisherDescriptions_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::PublisherDescriptions &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::PublisherDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_PublisherDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Events_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Events_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::PrimaryKeyBase *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::PrimaryKeyBase *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::PrimaryKeyBase *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::PrimaryKeyBase *&);

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::CCMObject_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::CCMObject_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::CCMHome_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::CCMHome_ptr &
  );


#if !defined _TAO_CDR_OP_Components_CCMHomes_I_
#define _TAO_CDR_OP_Components_CCMHomes_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::CCMHomes &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::CCMHomes &
  );

#endif /* _TAO_CDR_OP_Components_CCMHomes_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::KeylessCCMHome_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::KeylessCCMHome_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::HomeFinder_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::HomeFinder_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Configurator_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Configurator_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::ConfigValue *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::ConfigValue *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::ConfigValue *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::ConfigValue *&);


#if !defined _TAO_CDR_OP_Components_ConfigValues_I_
#define _TAO_CDR_OP_Components_ConfigValues_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::ConfigValues &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::ConfigValues &
  );

#endif /* _TAO_CDR_OP_Components_ConfigValues_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::StandardConfigurator_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::StandardConfigurator_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::HomeConfiguration_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::HomeConfiguration_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::ComponentPortDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::ComponentPortDescription *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::ComponentPortDescription *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::ComponentPortDescription *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::Enumeration *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::Enumeration *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::Enumeration *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::Enumeration *&);


#if !defined _TAO_CDR_OP_Components_CCMObjectSeq_I_
#define _TAO_CDR_OP_Components_CCMObjectSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::CCMObjectSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::CCMObjectSeq &
  );

#endif /* _TAO_CDR_OP_Components_CCMObjectSeq_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::DefaultEnumeration *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::DefaultEnumeration *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::DefaultEnumeration *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::DefaultEnumeration *&);


#if !defined _TAO_CDR_OP_Components_Transaction_TranToken_I_
#define _TAO_CDR_OP_Components_Transaction_TranToken_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::Transaction::TranToken &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::Transaction::TranToken &
  );

#endif /* _TAO_CDR_OP_Components_Transaction_TranToken_I_ */

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::NoTransaction &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::NoTransaction&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::NotSupported &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::NotSupported&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::SystemError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::SystemError&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::RollbackError &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::RollbackError&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::HeuristicMixed &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::HeuristicMixed&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::HeuristicRollback &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::HeuristicRollback&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::Security &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::Security&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::InvalidToken &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Transaction::InvalidToken&
  )
{
  return 1;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const Components::Transaction::Status &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, Components::Transaction::Status &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (Components::Transaction::Status, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const Components::CCMExceptionReason &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, Components::CCMExceptionReason &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (Components::CCMExceptionReason, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMException &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.reason)
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMException &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.reason)
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const Components::BadComponentReferenceReason &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, Components::BadComponentReferenceReason &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (Components::BadComponentReferenceReason, _tao_temp);
    }
  
  return _tao_result;
}


#if !defined _TAO_CDR_OP_Components_IdData_I_
#define _TAO_CDR_OP_Components_IdData_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::IdData &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::IdData &
  );

#endif /* _TAO_CDR_OP_Components_IdData_I_ */

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::BadComponentReference &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.reason)
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::BadComponentReference &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.reason)
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::PolicyMismatch &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::PolicyMismatch&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::PersistenceNotAvailable &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::PersistenceNotAvailable&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::UnknownActualHome &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::UnknownActualHome&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ProxyHomeNotSupported &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::ProxyHomeNotSupported&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::InvalidStateIdData &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::InvalidStateIdData&
  )
{
  return 1;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::StateIdValue *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::StateIdValue *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::StateIdValue *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::StateIdValue *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::PersistentIdValue *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::PersistentIdValue *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::PersistentIdValue *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::PersistentIdValue *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:714

#if defined (__ACE_INLINE__)
TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::SegmentDescr *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::SegmentDescr *);
}
TAO_NAMESPACE_CLOSE
#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

 CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::SegmentDescr *);
 CORBA::Boolean operator>> (TAO_InputCDR &, Components::SegmentDescr *&);


#if !defined _TAO_CDR_OP_Components_SegmentDescrSeq_I_
#define _TAO_CDR_OP_Components_SegmentDescrSeq_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::SegmentDescrSeq &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::SegmentDescrSeq &
  );

#endif /* _TAO_CDR_OP_Components_SegmentDescrSeq_I_ */

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const Components::Deployment::AssemblyState &_tao_enumval)
{
  CORBA::ULong _tao_temp = _tao_enumval;
  return strm << _tao_temp;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm, Components::Deployment::AssemblyState &_tao_enumval)
{
  CORBA::ULong _tao_temp = 0;
  CORBA::Boolean _tao_result = strm >> _tao_temp;
  
  if (_tao_result == 1)
    {
      _tao_enumval = ACE_static_cast (Components::Deployment::AssemblyState, _tao_temp);
    }
  
  return _tao_result;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::UnknownImplId &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::UnknownImplId&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::InvalidLocation &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::InvalidLocation&
  )
{
  return 1;
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::InstallationFailure &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      if (
        (strm << _tao_aggregate.reason)
       )
        {
          return 1;
        }
      else
        {
          return 0;
        }
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::InstallationFailure &_tao_aggregate
  )
{
  // Demarshal the members.
  if (
    (strm >> _tao_aggregate.reason)
  )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::InvalidAssembly &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::InvalidAssembly&
  )
{
  return 1;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::ComponentInstallation_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::ComponentInstallation_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::Assembly_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::Assembly_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::AssemblyFactory_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::AssemblyFactory_ptr &
  );

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::ComponentServer_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::ComponentServer_ptr &
  );


#if !defined _TAO_CDR_OP_Components_Deployment_ComponentServers_I_
#define _TAO_CDR_OP_Components_Deployment_ComponentServers_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::ComponentServers &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::Deployment::ComponentServers &
  );

#endif /* _TAO_CDR_OP_Components_Deployment_ComponentServers_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::ServerActivator_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::ServerActivator_ptr &
  );

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::Container_ptr
  );

 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::Container_ptr &
  );


#if !defined _TAO_CDR_OP_Components_Deployment_Containers_I_
#define _TAO_CDR_OP_Components_Deployment_Containers_I_

CORBA::Boolean  operator<< (
    TAO_OutputCDR &,
    const Components::Deployment::Containers &
  );
CORBA::Boolean  operator>> (
    TAO_InputCDR &,
    Components::Deployment::Containers &
  );

#endif /* _TAO_CDR_OP_Components_Deployment_Containers_I_ */

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::ImplEntryPointNotFound &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Deployment::ImplEntryPointNotFound&
  )
{
  return 1;
}

