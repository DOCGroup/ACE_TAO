// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:56

ACE_INLINE
Components::EventBase::EventBase (void)
{}

ACE_INLINE
Components::EventBase::~EventBase (void)
{}

ACE_INLINE const char* 
Components::EventBase::_tao_obv_static_repository_id ()
{
  return "IDL:Components/EventBase:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_EVENTCONSUMERBASE___CI_)
#define _COMPONENTS_EVENTCONSUMERBASE___CI_

ACE_INLINE
Components::EventConsumerBase::EventConsumerBase (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_EventConsumerBase_setup_collocation (_tao_collocated);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:56

ACE_INLINE
Components::ConsumerDescription::ConsumerDescription (void)
{}

ACE_INLINE
Components::ConsumerDescription::~ConsumerDescription (void)
{}

ACE_INLINE const char* 
Components::ConsumerDescription::_tao_obv_static_repository_id ()
{
  return "IDL:Components/ConsumerDescription:1.0";
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CI_

ACE_INLINE
Components::ConsumerDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::ConsumerDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::ConsumerDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE
void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::freebuf (Components::ConsumerDescription **buffer)
{
  if (buffer == 0)
    {
      return;
    }
  
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (
    CORBA::ULong maximum,
    CORBA::ULong length,
    Components::ConsumerDescription* *value,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions(
    const _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      Components::ConsumerDescription **tmp1 =
        _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (this->maximum_);
      Components::ConsumerDescription ** const tmp2 =
        ACE_reinterpret_cast (Components::ConsumerDescription ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        {
          if (tmp2[i] != 0)
            {
              tmp2[i]->_add_ref ();
            }
          
          tmp1[i] = tmp2 [i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::operator= (
    const _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      Components::ConsumerDescription **tmp =
        ACE_reinterpret_cast (Components::ConsumerDescription **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (tmp[i] != 0)
            {
              tmp[i]->_remove_ref ();
            }
          
          tmp[i] = 0;
        }
      
      if (this->maximum_ < rhs.maximum_)
        {
          _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::freebuf (tmp);
          this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::ConsumerDescription **tmp1 =
    ACE_reinterpret_cast (Components::ConsumerDescription **, this->buffer_);
  
  Components::ConsumerDescription ** const tmp2 =
    ACE_reinterpret_cast (Components::ConsumerDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        {
          tmp2[i]->_add_ref ();
        }
      
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::ConsumerDescription,Components::ConsumerDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::operator[] (CORBA::ULong index) const
{
  ACE_ASSERT (index < this->maximum_);
  Components::ConsumerDescription ** const tmp =
    ACE_reinterpret_cast (Components::ConsumerDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::ConsumerDescription,Components::ConsumerDescription_var> (tmp + index, this->release_);
}

ACE_INLINE
Components::ConsumerDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::ConsumerDescription **result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (this->maximum_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(Components::ConsumerDescription**,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const Components::ConsumerDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast (const Components::ConsumerDescription ** ACE_CAST_CONST, this->buffer_);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONSUMERDESCRIPTIONS_CI_)
#define _COMPONENTS_CONSUMERDESCRIPTIONS_CI_

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class Components::ConsumerDescriptions_var
// *************************************************************

ACE_INLINE
Components::ConsumerDescriptions_var::ConsumerDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::ConsumerDescriptions_var::ConsumerDescriptions_var (ConsumerDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::ConsumerDescriptions_var::ConsumerDescriptions_var (const ::Components::ConsumerDescriptions_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::Components::ConsumerDescriptions (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
Components::ConsumerDescriptions_var::~ConsumerDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
Components::ConsumerDescriptions_var &
Components::ConsumerDescriptions_var::operator= (ConsumerDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::Components::ConsumerDescriptions_var &
Components::ConsumerDescriptions_var::operator= (const ::Components::ConsumerDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ConsumerDescriptions *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              ConsumerDescriptions (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              ConsumerDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
Components::ConsumerDescriptions_var::operator const ::Components::ConsumerDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
Components::ConsumerDescriptions_var::operator ::Components::ConsumerDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
Components::ConsumerDescriptions_var::operator ::Components::ConsumerDescriptions &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
Components::ConsumerDescriptions_var::operator ::Components::ConsumerDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>
Components::ConsumerDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const ::Components::ConsumerDescriptions &
Components::ConsumerDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::Components::ConsumerDescriptions &
Components::ConsumerDescriptions_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::Components::ConsumerDescriptions *&
Components::ConsumerDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::_retn (void)
{
  ::Components::ConsumerDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class Components::ConsumerDescriptions_out
// *************************************************************

ACE_INLINE
Components::ConsumerDescriptions_out::ConsumerDescriptions_out (ConsumerDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConsumerDescriptions_out::ConsumerDescriptions_out (ConsumerDescriptions_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::ConsumerDescriptions_out::ConsumerDescriptions_out (const ::Components::ConsumerDescriptions_out &p)
  : ptr_ (ACE_const_cast (ConsumerDescriptions_out&, p).ptr_)
{}

ACE_INLINE
::Components::ConsumerDescriptions_out &
Components::ConsumerDescriptions_out::operator= (const ::Components::ConsumerDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumerDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::Components::ConsumerDescriptions_out &
Components::ConsumerDescriptions_out::operator= (ConsumerDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
Components::ConsumerDescriptions_out::operator ::Components::ConsumerDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::Components::ConsumerDescriptions *&
Components::ConsumerDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::Components::ConsumerDescriptions *
Components::ConsumerDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>
Components::ConsumerDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:56

ACE_INLINE
Components::EmitterDescription::EmitterDescription (void)
{}

ACE_INLINE
Components::EmitterDescription::~EmitterDescription (void)
{}

ACE_INLINE const char* 
Components::EmitterDescription::_tao_obv_static_repository_id ()
{
  return "IDL:Components/EmitterDescription:1.0";
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CI_

ACE_INLINE
Components::EmitterDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::EmitterDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::EmitterDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE
void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::freebuf (Components::EmitterDescription **buffer)
{
  if (buffer == 0)
    {
      return;
    }
  
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (
    CORBA::ULong maximum,
    CORBA::ULong length,
    Components::EmitterDescription* *value,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions(
    const _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      Components::EmitterDescription **tmp1 =
        _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (this->maximum_);
      Components::EmitterDescription ** const tmp2 =
        ACE_reinterpret_cast (Components::EmitterDescription ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        {
          if (tmp2[i] != 0)
            {
              tmp2[i]->_add_ref ();
            }
          
          tmp1[i] = tmp2 [i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::operator= (
    const _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      Components::EmitterDescription **tmp =
        ACE_reinterpret_cast (Components::EmitterDescription **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (tmp[i] != 0)
            {
              tmp[i]->_remove_ref ();
            }
          
          tmp[i] = 0;
        }
      
      if (this->maximum_ < rhs.maximum_)
        {
          _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::freebuf (tmp);
          this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::EmitterDescription **tmp1 =
    ACE_reinterpret_cast (Components::EmitterDescription **, this->buffer_);
  
  Components::EmitterDescription ** const tmp2 =
    ACE_reinterpret_cast (Components::EmitterDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        {
          tmp2[i]->_add_ref ();
        }
      
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::EmitterDescription,Components::EmitterDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::operator[] (CORBA::ULong index) const
{
  ACE_ASSERT (index < this->maximum_);
  Components::EmitterDescription ** const tmp =
    ACE_reinterpret_cast (Components::EmitterDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::EmitterDescription,Components::EmitterDescription_var> (tmp + index, this->release_);
}

ACE_INLINE
Components::EmitterDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::EmitterDescription **result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (this->maximum_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(Components::EmitterDescription**,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const Components::EmitterDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast (const Components::EmitterDescription ** ACE_CAST_CONST, this->buffer_);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_EMITTERDESCRIPTIONS_CI_)
#define _COMPONENTS_EMITTERDESCRIPTIONS_CI_

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class Components::EmitterDescriptions_var
// *************************************************************

ACE_INLINE
Components::EmitterDescriptions_var::EmitterDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::EmitterDescriptions_var::EmitterDescriptions_var (EmitterDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::EmitterDescriptions_var::EmitterDescriptions_var (const ::Components::EmitterDescriptions_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::Components::EmitterDescriptions (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
Components::EmitterDescriptions_var::~EmitterDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
Components::EmitterDescriptions_var &
Components::EmitterDescriptions_var::operator= (EmitterDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::Components::EmitterDescriptions_var &
Components::EmitterDescriptions_var::operator= (const ::Components::EmitterDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          EmitterDescriptions *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              EmitterDescriptions (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              EmitterDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
Components::EmitterDescriptions_var::operator const ::Components::EmitterDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
Components::EmitterDescriptions_var::operator ::Components::EmitterDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
Components::EmitterDescriptions_var::operator ::Components::EmitterDescriptions &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
Components::EmitterDescriptions_var::operator ::Components::EmitterDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>
Components::EmitterDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const ::Components::EmitterDescriptions &
Components::EmitterDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::Components::EmitterDescriptions &
Components::EmitterDescriptions_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::Components::EmitterDescriptions *&
Components::EmitterDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::_retn (void)
{
  ::Components::EmitterDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::Components::EmitterDescriptions *
Components::EmitterDescriptions_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class Components::EmitterDescriptions_out
// *************************************************************

ACE_INLINE
Components::EmitterDescriptions_out::EmitterDescriptions_out (EmitterDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::EmitterDescriptions_out::EmitterDescriptions_out (EmitterDescriptions_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::EmitterDescriptions_out::EmitterDescriptions_out (const ::Components::EmitterDescriptions_out &p)
  : ptr_ (ACE_const_cast (EmitterDescriptions_out&, p).ptr_)
{}

ACE_INLINE
::Components::EmitterDescriptions_out &
Components::EmitterDescriptions_out::operator= (const ::Components::EmitterDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (EmitterDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::Components::EmitterDescriptions_out &
Components::EmitterDescriptions_out::operator= (EmitterDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
Components::EmitterDescriptions_out::operator ::Components::EmitterDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::Components::EmitterDescriptions *&
Components::EmitterDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::Components::EmitterDescriptions *
Components::EmitterDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>
Components::EmitterDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:56

ACE_INLINE
Components::SubscriberDescription::SubscriberDescription (void)
{}

ACE_INLINE
Components::SubscriberDescription::~SubscriberDescription (void)
{}

ACE_INLINE const char* 
Components::SubscriberDescription::_tao_obv_static_repository_id ()
{
  return "IDL:Components/SubscriberDescription:1.0";
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_

ACE_INLINE
Components::SubscriberDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::SubscriberDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::SubscriberDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE
void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::freebuf (Components::SubscriberDescription **buffer)
{
  if (buffer == 0)
    {
      return;
    }
  
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (
    CORBA::ULong maximum,
    CORBA::ULong length,
    Components::SubscriberDescription* *value,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions(
    const _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      Components::SubscriberDescription **tmp1 =
        _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (this->maximum_);
      Components::SubscriberDescription ** const tmp2 =
        ACE_reinterpret_cast (Components::SubscriberDescription ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        {
          if (tmp2[i] != 0)
            {
              tmp2[i]->_add_ref ();
            }
          
          tmp1[i] = tmp2 [i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::operator= (
    const _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      Components::SubscriberDescription **tmp =
        ACE_reinterpret_cast (Components::SubscriberDescription **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (tmp[i] != 0)
            {
              tmp[i]->_remove_ref ();
            }
          
          tmp[i] = 0;
        }
      
      if (this->maximum_ < rhs.maximum_)
        {
          _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::freebuf (tmp);
          this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::SubscriberDescription **tmp1 =
    ACE_reinterpret_cast (Components::SubscriberDescription **, this->buffer_);
  
  Components::SubscriberDescription ** const tmp2 =
    ACE_reinterpret_cast (Components::SubscriberDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        {
          tmp2[i]->_add_ref ();
        }
      
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::SubscriberDescription,Components::SubscriberDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::operator[] (CORBA::ULong index) const
{
  ACE_ASSERT (index < this->maximum_);
  Components::SubscriberDescription ** const tmp =
    ACE_reinterpret_cast (Components::SubscriberDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::SubscriberDescription,Components::SubscriberDescription_var> (tmp + index, this->release_);
}

ACE_INLINE
Components::SubscriberDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::SubscriberDescription **result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (this->maximum_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(Components::SubscriberDescription**,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const Components::SubscriberDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast (const Components::SubscriberDescription ** ACE_CAST_CONST, this->buffer_);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_)
#define _COMPONENTS_SUBSCRIBERDESCRIPTIONS_CI_

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class Components::SubscriberDescriptions_var
// *************************************************************

ACE_INLINE
Components::SubscriberDescriptions_var::SubscriberDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::SubscriberDescriptions_var::SubscriberDescriptions_var (SubscriberDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::SubscriberDescriptions_var::SubscriberDescriptions_var (const ::Components::SubscriberDescriptions_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::Components::SubscriberDescriptions (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
Components::SubscriberDescriptions_var::~SubscriberDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
Components::SubscriberDescriptions_var &
Components::SubscriberDescriptions_var::operator= (SubscriberDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::Components::SubscriberDescriptions_var &
Components::SubscriberDescriptions_var::operator= (const ::Components::SubscriberDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          SubscriberDescriptions *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              SubscriberDescriptions (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              SubscriberDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
Components::SubscriberDescriptions_var::operator const ::Components::SubscriberDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
Components::SubscriberDescriptions_var::operator ::Components::SubscriberDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
Components::SubscriberDescriptions_var::operator ::Components::SubscriberDescriptions &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
Components::SubscriberDescriptions_var::operator ::Components::SubscriberDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>
Components::SubscriberDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const ::Components::SubscriberDescriptions &
Components::SubscriberDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::Components::SubscriberDescriptions &
Components::SubscriberDescriptions_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::Components::SubscriberDescriptions *&
Components::SubscriberDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::_retn (void)
{
  ::Components::SubscriberDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class Components::SubscriberDescriptions_out
// *************************************************************

ACE_INLINE
Components::SubscriberDescriptions_out::SubscriberDescriptions_out (SubscriberDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::SubscriberDescriptions_out::SubscriberDescriptions_out (SubscriberDescriptions_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::SubscriberDescriptions_out::SubscriberDescriptions_out (const ::Components::SubscriberDescriptions_out &p)
  : ptr_ (ACE_const_cast (SubscriberDescriptions_out&, p).ptr_)
{}

ACE_INLINE
::Components::SubscriberDescriptions_out &
Components::SubscriberDescriptions_out::operator= (const ::Components::SubscriberDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (SubscriberDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::Components::SubscriberDescriptions_out &
Components::SubscriberDescriptions_out::operator= (SubscriberDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
Components::SubscriberDescriptions_out::operator ::Components::SubscriberDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::Components::SubscriberDescriptions *&
Components::SubscriberDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::Components::SubscriberDescriptions *
Components::SubscriberDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>
Components::SubscriberDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/valuetype_ci.cpp:56

ACE_INLINE
Components::PublisherDescription::PublisherDescription (void)
{}

ACE_INLINE
Components::PublisherDescription::~PublisherDescription (void)
{}

ACE_INLINE const char* 
Components::PublisherDescription::_tao_obv_static_repository_id ()
{
  return "IDL:Components/PublisherDescription:1.0";
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_obj_sequence_ci.cpp:108

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CI_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CI_

ACE_INLINE
Components::PublisherDescription **
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (CORBA::ULong nelems)
{
  Components::PublisherDescription **buf = 0;
  
  ACE_NEW_RETURN (buf, Components::PublisherDescription*[nelems], 0);
  
  for (CORBA::ULong i = 0; i < nelems; i++)
    {
      buf[i] = 0;
    }
  
  return buf;
}

ACE_INLINE
void 
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::freebuf (Components::PublisherDescription **buffer)
{
  if (buffer == 0)
    {
      return;
    }
  
  delete[] buffer;
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (void)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (CORBA::ULong maximum)
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (maximum))
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (
    CORBA::ULong maximum,
    CORBA::ULong length,
    Components::PublisherDescription* *value,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, value, release)
{
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions(
    const _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      Components::PublisherDescription **tmp1 =
        _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (this->maximum_);
      Components::PublisherDescription ** const tmp2 =
        ACE_reinterpret_cast (Components::PublisherDescription ** ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < rhs.length_; ++i)
        {
          if (tmp2[i] != 0)
            {
              tmp2[i]->_add_ref ();
            }
          
          tmp1[i] = tmp2 [i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions &
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::operator= (
    const _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      Components::PublisherDescription **tmp =
        ACE_reinterpret_cast (Components::PublisherDescription **, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          if (tmp[i] != 0)
            {
              tmp[i]->_remove_ref ();
            }
          
          tmp[i] = 0;
        }
      
      if (this->maximum_ < rhs.maximum_)
        {
          _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::freebuf (tmp);
          this->buffer_ = _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  Components::PublisherDescription **tmp1 =
    ACE_reinterpret_cast (Components::PublisherDescription **, this->buffer_);
  
  Components::PublisherDescription ** const tmp2 =
    ACE_reinterpret_cast (Components::PublisherDescription ** ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < rhs.length_; ++i)
    {
      if (tmp2[i] != 0)
        {
          tmp2[i]->_add_ref ();
        }
      
      tmp1[i] = tmp2 [i];
    }
  
  return *this;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::PublisherDescription,Components::PublisherDescription_var>
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::operator[] (CORBA::ULong index) const
{
  ACE_ASSERT (index < this->maximum_);
  Components::PublisherDescription ** const tmp =
    ACE_reinterpret_cast (Components::PublisherDescription ** ACE_CAST_CONST, this->buffer_);
  return TAO_Valuetype_Manager<Components::PublisherDescription,Components::PublisherDescription_var> (tmp + index, this->release_);
}

ACE_INLINE
Components::PublisherDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::get_buffer (CORBA::Boolean orphan)
{
  Components::PublisherDescription **result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (this->maximum_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(Components::PublisherDescription**,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const Components::PublisherDescription* *
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::get_buffer (void) const
{
  return ACE_reinterpret_cast (const Components::PublisherDescription ** ACE_CAST_CONST, this->buffer_);
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_PUBLISHERDESCRIPTIONS_CI_)
#define _COMPONENTS_PUBLISHERDESCRIPTIONS_CI_

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class Components::PublisherDescriptions_var
// *************************************************************

ACE_INLINE
Components::PublisherDescriptions_var::PublisherDescriptions_var (void)
  : ptr_ (0)
{}

ACE_INLINE
Components::PublisherDescriptions_var::PublisherDescriptions_var (PublisherDescriptions *p)
  : ptr_ (p)
{}

ACE_INLINE
Components::PublisherDescriptions_var::PublisherDescriptions_var (const ::Components::PublisherDescriptions_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::Components::PublisherDescriptions (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
Components::PublisherDescriptions_var::~PublisherDescriptions_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
Components::PublisherDescriptions_var &
Components::PublisherDescriptions_var::operator= (PublisherDescriptions *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::Components::PublisherDescriptions_var &
Components::PublisherDescriptions_var::operator= (const ::Components::PublisherDescriptions_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          PublisherDescriptions *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              PublisherDescriptions (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              PublisherDescriptions *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
Components::PublisherDescriptions_var::operator const ::Components::PublisherDescriptions &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
Components::PublisherDescriptions_var::operator ::Components::PublisherDescriptions &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
Components::PublisherDescriptions_var::operator ::Components::PublisherDescriptions &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
Components::PublisherDescriptions_var::operator ::Components::PublisherDescriptions *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>
Components::PublisherDescriptions_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const ::Components::PublisherDescriptions &
Components::PublisherDescriptions_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::Components::PublisherDescriptions &
Components::PublisherDescriptions_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::Components::PublisherDescriptions *&
Components::PublisherDescriptions_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::_retn (void)
{
  ::Components::PublisherDescriptions *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::Components::PublisherDescriptions *
Components::PublisherDescriptions_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:567

// *************************************************************
// Inline operations for class Components::PublisherDescriptions_out
// *************************************************************

ACE_INLINE
Components::PublisherDescriptions_out::PublisherDescriptions_out (PublisherDescriptions *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
Components::PublisherDescriptions_out::PublisherDescriptions_out (PublisherDescriptions_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
Components::PublisherDescriptions_out::PublisherDescriptions_out (const ::Components::PublisherDescriptions_out &p)
  : ptr_ (ACE_const_cast (PublisherDescriptions_out&, p).ptr_)
{}

ACE_INLINE
::Components::PublisherDescriptions_out &
Components::PublisherDescriptions_out::operator= (const ::Components::PublisherDescriptions_out &p)
{
  this->ptr_ = ACE_const_cast (PublisherDescriptions_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::Components::PublisherDescriptions_out &
Components::PublisherDescriptions_out::operator= (PublisherDescriptions *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
Components::PublisherDescriptions_out::operator ::Components::PublisherDescriptions *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::Components::PublisherDescriptions *&
Components::PublisherDescriptions_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::Components::PublisherDescriptions *
Components::PublisherDescriptions_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>
Components::PublisherDescriptions_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_COMPONENTS_EVENTS___CI_)
#define _COMPONENTS_EVENTS___CI_

ACE_INLINE
Components::Events::Events (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->Components_Events_setup_collocation (_tao_collocated);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:712

#if defined (__ACE_INLINE__)

TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::EventBase *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::EventBase *);
}
TAO_NAMESPACE_CLOSE

#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

CIAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::EventBase *);
CIAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Components::EventBase *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

CIAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::EventConsumerBase_ptr
  );

CIAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::EventConsumerBase_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:712

#if defined (__ACE_INLINE__)

TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::ConsumerDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::ConsumerDescription *);
}
TAO_NAMESPACE_CLOSE

#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

CIAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::ConsumerDescription *);
CIAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Components::ConsumerDescription *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_Components_ConsumerDescriptions_I_
#define _TAO_CDR_OP_Components_ConsumerDescriptions_I_

CORBA::Boolean CIAO_Export operator<< (
    TAO_OutputCDR &,
    const Components::ConsumerDescriptions &
  );

CORBA::Boolean CIAO_Export operator>> (
    TAO_InputCDR &,
    Components::ConsumerDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_ConsumerDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:712

#if defined (__ACE_INLINE__)

TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::EmitterDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::EmitterDescription *);
}
TAO_NAMESPACE_CLOSE

#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

CIAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::EmitterDescription *);
CIAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Components::EmitterDescription *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_Components_EmitterDescriptions_I_
#define _TAO_CDR_OP_Components_EmitterDescriptions_I_

CORBA::Boolean CIAO_Export operator<< (
    TAO_OutputCDR &,
    const Components::EmitterDescriptions &
  );

CORBA::Boolean CIAO_Export operator>> (
    TAO_InputCDR &,
    Components::EmitterDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_EmitterDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:712

#if defined (__ACE_INLINE__)

TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::SubscriberDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::SubscriberDescription *);
}
TAO_NAMESPACE_CLOSE

#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

CIAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::SubscriberDescription *);
CIAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Components::SubscriberDescription *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_Components_SubscriberDescriptions_I_
#define _TAO_CDR_OP_Components_SubscriberDescriptions_I_

CORBA::Boolean CIAO_Export operator<< (
    TAO_OutputCDR &,
    const Components::SubscriberDescriptions &
  );

CORBA::Boolean CIAO_Export operator>> (
    TAO_InputCDR &,
    Components::SubscriberDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_SubscriberDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_valuetype.cpp:712

#if defined (__ACE_INLINE__)

TAO_NAMESPACE CORBA
{
  TAO_NAMESPACE_STORAGE_CLASS void add_ref (Components::PublisherDescription *);
  TAO_NAMESPACE_STORAGE_CLASS void remove_ref (Components::PublisherDescription *);
}
TAO_NAMESPACE_CLOSE

#endif /*__ACE_INLINE__*/

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_valuetype/cdr_op_ci.cpp:60

CIAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const Components::PublisherDescription *);
CIAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, Components::PublisherDescription *&);

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_Components_PublisherDescriptions_I_
#define _TAO_CDR_OP_Components_PublisherDescriptions_I_

CORBA::Boolean CIAO_Export operator<< (
    TAO_OutputCDR &,
    const Components::PublisherDescriptions &
  );

CORBA::Boolean CIAO_Export operator>> (
    TAO_InputCDR &,
    Components::PublisherDescriptions &
  );

#endif /* _TAO_CDR_OP_Components_PublisherDescriptions_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

CIAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const Components::Events_ptr
  );

CIAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Components::Events_ptr &
  );

