// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "Component_BaseC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "Component_BaseC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_Components_FeatureName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x65617475), 
  ACE_NTOHL (0x72654e61), 
  ACE_NTOHL (0x6d653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
  12,
  ACE_NTOHL (0x46656174), 
  ACE_NTOHL (0x7572654e), 
  ACE_NTOHL (0x616d6500),  // name = FeatureName
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_Components_FeatureName (
    CORBA::tk_alias,
    sizeof (_oc_Components_FeatureName),
    (char *) &_oc_Components_FeatureName,
    0,
    sizeof (Components::FeatureName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_FeatureName, &_tc_TAO_tc_Components_FeatureName)
TAO_NAMESPACE_END


#if !defined (_COMPONENTS_NAMELIST_CS_)
#define _COMPONENTS_NAMELIST_CS_

// *************************************************************
// Components::NameList
// *************************************************************

Components::NameList::NameList (void)
{}
Components::NameList::NameList (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::NameList::NameList (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::NameList::NameList (const NameList &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::NameList::~NameList (void) // dtor
{}
void Components::NameList::_tao_any_destructor (void *_tao_void_pointer)
{
  NameList *tmp = ACE_static_cast (NameList*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_NameList[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x616d654c), 
  ACE_NTOHL (0x6973743a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/NameList:1.0
  9,
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x0),  // name = NameList
  CORBA::tk_sequence, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_NameList (
    CORBA::tk_alias,
    sizeof (_oc_Components_NameList),
    (char *) &_oc_Components_NameList,
    0,
    sizeof (Components::NameList)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_NameList, &_tc_TAO_tc_Components_NameList)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_Cookie[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6f6b69), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
  7,
  ACE_NTOHL (0x436f6f6b), 
  ACE_NTOHL (0x69650000),  // name = Cookie
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  1, // member count
  12,
  ACE_NTOHL (0x636f6f6b), 
  ACE_NTOHL (0x69655661), 
  ACE_NTOHL (0x6c756500),  // name = cookieValue
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f63), 
    ACE_NTOHL (0x74657453), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
    9,
    ACE_NTOHL (0x4f637465), 
    ACE_NTOHL (0x74536571), 
    ACE_NTOHL (0x0),  // name = OctetSeq
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      0U,


  0, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_Cookie (
    CORBA::tk_value,
    sizeof (_oc_Components_Cookie),
    (char *) &_oc_Components_Cookie,
    0,
    sizeof (Components::Cookie)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Cookie, &_tc_TAO_tc_Components_Cookie)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::Cookie_var
// *************************************************************

Components::Cookie_var::Cookie_var (void) // default constructor
  : ptr_ (0)
{}

Components::Cookie_var::Cookie_var (Cookie* p)
  : ptr_ (p)
{}

Components::Cookie_var::Cookie_var (const Cookie* p)
  : ptr_ (ACE_const_cast(Cookie*, p))
{}

Components::Cookie* 
Components::Cookie_var::ptr (void) const
{
  return this->ptr_;
}

Components::Cookie_var::Cookie_var (const Cookie_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::Cookie_var::~Cookie_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::Cookie_var &
Components::Cookie_var::operator= (Cookie* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Cookie_var &
Components::Cookie_var::operator= (const Cookie_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    Cookie* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::Cookie_var::operator const Components::Cookie* () const // cast
{
  return this->ptr_;
}

Components::Cookie_var::operator Components::Cookie* () // cast 
{
  return this->ptr_;
}

Components::Cookie* 
Components::Cookie_var::operator-> (void) const
{
  return this->ptr_;
}

Components::Cookie*
Components::Cookie_var::in (void) const
{
  return this->ptr_;
}

Components::Cookie* &
Components::Cookie_var::inout (void)
{
  return this->ptr_;
}

Components::Cookie* &
Components::Cookie_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::Cookie* 
Components::Cookie_var::_retn (void)
{
  // yield ownership of managed obj reference
  Cookie* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::Cookie_out
// *************************************************************

Components::Cookie_out::Cookie_out (Cookie* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::Cookie_out::Cookie_out (Cookie_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::Cookie_out::Cookie_out (const Cookie_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Cookie_out&,p).ptr_)
{}

Components::Cookie_out &
Components::Cookie_out::operator= (const Cookie_out &p)
{
  this->ptr_ = ACE_const_cast (Cookie_out&,p).ptr_;
  return *this;
}

Components::Cookie_out &
Components::Cookie_out::operator= (const Cookie_var &p)
{
  Cookie* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::Cookie_out &
Components::Cookie_out::operator= (Cookie* p)
{
  this->ptr_ = p;
  return *this;
}

Components::Cookie_out::operator Components::Cookie* &() // cast
{
  return this->ptr_;
}

Components::Cookie* &
Components::Cookie_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::Cookie* 
Components::Cookie_out::operator-> (void)
{
  return this->ptr_;
}

Components::Cookie* Components::Cookie::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (Cookie* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::Cookie::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::Cookie::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::Cookie::_tao_any_destructor (void *_tao_void_pointer)
{
  Cookie *tmp = ACE_static_cast (Cookie*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::Cookie::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_Cookie (strm);
}

CORBA::Boolean Components::Cookie::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_Cookie (strm);
}

CORBA::Boolean Components::Cookie::_tao_unmarshal (TAO_InputCDR &strm, Cookie *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          Cookie::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::Cookie::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::Cookie::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Cookie::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::Cookie_init::Cookie_init ()
{
}

Components::Cookie_init::~Cookie_init ()
{
}

const char* 
Components::Cookie_init::tao_repository_id (void)
{
  return Components::Cookie::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::Cookie_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::Cookie, 
                 0);
  return ret_val;
}
static const CORBA::Long _oc_Components_PortDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x6f727444), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
  16,
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = PortDescription
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  2, // member count
  5,
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x0),  // name = Name
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x65617475), 
    ACE_NTOHL (0x72654e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
    12,
    ACE_NTOHL (0x46656174), 
    ACE_NTOHL (0x7572654e), 
    ACE_NTOHL (0x616d6500),  // name = FeatureName
    CORBA::tk_string, 
    0U, // string length

  1, // data memeber visibility marker

  8,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x5f696400),  // name = type_id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_PortDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_PortDescription),
    (char *) &_oc_Components_PortDescription,
    0,
    sizeof (Components::PortDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PortDescription, &_tc_TAO_tc_Components_PortDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::PortDescription_var
// *************************************************************

Components::PortDescription_var::PortDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::PortDescription_var::PortDescription_var (PortDescription* p)
  : ptr_ (p)
{}

Components::PortDescription_var::PortDescription_var (const PortDescription* p)
  : ptr_ (ACE_const_cast(PortDescription*, p))
{}

Components::PortDescription* 
Components::PortDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::PortDescription_var::PortDescription_var (const PortDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::PortDescription_var::~PortDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::PortDescription_var &
Components::PortDescription_var::operator= (PortDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::PortDescription_var &
Components::PortDescription_var::operator= (const PortDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    PortDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::PortDescription_var::operator const Components::PortDescription* () const // cast
{
  return this->ptr_;
}

Components::PortDescription_var::operator Components::PortDescription* () // cast 
{
  return this->ptr_;
}

Components::PortDescription* 
Components::PortDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::PortDescription*
Components::PortDescription_var::in (void) const
{
  return this->ptr_;
}

Components::PortDescription* &
Components::PortDescription_var::inout (void)
{
  return this->ptr_;
}

Components::PortDescription* &
Components::PortDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::PortDescription* 
Components::PortDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  PortDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::PortDescription_out
// *************************************************************

Components::PortDescription_out::PortDescription_out (PortDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::PortDescription_out::PortDescription_out (PortDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::PortDescription_out::PortDescription_out (const PortDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PortDescription_out&,p).ptr_)
{}

Components::PortDescription_out &
Components::PortDescription_out::operator= (const PortDescription_out &p)
{
  this->ptr_ = ACE_const_cast (PortDescription_out&,p).ptr_;
  return *this;
}

Components::PortDescription_out &
Components::PortDescription_out::operator= (const PortDescription_var &p)
{
  PortDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::PortDescription_out &
Components::PortDescription_out::operator= (PortDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::PortDescription_out::operator Components::PortDescription* &() // cast
{
  return this->ptr_;
}

Components::PortDescription* &
Components::PortDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::PortDescription* 
Components::PortDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::PortDescription* Components::PortDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (PortDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::PortDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::PortDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::PortDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  PortDescription *tmp = ACE_static_cast (PortDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::PortDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_PortDescription (strm);
}

CORBA::Boolean Components::PortDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_PortDescription (strm);
}

CORBA::Boolean Components::PortDescription::_tao_unmarshal (TAO_InputCDR &strm, PortDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          PortDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PortDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PortDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = PortDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::PortDescription_init::PortDescription_init ()
{
}

Components::PortDescription_init::~PortDescription_init ()
{
}

const char* 
Components::PortDescription_init::tao_repository_id (void)
{
  return Components::PortDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::PortDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::PortDescription, 
                 0);
  return ret_val;
}
static const CORBA::Long _oc_Components_FacetDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x61636574), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/FacetDescription:1.0
  17,
  ACE_NTOHL (0x46616365), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = FacetDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker


  1, // member count
  10,
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x745f7265), 
  ACE_NTOHL (0x66000000),  // name = facet_ref
  CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7,
    ACE_NTOHL (0x4f626a65), 
    ACE_NTOHL (0x63740000),  // name = Object

  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_FacetDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_FacetDescription),
    (char *) &_oc_Components_FacetDescription,
    0,
    sizeof (Components::FacetDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_FacetDescription, &_tc_TAO_tc_Components_FacetDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::FacetDescription_var
// *************************************************************

Components::FacetDescription_var::FacetDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::FacetDescription_var::FacetDescription_var (FacetDescription* p)
  : ptr_ (p)
{}

Components::FacetDescription_var::FacetDescription_var (const FacetDescription* p)
  : ptr_ (ACE_const_cast(FacetDescription*, p))
{}

Components::FacetDescription* 
Components::FacetDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::FacetDescription_var::FacetDescription_var (const FacetDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::FacetDescription_var::~FacetDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::FacetDescription_var &
Components::FacetDescription_var::operator= (FacetDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::FacetDescription_var &
Components::FacetDescription_var::operator= (const FacetDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    FacetDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::FacetDescription_var::operator const Components::FacetDescription* () const // cast
{
  return this->ptr_;
}

Components::FacetDescription_var::operator Components::FacetDescription* () // cast 
{
  return this->ptr_;
}

Components::FacetDescription* 
Components::FacetDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::FacetDescription*
Components::FacetDescription_var::in (void) const
{
  return this->ptr_;
}

Components::FacetDescription* &
Components::FacetDescription_var::inout (void)
{
  return this->ptr_;
}

Components::FacetDescription* &
Components::FacetDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::FacetDescription* 
Components::FacetDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  FacetDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::FacetDescription_out
// *************************************************************

Components::FacetDescription_out::FacetDescription_out (FacetDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::FacetDescription_out::FacetDescription_out (FacetDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::FacetDescription_out::FacetDescription_out (const FacetDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (FacetDescription_out&,p).ptr_)
{}

Components::FacetDescription_out &
Components::FacetDescription_out::operator= (const FacetDescription_out &p)
{
  this->ptr_ = ACE_const_cast (FacetDescription_out&,p).ptr_;
  return *this;
}

Components::FacetDescription_out &
Components::FacetDescription_out::operator= (const FacetDescription_var &p)
{
  FacetDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::FacetDescription_out &
Components::FacetDescription_out::operator= (FacetDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::FacetDescription_out::operator Components::FacetDescription* &() // cast
{
  return this->ptr_;
}

Components::FacetDescription* &
Components::FacetDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::FacetDescription* 
Components::FacetDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::FacetDescription* Components::FacetDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (FacetDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::FacetDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::FacetDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::FacetDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  FacetDescription *tmp = ACE_static_cast (FacetDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::FacetDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_FacetDescription (strm);
}

CORBA::Boolean Components::FacetDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_FacetDescription (strm);
}

CORBA::Boolean Components::FacetDescription::_tao_unmarshal (TAO_InputCDR &strm, FacetDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          FacetDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::FacetDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::FacetDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = FacetDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::FacetDescription_init::FacetDescription_init ()
{
}

Components::FacetDescription_init::~FacetDescription_init ()
{
}

const char* 
Components::FacetDescription_init::tao_repository_id (void)
{
  return Components::FacetDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::FacetDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::FacetDescription, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_FACETDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_FACETDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::FacetDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::FacetDescription **old = ACE_reinterpret_cast (Components::FacetDescription**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::FacetDescription **tmp = ACE_reinterpret_cast (Components::FacetDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::FacetDescription **tmp = ACE_reinterpret_cast (Components::FacetDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_FACETDESCRIPTIONS_CS_)
#define _COMPONENTS_FACETDESCRIPTIONS_CS_

// *************************************************************
// Components::FacetDescriptions
// *************************************************************

Components::FacetDescriptions::FacetDescriptions (void)
{}
Components::FacetDescriptions::FacetDescriptions (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::FacetDescription,Components::FacetDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::FacetDescriptions::FacetDescriptions (CORBA::ULong max, CORBA::ULong length, Components::FacetDescription_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::FacetDescription,Components::FacetDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::FacetDescriptions::FacetDescriptions (const FacetDescriptions &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_FacetDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::FacetDescription,Components::FacetDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::FacetDescriptions::~FacetDescriptions (void) // dtor
{}
void Components::FacetDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  FacetDescriptions *tmp = ACE_static_cast (FacetDescriptions*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_FacetDescriptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x61636574), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e73), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FacetDescriptions:1.0
  18,
  ACE_NTOHL (0x46616365), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x73000000),  // name = FacetDescriptions
  CORBA::tk_sequence, // typecode kind
  464, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    448, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      44,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x61636574), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e3a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/FacetDescription:1.0
      17,
      ACE_NTOHL (0x46616365), 
      ACE_NTOHL (0x74446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = FacetDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker


      1, // member count
      10,
      ACE_NTOHL (0x66616365), 
      ACE_NTOHL (0x745f7265), 
      ACE_NTOHL (0x66000000),  // name = facet_ref
      CORBA::tk_objref,
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f62), 
        ACE_NTOHL (0x6a656374), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
        7,
        ACE_NTOHL (0x4f626a65), 
        ACE_NTOHL (0x63740000),  // name = Object

      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_FacetDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_FacetDescriptions),
    (char *) &_oc_Components_FacetDescriptions,
    0,
    sizeof (Components::FacetDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_FacetDescriptions, &_tc_TAO_tc_Components_FacetDescriptions)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_FailureReason[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x61696c75), 
  ACE_NTOHL (0x72655265), 
  ACE_NTOHL (0x61736f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
  14,
  ACE_NTOHL (0x4661696c), 
  ACE_NTOHL (0x75726552), 
  ACE_NTOHL (0x6561736f), 
  ACE_NTOHL (0x6e000000),  // name = FailureReason
  CORBA::tk_ulong,

};

static CORBA::TypeCode _tc_TAO_tc_Components_FailureReason (
    CORBA::tk_alias,
    sizeof (_oc_Components_FailureReason),
    (char *) &_oc_Components_FailureReason,
    0,
    sizeof (Components::FailureReason)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_FailureReason, &_tc_TAO_tc_Components_FailureReason)
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::InvalidName::InvalidName (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidName:1.0",
        "InvalidName"
      )
{
}

// Destructor - all members are of self managing types.
Components::InvalidName::~InvalidName (void)
{
}

// Copy constructor.
Components::InvalidName::InvalidName (const ::Components::InvalidName &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::InvalidName&
Components::InvalidName::operator= (const ::Components::InvalidName &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::InvalidName::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidName *tmp = ACE_static_cast (InvalidName*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidName *
Components::InvalidName::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidName:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidName *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidName::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidName, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidName::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidName (*this),
      0
    );
  return result;
}

void Components::InvalidName::_raise ()
{
  TAO_RAISE (*this);
}

void Components::InvalidName::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidName::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_InvalidName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x69644e61), 
  ACE_NTOHL (0x6d653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/InvalidName:1.0
  12,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c69644e), 
  ACE_NTOHL (0x616d6500),  // name = InvalidName
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidName (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidName),
    (char *) &_oc_Components_InvalidName,
    0,
    sizeof (Components::InvalidName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidName, &_tc_TAO_tc_Components_InvalidName)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidName::_type (void) const
{
  return ::Components::_tc_InvalidName;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::InvalidConnection::InvalidConnection (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidConnection:1.0",
        "InvalidConnection"
      )
{
}

// Destructor - all members are of self managing types.
Components::InvalidConnection::~InvalidConnection (void)
{
}

// Copy constructor.
Components::InvalidConnection::InvalidConnection (const ::Components::InvalidConnection &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::InvalidConnection&
Components::InvalidConnection::operator= (const ::Components::InvalidConnection &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::InvalidConnection::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidConnection *tmp = ACE_static_cast (InvalidConnection*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidConnection *
Components::InvalidConnection::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidConnection:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidConnection *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidConnection::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidConnection, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidConnection::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidConnection (*this),
      0
    );
  return result;
}

void Components::InvalidConnection::_raise ()
{
  TAO_RAISE (*this);
}

void Components::InvalidConnection::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidConnection::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_InvalidConnection[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964436f), 
  ACE_NTOHL (0x6e6e6563), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/InvalidConnection:1.0
  18,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696443), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e000000),  // name = InvalidConnection
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidConnection (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidConnection),
    (char *) &_oc_Components_InvalidConnection,
    0,
    sizeof (Components::InvalidConnection)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidConnection, &_tc_TAO_tc_Components_InvalidConnection)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidConnection::_type (void) const
{
  return ::Components::_tc_InvalidConnection;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::ExceededConnectionLimit::ExceededConnectionLimit (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/ExceededConnectionLimit:1.0",
        "ExceededConnectionLimit"
      )
{
}

// Destructor - all members are of self managing types.
Components::ExceededConnectionLimit::~ExceededConnectionLimit (void)
{
}

// Copy constructor.
Components::ExceededConnectionLimit::ExceededConnectionLimit (const ::Components::ExceededConnectionLimit &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::ExceededConnectionLimit&
Components::ExceededConnectionLimit::operator= (const ::Components::ExceededConnectionLimit &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::ExceededConnectionLimit::_tao_any_destructor (void *_tao_void_pointer)
{
  ExceededConnectionLimit *tmp = ACE_static_cast (ExceededConnectionLimit*, _tao_void_pointer);
  delete tmp;
}

Components::ExceededConnectionLimit *
Components::ExceededConnectionLimit::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/ExceededConnectionLimit:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (ExceededConnectionLimit *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::ExceededConnectionLimit::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::ExceededConnectionLimit, 0);
  return retval;
}

CORBA::Exception *
Components::ExceededConnectionLimit::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::ExceededConnectionLimit (*this),
      0
    );
  return result;
}

void Components::ExceededConnectionLimit::_raise ()
{
  TAO_RAISE (*this);
}

void Components::ExceededConnectionLimit::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::ExceededConnectionLimit::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_ExceededConnectionLimit[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x78636565), 
  ACE_NTOHL (0x64656443), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e4c696d), 
  ACE_NTOHL (0x69743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ExceededConnectionLimit:1.0
  24,
  ACE_NTOHL (0x45786365), 
  ACE_NTOHL (0x65646564), 
  ACE_NTOHL (0x436f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e4c69), 
  ACE_NTOHL (0x6d697400),  // name = ExceededConnectionLimit
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_ExceededConnectionLimit (
    CORBA::tk_except,
    sizeof (_oc_Components_ExceededConnectionLimit),
    (char *) &_oc_Components_ExceededConnectionLimit,
    0,
    sizeof (Components::ExceededConnectionLimit)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ExceededConnectionLimit, &_tc_TAO_tc_Components_ExceededConnectionLimit)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::ExceededConnectionLimit::_type (void) const
{
  return ::Components::_tc_ExceededConnectionLimit;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::AlreadyConnected::AlreadyConnected (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/AlreadyConnected:1.0",
        "AlreadyConnected"
      )
{
}

// Destructor - all members are of self managing types.
Components::AlreadyConnected::~AlreadyConnected (void)
{
}

// Copy constructor.
Components::AlreadyConnected::AlreadyConnected (const ::Components::AlreadyConnected &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::AlreadyConnected&
Components::AlreadyConnected::operator= (const ::Components::AlreadyConnected &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::AlreadyConnected::_tao_any_destructor (void *_tao_void_pointer)
{
  AlreadyConnected *tmp = ACE_static_cast (AlreadyConnected*, _tao_void_pointer);
  delete tmp;
}

Components::AlreadyConnected *
Components::AlreadyConnected::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/AlreadyConnected:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (AlreadyConnected *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::AlreadyConnected::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::AlreadyConnected, 0);
  return retval;
}

CORBA::Exception *
Components::AlreadyConnected::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::AlreadyConnected (*this),
      0
    );
  return result;
}

void Components::AlreadyConnected::_raise ()
{
  TAO_RAISE (*this);
}

void Components::AlreadyConnected::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::AlreadyConnected::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_AlreadyConnected[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f41), 
  ACE_NTOHL (0x6c726561), 
  ACE_NTOHL (0x6479436f), 
  ACE_NTOHL (0x6e6e6563), 
  ACE_NTOHL (0x7465643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/AlreadyConnected:1.0
  17,
  ACE_NTOHL (0x416c7265), 
  ACE_NTOHL (0x61647943), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x63746564), 
  ACE_NTOHL (0x0),  // name = AlreadyConnected
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_AlreadyConnected (
    CORBA::tk_except,
    sizeof (_oc_Components_AlreadyConnected),
    (char *) &_oc_Components_AlreadyConnected,
    0,
    sizeof (Components::AlreadyConnected)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_AlreadyConnected, &_tc_TAO_tc_Components_AlreadyConnected)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::AlreadyConnected::_type (void) const
{
  return ::Components::_tc_AlreadyConnected;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::NoConnection::NoConnection (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/NoConnection:1.0",
        "NoConnection"
      )
{
}

// Destructor - all members are of self managing types.
Components::NoConnection::~NoConnection (void)
{
}

// Copy constructor.
Components::NoConnection::NoConnection (const ::Components::NoConnection &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::NoConnection&
Components::NoConnection::operator= (const ::Components::NoConnection &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::NoConnection::_tao_any_destructor (void *_tao_void_pointer)
{
  NoConnection *tmp = ACE_static_cast (NoConnection*, _tao_void_pointer);
  delete tmp;
}

Components::NoConnection *
Components::NoConnection::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/NoConnection:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NoConnection *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::NoConnection::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::NoConnection, 0);
  return retval;
}

CORBA::Exception *
Components::NoConnection::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::NoConnection (*this),
      0
    );
  return result;
}

void Components::NoConnection::_raise ()
{
  TAO_RAISE (*this);
}

void Components::NoConnection::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::NoConnection::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_NoConnection[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x6f436f6e), 
  ACE_NTOHL (0x6e656374), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/NoConnection:1.0
  13,
  ACE_NTOHL (0x4e6f436f), 
  ACE_NTOHL (0x6e6e6563), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = NoConnection
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_NoConnection (
    CORBA::tk_except,
    sizeof (_oc_Components_NoConnection),
    (char *) &_oc_Components_NoConnection,
    0,
    sizeof (Components::NoConnection)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_NoConnection, &_tc_TAO_tc_Components_NoConnection)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::NoConnection::_type (void) const
{
  return ::Components::_tc_NoConnection;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::CookieRequired::CookieRequired (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/CookieRequired:1.0",
        "CookieRequired"
      )
{
}

// Destructor - all members are of self managing types.
Components::CookieRequired::~CookieRequired (void)
{
}

// Copy constructor.
Components::CookieRequired::CookieRequired (const ::Components::CookieRequired &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::CookieRequired&
Components::CookieRequired::operator= (const ::Components::CookieRequired &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::CookieRequired::_tao_any_destructor (void *_tao_void_pointer)
{
  CookieRequired *tmp = ACE_static_cast (CookieRequired*, _tao_void_pointer);
  delete tmp;
}

Components::CookieRequired *
Components::CookieRequired::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/CookieRequired:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (CookieRequired *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::CookieRequired::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::CookieRequired, 0);
  return retval;
}

CORBA::Exception *
Components::CookieRequired::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::CookieRequired (*this),
      0
    );
  return result;
}

void Components::CookieRequired::_raise ()
{
  TAO_RAISE (*this);
}

void Components::CookieRequired::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::CookieRequired::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_CookieRequired[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6f6b69), 
  ACE_NTOHL (0x65526571), 
  ACE_NTOHL (0x75697265), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/CookieRequired:1.0
  15,
  ACE_NTOHL (0x436f6f6b), 
  ACE_NTOHL (0x69655265), 
  ACE_NTOHL (0x71756972), 
  ACE_NTOHL (0x65640000),  // name = CookieRequired
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_CookieRequired (
    CORBA::tk_except,
    sizeof (_oc_Components_CookieRequired),
    (char *) &_oc_Components_CookieRequired,
    0,
    sizeof (Components::CookieRequired)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CookieRequired, &_tc_TAO_tc_Components_CookieRequired)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::CookieRequired::_type (void) const
{
  return ::Components::_tc_CookieRequired;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::CreateFailure::CreateFailure (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/CreateFailure:1.0",
        "CreateFailure"
      )
{
}

// Destructor - all members are of self managing types.
Components::CreateFailure::~CreateFailure (void)
{
}

// Copy constructor.
Components::CreateFailure::CreateFailure (const ::Components::CreateFailure &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

// Assignment operator.
Components::CreateFailure&
Components::CreateFailure::operator= (const ::Components::CreateFailure &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::CreateFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  CreateFailure *tmp = ACE_static_cast (CreateFailure*, _tao_void_pointer);
  delete tmp;
}

Components::CreateFailure *
Components::CreateFailure::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/CreateFailure:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (CreateFailure *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::CreateFailure::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::CreateFailure, 0);
  return retval;
}

CORBA::Exception *
Components::CreateFailure::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::CreateFailure (*this),
      0
    );
  return result;
}

void Components::CreateFailure::_raise ()
{
  TAO_RAISE (*this);
}

void Components::CreateFailure::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::CreateFailure::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::CreateFailure::CreateFailure (
    Components::FailureReason _tao_reason
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/CreateFailure:1.0",
        "CreateFailure"
      )
{
  this->reason = _tao_reason;
}

static const CORBA::Long _oc_Components_CreateFailure[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x72656174), 
  ACE_NTOHL (0x65466169), 
  ACE_NTOHL (0x6c757265), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/CreateFailure:1.0
  14,
  ACE_NTOHL (0x43726561), 
  ACE_NTOHL (0x74654661), 
  ACE_NTOHL (0x696c7572), 
  ACE_NTOHL (0x65000000),  // name = CreateFailure
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_CreateFailure (
    CORBA::tk_except,
    sizeof (_oc_Components_CreateFailure),
    (char *) &_oc_Components_CreateFailure,
    0,
    sizeof (Components::CreateFailure)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CreateFailure, &_tc_TAO_tc_Components_CreateFailure)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::CreateFailure::_type (void) const
{
  return ::Components::_tc_CreateFailure;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::FinderFailure::FinderFailure (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/FinderFailure:1.0",
        "FinderFailure"
      )
{
}

// Destructor - all members are of self managing types.
Components::FinderFailure::~FinderFailure (void)
{
}

// Copy constructor.
Components::FinderFailure::FinderFailure (const ::Components::FinderFailure &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

// Assignment operator.
Components::FinderFailure&
Components::FinderFailure::operator= (const ::Components::FinderFailure &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::FinderFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  FinderFailure *tmp = ACE_static_cast (FinderFailure*, _tao_void_pointer);
  delete tmp;
}

Components::FinderFailure *
Components::FinderFailure::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/FinderFailure:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (FinderFailure *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::FinderFailure::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::FinderFailure, 0);
  return retval;
}

CORBA::Exception *
Components::FinderFailure::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::FinderFailure (*this),
      0
    );
  return result;
}

void Components::FinderFailure::_raise ()
{
  TAO_RAISE (*this);
}

void Components::FinderFailure::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::FinderFailure::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::FinderFailure::FinderFailure (
    Components::FailureReason _tao_reason
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/FinderFailure:1.0",
        "FinderFailure"
      )
{
  this->reason = _tao_reason;
}

static const CORBA::Long _oc_Components_FinderFailure[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x696e6465), 
  ACE_NTOHL (0x72466169), 
  ACE_NTOHL (0x6c757265), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FinderFailure:1.0
  14,
  ACE_NTOHL (0x46696e64), 
  ACE_NTOHL (0x65724661), 
  ACE_NTOHL (0x696c7572), 
  ACE_NTOHL (0x65000000),  // name = FinderFailure
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_FinderFailure (
    CORBA::tk_except,
    sizeof (_oc_Components_FinderFailure),
    (char *) &_oc_Components_FinderFailure,
    0,
    sizeof (Components::FinderFailure)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_FinderFailure, &_tc_TAO_tc_Components_FinderFailure)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::FinderFailure::_type (void) const
{
  return ::Components::_tc_FinderFailure;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::RemoveFailure::RemoveFailure (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/RemoveFailure:1.0",
        "RemoveFailure"
      )
{
}

// Destructor - all members are of self managing types.
Components::RemoveFailure::~RemoveFailure (void)
{
}

// Copy constructor.
Components::RemoveFailure::RemoveFailure (const ::Components::RemoveFailure &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

// Assignment operator.
Components::RemoveFailure&
Components::RemoveFailure::operator= (const ::Components::RemoveFailure &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::RemoveFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  RemoveFailure *tmp = ACE_static_cast (RemoveFailure*, _tao_void_pointer);
  delete tmp;
}

Components::RemoveFailure *
Components::RemoveFailure::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/RemoveFailure:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (RemoveFailure *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::RemoveFailure::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::RemoveFailure, 0);
  return retval;
}

CORBA::Exception *
Components::RemoveFailure::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::RemoveFailure (*this),
      0
    );
  return result;
}

void Components::RemoveFailure::_raise ()
{
  TAO_RAISE (*this);
}

void Components::RemoveFailure::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::RemoveFailure::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::RemoveFailure::RemoveFailure (
    Components::FailureReason _tao_reason
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/RemoveFailure:1.0",
        "RemoveFailure"
      )
{
  this->reason = _tao_reason;
}

static const CORBA::Long _oc_Components_RemoveFailure[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x656d6f76), 
  ACE_NTOHL (0x65466169), 
  ACE_NTOHL (0x6c757265), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/RemoveFailure:1.0
  14,
  ACE_NTOHL (0x52656d6f), 
  ACE_NTOHL (0x76654661), 
  ACE_NTOHL (0x696c7572), 
  ACE_NTOHL (0x65000000),  // name = RemoveFailure
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_RemoveFailure (
    CORBA::tk_except,
    sizeof (_oc_Components_RemoveFailure),
    (char *) &_oc_Components_RemoveFailure,
    0,
    sizeof (Components::RemoveFailure)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_RemoveFailure, &_tc_TAO_tc_Components_RemoveFailure)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::RemoveFailure::_type (void) const
{
  return ::Components::_tc_RemoveFailure;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::DuplicateKeyValue::DuplicateKeyValue (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/DuplicateKeyValue:1.0",
        "DuplicateKeyValue"
      )
{
}

// Destructor - all members are of self managing types.
Components::DuplicateKeyValue::~DuplicateKeyValue (void)
{
}

// Copy constructor.
Components::DuplicateKeyValue::DuplicateKeyValue (const ::Components::DuplicateKeyValue &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::DuplicateKeyValue&
Components::DuplicateKeyValue::operator= (const ::Components::DuplicateKeyValue &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::DuplicateKeyValue::_tao_any_destructor (void *_tao_void_pointer)
{
  DuplicateKeyValue *tmp = ACE_static_cast (DuplicateKeyValue*, _tao_void_pointer);
  delete tmp;
}

Components::DuplicateKeyValue *
Components::DuplicateKeyValue::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/DuplicateKeyValue:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (DuplicateKeyValue *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::DuplicateKeyValue::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::DuplicateKeyValue, 0);
  return retval;
}

CORBA::Exception *
Components::DuplicateKeyValue::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::DuplicateKeyValue (*this),
      0
    );
  return result;
}

void Components::DuplicateKeyValue::_raise ()
{
  TAO_RAISE (*this);
}

void Components::DuplicateKeyValue::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::DuplicateKeyValue::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_DuplicateKeyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x75706c69), 
  ACE_NTOHL (0x63617465), 
  ACE_NTOHL (0x4b657956), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/DuplicateKeyValue:1.0
  18,
  ACE_NTOHL (0x4475706c), 
  ACE_NTOHL (0x69636174), 
  ACE_NTOHL (0x654b6579), 
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65000000),  // name = DuplicateKeyValue
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_DuplicateKeyValue (
    CORBA::tk_except,
    sizeof (_oc_Components_DuplicateKeyValue),
    (char *) &_oc_Components_DuplicateKeyValue,
    0,
    sizeof (Components::DuplicateKeyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_DuplicateKeyValue, &_tc_TAO_tc_Components_DuplicateKeyValue)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::DuplicateKeyValue::_type (void) const
{
  return ::Components::_tc_DuplicateKeyValue;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::InvalidKey::InvalidKey (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidKey:1.0",
        "InvalidKey"
      )
{
}

// Destructor - all members are of self managing types.
Components::InvalidKey::~InvalidKey (void)
{
}

// Copy constructor.
Components::InvalidKey::InvalidKey (const ::Components::InvalidKey &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::InvalidKey&
Components::InvalidKey::operator= (const ::Components::InvalidKey &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::InvalidKey::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidKey *tmp = ACE_static_cast (InvalidKey*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidKey *
Components::InvalidKey::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidKey:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidKey *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidKey::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidKey, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidKey::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidKey (*this),
      0
    );
  return result;
}

void Components::InvalidKey::_raise ()
{
  TAO_RAISE (*this);
}

void Components::InvalidKey::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidKey::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_InvalidKey[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x69644b65), 
  ACE_NTOHL (0x793a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/InvalidKey:1.0
  11,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c69644b), 
  ACE_NTOHL (0x65790000),  // name = InvalidKey
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidKey (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidKey),
    (char *) &_oc_Components_InvalidKey,
    0,
    sizeof (Components::InvalidKey)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidKey, &_tc_TAO_tc_Components_InvalidKey)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidKey::_type (void) const
{
  return ::Components::_tc_InvalidKey;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::UnknownKeyValue::UnknownKeyValue (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/UnknownKeyValue:1.0",
        "UnknownKeyValue"
      )
{
}

// Destructor - all members are of self managing types.
Components::UnknownKeyValue::~UnknownKeyValue (void)
{
}

// Copy constructor.
Components::UnknownKeyValue::UnknownKeyValue (const ::Components::UnknownKeyValue &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::UnknownKeyValue&
Components::UnknownKeyValue::operator= (const ::Components::UnknownKeyValue &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::UnknownKeyValue::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownKeyValue *tmp = ACE_static_cast (UnknownKeyValue*, _tao_void_pointer);
  delete tmp;
}

Components::UnknownKeyValue *
Components::UnknownKeyValue::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/UnknownKeyValue:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (UnknownKeyValue *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::UnknownKeyValue::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::UnknownKeyValue, 0);
  return retval;
}

CORBA::Exception *
Components::UnknownKeyValue::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::UnknownKeyValue (*this),
      0
    );
  return result;
}

void Components::UnknownKeyValue::_raise ()
{
  TAO_RAISE (*this);
}

void Components::UnknownKeyValue::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::UnknownKeyValue::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_UnknownKeyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f55), 
  ACE_NTOHL (0x6e6b6e6f), 
  ACE_NTOHL (0x776e4b65), 
  ACE_NTOHL (0x7956616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/UnknownKeyValue:1.0
  16,
  ACE_NTOHL (0x556e6b6e), 
  ACE_NTOHL (0x6f776e4b), 
  ACE_NTOHL (0x65795661), 
  ACE_NTOHL (0x6c756500),  // name = UnknownKeyValue
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_UnknownKeyValue (
    CORBA::tk_except,
    sizeof (_oc_Components_UnknownKeyValue),
    (char *) &_oc_Components_UnknownKeyValue,
    0,
    sizeof (Components::UnknownKeyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_UnknownKeyValue, &_tc_TAO_tc_Components_UnknownKeyValue)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::UnknownKeyValue::_type (void) const
{
  return ::Components::_tc_UnknownKeyValue;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::NoKeyAvailable::NoKeyAvailable (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/NoKeyAvailable:1.0",
        "NoKeyAvailable"
      )
{
}

// Destructor - all members are of self managing types.
Components::NoKeyAvailable::~NoKeyAvailable (void)
{
}

// Copy constructor.
Components::NoKeyAvailable::NoKeyAvailable (const ::Components::NoKeyAvailable &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::NoKeyAvailable&
Components::NoKeyAvailable::operator= (const ::Components::NoKeyAvailable &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::NoKeyAvailable::_tao_any_destructor (void *_tao_void_pointer)
{
  NoKeyAvailable *tmp = ACE_static_cast (NoKeyAvailable*, _tao_void_pointer);
  delete tmp;
}

Components::NoKeyAvailable *
Components::NoKeyAvailable::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/NoKeyAvailable:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NoKeyAvailable *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::NoKeyAvailable::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::NoKeyAvailable, 0);
  return retval;
}

CORBA::Exception *
Components::NoKeyAvailable::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::NoKeyAvailable (*this),
      0
    );
  return result;
}

void Components::NoKeyAvailable::_raise ()
{
  TAO_RAISE (*this);
}

void Components::NoKeyAvailable::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::NoKeyAvailable::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_NoKeyAvailable[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x6f4b6579), 
  ACE_NTOHL (0x41766169), 
  ACE_NTOHL (0x6c61626c), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/NoKeyAvailable:1.0
  15,
  ACE_NTOHL (0x4e6f4b65), 
  ACE_NTOHL (0x79417661), 
  ACE_NTOHL (0x696c6162), 
  ACE_NTOHL (0x6c650000),  // name = NoKeyAvailable
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_NoKeyAvailable (
    CORBA::tk_except,
    sizeof (_oc_Components_NoKeyAvailable),
    (char *) &_oc_Components_NoKeyAvailable,
    0,
    sizeof (Components::NoKeyAvailable)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_NoKeyAvailable, &_tc_TAO_tc_Components_NoKeyAvailable)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::NoKeyAvailable::_type (void) const
{
  return ::Components::_tc_NoKeyAvailable;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::BadEventType::BadEventType (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/BadEventType:1.0",
        "BadEventType"
      )
{
}

// Destructor - all members are of self managing types.
Components::BadEventType::~BadEventType (void)
{
}

// Copy constructor.
Components::BadEventType::BadEventType (const ::Components::BadEventType &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->expected_event_type = CORBA::string_dup (_tao_excp.expected_event_type.in ());
}

// Assignment operator.
Components::BadEventType&
Components::BadEventType::operator= (const ::Components::BadEventType &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->expected_event_type = CORBA::string_dup (_tao_excp.expected_event_type.in ());
  return *this;
}

void Components::BadEventType::_tao_any_destructor (void *_tao_void_pointer)
{
  BadEventType *tmp = ACE_static_cast (BadEventType*, _tao_void_pointer);
  delete tmp;
}

Components::BadEventType *
Components::BadEventType::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/BadEventType:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (BadEventType *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::BadEventType::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::BadEventType, 0);
  return retval;
}

CORBA::Exception *
Components::BadEventType::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::BadEventType (*this),
      0
    );
  return result;
}

void Components::BadEventType::_raise ()
{
  TAO_RAISE (*this);
}

void Components::BadEventType::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::BadEventType::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::BadEventType::BadEventType (
    const char * _tao_expected_event_type
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/BadEventType:1.0",
        "BadEventType"
      )
{
  this->expected_event_type = CORBA::string_dup (_tao_expected_event_type);
}

static const CORBA::Long _oc_Components_BadEventType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f42), 
  ACE_NTOHL (0x61644576), 
  ACE_NTOHL (0x656e7454), 
  ACE_NTOHL (0x7970653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/BadEventType:1.0
  13,
  ACE_NTOHL (0x42616445), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x0),  // name = BadEventType
  1, // member count
  20,
  ACE_NTOHL (0x65787065), 
  ACE_NTOHL (0x63746564), 
  ACE_NTOHL (0x5f657665), 
  ACE_NTOHL (0x6e745f74), 
  ACE_NTOHL (0x79706500),  // name = expected_event_type
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_Components_BadEventType (
    CORBA::tk_except,
    sizeof (_oc_Components_BadEventType),
    (char *) &_oc_Components_BadEventType,
    0,
    sizeof (Components::BadEventType)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_BadEventType, &_tc_TAO_tc_Components_BadEventType)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::BadEventType::_type (void) const
{
  return ::Components::_tc_BadEventType;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::HomeNotFound::HomeNotFound (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/HomeNotFound:1.0",
        "HomeNotFound"
      )
{
}

// Destructor - all members are of self managing types.
Components::HomeNotFound::~HomeNotFound (void)
{
}

// Copy constructor.
Components::HomeNotFound::HomeNotFound (const ::Components::HomeNotFound &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::HomeNotFound&
Components::HomeNotFound::operator= (const ::Components::HomeNotFound &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::HomeNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeNotFound *tmp = ACE_static_cast (HomeNotFound*, _tao_void_pointer);
  delete tmp;
}

Components::HomeNotFound *
Components::HomeNotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/HomeNotFound:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (HomeNotFound *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::HomeNotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::HomeNotFound, 0);
  return retval;
}

CORBA::Exception *
Components::HomeNotFound::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::HomeNotFound (*this),
      0
    );
  return result;
}

void Components::HomeNotFound::_raise ()
{
  TAO_RAISE (*this);
}

void Components::HomeNotFound::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::HomeNotFound::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_HomeNotFound[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d654e), 
  ACE_NTOHL (0x6f74466f), 
  ACE_NTOHL (0x756e643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/HomeNotFound:1.0
  13,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x4e6f7446), 
  ACE_NTOHL (0x6f756e64), 
  ACE_NTOHL (0x0),  // name = HomeNotFound
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeNotFound (
    CORBA::tk_except,
    sizeof (_oc_Components_HomeNotFound),
    (char *) &_oc_Components_HomeNotFound,
    0,
    sizeof (Components::HomeNotFound)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_HomeNotFound, &_tc_TAO_tc_Components_HomeNotFound)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::HomeNotFound::_type (void) const
{
  return ::Components::_tc_HomeNotFound;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::WrongComponentType::WrongComponentType (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/WrongComponentType:1.0",
        "WrongComponentType"
      )
{
}

// Destructor - all members are of self managing types.
Components::WrongComponentType::~WrongComponentType (void)
{
}

// Copy constructor.
Components::WrongComponentType::WrongComponentType (const ::Components::WrongComponentType &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::WrongComponentType&
Components::WrongComponentType::operator= (const ::Components::WrongComponentType &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::WrongComponentType::_tao_any_destructor (void *_tao_void_pointer)
{
  WrongComponentType *tmp = ACE_static_cast (WrongComponentType*, _tao_void_pointer);
  delete tmp;
}

Components::WrongComponentType *
Components::WrongComponentType::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/WrongComponentType:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (WrongComponentType *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::WrongComponentType::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::WrongComponentType, 0);
  return retval;
}

CORBA::Exception *
Components::WrongComponentType::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::WrongComponentType (*this),
      0
    );
  return result;
}

void Components::WrongComponentType::_raise ()
{
  TAO_RAISE (*this);
}

void Components::WrongComponentType::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::WrongComponentType::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_WrongComponentType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f57), 
  ACE_NTOHL (0x726f6e67), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74547970), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/WrongComponentType:1.0
  19,
  ACE_NTOHL (0x57726f6e), 
  ACE_NTOHL (0x67436f6d), 
  ACE_NTOHL (0x706f6e65), 
  ACE_NTOHL (0x6e745479), 
  ACE_NTOHL (0x70650000),  // name = WrongComponentType
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_WrongComponentType (
    CORBA::tk_except,
    sizeof (_oc_Components_WrongComponentType),
    (char *) &_oc_Components_WrongComponentType,
    0,
    sizeof (Components::WrongComponentType)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_WrongComponentType, &_tc_TAO_tc_Components_WrongComponentType)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::WrongComponentType::_type (void) const
{
  return ::Components::_tc_WrongComponentType;
}

static const CORBA::Long _oc_Components_InvalidConfigurationReason[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964436f), 
  ACE_NTOHL (0x6e666967), 
  ACE_NTOHL (0x75726174), 
  ACE_NTOHL (0x696f6e52), 
  ACE_NTOHL (0x6561736f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/InvalidConfigurationReason:1.0
  27,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696443), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x52656173), 
  ACE_NTOHL (0x6f6e0000),  // name = InvalidConfigurationReason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidConfigurationReason (
    CORBA::tk_alias,
    sizeof (_oc_Components_InvalidConfigurationReason),
    (char *) &_oc_Components_InvalidConfigurationReason,
    0,
    sizeof (Components::InvalidConfigurationReason)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidConfigurationReason, &_tc_TAO_tc_Components_InvalidConfigurationReason)
TAO_NAMESPACE_END

TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, UnknownConfigValueName, 0U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, InvalidConfigValueType, 1U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ConfigValueRequired, 2U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ConfigValueNotExpected, 3U)
TAO_NAMESPACE_END
// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::InvalidConfiguration::InvalidConfiguration (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidConfiguration:1.0",
        "InvalidConfiguration"
      )
{
}

// Destructor - all members are of self managing types.
Components::InvalidConfiguration::~InvalidConfiguration (void)
{
}

// Copy constructor.
Components::InvalidConfiguration::InvalidConfiguration (const ::Components::InvalidConfiguration &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
  this->name = CORBA::string_dup (_tao_excp.name.in ());
}

// Assignment operator.
Components::InvalidConfiguration&
Components::InvalidConfiguration::operator= (const ::Components::InvalidConfiguration &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  this->name = CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

void Components::InvalidConfiguration::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidConfiguration *tmp = ACE_static_cast (InvalidConfiguration*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidConfiguration *
Components::InvalidConfiguration::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidConfiguration:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidConfiguration *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidConfiguration::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidConfiguration, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidConfiguration::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidConfiguration (*this),
      0
    );
  return result;
}

void Components::InvalidConfiguration::_raise ()
{
  TAO_RAISE (*this);
}

void Components::InvalidConfiguration::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidConfiguration::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::InvalidConfiguration::InvalidConfiguration (
    Components::InvalidConfigurationReason _tao_reason,
    const char * _tao_name
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidConfiguration:1.0",
        "InvalidConfiguration"
      )
{
  this->reason = _tao_reason;
  this->name = CORBA::string_dup (_tao_name);
}

static const CORBA::Long _oc_Components_InvalidConfiguration[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964436f), 
  ACE_NTOHL (0x6e666967), 
  ACE_NTOHL (0x75726174), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/InvalidConfiguration:1.0
  21,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696443), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = InvalidConfiguration
  2, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  180, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    54,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f49), 
    ACE_NTOHL (0x6e76616c), 
    ACE_NTOHL (0x6964436f), 
    ACE_NTOHL (0x6e666967), 
    ACE_NTOHL (0x75726174), 
    ACE_NTOHL (0x696f6e52), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e3a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/InvalidConfigurationReason:1.0
    27,
    ACE_NTOHL (0x496e7661), 
    ACE_NTOHL (0x6c696443), 
    ACE_NTOHL (0x6f6e6669), 
    ACE_NTOHL (0x67757261), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x52656173), 
    ACE_NTOHL (0x6f6e0000),  // name = InvalidConfigurationReason
    CORBA::tk_alias, // typecode kind for typedefs
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      41,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x61696c75), 
      ACE_NTOHL (0x72655265), 
      ACE_NTOHL (0x61736f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
      14,
      ACE_NTOHL (0x4661696c), 
      ACE_NTOHL (0x75726552), 
      ACE_NTOHL (0x6561736f), 
      ACE_NTOHL (0x6e000000),  // name = FailureReason
      CORBA::tk_ulong,



  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x65617475), 
    ACE_NTOHL (0x72654e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
    12,
    ACE_NTOHL (0x46656174), 
    ACE_NTOHL (0x7572654e), 
    ACE_NTOHL (0x616d6500),  // name = FeatureName
    CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidConfiguration (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidConfiguration),
    (char *) &_oc_Components_InvalidConfiguration,
    0,
    sizeof (Components::InvalidConfiguration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidConfiguration, &_tc_TAO_tc_Components_InvalidConfiguration)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidConfiguration::_type (void) const
{
  return ::Components::_tc_InvalidConfiguration;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::IllegalState::IllegalState (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/IllegalState:1.0",
        "IllegalState"
      )
{
}

// Destructor - all members are of self managing types.
Components::IllegalState::~IllegalState (void)
{
}

// Copy constructor.
Components::IllegalState::IllegalState (const ::Components::IllegalState &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::IllegalState&
Components::IllegalState::operator= (const ::Components::IllegalState &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::IllegalState::_tao_any_destructor (void *_tao_void_pointer)
{
  IllegalState *tmp = ACE_static_cast (IllegalState*, _tao_void_pointer);
  delete tmp;
}

Components::IllegalState *
Components::IllegalState::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/IllegalState:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (IllegalState *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::IllegalState::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::IllegalState, 0);
  return retval;
}

CORBA::Exception *
Components::IllegalState::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::IllegalState (*this),
      0
    );
  return result;
}

void Components::IllegalState::_raise ()
{
  TAO_RAISE (*this);
}

void Components::IllegalState::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::IllegalState::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_IllegalState[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6c6c6567), 
  ACE_NTOHL (0x616c5374), 
  ACE_NTOHL (0x6174653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/IllegalState:1.0
  13,
  ACE_NTOHL (0x496c6c65), 
  ACE_NTOHL (0x67616c53), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x0),  // name = IllegalState
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_IllegalState (
    CORBA::tk_except,
    sizeof (_oc_Components_IllegalState),
    (char *) &_oc_Components_IllegalState,
    0,
    sizeof (Components::IllegalState)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_IllegalState, &_tc_TAO_tc_Components_IllegalState)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::IllegalState::_type (void) const
{
  return ::Components::_tc_IllegalState;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Navigation::_tao_class_id = 0;

Components::Navigation_ptr
tao_Components_Navigation_duplicate (
    Components::Navigation_ptr p
  )
{
  return Components::Navigation::_duplicate (p);
}

void
tao_Components_Navigation_release (
    Components::Navigation_ptr p
  )
{
  CORBA::release (p);
}

Components::Navigation_ptr
tao_Components_Navigation_nil (
    void
  )
{
  return Components::Navigation::_nil ();
}

Components::Navigation_ptr
tao_Components_Navigation_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Navigation::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Navigation_upcast (
    void *src
  )
{
  Components::Navigation **tmp =
    ACE_static_cast (Components::Navigation **, src);
  return *tmp;
}

// *************************************************************
// Components::Navigation_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Navigation_var::Navigation_var (void) // default constructor
  : ptr_ (Navigation::_nil ())
{}

::Components::Navigation_ptr
Components::Navigation_var::ptr (void) const
{
  return this->ptr_;
}

Components::Navigation_var::Navigation_var (const ::Components::Navigation_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Navigation::_duplicate (p.ptr ()))
{}

Components::Navigation_var::~Navigation_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Navigation_var &
Components::Navigation_var::operator= (Navigation_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Navigation_var &
Components::Navigation_var::operator= (const ::Components::Navigation_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Navigation::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Navigation_var::operator const ::Components::Navigation_ptr &() const // cast
{
  return this->ptr_;
}

Components::Navigation_var::operator ::Components::Navigation_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_var::in (void) const
{
  return this->ptr_;
}

::Components::Navigation_ptr &
Components::Navigation_var::inout (void)
{
  return this->ptr_;
}

::Components::Navigation_ptr &
Components::Navigation_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Navigation::_nil ();
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Navigation_ptr val = this->ptr_;
  this->ptr_ = ::Components::Navigation::_nil ();
  return val;
}

::Components::Navigation_ptr
Components::Navigation_var::tao_duplicate (Navigation_ptr p)
{
  return ::Components::Navigation::_duplicate (p);
}

void
Components::Navigation_var::tao_release (Navigation_ptr p)
{
  CORBA::release (p);
}

::Components::Navigation_ptr
Components::Navigation_var::tao_nil (void)
{
  return ::Components::Navigation::_nil ();
}

::Components::Navigation_ptr
Components::Navigation_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Navigation::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Navigation_var::tao_upcast (void *src)
{
  Navigation **tmp =
    ACE_static_cast (Navigation **, src);
  return *tmp;
}

// *************************************************************
// Components::Navigation_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Navigation_out::Navigation_out (Navigation_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Navigation::_nil ();
}

Components::Navigation_out::Navigation_out (Navigation_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Navigation::_nil ();
}

Components::Navigation_out::Navigation_out (const ::Components::Navigation_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Navigation_out &, p).ptr_)
{}

::Components::Navigation_out &
Components::Navigation_out::operator= (const ::Components::Navigation_out &p)
{
  this->ptr_ = ACE_const_cast (Navigation_out&, p).ptr_;
  return *this;
}

Components::Navigation_out &
Components::Navigation_out::operator= (const ::Components::Navigation_var &p)
{
  this->ptr_ = ::Components::Navigation::_duplicate (p.ptr ());
  return *this;
}

Components::Navigation_out &
Components::Navigation_out::operator= (Navigation_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Navigation_out::operator ::Components::Navigation_ptr &() // cast
{
  return this->ptr_;
}

::Components::Navigation_ptr &
Components::Navigation_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Navigation_ptr
Components::Navigation_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Navigation_provide_facet : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_provide_facet (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Object_ptr result);

private:
  TAO_ClientRequestInfo_Components_Navigation_provide_facet (const TAO_ClientRequestInfo_Components_Navigation_provide_facet &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_provide_facet &);

  const char * name_;
  CORBA::Object_ptr _result;
};

TAO_ClientRequestInfo_Components_Navigation_provide_facet::TAO_ClientRequestInfo_Components_Navigation_provide_facet (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_provide_facet::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_provide_facet::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Navigation_provide_facet_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Navigation_provide_facet_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_provide_facet::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_provide_facet::result (CORBA::Object_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Navigation_get_all_facets : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_get_all_facets (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::FacetDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Navigation_get_all_facets (const TAO_ClientRequestInfo_Components_Navigation_get_all_facets &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_get_all_facets &);

  Components::FacetDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Navigation_get_all_facets::TAO_ClientRequestInfo_Components_Navigation_get_all_facets (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_get_all_facets::result (::Components::FacetDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Navigation_get_named_facets : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_get_named_facets (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::FacetDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Navigation_get_named_facets (const TAO_ClientRequestInfo_Components_Navigation_get_named_facets &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_get_named_facets &);

  const Components::NameList & names_;
  Components::FacetDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Navigation_get_named_facets::TAO_ClientRequestInfo_Components_Navigation_get_named_facets (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Navigation_get_named_facets_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Navigation_get_named_facets_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_get_named_facets::result (::Components::FacetDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Navigation_same_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Navigation_same_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::Object_ptr object_ref);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ClientRequestInfo_Components_Navigation_same_component (const TAO_ClientRequestInfo_Components_Navigation_same_component &);
  void operator= (const TAO_ClientRequestInfo_Components_Navigation_same_component &);

  CORBA::Object_ptr object_ref_;
  CORBA::Boolean _result;
};

TAO_ClientRequestInfo_Components_Navigation_same_component::TAO_ClientRequestInfo_Components_Navigation_same_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Object_ptr object_ref    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    object_ref_ (object_ref)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Navigation_same_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= object_ref_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Navigation_same_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Navigation_same_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Navigation_same_component::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Navigation_Proxy_Impl::_TAO_Navigation_Proxy_Impl (void)
{}

Components::_TAO_Navigation_Remote_Proxy_Impl::_TAO_Navigation_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Object_ptr Components::_TAO_Navigation_Remote_Proxy_Impl::provide_facet (
    CORBA_Object *_collocated_tao_target_,
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Navigation_provide_facet_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  CORBA::Object_var _tao_retval (CORBA::Object::_nil ());
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "provide_facet",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_provide_facet _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        name
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << name)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Navigation_provide_facet_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Object_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::FacetDescriptions * Components::_TAO_Navigation_Remote_Proxy_Impl::get_all_facets (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::FacetDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::FacetDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::FacetDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_facets",
      14,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_get_all_facets _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::FacetDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::FacetDescriptions * Components::_TAO_Navigation_Remote_Proxy_Impl::get_named_facets (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Navigation_get_named_facets_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  Components::FacetDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::FacetDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::FacetDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_facets",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_get_named_facets _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        names
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << names)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Navigation_get_named_facets_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::FacetDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

CORBA::Boolean Components::_TAO_Navigation_Remote_Proxy_Impl::same_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Object_ptr object_ref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "same_component",
      14,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Navigation_same_component _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        object_ref
      );
            ACE_CHECK_RETURN (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << object_ref)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info = _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval;
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Navigation_Proxy_Broker::_TAO_Navigation_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Proxy_Broker::~_TAO_Navigation_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Proxy_Broker * (*Components__TAO_Navigation_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Navigation_Remote_Proxy_Broker *
Components::_TAO_Navigation_Remote_Proxy_Broker::the_TAO_Navigation_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Navigation_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Navigation_Remote_Proxy_Broker::_TAO_Navigation_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Remote_Proxy_Broker::~_TAO_Navigation_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Navigation_Proxy_Impl&
Components::_TAO_Navigation_Remote_Proxy_Broker::select_proxy (
  ::Components::Navigation *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Navigation::Navigation (int collocated)
{
  this->Components_Navigation_setup_collocation (collocated);
}

Components::Navigation::~Navigation (void)
{}

void
Components::Navigation::Components_Navigation_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Navigation_Proxy_Broker_ =
      ::Components__TAO_Navigation_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Navigation_Proxy_Broker_ =
      ::Components::_TAO_Navigation_Remote_Proxy_Broker::the_TAO_Navigation_Remote_Proxy_Broker ();
}

void Components::Navigation::_tao_any_destructor (void *_tao_void_pointer)
{
  Navigation *tmp = ACE_static_cast (Navigation*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Navigation_ptr Components::Navigation::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return Navigation::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Navigation:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (Navigation::_nil ());
      if (is_a == 0)
        return Navigation::_nil ();
    }
  return Navigation::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Navigation_ptr 
Components::Navigation::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Navigation::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Navigation_ptr default_proxy = Navigation::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Navigation_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Navigation (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Navigation::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Navigation (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Navigation::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Navigation_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Navigation::_tao_class_id
                  )
              )
        );
}

Components::Navigation_ptr
Components::Navigation::_duplicate (Navigation_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Navigation::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Navigation:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Navigation::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Navigation)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Navigation::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Navigation:1.0";
}

CORBA::Object_ptr Components::Navigation::provide_facet (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.provide_facet (
      this,
      name
    );
}

::Components::FacetDescriptions * Components::Navigation::get_all_facets (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_facets (
      this
    );
}

::Components::FacetDescriptions * Components::Navigation::get_named_facets (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_facets (
      this,
      names
    );
}

CORBA::Boolean Components::Navigation::same_component (
    CORBA::Object_ptr object_ref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Navigation_Proxy_Impl &proxy = 
    this->the_TAO_Navigation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.same_component (
      this,
      object_ref
    );
}

static const CORBA::Long _oc_Components_Navigation[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4e), 
  ACE_NTOHL (0x61766967), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Navigation:1.0
  11,
  ACE_NTOHL (0x4e617669), 
  ACE_NTOHL (0x67617469), 
  ACE_NTOHL (0x6f6e0000),  // name = Navigation
};

static CORBA::TypeCode _tc_TAO_tc_Components_Navigation (
    CORBA::tk_objref,
    sizeof (_oc_Components_Navigation),
    (char *) &_oc_Components_Navigation,
    0,
    sizeof (Components::Navigation)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Navigation, &_tc_TAO_tc_Components_Navigation)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_ConnectionDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
  22,
  ACE_NTOHL (0x436f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e4465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  2, // member count
  3,
  ACE_NTOHL (0x636b0000),  // name = ck
  CORBA::tk_value, // typecode kind
  172, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6f6b69), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
    7,
    ACE_NTOHL (0x436f6f6b), 
    ACE_NTOHL (0x69650000),  // name = Cookie
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    1, // member count
    12,
    ACE_NTOHL (0x636f6f6b), 
    ACE_NTOHL (0x69655661), 
    ACE_NTOHL (0x6c756500),  // name = cookieValue
    CORBA::tk_alias, // typecode kind for typedefs
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4f63), 
      ACE_NTOHL (0x74657453), 
      ACE_NTOHL (0x65713a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
      9,
      ACE_NTOHL (0x4f637465), 
      ACE_NTOHL (0x74536571), 
      ACE_NTOHL (0x0),  // name = OctetSeq
      CORBA::tk_sequence, // typecode kind
      12, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_octet,

        0U,


    0, // data memeber visibility marker


  1, // data memeber visibility marker

  7,
  ACE_NTOHL (0x6f626a72), 
  ACE_NTOHL (0x65660000),  // name = objref
  CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7,
    ACE_NTOHL (0x4f626a65), 
    ACE_NTOHL (0x63740000),  // name = Object

  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConnectionDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ConnectionDescription),
    (char *) &_oc_Components_ConnectionDescription,
    0,
    sizeof (Components::ConnectionDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ConnectionDescription, &_tc_TAO_tc_Components_ConnectionDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::ConnectionDescription_var
// *************************************************************

Components::ConnectionDescription_var::ConnectionDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::ConnectionDescription_var::ConnectionDescription_var (ConnectionDescription* p)
  : ptr_ (p)
{}

Components::ConnectionDescription_var::ConnectionDescription_var (const ConnectionDescription* p)
  : ptr_ (ACE_const_cast(ConnectionDescription*, p))
{}

Components::ConnectionDescription* 
Components::ConnectionDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ConnectionDescription_var::ConnectionDescription_var (const ConnectionDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ConnectionDescription_var::~ConnectionDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ConnectionDescription_var &
Components::ConnectionDescription_var::operator= (ConnectionDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ConnectionDescription_var &
Components::ConnectionDescription_var::operator= (const ConnectionDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ConnectionDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::ConnectionDescription_var::operator const Components::ConnectionDescription* () const // cast
{
  return this->ptr_;
}

Components::ConnectionDescription_var::operator Components::ConnectionDescription* () // cast 
{
  return this->ptr_;
}

Components::ConnectionDescription* 
Components::ConnectionDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ConnectionDescription*
Components::ConnectionDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ConnectionDescription* &
Components::ConnectionDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ConnectionDescription* &
Components::ConnectionDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ConnectionDescription* 
Components::ConnectionDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ConnectionDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::ConnectionDescription_out
// *************************************************************

Components::ConnectionDescription_out::ConnectionDescription_out (ConnectionDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ConnectionDescription_out::ConnectionDescription_out (ConnectionDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ConnectionDescription_out::ConnectionDescription_out (const ConnectionDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConnectionDescription_out&,p).ptr_)
{}

Components::ConnectionDescription_out &
Components::ConnectionDescription_out::operator= (const ConnectionDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ConnectionDescription_out&,p).ptr_;
  return *this;
}

Components::ConnectionDescription_out &
Components::ConnectionDescription_out::operator= (const ConnectionDescription_var &p)
{
  ConnectionDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ConnectionDescription_out &
Components::ConnectionDescription_out::operator= (ConnectionDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::ConnectionDescription_out::operator Components::ConnectionDescription* &() // cast
{
  return this->ptr_;
}

Components::ConnectionDescription* &
Components::ConnectionDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ConnectionDescription* 
Components::ConnectionDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::ConnectionDescription* Components::ConnectionDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ConnectionDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::ConnectionDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::ConnectionDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::ConnectionDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ConnectionDescription *tmp = ACE_static_cast (ConnectionDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::ConnectionDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ConnectionDescription (strm);
}

CORBA::Boolean Components::ConnectionDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ConnectionDescription (strm);
}

CORBA::Boolean Components::ConnectionDescription::_tao_unmarshal (TAO_InputCDR &strm, ConnectionDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          ConnectionDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ConnectionDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ConnectionDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ConnectionDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::ConnectionDescription_init::ConnectionDescription_init ()
{
}

Components::ConnectionDescription_init::~ConnectionDescription_init ()
{
}

const char* 
Components::ConnectionDescription_init::tao_repository_id (void)
{
  return Components::ConnectionDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::ConnectionDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::ConnectionDescription, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONNECTIONDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONNECTIONDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::ConnectionDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::ConnectionDescription **old = ACE_reinterpret_cast (Components::ConnectionDescription**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::ConnectionDescription **tmp = ACE_reinterpret_cast (Components::ConnectionDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ConnectionDescription **tmp = ACE_reinterpret_cast (Components::ConnectionDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONNECTIONDESCRIPTIONS_CS_)
#define _COMPONENTS_CONNECTIONDESCRIPTIONS_CS_

// *************************************************************
// Components::ConnectionDescriptions
// *************************************************************

Components::ConnectionDescriptions::ConnectionDescriptions (void)
{}
Components::ConnectionDescriptions::ConnectionDescriptions (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConnectionDescription,Components::ConnectionDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::ConnectionDescriptions::ConnectionDescriptions (CORBA::ULong max, CORBA::ULong length, Components::ConnectionDescription_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConnectionDescription,Components::ConnectionDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::ConnectionDescriptions::ConnectionDescriptions (const ConnectionDescriptions &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConnectionDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConnectionDescription,Components::ConnectionDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::ConnectionDescriptions::~ConnectionDescriptions (void) // dtor
{}
void Components::ConnectionDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  ConnectionDescriptions *tmp = ACE_static_cast (ConnectionDescriptions*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_ConnectionDescriptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6e65), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
  23,
  ACE_NTOHL (0x436f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e4465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
  CORBA::tk_sequence, // typecode kind
  384, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    368, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      49,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x6f6e6e65), 
      ACE_NTOHL (0x6374696f), 
      ACE_NTOHL (0x6e446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
      22,
      ACE_NTOHL (0x436f6e6e), 
      ACE_NTOHL (0x65637469), 
      ACE_NTOHL (0x6f6e4465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
      0, // value modifier
      CORBA::tk_null, // no stateful base valuetype

      2, // member count
      3,
      ACE_NTOHL (0x636b0000),  // name = ck
      CORBA::tk_value, // typecode kind
      172, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6f6b69), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
        7,
        ACE_NTOHL (0x436f6f6b), 
        ACE_NTOHL (0x69650000),  // name = Cookie
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        1, // member count
        12,
        ACE_NTOHL (0x636f6f6b), 
        ACE_NTOHL (0x69655661), 
        ACE_NTOHL (0x6c756500),  // name = cookieValue
        CORBA::tk_alias, // typecode kind for typedefs
        76, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f63), 
          ACE_NTOHL (0x74657453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
          9,
          ACE_NTOHL (0x4f637465), 
          ACE_NTOHL (0x74536571), 
          ACE_NTOHL (0x0),  // name = OctetSeq
          CORBA::tk_sequence, // typecode kind
          12, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_octet,

            0U,


        0, // data memeber visibility marker


      1, // data memeber visibility marker

      7,
      ACE_NTOHL (0x6f626a72), 
      ACE_NTOHL (0x65660000),  // name = objref
      CORBA::tk_objref,
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f62), 
        ACE_NTOHL (0x6a656374), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
        7,
        ACE_NTOHL (0x4f626a65), 
        ACE_NTOHL (0x63740000),  // name = Object

      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConnectionDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_ConnectionDescriptions),
    (char *) &_oc_Components_ConnectionDescriptions,
    0,
    sizeof (Components::ConnectionDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ConnectionDescriptions, &_tc_TAO_tc_Components_ConnectionDescriptions)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_ReceptacleDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x65636570), 
  ACE_NTOHL (0x7461636c), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ReceptacleDescription:1.0
  22,
  ACE_NTOHL (0x52656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = ReceptacleDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker


  2, // member count
  12,
  ACE_NTOHL (0x69735f6d), 
  ACE_NTOHL (0x756c7469), 
  ACE_NTOHL (0x706c6500),  // name = is_multiple
  CORBA::tk_boolean,

  1, // data memeber visibility marker

  12,
  ACE_NTOHL (0x636f6e6e), 
  ACE_NTOHL (0x65637469), 
  ACE_NTOHL (0x6f6e7300),  // name = connections
  CORBA::tk_alias, // typecode kind for typedefs
  480, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    50,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6e6e65), 
    ACE_NTOHL (0x6374696f), 
    ACE_NTOHL (0x6e446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x733a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
    23,
    ACE_NTOHL (0x436f6e6e), 
    ACE_NTOHL (0x65637469), 
    ACE_NTOHL (0x6f6e4465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
    CORBA::tk_sequence, // typecode kind
    384, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      368, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        49,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6e6e65), 
        ACE_NTOHL (0x6374696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
        22,
        ACE_NTOHL (0x436f6e6e), 
        ACE_NTOHL (0x65637469), 
        ACE_NTOHL (0x6f6e4465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        3,
        ACE_NTOHL (0x636b0000),  // name = ck
        CORBA::tk_value, // typecode kind
        172, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f43), 
          ACE_NTOHL (0x6f6f6b69), 
          ACE_NTOHL (0x653a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
          7,
          ACE_NTOHL (0x436f6f6b), 
          ACE_NTOHL (0x69650000),  // name = Cookie
          0, // value modifier
          CORBA::tk_null, // no stateful base valuetype

          1, // member count
          12,
          ACE_NTOHL (0x636f6f6b), 
          ACE_NTOHL (0x69655661), 
          ACE_NTOHL (0x6c756500),  // name = cookieValue
          CORBA::tk_alias, // typecode kind for typedefs
          76, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            31,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f4f63), 
            ACE_NTOHL (0x74657453), 
            ACE_NTOHL (0x65713a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
            9,
            ACE_NTOHL (0x4f637465), 
            ACE_NTOHL (0x74536571), 
            ACE_NTOHL (0x0),  // name = OctetSeq
            CORBA::tk_sequence, // typecode kind
            12, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              CORBA::tk_octet,

              0U,


          0, // data memeber visibility marker


        1, // data memeber visibility marker

        7,
        ACE_NTOHL (0x6f626a72), 
        ACE_NTOHL (0x65660000),  // name = objref
        CORBA::tk_objref,
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          29,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f62), 
          ACE_NTOHL (0x6a656374), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
          7,
          ACE_NTOHL (0x4f626a65), 
          ACE_NTOHL (0x63740000),  // name = Object

        1, // data memeber visibility marker


      0U,


  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ReceptacleDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ReceptacleDescription),
    (char *) &_oc_Components_ReceptacleDescription,
    0,
    sizeof (Components::ReceptacleDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ReceptacleDescription, &_tc_TAO_tc_Components_ReceptacleDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::ReceptacleDescription_var
// *************************************************************

Components::ReceptacleDescription_var::ReceptacleDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::ReceptacleDescription_var::ReceptacleDescription_var (ReceptacleDescription* p)
  : ptr_ (p)
{}

Components::ReceptacleDescription_var::ReceptacleDescription_var (const ReceptacleDescription* p)
  : ptr_ (ACE_const_cast(ReceptacleDescription*, p))
{}

Components::ReceptacleDescription* 
Components::ReceptacleDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ReceptacleDescription_var::ReceptacleDescription_var (const ReceptacleDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ReceptacleDescription_var::~ReceptacleDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ReceptacleDescription_var &
Components::ReceptacleDescription_var::operator= (ReceptacleDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ReceptacleDescription_var &
Components::ReceptacleDescription_var::operator= (const ReceptacleDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ReceptacleDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::ReceptacleDescription_var::operator const Components::ReceptacleDescription* () const // cast
{
  return this->ptr_;
}

Components::ReceptacleDescription_var::operator Components::ReceptacleDescription* () // cast 
{
  return this->ptr_;
}

Components::ReceptacleDescription* 
Components::ReceptacleDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ReceptacleDescription*
Components::ReceptacleDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ReceptacleDescription* &
Components::ReceptacleDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ReceptacleDescription* &
Components::ReceptacleDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ReceptacleDescription* 
Components::ReceptacleDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ReceptacleDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::ReceptacleDescription_out
// *************************************************************

Components::ReceptacleDescription_out::ReceptacleDescription_out (ReceptacleDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ReceptacleDescription_out::ReceptacleDescription_out (ReceptacleDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ReceptacleDescription_out::ReceptacleDescription_out (const ReceptacleDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ReceptacleDescription_out&,p).ptr_)
{}

Components::ReceptacleDescription_out &
Components::ReceptacleDescription_out::operator= (const ReceptacleDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ReceptacleDescription_out&,p).ptr_;
  return *this;
}

Components::ReceptacleDescription_out &
Components::ReceptacleDescription_out::operator= (const ReceptacleDescription_var &p)
{
  ReceptacleDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ReceptacleDescription_out &
Components::ReceptacleDescription_out::operator= (ReceptacleDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::ReceptacleDescription_out::operator Components::ReceptacleDescription* &() // cast
{
  return this->ptr_;
}

Components::ReceptacleDescription* &
Components::ReceptacleDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ReceptacleDescription* 
Components::ReceptacleDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::ReceptacleDescription* Components::ReceptacleDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ReceptacleDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::ReceptacleDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::ReceptacleDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::ReceptacleDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ReceptacleDescription *tmp = ACE_static_cast (ReceptacleDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::ReceptacleDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ReceptacleDescription (strm);
}

CORBA::Boolean Components::ReceptacleDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ReceptacleDescription (strm);
}

CORBA::Boolean Components::ReceptacleDescription::_tao_unmarshal (TAO_InputCDR &strm, ReceptacleDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          ReceptacleDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ReceptacleDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ReceptacleDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ReceptacleDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::ReceptacleDescription_init::ReceptacleDescription_init ()
{
}

Components::ReceptacleDescription_init::~ReceptacleDescription_init ()
{
}

const char* 
Components::ReceptacleDescription_init::tao_repository_id (void)
{
  return Components::ReceptacleDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::ReceptacleDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::ReceptacleDescription, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::ReceptacleDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::ReceptacleDescription **old = ACE_reinterpret_cast (Components::ReceptacleDescription**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::ReceptacleDescription **tmp = ACE_reinterpret_cast (Components::ReceptacleDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ReceptacleDescription **tmp = ACE_reinterpret_cast (Components::ReceptacleDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_)
#define _COMPONENTS_RECEPTACLEDESCRIPTIONS_CS_

// *************************************************************
// Components::ReceptacleDescriptions
// *************************************************************

Components::ReceptacleDescriptions::ReceptacleDescriptions (void)
{}
Components::ReceptacleDescriptions::ReceptacleDescriptions (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ReceptacleDescription,Components::ReceptacleDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::ReceptacleDescriptions::ReceptacleDescriptions (CORBA::ULong max, CORBA::ULong length, Components::ReceptacleDescription_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ReceptacleDescription,Components::ReceptacleDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::ReceptacleDescriptions::ReceptacleDescriptions (const ReceptacleDescriptions &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ReceptacleDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ReceptacleDescription,Components::ReceptacleDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::ReceptacleDescriptions::~ReceptacleDescriptions (void) // dtor
{}
void Components::ReceptacleDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  ReceptacleDescriptions *tmp = ACE_static_cast (ReceptacleDescriptions*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_ReceptacleDescriptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x65636570), 
  ACE_NTOHL (0x7461636c), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ReceptacleDescriptions:1.0
  23,
  ACE_NTOHL (0x52656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = ReceptacleDescriptions
  CORBA::tk_sequence, // typecode kind
  928, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    912, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      49,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f52), 
      ACE_NTOHL (0x65636570), 
      ACE_NTOHL (0x7461636c), 
      ACE_NTOHL (0x65446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ReceptacleDescription:1.0
      22,
      ACE_NTOHL (0x52656365), 
      ACE_NTOHL (0x70746163), 
      ACE_NTOHL (0x6c654465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e000000),  // name = ReceptacleDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker


      2, // member count
      12,
      ACE_NTOHL (0x69735f6d), 
      ACE_NTOHL (0x756c7469), 
      ACE_NTOHL (0x706c6500),  // name = is_multiple
      CORBA::tk_boolean,

      1, // data memeber visibility marker

      12,
      ACE_NTOHL (0x636f6e6e), 
      ACE_NTOHL (0x65637469), 
      ACE_NTOHL (0x6f6e7300),  // name = connections
      CORBA::tk_alias, // typecode kind for typedefs
      480, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        50,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6e6e65), 
        ACE_NTOHL (0x6374696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x733a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
        23,
        ACE_NTOHL (0x436f6e6e), 
        ACE_NTOHL (0x65637469), 
        ACE_NTOHL (0x6f6e4465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
        CORBA::tk_sequence, // typecode kind
        384, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_value, // typecode kind
          368, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            49,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f6d70), 
            ACE_NTOHL (0x6f6e656e), 
            ACE_NTOHL (0x74732f43), 
            ACE_NTOHL (0x6f6e6e65), 
            ACE_NTOHL (0x6374696f), 
            ACE_NTOHL (0x6e446573), 
            ACE_NTOHL (0x63726970), 
            ACE_NTOHL (0x74696f6e), 
            ACE_NTOHL (0x3a312e30), 
            ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
            22,
            ACE_NTOHL (0x436f6e6e), 
            ACE_NTOHL (0x65637469), 
            ACE_NTOHL (0x6f6e4465), 
            ACE_NTOHL (0x73637269), 
            ACE_NTOHL (0x7074696f), 
            ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
            0, // value modifier
            CORBA::tk_null, // no stateful base valuetype

            2, // member count
            3,
            ACE_NTOHL (0x636b0000),  // name = ck
            CORBA::tk_value, // typecode kind
            172, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f43), 
              ACE_NTOHL (0x6f6f6b69), 
              ACE_NTOHL (0x653a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
              7,
              ACE_NTOHL (0x436f6f6b), 
              ACE_NTOHL (0x69650000),  // name = Cookie
              0, // value modifier
              CORBA::tk_null, // no stateful base valuetype

              1, // member count
              12,
              ACE_NTOHL (0x636f6f6b), 
              ACE_NTOHL (0x69655661), 
              ACE_NTOHL (0x6c756500),  // name = cookieValue
              CORBA::tk_alias, // typecode kind for typedefs
              76, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4f63), 
                ACE_NTOHL (0x74657453), 
                ACE_NTOHL (0x65713a31), 
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
                9,
                ACE_NTOHL (0x4f637465), 
                ACE_NTOHL (0x74536571), 
                ACE_NTOHL (0x0),  // name = OctetSeq
                CORBA::tk_sequence, // typecode kind
                12, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  CORBA::tk_octet,

                  0U,


              0, // data memeber visibility marker


            1, // data memeber visibility marker

            7,
            ACE_NTOHL (0x6f626a72), 
            ACE_NTOHL (0x65660000),  // name = objref
            CORBA::tk_objref,
            52, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              29,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4f62), 
              ACE_NTOHL (0x6a656374), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
              7,
              ACE_NTOHL (0x4f626a65), 
              ACE_NTOHL (0x63740000),  // name = Object

            1, // data memeber visibility marker


          0U,


      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ReceptacleDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_ReceptacleDescriptions),
    (char *) &_oc_Components_ReceptacleDescriptions,
    0,
    sizeof (Components::ReceptacleDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ReceptacleDescriptions, &_tc_TAO_tc_Components_ReceptacleDescriptions)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Receptacles::_tao_class_id = 0;

Components::Receptacles_ptr
tao_Components_Receptacles_duplicate (
    Components::Receptacles_ptr p
  )
{
  return Components::Receptacles::_duplicate (p);
}

void
tao_Components_Receptacles_release (
    Components::Receptacles_ptr p
  )
{
  CORBA::release (p);
}

Components::Receptacles_ptr
tao_Components_Receptacles_nil (
    void
  )
{
  return Components::Receptacles::_nil ();
}

Components::Receptacles_ptr
tao_Components_Receptacles_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Receptacles::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Receptacles_upcast (
    void *src
  )
{
  Components::Receptacles **tmp =
    ACE_static_cast (Components::Receptacles **, src);
  return *tmp;
}

// *************************************************************
// Components::Receptacles_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Receptacles_var::Receptacles_var (void) // default constructor
  : ptr_ (Receptacles::_nil ())
{}

::Components::Receptacles_ptr
Components::Receptacles_var::ptr (void) const
{
  return this->ptr_;
}

Components::Receptacles_var::Receptacles_var (const ::Components::Receptacles_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Receptacles::_duplicate (p.ptr ()))
{}

Components::Receptacles_var::~Receptacles_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Receptacles_var &
Components::Receptacles_var::operator= (Receptacles_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Receptacles_var &
Components::Receptacles_var::operator= (const ::Components::Receptacles_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Receptacles::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Receptacles_var::operator const ::Components::Receptacles_ptr &() const // cast
{
  return this->ptr_;
}

Components::Receptacles_var::operator ::Components::Receptacles_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_var::in (void) const
{
  return this->ptr_;
}

::Components::Receptacles_ptr &
Components::Receptacles_var::inout (void)
{
  return this->ptr_;
}

::Components::Receptacles_ptr &
Components::Receptacles_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Receptacles::_nil ();
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Receptacles_ptr val = this->ptr_;
  this->ptr_ = ::Components::Receptacles::_nil ();
  return val;
}

::Components::Receptacles_ptr
Components::Receptacles_var::tao_duplicate (Receptacles_ptr p)
{
  return ::Components::Receptacles::_duplicate (p);
}

void
Components::Receptacles_var::tao_release (Receptacles_ptr p)
{
  CORBA::release (p);
}

::Components::Receptacles_ptr
Components::Receptacles_var::tao_nil (void)
{
  return ::Components::Receptacles::_nil ();
}

::Components::Receptacles_ptr
Components::Receptacles_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Receptacles::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Receptacles_var::tao_upcast (void *src)
{
  Receptacles **tmp =
    ACE_static_cast (Receptacles **, src);
  return *tmp;
}

// *************************************************************
// Components::Receptacles_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Receptacles_out::Receptacles_out (Receptacles_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Receptacles::_nil ();
}

Components::Receptacles_out::Receptacles_out (Receptacles_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Receptacles::_nil ();
}

Components::Receptacles_out::Receptacles_out (const ::Components::Receptacles_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Receptacles_out &, p).ptr_)
{}

::Components::Receptacles_out &
Components::Receptacles_out::operator= (const ::Components::Receptacles_out &p)
{
  this->ptr_ = ACE_const_cast (Receptacles_out&, p).ptr_;
  return *this;
}

Components::Receptacles_out &
Components::Receptacles_out::operator= (const ::Components::Receptacles_var &p)
{
  this->ptr_ = ::Components::Receptacles::_duplicate (p.ptr ());
  return *this;
}

Components::Receptacles_out &
Components::Receptacles_out::operator= (Receptacles_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Receptacles_out::operator ::Components::Receptacles_ptr &() // cast
{
  return this->ptr_;
}

::Components::Receptacles_ptr &
Components::Receptacles_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Receptacles_ptr
Components::Receptacles_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Receptacles_connect : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_connect (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name,
      CORBA::Object_ptr connection);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Cookie * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_connect (const TAO_ClientRequestInfo_Components_Receptacles_connect &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_connect &);

  const char * name_;
  CORBA::Object_ptr connection_;
  Components::Cookie * _result;
};

TAO_ClientRequestInfo_Components_Receptacles_connect::TAO_ClientRequestInfo_Components_Receptacles_connect (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name,
    CORBA::Object_ptr connection    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name),
    connection_ (connection)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_connect::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= connection_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_connect::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_connect_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection,
    Components::_tc_AlreadyConnected,
    Components::_tc_ExceededConnectionLimit
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_connect_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_connect::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_connect::result (::Components::Cookie * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Receptacles_disconnect : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_disconnect (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name,
      Components::Cookie * ck);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Receptacles_disconnect (const TAO_ClientRequestInfo_Components_Receptacles_disconnect &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_disconnect &);

  const char * name_;
  Components::Cookie * ck_;
  
};

TAO_ClientRequestInfo_Components_Receptacles_disconnect::TAO_ClientRequestInfo_Components_Receptacles_disconnect (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name,
    Components::Cookie * ck    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name),
    ck_ (ck)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_disconnect::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_disconnect::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_disconnect_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection,
    Components::_tc_CookieRequired,
    Components::_tc_NoConnection
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_disconnect_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_disconnect::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Receptacles_get_connections : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_get_connections (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConnectionDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_get_connections (const TAO_ClientRequestInfo_Components_Receptacles_get_connections &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_get_connections &);

  const char * name_;
  Components::ConnectionDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Receptacles_get_connections::TAO_ClientRequestInfo_Components_Receptacles_get_connections (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_get_connections::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_get_connections::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_get_connections_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_get_connections_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_get_connections::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_get_connections::result (::Components::ConnectionDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ReceptacleDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles (const TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles &);

  Components::ReceptacleDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles::result (::Components::ReceptacleDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ReceptacleDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles (const TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles &);
  void operator= (const TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles &);

  const Components::NameList & names_;
  Components::ReceptacleDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Receptacles_get_named_receptacles_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Receptacles_get_named_receptacles_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles::result (::Components::ReceptacleDescriptions * result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Receptacles_Proxy_Impl::_TAO_Receptacles_Proxy_Impl (void)
{}

Components::_TAO_Receptacles_Remote_Proxy_Impl::_TAO_Receptacles_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::Cookie * Components::_TAO_Receptacles_Remote_Proxy_Impl::connect (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Object_ptr connection
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::AlreadyConnected
    , Components::ExceededConnectionLimit
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Receptacles_connect_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    },
    {
      "IDL:omg.org/Components/AlreadyConnected:1.0",
      Components::AlreadyConnected::_alloc
    },
    {
      "IDL:omg.org/Components/ExceededConnectionLimit:1.0",
      Components::ExceededConnectionLimit::_alloc
    }
  };

  ::Components::Cookie_var _tao_retval;


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "connect",
      7,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_connect _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        name,
        connection
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << name) &&
              (_tao_out << connection)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_connect_exceptiondata, 4 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Cookie * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::_TAO_Receptacles_Remote_Proxy_Impl::disconnect (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::CookieRequired
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Receptacles_disconnect_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    },
    {
      "IDL:omg.org/Components/CookieRequired:1.0",
      Components::CookieRequired::_alloc
    },
    {
      "IDL:omg.org/Components/NoConnection:1.0",
      Components::NoConnection::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "disconnect",
      10,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_disconnect _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        name,
        ck
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << name) &&
              (_tao_out << ck)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_disconnect_exceptiondata, 4 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

::Components::ConnectionDescriptions * Components::_TAO_Receptacles_Remote_Proxy_Impl::get_connections (
    CORBA_Object *_collocated_tao_target_,
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Receptacles_get_connections_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  Components::ConnectionDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::ConnectionDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ConnectionDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_connections",
      15,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_get_connections _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        name
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << name)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_get_connections_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConnectionDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::ReceptacleDescriptions * Components::_TAO_Receptacles_Remote_Proxy_Impl::get_all_receptacles (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::ReceptacleDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::ReceptacleDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ReceptacleDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_receptacles",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_get_all_receptacles _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ReceptacleDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::ReceptacleDescriptions * Components::_TAO_Receptacles_Remote_Proxy_Impl::get_named_receptacles (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Receptacles_get_named_receptacles_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  Components::ReceptacleDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::ReceptacleDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ReceptacleDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_receptacles",
      21,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Receptacles_get_named_receptacles _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        names
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << names)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Receptacles_get_named_receptacles_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ReceptacleDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Receptacles_Proxy_Broker::_TAO_Receptacles_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Proxy_Broker::~_TAO_Receptacles_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Proxy_Broker * (*Components__TAO_Receptacles_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Receptacles_Remote_Proxy_Broker *
Components::_TAO_Receptacles_Remote_Proxy_Broker::the_TAO_Receptacles_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Receptacles_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Receptacles_Remote_Proxy_Broker::_TAO_Receptacles_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Remote_Proxy_Broker::~_TAO_Receptacles_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Receptacles_Proxy_Impl&
Components::_TAO_Receptacles_Remote_Proxy_Broker::select_proxy (
  ::Components::Receptacles *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Receptacles::Receptacles (int collocated)
{
  this->Components_Receptacles_setup_collocation (collocated);
}

Components::Receptacles::~Receptacles (void)
{}

void
Components::Receptacles::Components_Receptacles_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Receptacles_Proxy_Broker_ =
      ::Components__TAO_Receptacles_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Receptacles_Proxy_Broker_ =
      ::Components::_TAO_Receptacles_Remote_Proxy_Broker::the_TAO_Receptacles_Remote_Proxy_Broker ();
}

void Components::Receptacles::_tao_any_destructor (void *_tao_void_pointer)
{
  Receptacles *tmp = ACE_static_cast (Receptacles*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Receptacles_ptr Components::Receptacles::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return Receptacles::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Receptacles:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (Receptacles::_nil ());
      if (is_a == 0)
        return Receptacles::_nil ();
    }
  return Receptacles::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Receptacles_ptr 
Components::Receptacles::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Receptacles::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Receptacles_ptr default_proxy = Receptacles::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Receptacles_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Receptacles (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Receptacles::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Receptacles (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Receptacles::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Receptacles_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Receptacles::_tao_class_id
                  )
              )
        );
}

Components::Receptacles_ptr
Components::Receptacles::_duplicate (Receptacles_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Receptacles::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Receptacles:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Receptacles::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Receptacles)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Receptacles::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Receptacles:1.0";
}

::Components::Cookie * Components::Receptacles::connect (
    const char * name,
    CORBA::Object_ptr connection
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::AlreadyConnected
    , Components::ExceededConnectionLimit
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.connect (
      this,
      name,
      connection
    );
}

void Components::Receptacles::disconnect (
    const char * name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
    , Components::CookieRequired
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.disconnect (
      this,
      name,
      ck
    );
}

::Components::ConnectionDescriptions * Components::Receptacles::get_connections (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_connections (
      this,
      name
    );
}

::Components::ReceptacleDescriptions * Components::Receptacles::get_all_receptacles (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_receptacles (
      this
    );
}

::Components::ReceptacleDescriptions * Components::Receptacles::get_named_receptacles (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Receptacles_Proxy_Impl &proxy = 
    this->the_TAO_Receptacles_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_receptacles (
      this,
      names
    );
}

static const CORBA::Long _oc_Components_Receptacles[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f52), 
  ACE_NTOHL (0x65636570), 
  ACE_NTOHL (0x7461636c), 
  ACE_NTOHL (0x65733a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Receptacles:1.0
  12,
  ACE_NTOHL (0x52656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c657300),  // name = Receptacles
};

static CORBA::TypeCode _tc_TAO_tc_Components_Receptacles (
    CORBA::tk_objref,
    sizeof (_oc_Components_Receptacles),
    (char *) &_oc_Components_Receptacles,
    0,
    sizeof (Components::Receptacles)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Receptacles, &_tc_TAO_tc_Components_Receptacles)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_EventBase[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x42617365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventBase:1.0
  10,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74426173), 
  ACE_NTOHL (0x65000000),  // name = EventBase
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_EventBase (
    CORBA::tk_value,
    sizeof (_oc_Components_EventBase),
    (char *) &_oc_Components_EventBase,
    0,
    sizeof (Components::EventBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_EventBase, &_tc_TAO_tc_Components_EventBase)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::EventBase_var
// *************************************************************

Components::EventBase_var::EventBase_var (void) // default constructor
  : ptr_ (0)
{}

Components::EventBase_var::EventBase_var (EventBase* p)
  : ptr_ (p)
{}

Components::EventBase_var::EventBase_var (const EventBase* p)
  : ptr_ (ACE_const_cast(EventBase*, p))
{}

Components::EventBase* 
Components::EventBase_var::ptr (void) const
{
  return this->ptr_;
}

Components::EventBase_var::EventBase_var (const EventBase_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::EventBase_var::~EventBase_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::EventBase_var &
Components::EventBase_var::operator= (EventBase* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EventBase_var &
Components::EventBase_var::operator= (const EventBase_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    EventBase* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::EventBase_var::operator const Components::EventBase* () const // cast
{
  return this->ptr_;
}

Components::EventBase_var::operator Components::EventBase* () // cast 
{
  return this->ptr_;
}

Components::EventBase* 
Components::EventBase_var::operator-> (void) const
{
  return this->ptr_;
}

Components::EventBase*
Components::EventBase_var::in (void) const
{
  return this->ptr_;
}

Components::EventBase* &
Components::EventBase_var::inout (void)
{
  return this->ptr_;
}

Components::EventBase* &
Components::EventBase_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::EventBase* 
Components::EventBase_var::_retn (void)
{
  // yield ownership of managed obj reference
  EventBase* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::EventBase_out
// *************************************************************

Components::EventBase_out::EventBase_out (EventBase* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::EventBase_out::EventBase_out (EventBase_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::EventBase_out::EventBase_out (const EventBase_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EventBase_out&,p).ptr_)
{}

Components::EventBase_out &
Components::EventBase_out::operator= (const EventBase_out &p)
{
  this->ptr_ = ACE_const_cast (EventBase_out&,p).ptr_;
  return *this;
}

Components::EventBase_out &
Components::EventBase_out::operator= (const EventBase_var &p)
{
  EventBase* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::EventBase_out &
Components::EventBase_out::operator= (EventBase* p)
{
  this->ptr_ = p;
  return *this;
}

Components::EventBase_out::operator Components::EventBase* &() // cast
{
  return this->ptr_;
}

Components::EventBase* &
Components::EventBase_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::EventBase* 
Components::EventBase_out::operator-> (void)
{
  return this->ptr_;
}

Components::EventBase* Components::EventBase::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (EventBase* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::EventBase::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::EventBase::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::EventBase::_tao_any_destructor (void *_tao_void_pointer)
{
  EventBase *tmp = ACE_static_cast (EventBase*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::EventBase::_tao_unmarshal (TAO_InputCDR &strm, EventBase *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          EventBase::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::EventBase::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::EventBase::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = EventBase::_downcast (base);
  // %! unmarshal_post
  return 1;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::EventConsumerBase::_tao_class_id = 0;

Components::EventConsumerBase_ptr
tao_Components_EventConsumerBase_duplicate (
    Components::EventConsumerBase_ptr p
  )
{
  return Components::EventConsumerBase::_duplicate (p);
}

void
tao_Components_EventConsumerBase_release (
    Components::EventConsumerBase_ptr p
  )
{
  CORBA::release (p);
}

Components::EventConsumerBase_ptr
tao_Components_EventConsumerBase_nil (
    void
  )
{
  return Components::EventConsumerBase::_nil ();
}

Components::EventConsumerBase_ptr
tao_Components_EventConsumerBase_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::EventConsumerBase::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_EventConsumerBase_upcast (
    void *src
  )
{
  Components::EventConsumerBase **tmp =
    ACE_static_cast (Components::EventConsumerBase **, src);
  return *tmp;
}

// *************************************************************
// Components::EventConsumerBase_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::EventConsumerBase_var::EventConsumerBase_var (void) // default constructor
  : ptr_ (EventConsumerBase::_nil ())
{}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::ptr (void) const
{
  return this->ptr_;
}

Components::EventConsumerBase_var::EventConsumerBase_var (const ::Components::EventConsumerBase_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EventConsumerBase::_duplicate (p.ptr ()))
{}

Components::EventConsumerBase_var::~EventConsumerBase_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::EventConsumerBase_var &
Components::EventConsumerBase_var::operator= (EventConsumerBase_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EventConsumerBase_var &
Components::EventConsumerBase_var::operator= (const ::Components::EventConsumerBase_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::EventConsumerBase::_duplicate (p.ptr ());
  }
  return *this;
}

Components::EventConsumerBase_var::operator const ::Components::EventConsumerBase_ptr &() const // cast
{
  return this->ptr_;
}

Components::EventConsumerBase_var::operator ::Components::EventConsumerBase_ptr &() // cast 
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::in (void) const
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr &
Components::EventConsumerBase_var::inout (void)
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr &
Components::EventConsumerBase_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::EventConsumerBase_ptr val = this->ptr_;
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
  return val;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::tao_duplicate (EventConsumerBase_ptr p)
{
  return ::Components::EventConsumerBase::_duplicate (p);
}

void
Components::EventConsumerBase_var::tao_release (EventConsumerBase_ptr p)
{
  CORBA::release (p);
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::tao_nil (void)
{
  return ::Components::EventConsumerBase::_nil ();
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::EventConsumerBase::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::EventConsumerBase_var::tao_upcast (void *src)
{
  EventConsumerBase **tmp =
    ACE_static_cast (EventConsumerBase **, src);
  return *tmp;
}

// *************************************************************
// Components::EventConsumerBase_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::EventConsumerBase_out::EventConsumerBase_out (EventConsumerBase_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
}

Components::EventConsumerBase_out::EventConsumerBase_out (EventConsumerBase_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EventConsumerBase::_nil ();
}

Components::EventConsumerBase_out::EventConsumerBase_out (const ::Components::EventConsumerBase_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EventConsumerBase_out &, p).ptr_)
{}

::Components::EventConsumerBase_out &
Components::EventConsumerBase_out::operator= (const ::Components::EventConsumerBase_out &p)
{
  this->ptr_ = ACE_const_cast (EventConsumerBase_out&, p).ptr_;
  return *this;
}

Components::EventConsumerBase_out &
Components::EventConsumerBase_out::operator= (const ::Components::EventConsumerBase_var &p)
{
  this->ptr_ = ::Components::EventConsumerBase::_duplicate (p.ptr ());
  return *this;
}

Components::EventConsumerBase_out &
Components::EventConsumerBase_out::operator= (EventConsumerBase_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::EventConsumerBase_out::operator ::Components::EventConsumerBase_ptr &() // cast
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr &
Components::EventConsumerBase_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::EventConsumerBase_ptr
Components::EventConsumerBase_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_EventConsumerBase_push_event : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_EventConsumerBase_push_event (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::EventBase * evt);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_EventConsumerBase_push_event (const TAO_ClientRequestInfo_Components_EventConsumerBase_push_event &);
  void operator= (const TAO_ClientRequestInfo_Components_EventConsumerBase_push_event &);

  Components::EventBase * evt_;
  
};

TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::TAO_ClientRequestInfo_Components_EventConsumerBase_push_event (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::EventBase * evt    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    evt_ (evt)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_EventConsumerBase_push_event_exceptiondata[] = 
  {
    Components::_tc_BadEventType
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_EventConsumerBase_push_event_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_EventConsumerBase_push_event::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_EventConsumerBase_Proxy_Impl::_TAO_EventConsumerBase_Proxy_Impl (void)
{}

Components::_TAO_EventConsumerBase_Remote_Proxy_Impl::_TAO_EventConsumerBase_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

void Components::_TAO_EventConsumerBase_Remote_Proxy_Impl::push_event (
    CORBA_Object *_collocated_tao_target_,
    Components::EventBase * evt
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::BadEventType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_EventConsumerBase_push_event_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/BadEventType:1.0",
      Components::BadEventType::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "push_event",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_EventConsumerBase_push_event _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        evt
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << evt)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_EventConsumerBase_push_event_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_EventConsumerBase_Proxy_Broker::_TAO_EventConsumerBase_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Proxy_Broker::~_TAO_EventConsumerBase_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Proxy_Broker * (*Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_EventConsumerBase_Remote_Proxy_Broker *
Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::the_TAO_EventConsumerBase_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_EventConsumerBase_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::_TAO_EventConsumerBase_Remote_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::~_TAO_EventConsumerBase_Remote_Proxy_Broker (void)
{
}

Components::_TAO_EventConsumerBase_Proxy_Impl&
Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::select_proxy (
  ::Components::EventConsumerBase *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::EventConsumerBase::EventConsumerBase (int collocated)
{
  this->Components_EventConsumerBase_setup_collocation (collocated);
}

Components::EventConsumerBase::~EventConsumerBase (void)
{}

void
Components::EventConsumerBase::Components_EventConsumerBase_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EventConsumerBase_Proxy_Broker_ =
      ::Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EventConsumerBase_Proxy_Broker_ =
      ::Components::_TAO_EventConsumerBase_Remote_Proxy_Broker::the_TAO_EventConsumerBase_Remote_Proxy_Broker ();
}

void Components::EventConsumerBase::_tao_any_destructor (void *_tao_void_pointer)
{
  EventConsumerBase *tmp = ACE_static_cast (EventConsumerBase*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::EventConsumerBase_ptr Components::EventConsumerBase::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return EventConsumerBase::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/EventConsumerBase:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (EventConsumerBase::_nil ());
      if (is_a == 0)
        return EventConsumerBase::_nil ();
    }
  return EventConsumerBase::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::EventConsumerBase_ptr 
Components::EventConsumerBase::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return EventConsumerBase::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      EventConsumerBase_ptr default_proxy = EventConsumerBase::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_EventConsumerBase_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::EventConsumerBase (
                  stub,
                  1,
                  obj->_servant ()
                ),
              EventConsumerBase::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::EventConsumerBase (
                  stub,
                  0,
                  obj->_servant ()
                ),
              EventConsumerBase::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          EventConsumerBase_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &EventConsumerBase::_tao_class_id
                  )
              )
        );
}

Components::EventConsumerBase_ptr
Components::EventConsumerBase::_duplicate (EventConsumerBase_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::EventConsumerBase::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/EventConsumerBase:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::EventConsumerBase::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, EventConsumerBase)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::EventConsumerBase::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/EventConsumerBase:1.0";
}

void Components::EventConsumerBase::push_event (
    Components::EventBase * evt
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::BadEventType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_EventConsumerBase_Proxy_Impl &proxy = 
    this->the_TAO_EventConsumerBase_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.push_event (
      this,
      evt
    );
}

static const CORBA::Long _oc_Components_EventConsumerBase[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x42617365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
  18,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74436f6e), 
  ACE_NTOHL (0x73756d65), 
  ACE_NTOHL (0x72426173), 
  ACE_NTOHL (0x65000000),  // name = EventConsumerBase
};

static CORBA::TypeCode _tc_TAO_tc_Components_EventConsumerBase (
    CORBA::tk_objref,
    sizeof (_oc_Components_EventConsumerBase),
    (char *) &_oc_Components_EventConsumerBase,
    0,
    sizeof (Components::EventConsumerBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_EventConsumerBase, &_tc_TAO_tc_Components_EventConsumerBase)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_ConsumerDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e7375), 
  ACE_NTOHL (0x6d657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ConsumerDescription:1.0
  20,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ConsumerDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker


  1, // member count
  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_objref, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    45,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x76656e74), 
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x42617365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
    18,
    ACE_NTOHL (0x4576656e), 
    ACE_NTOHL (0x74436f6e), 
    ACE_NTOHL (0x73756d65), 
    ACE_NTOHL (0x72426173), 
    ACE_NTOHL (0x65000000),  // name = EventConsumerBase

  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConsumerDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ConsumerDescription),
    (char *) &_oc_Components_ConsumerDescription,
    0,
    sizeof (Components::ConsumerDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ConsumerDescription, &_tc_TAO_tc_Components_ConsumerDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::ConsumerDescription_var
// *************************************************************

Components::ConsumerDescription_var::ConsumerDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::ConsumerDescription_var::ConsumerDescription_var (ConsumerDescription* p)
  : ptr_ (p)
{}

Components::ConsumerDescription_var::ConsumerDescription_var (const ConsumerDescription* p)
  : ptr_ (ACE_const_cast(ConsumerDescription*, p))
{}

Components::ConsumerDescription* 
Components::ConsumerDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ConsumerDescription_var::ConsumerDescription_var (const ConsumerDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ConsumerDescription_var::~ConsumerDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ConsumerDescription_var &
Components::ConsumerDescription_var::operator= (ConsumerDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ConsumerDescription_var &
Components::ConsumerDescription_var::operator= (const ConsumerDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ConsumerDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::ConsumerDescription_var::operator const Components::ConsumerDescription* () const // cast
{
  return this->ptr_;
}

Components::ConsumerDescription_var::operator Components::ConsumerDescription* () // cast 
{
  return this->ptr_;
}

Components::ConsumerDescription* 
Components::ConsumerDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ConsumerDescription*
Components::ConsumerDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ConsumerDescription* &
Components::ConsumerDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ConsumerDescription* &
Components::ConsumerDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ConsumerDescription* 
Components::ConsumerDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ConsumerDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::ConsumerDescription_out
// *************************************************************

Components::ConsumerDescription_out::ConsumerDescription_out (ConsumerDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ConsumerDescription_out::ConsumerDescription_out (ConsumerDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ConsumerDescription_out::ConsumerDescription_out (const ConsumerDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConsumerDescription_out&,p).ptr_)
{}

Components::ConsumerDescription_out &
Components::ConsumerDescription_out::operator= (const ConsumerDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumerDescription_out&,p).ptr_;
  return *this;
}

Components::ConsumerDescription_out &
Components::ConsumerDescription_out::operator= (const ConsumerDescription_var &p)
{
  ConsumerDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ConsumerDescription_out &
Components::ConsumerDescription_out::operator= (ConsumerDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::ConsumerDescription_out::operator Components::ConsumerDescription* &() // cast
{
  return this->ptr_;
}

Components::ConsumerDescription* &
Components::ConsumerDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ConsumerDescription* 
Components::ConsumerDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::ConsumerDescription* Components::ConsumerDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ConsumerDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::ConsumerDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::ConsumerDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::ConsumerDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ConsumerDescription *tmp = ACE_static_cast (ConsumerDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::ConsumerDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ConsumerDescription (strm);
}

CORBA::Boolean Components::ConsumerDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ConsumerDescription (strm);
}

CORBA::Boolean Components::ConsumerDescription::_tao_unmarshal (TAO_InputCDR &strm, ConsumerDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          ConsumerDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ConsumerDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ConsumerDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ConsumerDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::ConsumerDescription_init::ConsumerDescription_init ()
{
}

Components::ConsumerDescription_init::~ConsumerDescription_init ()
{
}

const char* 
Components::ConsumerDescription_init::tao_repository_id (void)
{
  return Components::ConsumerDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::ConsumerDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::ConsumerDescription, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONSUMERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::ConsumerDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::ConsumerDescription **old = ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::ConsumerDescription **tmp = ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ConsumerDescription **tmp = ACE_reinterpret_cast (Components::ConsumerDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONSUMERDESCRIPTIONS_CS_)
#define _COMPONENTS_CONSUMERDESCRIPTIONS_CS_

// *************************************************************
// Components::ConsumerDescriptions
// *************************************************************

Components::ConsumerDescriptions::ConsumerDescriptions (void)
{}
Components::ConsumerDescriptions::ConsumerDescriptions (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConsumerDescription,Components::ConsumerDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::ConsumerDescriptions::ConsumerDescriptions (CORBA::ULong max, CORBA::ULong length, Components::ConsumerDescription_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConsumerDescription,Components::ConsumerDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::ConsumerDescriptions::ConsumerDescriptions (const ConsumerDescriptions &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConsumerDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConsumerDescription,Components::ConsumerDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::ConsumerDescriptions::~ConsumerDescriptions (void) // dtor
{}
void Components::ConsumerDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  ConsumerDescriptions *tmp = ACE_static_cast (ConsumerDescriptions*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_ConsumerDescriptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e7375), 
  ACE_NTOHL (0x6d657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e733a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/ConsumerDescriptions:1.0
  21,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e73), 
  ACE_NTOHL (0x0),  // name = ConsumerDescriptions
  CORBA::tk_sequence, // typecode kind
  496, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    480, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      47,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x6f6e7375), 
      ACE_NTOHL (0x6d657244), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ConsumerDescription:1.0
      20,
      ACE_NTOHL (0x436f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = ConsumerDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker


      1, // member count
      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_objref, // typecode kind
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        45,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x76656e74), 
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x42617365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
        18,
        ACE_NTOHL (0x4576656e), 
        ACE_NTOHL (0x74436f6e), 
        ACE_NTOHL (0x73756d65), 
        ACE_NTOHL (0x72426173), 
        ACE_NTOHL (0x65000000),  // name = EventConsumerBase

      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConsumerDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_ConsumerDescriptions),
    (char *) &_oc_Components_ConsumerDescriptions,
    0,
    sizeof (Components::ConsumerDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ConsumerDescriptions, &_tc_TAO_tc_Components_ConsumerDescriptions)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_EmitterDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6d697474), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/EmitterDescription:1.0
  19,
  ACE_NTOHL (0x456d6974), 
  ACE_NTOHL (0x74657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e0000),  // name = EmitterDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker


  1, // member count
  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_objref, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    45,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x76656e74), 
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x42617365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
    18,
    ACE_NTOHL (0x4576656e), 
    ACE_NTOHL (0x74436f6e), 
    ACE_NTOHL (0x73756d65), 
    ACE_NTOHL (0x72426173), 
    ACE_NTOHL (0x65000000),  // name = EventConsumerBase

  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_EmitterDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_EmitterDescription),
    (char *) &_oc_Components_EmitterDescription,
    0,
    sizeof (Components::EmitterDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_EmitterDescription, &_tc_TAO_tc_Components_EmitterDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::EmitterDescription_var
// *************************************************************

Components::EmitterDescription_var::EmitterDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::EmitterDescription_var::EmitterDescription_var (EmitterDescription* p)
  : ptr_ (p)
{}

Components::EmitterDescription_var::EmitterDescription_var (const EmitterDescription* p)
  : ptr_ (ACE_const_cast(EmitterDescription*, p))
{}

Components::EmitterDescription* 
Components::EmitterDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::EmitterDescription_var::EmitterDescription_var (const EmitterDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::EmitterDescription_var::~EmitterDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::EmitterDescription_var &
Components::EmitterDescription_var::operator= (EmitterDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EmitterDescription_var &
Components::EmitterDescription_var::operator= (const EmitterDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    EmitterDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::EmitterDescription_var::operator const Components::EmitterDescription* () const // cast
{
  return this->ptr_;
}

Components::EmitterDescription_var::operator Components::EmitterDescription* () // cast 
{
  return this->ptr_;
}

Components::EmitterDescription* 
Components::EmitterDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::EmitterDescription*
Components::EmitterDescription_var::in (void) const
{
  return this->ptr_;
}

Components::EmitterDescription* &
Components::EmitterDescription_var::inout (void)
{
  return this->ptr_;
}

Components::EmitterDescription* &
Components::EmitterDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::EmitterDescription* 
Components::EmitterDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  EmitterDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::EmitterDescription_out
// *************************************************************

Components::EmitterDescription_out::EmitterDescription_out (EmitterDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::EmitterDescription_out::EmitterDescription_out (EmitterDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::EmitterDescription_out::EmitterDescription_out (const EmitterDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EmitterDescription_out&,p).ptr_)
{}

Components::EmitterDescription_out &
Components::EmitterDescription_out::operator= (const EmitterDescription_out &p)
{
  this->ptr_ = ACE_const_cast (EmitterDescription_out&,p).ptr_;
  return *this;
}

Components::EmitterDescription_out &
Components::EmitterDescription_out::operator= (const EmitterDescription_var &p)
{
  EmitterDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::EmitterDescription_out &
Components::EmitterDescription_out::operator= (EmitterDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::EmitterDescription_out::operator Components::EmitterDescription* &() // cast
{
  return this->ptr_;
}

Components::EmitterDescription* &
Components::EmitterDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::EmitterDescription* 
Components::EmitterDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::EmitterDescription* Components::EmitterDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (EmitterDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::EmitterDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::EmitterDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::EmitterDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  EmitterDescription *tmp = ACE_static_cast (EmitterDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::EmitterDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_EmitterDescription (strm);
}

CORBA::Boolean Components::EmitterDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_EmitterDescription (strm);
}

CORBA::Boolean Components::EmitterDescription::_tao_unmarshal (TAO_InputCDR &strm, EmitterDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          EmitterDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::EmitterDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::EmitterDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = EmitterDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::EmitterDescription_init::EmitterDescription_init ()
{
}

Components::EmitterDescription_init::~EmitterDescription_init ()
{
}

const char* 
Components::EmitterDescription_init::tao_repository_id (void)
{
  return Components::EmitterDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::EmitterDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::EmitterDescription, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_EMITTERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::EmitterDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::EmitterDescription **old = ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::EmitterDescription **tmp = ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::EmitterDescription **tmp = ACE_reinterpret_cast (Components::EmitterDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_EMITTERDESCRIPTIONS_CS_)
#define _COMPONENTS_EMITTERDESCRIPTIONS_CS_

// *************************************************************
// Components::EmitterDescriptions
// *************************************************************

Components::EmitterDescriptions::EmitterDescriptions (void)
{}
Components::EmitterDescriptions::EmitterDescriptions (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::EmitterDescription,Components::EmitterDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::EmitterDescriptions::EmitterDescriptions (CORBA::ULong max, CORBA::ULong length, Components::EmitterDescription_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::EmitterDescription,Components::EmitterDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::EmitterDescriptions::EmitterDescriptions (const EmitterDescriptions &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_EmitterDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::EmitterDescription,Components::EmitterDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::EmitterDescriptions::~EmitterDescriptions (void) // dtor
{}
void Components::EmitterDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  EmitterDescriptions *tmp = ACE_static_cast (EmitterDescriptions*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_EmitterDescriptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6d697474), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e733a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/EmitterDescriptions:1.0
  20,
  ACE_NTOHL (0x456d6974), 
  ACE_NTOHL (0x74657244), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e7300),  // name = EmitterDescriptions
  CORBA::tk_sequence, // typecode kind
  496, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    480, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      46,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f45), 
      ACE_NTOHL (0x6d697474), 
      ACE_NTOHL (0x65724465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e3a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/EmitterDescription:1.0
      19,
      ACE_NTOHL (0x456d6974), 
      ACE_NTOHL (0x74657244), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e0000),  // name = EmitterDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker


      1, // member count
      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_objref, // typecode kind
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        45,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x76656e74), 
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x42617365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
        18,
        ACE_NTOHL (0x4576656e), 
        ACE_NTOHL (0x74436f6e), 
        ACE_NTOHL (0x73756d65), 
        ACE_NTOHL (0x72426173), 
        ACE_NTOHL (0x65000000),  // name = EventConsumerBase

      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_EmitterDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_EmitterDescriptions),
    (char *) &_oc_Components_EmitterDescriptions,
    0,
    sizeof (Components::EmitterDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_EmitterDescriptions, &_tc_TAO_tc_Components_EmitterDescriptions)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_SubscriberDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x75627363), 
  ACE_NTOHL (0x72696265), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SubscriberDescription:1.0
  22,
  ACE_NTOHL (0x53756273), 
  ACE_NTOHL (0x63726962), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker


  2, // member count
  3,
  ACE_NTOHL (0x636b0000),  // name = ck
  CORBA::tk_value, // typecode kind
  172, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6f6b69), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
    7,
    ACE_NTOHL (0x436f6f6b), 
    ACE_NTOHL (0x69650000),  // name = Cookie
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    1, // member count
    12,
    ACE_NTOHL (0x636f6f6b), 
    ACE_NTOHL (0x69655661), 
    ACE_NTOHL (0x6c756500),  // name = cookieValue
    CORBA::tk_alias, // typecode kind for typedefs
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f4f63), 
      ACE_NTOHL (0x74657453), 
      ACE_NTOHL (0x65713a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
      9,
      ACE_NTOHL (0x4f637465), 
      ACE_NTOHL (0x74536571), 
      ACE_NTOHL (0x0),  // name = OctetSeq
      CORBA::tk_sequence, // typecode kind
      12, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_octet,

        0U,


    0, // data memeber visibility marker


  1, // data memeber visibility marker

  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_objref, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    45,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x76656e74), 
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x42617365), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
    18,
    ACE_NTOHL (0x4576656e), 
    ACE_NTOHL (0x74436f6e), 
    ACE_NTOHL (0x73756d65), 
    ACE_NTOHL (0x72426173), 
    ACE_NTOHL (0x65000000),  // name = EventConsumerBase

  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_SubscriberDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_SubscriberDescription),
    (char *) &_oc_Components_SubscriberDescription,
    0,
    sizeof (Components::SubscriberDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SubscriberDescription, &_tc_TAO_tc_Components_SubscriberDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::SubscriberDescription_var
// *************************************************************

Components::SubscriberDescription_var::SubscriberDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::SubscriberDescription_var::SubscriberDescription_var (SubscriberDescription* p)
  : ptr_ (p)
{}

Components::SubscriberDescription_var::SubscriberDescription_var (const SubscriberDescription* p)
  : ptr_ (ACE_const_cast(SubscriberDescription*, p))
{}

Components::SubscriberDescription* 
Components::SubscriberDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::SubscriberDescription_var::SubscriberDescription_var (const SubscriberDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::SubscriberDescription_var::~SubscriberDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::SubscriberDescription_var &
Components::SubscriberDescription_var::operator= (SubscriberDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::SubscriberDescription_var &
Components::SubscriberDescription_var::operator= (const SubscriberDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    SubscriberDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::SubscriberDescription_var::operator const Components::SubscriberDescription* () const // cast
{
  return this->ptr_;
}

Components::SubscriberDescription_var::operator Components::SubscriberDescription* () // cast 
{
  return this->ptr_;
}

Components::SubscriberDescription* 
Components::SubscriberDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::SubscriberDescription*
Components::SubscriberDescription_var::in (void) const
{
  return this->ptr_;
}

Components::SubscriberDescription* &
Components::SubscriberDescription_var::inout (void)
{
  return this->ptr_;
}

Components::SubscriberDescription* &
Components::SubscriberDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::SubscriberDescription* 
Components::SubscriberDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  SubscriberDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::SubscriberDescription_out
// *************************************************************

Components::SubscriberDescription_out::SubscriberDescription_out (SubscriberDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::SubscriberDescription_out::SubscriberDescription_out (SubscriberDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::SubscriberDescription_out::SubscriberDescription_out (const SubscriberDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (SubscriberDescription_out&,p).ptr_)
{}

Components::SubscriberDescription_out &
Components::SubscriberDescription_out::operator= (const SubscriberDescription_out &p)
{
  this->ptr_ = ACE_const_cast (SubscriberDescription_out&,p).ptr_;
  return *this;
}

Components::SubscriberDescription_out &
Components::SubscriberDescription_out::operator= (const SubscriberDescription_var &p)
{
  SubscriberDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::SubscriberDescription_out &
Components::SubscriberDescription_out::operator= (SubscriberDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::SubscriberDescription_out::operator Components::SubscriberDescription* &() // cast
{
  return this->ptr_;
}

Components::SubscriberDescription* &
Components::SubscriberDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::SubscriberDescription* 
Components::SubscriberDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::SubscriberDescription* Components::SubscriberDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (SubscriberDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::SubscriberDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::SubscriberDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::SubscriberDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  SubscriberDescription *tmp = ACE_static_cast (SubscriberDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::SubscriberDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_SubscriberDescription (strm);
}

CORBA::Boolean Components::SubscriberDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_SubscriberDescription (strm);
}

CORBA::Boolean Components::SubscriberDescription::_tao_unmarshal (TAO_InputCDR &strm, SubscriberDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          SubscriberDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::SubscriberDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::SubscriberDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = SubscriberDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::SubscriberDescription_init::SubscriberDescription_init ()
{
}

Components::SubscriberDescription_init::~SubscriberDescription_init ()
{
}

const char* 
Components::SubscriberDescription_init::tao_repository_id (void)
{
  return Components::SubscriberDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::SubscriberDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::SubscriberDescription, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::SubscriberDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::SubscriberDescription **old = ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::SubscriberDescription **tmp = ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::SubscriberDescription **tmp = ACE_reinterpret_cast (Components::SubscriberDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_)
#define _COMPONENTS_SUBSCRIBERDESCRIPTIONS_CS_

// *************************************************************
// Components::SubscriberDescriptions
// *************************************************************

Components::SubscriberDescriptions::SubscriberDescriptions (void)
{}
Components::SubscriberDescriptions::SubscriberDescriptions (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SubscriberDescription,Components::SubscriberDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::SubscriberDescriptions::SubscriberDescriptions (CORBA::ULong max, CORBA::ULong length, Components::SubscriberDescription_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SubscriberDescription,Components::SubscriberDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::SubscriberDescriptions::SubscriberDescriptions (const SubscriberDescriptions &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SubscriberDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SubscriberDescription,Components::SubscriberDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::SubscriberDescriptions::~SubscriberDescriptions (void) // dtor
{}
void Components::SubscriberDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  SubscriberDescriptions *tmp = ACE_static_cast (SubscriberDescriptions*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_SubscriberDescriptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x75627363), 
  ACE_NTOHL (0x72696265), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/SubscriberDescriptions:1.0
  23,
  ACE_NTOHL (0x53756273), 
  ACE_NTOHL (0x63726962), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
  CORBA::tk_sequence, // typecode kind
  696, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    680, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      49,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f53), 
      ACE_NTOHL (0x75627363), 
      ACE_NTOHL (0x72696265), 
      ACE_NTOHL (0x72446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SubscriberDescription:1.0
      22,
      ACE_NTOHL (0x53756273), 
      ACE_NTOHL (0x63726962), 
      ACE_NTOHL (0x65724465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker


      2, // member count
      3,
      ACE_NTOHL (0x636b0000),  // name = ck
      CORBA::tk_value, // typecode kind
      172, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6f6b69), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
        7,
        ACE_NTOHL (0x436f6f6b), 
        ACE_NTOHL (0x69650000),  // name = Cookie
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        1, // member count
        12,
        ACE_NTOHL (0x636f6f6b), 
        ACE_NTOHL (0x69655661), 
        ACE_NTOHL (0x6c756500),  // name = cookieValue
        CORBA::tk_alias, // typecode kind for typedefs
        76, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f63), 
          ACE_NTOHL (0x74657453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
          9,
          ACE_NTOHL (0x4f637465), 
          ACE_NTOHL (0x74536571), 
          ACE_NTOHL (0x0),  // name = OctetSeq
          CORBA::tk_sequence, // typecode kind
          12, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_octet,

            0U,


        0, // data memeber visibility marker


      1, // data memeber visibility marker

      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_objref, // typecode kind
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        45,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x76656e74), 
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x42617365), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
        18,
        ACE_NTOHL (0x4576656e), 
        ACE_NTOHL (0x74436f6e), 
        ACE_NTOHL (0x73756d65), 
        ACE_NTOHL (0x72426173), 
        ACE_NTOHL (0x65000000),  // name = EventConsumerBase

      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_SubscriberDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_SubscriberDescriptions),
    (char *) &_oc_Components_SubscriberDescriptions,
    0,
    sizeof (Components::SubscriberDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SubscriberDescriptions, &_tc_TAO_tc_Components_SubscriberDescriptions)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_PublisherDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x75626c69), 
  ACE_NTOHL (0x73686572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/PublisherDescription:1.0
  21,
  ACE_NTOHL (0x5075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = PublisherDescription
  0, // value modifier
  CORBA::tk_value, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
    16,
    ACE_NTOHL (0x506f7274), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e00),  // name = PortDescription
    0, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    2, // member count
    5,
    ACE_NTOHL (0x4e616d65), 
    ACE_NTOHL (0x0),  // name = Name
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f46), 
      ACE_NTOHL (0x65617475), 
      ACE_NTOHL (0x72654e61), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
      12,
      ACE_NTOHL (0x46656174), 
      ACE_NTOHL (0x7572654e), 
      ACE_NTOHL (0x616d6500),  // name = FeatureName
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker

    8,
    ACE_NTOHL (0x74797065), 
    ACE_NTOHL (0x5f696400),  // name = type_id
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    1, // data memeber visibility marker


  1, // member count
  9,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x0),  // name = consumer
  CORBA::tk_alias, // typecode kind for typedefs
  516, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    50,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f53), 
    ACE_NTOHL (0x75627363), 
    ACE_NTOHL (0x72696265), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x733a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/SubscriberDescriptions:1.0
    23,
    ACE_NTOHL (0x53756273), 
    ACE_NTOHL (0x63726962), 
    ACE_NTOHL (0x65724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
    CORBA::tk_sequence, // typecode kind
    420, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      404, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        49,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f53), 
        ACE_NTOHL (0x75627363), 
        ACE_NTOHL (0x72696265), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SubscriberDescription:1.0
        22,
        ACE_NTOHL (0x53756273), 
        ACE_NTOHL (0x63726962), 
        ACE_NTOHL (0x65724465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffffdfc, // negative offset (-516)
        2, // member count
        3,
        ACE_NTOHL (0x636b0000),  // name = ck
        CORBA::tk_value, // typecode kind
        172, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f43), 
          ACE_NTOHL (0x6f6f6b69), 
          ACE_NTOHL (0x653a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
          7,
          ACE_NTOHL (0x436f6f6b), 
          ACE_NTOHL (0x69650000),  // name = Cookie
          0, // value modifier
          CORBA::tk_null, // no stateful base valuetype

          1, // member count
          12,
          ACE_NTOHL (0x636f6f6b), 
          ACE_NTOHL (0x69655661), 
          ACE_NTOHL (0x6c756500),  // name = cookieValue
          CORBA::tk_alias, // typecode kind for typedefs
          76, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            31,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f4f63), 
            ACE_NTOHL (0x74657453), 
            ACE_NTOHL (0x65713a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
            9,
            ACE_NTOHL (0x4f637465), 
            ACE_NTOHL (0x74536571), 
            ACE_NTOHL (0x0),  // name = OctetSeq
            CORBA::tk_sequence, // typecode kind
            12, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              CORBA::tk_octet,

              0U,


          0, // data memeber visibility marker


        1, // data memeber visibility marker

        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        CORBA::tk_objref, // typecode kind
        80, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          45,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f45), 
          ACE_NTOHL (0x76656e74), 
          ACE_NTOHL (0x436f6e73), 
          ACE_NTOHL (0x756d6572), 
          ACE_NTOHL (0x42617365), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
          18,
          ACE_NTOHL (0x4576656e), 
          ACE_NTOHL (0x74436f6e), 
          ACE_NTOHL (0x73756d65), 
          ACE_NTOHL (0x72426173), 
          ACE_NTOHL (0x65000000),  // name = EventConsumerBase

        1, // data memeber visibility marker


      0U,


  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_PublisherDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_PublisherDescription),
    (char *) &_oc_Components_PublisherDescription,
    0,
    sizeof (Components::PublisherDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PublisherDescription, &_tc_TAO_tc_Components_PublisherDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::PublisherDescription_var
// *************************************************************

Components::PublisherDescription_var::PublisherDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::PublisherDescription_var::PublisherDescription_var (PublisherDescription* p)
  : ptr_ (p)
{}

Components::PublisherDescription_var::PublisherDescription_var (const PublisherDescription* p)
  : ptr_ (ACE_const_cast(PublisherDescription*, p))
{}

Components::PublisherDescription* 
Components::PublisherDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::PublisherDescription_var::PublisherDescription_var (const PublisherDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::PublisherDescription_var::~PublisherDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::PublisherDescription_var &
Components::PublisherDescription_var::operator= (PublisherDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::PublisherDescription_var &
Components::PublisherDescription_var::operator= (const PublisherDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    PublisherDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::PublisherDescription_var::operator const Components::PublisherDescription* () const // cast
{
  return this->ptr_;
}

Components::PublisherDescription_var::operator Components::PublisherDescription* () // cast 
{
  return this->ptr_;
}

Components::PublisherDescription* 
Components::PublisherDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::PublisherDescription*
Components::PublisherDescription_var::in (void) const
{
  return this->ptr_;
}

Components::PublisherDescription* &
Components::PublisherDescription_var::inout (void)
{
  return this->ptr_;
}

Components::PublisherDescription* &
Components::PublisherDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::PublisherDescription* 
Components::PublisherDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  PublisherDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::PublisherDescription_out
// *************************************************************

Components::PublisherDescription_out::PublisherDescription_out (PublisherDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::PublisherDescription_out::PublisherDescription_out (PublisherDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::PublisherDescription_out::PublisherDescription_out (const PublisherDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PublisherDescription_out&,p).ptr_)
{}

Components::PublisherDescription_out &
Components::PublisherDescription_out::operator= (const PublisherDescription_out &p)
{
  this->ptr_ = ACE_const_cast (PublisherDescription_out&,p).ptr_;
  return *this;
}

Components::PublisherDescription_out &
Components::PublisherDescription_out::operator= (const PublisherDescription_var &p)
{
  PublisherDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::PublisherDescription_out &
Components::PublisherDescription_out::operator= (PublisherDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::PublisherDescription_out::operator Components::PublisherDescription* &() // cast
{
  return this->ptr_;
}

Components::PublisherDescription* &
Components::PublisherDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::PublisherDescription* 
Components::PublisherDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::PublisherDescription* Components::PublisherDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (PublisherDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::PublisherDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::PublisherDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,PortDescription)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::PublisherDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  PublisherDescription *tmp = ACE_static_cast (PublisherDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::PublisherDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_PublisherDescription (strm);
}

CORBA::Boolean Components::PublisherDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_PublisherDescription (strm);
}

CORBA::Boolean Components::PublisherDescription::_tao_unmarshal (TAO_InputCDR &strm, PublisherDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          PublisherDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PublisherDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PublisherDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = PublisherDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::PublisherDescription_init::PublisherDescription_init ()
{
}

Components::PublisherDescription_init::~PublisherDescription_init ()
{
}

const char* 
Components::PublisherDescription_init::tao_repository_id (void)
{
  return Components::PublisherDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::PublisherDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::PublisherDescription, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_PUBLISHERDESCRIPTIONS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_allocate_buffer (CORBA::ULong length)
{
  Components::PublisherDescription **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::PublisherDescription **old = ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::PublisherDescription **tmp = ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::~_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::PublisherDescription **tmp = ACE_reinterpret_cast (Components::PublisherDescription**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_PUBLISHERDESCRIPTIONS_CS_)
#define _COMPONENTS_PUBLISHERDESCRIPTIONS_CS_

// *************************************************************
// Components::PublisherDescriptions
// *************************************************************

Components::PublisherDescriptions::PublisherDescriptions (void)
{}
Components::PublisherDescriptions::PublisherDescriptions (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::PublisherDescription,Components::PublisherDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::PublisherDescriptions::PublisherDescriptions (CORBA::ULong max, CORBA::ULong length, Components::PublisherDescription_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::PublisherDescription,Components::PublisherDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::PublisherDescriptions::PublisherDescriptions (const PublisherDescriptions &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_PublisherDescriptions
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::PublisherDescription,Components::PublisherDescription_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::PublisherDescriptions::~PublisherDescriptions (void) // dtor
{}
void Components::PublisherDescriptions::_tao_any_destructor (void *_tao_void_pointer)
{
  PublisherDescriptions *tmp = ACE_static_cast (PublisherDescriptions*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_PublisherDescriptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x75626c69), 
  ACE_NTOHL (0x73686572), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e73), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/PublisherDescriptions:1.0
  22,
  ACE_NTOHL (0x5075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x72446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x73000000),  // name = PublisherDescriptions
  CORBA::tk_sequence, // typecode kind
  936, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    920, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      48,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f50), 
      ACE_NTOHL (0x75626c69), 
      ACE_NTOHL (0x73686572), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e3a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/PublisherDescription:1.0
      21,
      ACE_NTOHL (0x5075626c), 
      ACE_NTOHL (0x69736865), 
      ACE_NTOHL (0x72446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = PublisherDescription
      0, // value modifier
      CORBA::tk_value, // typecode kind
      276, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
        16,
        ACE_NTOHL (0x506f7274), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = PortDescription
        0, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        2, // member count
        5,
        ACE_NTOHL (0x4e616d65), 
        ACE_NTOHL (0x0),  // name = Name
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          39,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f46), 
          ACE_NTOHL (0x65617475), 
          ACE_NTOHL (0x72654e61), 
          ACE_NTOHL (0x6d653a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
          12,
          ACE_NTOHL (0x46656174), 
          ACE_NTOHL (0x7572654e), 
          ACE_NTOHL (0x616d6500),  // name = FeatureName
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker

        8,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f696400),  // name = type_id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5265), 
          ACE_NTOHL (0x706f7369), 
          ACE_NTOHL (0x746f7279), 
          ACE_NTOHL (0x49643a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13,
          ACE_NTOHL (0x5265706f), 
          ACE_NTOHL (0x7369746f), 
          ACE_NTOHL (0x72794964), 
          ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        1, // data memeber visibility marker


      1, // member count
      9,
      ACE_NTOHL (0x636f6e73), 
      ACE_NTOHL (0x756d6572), 
      ACE_NTOHL (0x0),  // name = consumer
      CORBA::tk_alias, // typecode kind for typedefs
      516, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        50,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f53), 
        ACE_NTOHL (0x75627363), 
        ACE_NTOHL (0x72696265), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x733a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/SubscriberDescriptions:1.0
        23,
        ACE_NTOHL (0x53756273), 
        ACE_NTOHL (0x63726962), 
        ACE_NTOHL (0x65724465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
        CORBA::tk_sequence, // typecode kind
        420, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_value, // typecode kind
          404, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            49,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f6d70), 
            ACE_NTOHL (0x6f6e656e), 
            ACE_NTOHL (0x74732f53), 
            ACE_NTOHL (0x75627363), 
            ACE_NTOHL (0x72696265), 
            ACE_NTOHL (0x72446573), 
            ACE_NTOHL (0x63726970), 
            ACE_NTOHL (0x74696f6e), 
            ACE_NTOHL (0x3a312e30), 
            ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SubscriberDescription:1.0
            22,
            ACE_NTOHL (0x53756273), 
            ACE_NTOHL (0x63726962), 
            ACE_NTOHL (0x65724465), 
            ACE_NTOHL (0x73637269), 
            ACE_NTOHL (0x7074696f), 
            ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
            0, // value modifier
            0xffffffff, // indirection
            0xfffffdfc, // negative offset (-516)
            2, // member count
            3,
            ACE_NTOHL (0x636b0000),  // name = ck
            CORBA::tk_value, // typecode kind
            172, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f43), 
              ACE_NTOHL (0x6f6f6b69), 
              ACE_NTOHL (0x653a312e), 
              ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
              7,
              ACE_NTOHL (0x436f6f6b), 
              ACE_NTOHL (0x69650000),  // name = Cookie
              0, // value modifier
              CORBA::tk_null, // no stateful base valuetype

              1, // member count
              12,
              ACE_NTOHL (0x636f6f6b), 
              ACE_NTOHL (0x69655661), 
              ACE_NTOHL (0x6c756500),  // name = cookieValue
              CORBA::tk_alias, // typecode kind for typedefs
              76, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4f63), 
                ACE_NTOHL (0x74657453), 
                ACE_NTOHL (0x65713a31), 
                ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
                9,
                ACE_NTOHL (0x4f637465), 
                ACE_NTOHL (0x74536571), 
                ACE_NTOHL (0x0),  // name = OctetSeq
                CORBA::tk_sequence, // typecode kind
                12, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  CORBA::tk_octet,

                  0U,


              0, // data memeber visibility marker


            1, // data memeber visibility marker

            9,
            ACE_NTOHL (0x636f6e73), 
            ACE_NTOHL (0x756d6572), 
            ACE_NTOHL (0x0),  // name = consumer
            CORBA::tk_objref, // typecode kind
            80, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              45,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f45), 
              ACE_NTOHL (0x76656e74), 
              ACE_NTOHL (0x436f6e73), 
              ACE_NTOHL (0x756d6572), 
              ACE_NTOHL (0x42617365), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
              18,
              ACE_NTOHL (0x4576656e), 
              ACE_NTOHL (0x74436f6e), 
              ACE_NTOHL (0x73756d65), 
              ACE_NTOHL (0x72426173), 
              ACE_NTOHL (0x65000000),  // name = EventConsumerBase

            1, // data memeber visibility marker


          0U,


      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_PublisherDescriptions (
    CORBA::tk_alias,
    sizeof (_oc_Components_PublisherDescriptions),
    (char *) &_oc_Components_PublisherDescriptions,
    0,
    sizeof (Components::PublisherDescriptions)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PublisherDescriptions, &_tc_TAO_tc_Components_PublisherDescriptions)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Events::_tao_class_id = 0;

Components::Events_ptr
tao_Components_Events_duplicate (
    Components::Events_ptr p
  )
{
  return Components::Events::_duplicate (p);
}

void
tao_Components_Events_release (
    Components::Events_ptr p
  )
{
  CORBA::release (p);
}

Components::Events_ptr
tao_Components_Events_nil (
    void
  )
{
  return Components::Events::_nil ();
}

Components::Events_ptr
tao_Components_Events_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Events::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Events_upcast (
    void *src
  )
{
  Components::Events **tmp =
    ACE_static_cast (Components::Events **, src);
  return *tmp;
}

// *************************************************************
// Components::Events_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Events_var::Events_var (void) // default constructor
  : ptr_ (Events::_nil ())
{}

::Components::Events_ptr
Components::Events_var::ptr (void) const
{
  return this->ptr_;
}

Components::Events_var::Events_var (const ::Components::Events_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Events::_duplicate (p.ptr ()))
{}

Components::Events_var::~Events_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Events_var &
Components::Events_var::operator= (Events_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Events_var &
Components::Events_var::operator= (const ::Components::Events_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Events::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Events_var::operator const ::Components::Events_ptr &() const // cast
{
  return this->ptr_;
}

Components::Events_var::operator ::Components::Events_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_var::in (void) const
{
  return this->ptr_;
}

::Components::Events_ptr &
Components::Events_var::inout (void)
{
  return this->ptr_;
}

::Components::Events_ptr &
Components::Events_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Events::_nil ();
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Events_ptr val = this->ptr_;
  this->ptr_ = ::Components::Events::_nil ();
  return val;
}

::Components::Events_ptr
Components::Events_var::tao_duplicate (Events_ptr p)
{
  return ::Components::Events::_duplicate (p);
}

void
Components::Events_var::tao_release (Events_ptr p)
{
  CORBA::release (p);
}

::Components::Events_ptr
Components::Events_var::tao_nil (void)
{
  return ::Components::Events::_nil ();
}

::Components::Events_ptr
Components::Events_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Events::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Events_var::tao_upcast (void *src)
{
  Events **tmp =
    ACE_static_cast (Events **, src);
  return *tmp;
}

// *************************************************************
// Components::Events_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Events_out::Events_out (Events_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Events::_nil ();
}

Components::Events_out::Events_out (Events_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Events::_nil ();
}

Components::Events_out::Events_out (const ::Components::Events_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Events_out &, p).ptr_)
{}

::Components::Events_out &
Components::Events_out::operator= (const ::Components::Events_out &p)
{
  this->ptr_ = ACE_const_cast (Events_out&, p).ptr_;
  return *this;
}

Components::Events_out &
Components::Events_out::operator= (const ::Components::Events_var &p)
{
  this->ptr_ = ::Components::Events::_duplicate (p.ptr ());
  return *this;
}

Components::Events_out &
Components::Events_out::operator= (Events_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Events_out::operator ::Components::Events_ptr &() // cast
{
  return this->ptr_;
}

::Components::Events_ptr &
Components::Events_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Events_ptr
Components::Events_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Events_get_consumer : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_consumer (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * sink_name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EventConsumerBase_ptr result);

private:
  TAO_ClientRequestInfo_Components_Events_get_consumer (const TAO_ClientRequestInfo_Components_Events_get_consumer &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_consumer &);

  const char * sink_name_;
  Components::EventConsumerBase_ptr _result;
};

TAO_ClientRequestInfo_Components_Events_get_consumer::TAO_ClientRequestInfo_Components_Events_get_consumer (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * sink_name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    sink_name_ (sink_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= sink_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_consumer::result (::Components::EventConsumerBase_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_subscribe : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_subscribe (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * publisher_name,
      Components::EventConsumerBase_ptr subscriber);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Cookie * result);

private:
  TAO_ClientRequestInfo_Components_Events_subscribe (const TAO_ClientRequestInfo_Components_Events_subscribe &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_subscribe &);

  const char * publisher_name_;
  Components::EventConsumerBase_ptr subscriber_;
  Components::Cookie * _result;
};

TAO_ClientRequestInfo_Components_Events_subscribe::TAO_ClientRequestInfo_Components_Events_subscribe (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    publisher_name_ (publisher_name),
    subscriber_ (subscriber)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_subscribe::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= publisher_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->subscriber_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_subscribe::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_subscribe_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_AlreadyConnected,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (3);
  for (CORBA::ULong i = 0; i < 3; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_subscribe_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_subscribe::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_subscribe::result (::Components::Cookie * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_unsubscribe : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_unsubscribe (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * publisher_name,
      Components::Cookie * ck);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Events_unsubscribe (const TAO_ClientRequestInfo_Components_Events_unsubscribe &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_unsubscribe &);

  const char * publisher_name_;
  Components::Cookie * ck_;
  
};

TAO_ClientRequestInfo_Components_Events_unsubscribe::TAO_ClientRequestInfo_Components_Events_unsubscribe (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * publisher_name,
    Components::Cookie * ck    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    publisher_name_ (publisher_name),
    ck_ (ck)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_unsubscribe::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= publisher_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_unsubscribe::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_unsubscribe_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_unsubscribe_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_unsubscribe::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Events_connect_consumer : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_connect_consumer (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * emitter_name,
      Components::EventConsumerBase_ptr consumer);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Events_connect_consumer (const TAO_ClientRequestInfo_Components_Events_connect_consumer &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_connect_consumer &);

  const char * emitter_name_;
  Components::EventConsumerBase_ptr consumer_;
  
};

TAO_ClientRequestInfo_Components_Events_connect_consumer::TAO_ClientRequestInfo_Components_Events_connect_consumer (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    emitter_name_ (emitter_name),
    consumer_ (consumer)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_connect_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= emitter_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->consumer_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_connect_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_connect_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_AlreadyConnected,
    Components::_tc_InvalidConnection
  };
  
  exception_list->length (3);
  for (CORBA::ULong i = 0; i < 3; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_connect_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_connect_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Events_disconnect_consumer : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_disconnect_consumer (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * source_name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EventConsumerBase_ptr result);

private:
  TAO_ClientRequestInfo_Components_Events_disconnect_consumer (const TAO_ClientRequestInfo_Components_Events_disconnect_consumer &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_disconnect_consumer &);

  const char * source_name_;
  Components::EventConsumerBase_ptr _result;
};

TAO_ClientRequestInfo_Components_Events_disconnect_consumer::TAO_ClientRequestInfo_Components_Events_disconnect_consumer (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * source_name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    source_name_ (source_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= source_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_disconnect_consumer_exceptiondata[] = 
  {
    Components::_tc_InvalidName,
    Components::_tc_NoConnection
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_disconnect_consumer_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_disconnect_consumer::result (::Components::EventConsumerBase_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_get_all_consumers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_all_consumers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConsumerDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_all_consumers (const TAO_ClientRequestInfo_Components_Events_get_all_consumers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_all_consumers &);

  Components::ConsumerDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Events_get_all_consumers::TAO_ClientRequestInfo_Components_Events_get_all_consumers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_all_consumers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_all_consumers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_all_consumers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_all_consumers::result (::Components::ConsumerDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_get_named_consumers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_named_consumers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConsumerDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_named_consumers (const TAO_ClientRequestInfo_Components_Events_get_named_consumers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_named_consumers &);

  const Components::NameList & names_;
  Components::ConsumerDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Events_get_named_consumers::TAO_ClientRequestInfo_Components_Events_get_named_consumers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_named_consumers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_named_consumers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_consumers_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_consumers_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_named_consumers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_named_consumers::result (::Components::ConsumerDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_get_all_emitters : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_all_emitters (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EmitterDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_all_emitters (const TAO_ClientRequestInfo_Components_Events_get_all_emitters &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_all_emitters &);

  Components::EmitterDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Events_get_all_emitters::TAO_ClientRequestInfo_Components_Events_get_all_emitters (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_all_emitters::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_all_emitters::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_all_emitters::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_all_emitters::result (::Components::EmitterDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_get_named_emitters : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_named_emitters (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::EmitterDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_named_emitters (const TAO_ClientRequestInfo_Components_Events_get_named_emitters &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_named_emitters &);

  const Components::NameList & names_;
  Components::EmitterDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Events_get_named_emitters::TAO_ClientRequestInfo_Components_Events_get_named_emitters (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_named_emitters::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_named_emitters::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_emitters_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_emitters_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_named_emitters::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_named_emitters::result (::Components::EmitterDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_get_all_publishers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_all_publishers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::PublisherDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_all_publishers (const TAO_ClientRequestInfo_Components_Events_get_all_publishers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_all_publishers &);

  Components::PublisherDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Events_get_all_publishers::TAO_ClientRequestInfo_Components_Events_get_all_publishers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_all_publishers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_all_publishers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_all_publishers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_all_publishers::result (::Components::PublisherDescriptions * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Events_get_named_publishers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Events_get_named_publishers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::NameList & names);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::PublisherDescriptions * result);

private:
  TAO_ClientRequestInfo_Components_Events_get_named_publishers (const TAO_ClientRequestInfo_Components_Events_get_named_publishers &);
  void operator= (const TAO_ClientRequestInfo_Components_Events_get_named_publishers &);

  const Components::NameList & names_;
  Components::PublisherDescriptions * _result;
};

TAO_ClientRequestInfo_Components_Events_get_named_publishers::TAO_ClientRequestInfo_Components_Events_get_named_publishers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::NameList & names    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    names_ (names)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Events_get_named_publishers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->names_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Events_get_named_publishers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Events_get_named_publishers_exceptiondata[] = 
  {
    Components::_tc_InvalidName
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Events_get_named_publishers_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Events_get_named_publishers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Events_get_named_publishers::result (::Components::PublisherDescriptions * result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Events_Proxy_Impl::_TAO_Events_Proxy_Impl (void)
{}

Components::_TAO_Events_Remote_Proxy_Impl::_TAO_Events_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::EventConsumerBase_ptr Components::_TAO_Events_Remote_Proxy_Impl::get_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * sink_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_get_consumer_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  Components::EventConsumerBase_var _tao_retval (Components::EventConsumerBase::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_consumer",
      12,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_consumer _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        sink_name
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << sink_name)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_consumer_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EventConsumerBase_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::Cookie * Components::_TAO_Events_Remote_Proxy_Impl::subscribe (
    CORBA_Object *_collocated_tao_target_,
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_subscribe_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/AlreadyConnected:1.0",
      Components::AlreadyConnected::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    }
  };

  ::Components::Cookie_var _tao_retval;


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "subscribe",
      9,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_subscribe _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        publisher_name,
        subscriber
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << publisher_name) &&
              (_tao_out << subscriber)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_subscribe_exceptiondata, 3 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Cookie * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::_TAO_Events_Remote_Proxy_Impl::unsubscribe (
    CORBA_Object *_collocated_tao_target_,
    const char * publisher_name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_unsubscribe_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "unsubscribe",
      11,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_unsubscribe _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        publisher_name,
        ck
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << publisher_name) &&
              (_tao_out << ck)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_unsubscribe_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::_TAO_Events_Remote_Proxy_Impl::connect_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_connect_consumer_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/AlreadyConnected:1.0",
      Components::AlreadyConnected::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConnection:1.0",
      Components::InvalidConnection::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "connect_consumer",
      16,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_connect_consumer _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        emitter_name,
        consumer
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << emitter_name) &&
              (_tao_out << consumer)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_connect_consumer_exceptiondata, 3 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

::Components::EventConsumerBase_ptr Components::_TAO_Events_Remote_Proxy_Impl::disconnect_consumer (
    CORBA_Object *_collocated_tao_target_,
    const char * source_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_disconnect_consumer_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    },
    {
      "IDL:omg.org/Components/NoConnection:1.0",
      Components::NoConnection::_alloc
    }
  };

  Components::EventConsumerBase_var _tao_retval (Components::EventConsumerBase::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "disconnect_consumer",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_disconnect_consumer _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        source_name
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << source_name)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_disconnect_consumer_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EventConsumerBase_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::ConsumerDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_all_consumers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::ConsumerDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::ConsumerDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ConsumerDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_consumers",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_all_consumers _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConsumerDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::ConsumerDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_named_consumers (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_get_named_consumers_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  Components::ConsumerDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::ConsumerDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::ConsumerDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_consumers",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_named_consumers _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        names
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << names)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_named_consumers_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConsumerDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::EmitterDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_all_emitters (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::EmitterDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::EmitterDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::EmitterDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_emitters",
      16,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_all_emitters _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EmitterDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::EmitterDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_named_emitters (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_get_named_emitters_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  Components::EmitterDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::EmitterDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::EmitterDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_emitters",
      18,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_named_emitters _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        names
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << names)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_named_emitters_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::EmitterDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::PublisherDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_all_publishers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::PublisherDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::PublisherDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::PublisherDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_publishers",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_all_publishers _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::PublisherDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::PublisherDescriptions * Components::_TAO_Events_Remote_Proxy_Impl::get_named_publishers (
    CORBA_Object *_collocated_tao_target_,
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Events_get_named_publishers_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidName:1.0",
      Components::InvalidName::_alloc
    }
  };

  Components::PublisherDescriptions_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::PublisherDescriptions *tmp;
    ACE_NEW_RETURN (tmp, Components::PublisherDescriptions, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_named_publishers",
      20,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Events_get_named_publishers _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        names
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << names)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Events_get_named_publishers_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::PublisherDescriptions * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Events_Proxy_Broker::_TAO_Events_Proxy_Broker (void)
{
}

Components::_TAO_Events_Proxy_Broker::~_TAO_Events_Proxy_Broker (void)
{
}

Components::_TAO_Events_Proxy_Broker * (*Components__TAO_Events_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Events_Remote_Proxy_Broker *
Components::_TAO_Events_Remote_Proxy_Broker::the_TAO_Events_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Events_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Events_Remote_Proxy_Broker::_TAO_Events_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Events_Remote_Proxy_Broker::~_TAO_Events_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Events_Proxy_Impl&
Components::_TAO_Events_Remote_Proxy_Broker::select_proxy (
  ::Components::Events *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Events::Events (int collocated)
{
  this->Components_Events_setup_collocation (collocated);
}

Components::Events::~Events (void)
{}

void
Components::Events::Components_Events_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Events_Proxy_Broker_ =
      ::Components__TAO_Events_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Events_Proxy_Broker_ =
      ::Components::_TAO_Events_Remote_Proxy_Broker::the_TAO_Events_Remote_Proxy_Broker ();
}

void Components::Events::_tao_any_destructor (void *_tao_void_pointer)
{
  Events *tmp = ACE_static_cast (Events*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Events_ptr Components::Events::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return Events::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Events:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (Events::_nil ());
      if (is_a == 0)
        return Events::_nil ();
    }
  return Events::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Events_ptr 
Components::Events::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Events::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Events_ptr default_proxy = Events::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Events_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Events (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Events::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Events (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Events::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Events_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Events::_tao_class_id
                  )
              )
        );
}

Components::Events_ptr
Components::Events::_duplicate (Events_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Events::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Events:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Events::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Events)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Events::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Events:1.0";
}

::Components::EventConsumerBase_ptr Components::Events::get_consumer (
    const char * sink_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_consumer (
      this,
      sink_name
    );
}

::Components::Cookie * Components::Events::subscribe (
    const char * publisher_name,
    Components::EventConsumerBase_ptr subscriber
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.subscribe (
      this,
      publisher_name,
      subscriber
    );
}

void Components::Events::unsubscribe (
    const char * publisher_name,
    Components::Cookie * ck
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.unsubscribe (
      this,
      publisher_name,
      ck
    );
}

void Components::Events::connect_consumer (
    const char * emitter_name,
    Components::EventConsumerBase_ptr consumer
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::AlreadyConnected
    , Components::InvalidConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.connect_consumer (
      this,
      emitter_name,
      consumer
    );
}

::Components::EventConsumerBase_ptr Components::Events::disconnect_consumer (
    const char * source_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
    , Components::NoConnection
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.disconnect_consumer (
      this,
      source_name
    );
}

::Components::ConsumerDescriptions * Components::Events::get_all_consumers (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_consumers (
      this
    );
}

::Components::ConsumerDescriptions * Components::Events::get_named_consumers (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_consumers (
      this,
      names
    );
}

::Components::EmitterDescriptions * Components::Events::get_all_emitters (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_emitters (
      this
    );
}

::Components::EmitterDescriptions * Components::Events::get_named_emitters (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_emitters (
      this,
      names
    );
}

::Components::PublisherDescriptions * Components::Events::get_all_publishers (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_publishers (
      this
    );
}

::Components::PublisherDescriptions * Components::Events::get_named_publishers (
    const Components::NameList & names
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidName
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Events_Proxy_Impl &proxy = 
    this->the_TAO_Events_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_named_publishers (
      this,
      names
    );
}

static const CORBA::Long _oc_Components_Events[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x76656e74), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Events:1.0
  7,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74730000),  // name = Events
};

static CORBA::TypeCode _tc_TAO_tc_Components_Events (
    CORBA::tk_objref,
    sizeof (_oc_Components_Events),
    (char *) &_oc_Components_Events,
    0,
    sizeof (Components::Events)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Events, &_tc_TAO_tc_Components_Events)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_PrimaryKeyBase[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x72696d61), 
  ACE_NTOHL (0x72794b65), 
  ACE_NTOHL (0x79426173), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/PrimaryKeyBase:1.0
  15,
  ACE_NTOHL (0x5072696d), 
  ACE_NTOHL (0x6172794b), 
  ACE_NTOHL (0x65794261), 
  ACE_NTOHL (0x73650000),  // name = PrimaryKeyBase
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_PrimaryKeyBase (
    CORBA::tk_value,
    sizeof (_oc_Components_PrimaryKeyBase),
    (char *) &_oc_Components_PrimaryKeyBase,
    0,
    sizeof (Components::PrimaryKeyBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PrimaryKeyBase, &_tc_TAO_tc_Components_PrimaryKeyBase)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::PrimaryKeyBase_var
// *************************************************************

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (void) // default constructor
  : ptr_ (0)
{}

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (PrimaryKeyBase* p)
  : ptr_ (p)
{}

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (const PrimaryKeyBase* p)
  : ptr_ (ACE_const_cast(PrimaryKeyBase*, p))
{}

Components::PrimaryKeyBase* 
Components::PrimaryKeyBase_var::ptr (void) const
{
  return this->ptr_;
}

Components::PrimaryKeyBase_var::PrimaryKeyBase_var (const PrimaryKeyBase_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::PrimaryKeyBase_var::~PrimaryKeyBase_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::PrimaryKeyBase_var &
Components::PrimaryKeyBase_var::operator= (PrimaryKeyBase* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::PrimaryKeyBase_var &
Components::PrimaryKeyBase_var::operator= (const PrimaryKeyBase_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    PrimaryKeyBase* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::PrimaryKeyBase_var::operator const Components::PrimaryKeyBase* () const // cast
{
  return this->ptr_;
}

Components::PrimaryKeyBase_var::operator Components::PrimaryKeyBase* () // cast 
{
  return this->ptr_;
}

Components::PrimaryKeyBase* 
Components::PrimaryKeyBase_var::operator-> (void) const
{
  return this->ptr_;
}

Components::PrimaryKeyBase*
Components::PrimaryKeyBase_var::in (void) const
{
  return this->ptr_;
}

Components::PrimaryKeyBase* &
Components::PrimaryKeyBase_var::inout (void)
{
  return this->ptr_;
}

Components::PrimaryKeyBase* &
Components::PrimaryKeyBase_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::PrimaryKeyBase* 
Components::PrimaryKeyBase_var::_retn (void)
{
  // yield ownership of managed obj reference
  PrimaryKeyBase* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::PrimaryKeyBase_out
// *************************************************************

Components::PrimaryKeyBase_out::PrimaryKeyBase_out (PrimaryKeyBase* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::PrimaryKeyBase_out::PrimaryKeyBase_out (PrimaryKeyBase_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::PrimaryKeyBase_out::PrimaryKeyBase_out (const PrimaryKeyBase_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PrimaryKeyBase_out&,p).ptr_)
{}

Components::PrimaryKeyBase_out &
Components::PrimaryKeyBase_out::operator= (const PrimaryKeyBase_out &p)
{
  this->ptr_ = ACE_const_cast (PrimaryKeyBase_out&,p).ptr_;
  return *this;
}

Components::PrimaryKeyBase_out &
Components::PrimaryKeyBase_out::operator= (const PrimaryKeyBase_var &p)
{
  PrimaryKeyBase* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::PrimaryKeyBase_out &
Components::PrimaryKeyBase_out::operator= (PrimaryKeyBase* p)
{
  this->ptr_ = p;
  return *this;
}

Components::PrimaryKeyBase_out::operator Components::PrimaryKeyBase* &() // cast
{
  return this->ptr_;
}

Components::PrimaryKeyBase* &
Components::PrimaryKeyBase_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::PrimaryKeyBase* 
Components::PrimaryKeyBase_out::operator-> (void)
{
  return this->ptr_;
}

Components::PrimaryKeyBase* Components::PrimaryKeyBase::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (PrimaryKeyBase* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::PrimaryKeyBase::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::PrimaryKeyBase::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::PrimaryKeyBase::_tao_any_destructor (void *_tao_void_pointer)
{
  PrimaryKeyBase *tmp = ACE_static_cast (PrimaryKeyBase*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::PrimaryKeyBase::_tao_unmarshal (TAO_InputCDR &strm, PrimaryKeyBase *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          PrimaryKeyBase::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PrimaryKeyBase::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PrimaryKeyBase::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = PrimaryKeyBase::_downcast (base);
  // %! unmarshal_post
  return 1;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::CCMHome::_tao_class_id = 0;

Components::CCMHome_ptr
tao_Components_CCMHome_duplicate (
    Components::CCMHome_ptr p
  )
{
  return Components::CCMHome::_duplicate (p);
}

void
tao_Components_CCMHome_release (
    Components::CCMHome_ptr p
  )
{
  CORBA::release (p);
}

Components::CCMHome_ptr
tao_Components_CCMHome_nil (
    void
  )
{
  return Components::CCMHome::_nil ();
}

Components::CCMHome_ptr
tao_Components_CCMHome_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::CCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_CCMHome_upcast (
    void *src
  )
{
  Components::CCMHome **tmp =
    ACE_static_cast (Components::CCMHome **, src);
  return *tmp;
}

// *************************************************************
// Components::CCMHome_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::CCMHome_var::CCMHome_var (void) // default constructor
  : ptr_ (CCMHome::_nil ())
{}

::Components::CCMHome_ptr
Components::CCMHome_var::ptr (void) const
{
  return this->ptr_;
}

Components::CCMHome_var::CCMHome_var (const ::Components::CCMHome_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CCMHome::_duplicate (p.ptr ()))
{}

Components::CCMHome_var::~CCMHome_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::CCMHome_var &
Components::CCMHome_var::operator= (CCMHome_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::CCMHome_var &
Components::CCMHome_var::operator= (const ::Components::CCMHome_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::CCMHome::_duplicate (p.ptr ());
  }
  return *this;
}

Components::CCMHome_var::operator const ::Components::CCMHome_ptr &() const // cast
{
  return this->ptr_;
}

Components::CCMHome_var::operator ::Components::CCMHome_ptr &() // cast 
{
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_var::in (void) const
{
  return this->ptr_;
}

::Components::CCMHome_ptr &
Components::CCMHome_var::inout (void)
{
  return this->ptr_;
}

::Components::CCMHome_ptr &
Components::CCMHome_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMHome::_nil ();
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::CCMHome_ptr val = this->ptr_;
  this->ptr_ = ::Components::CCMHome::_nil ();
  return val;
}

::Components::CCMHome_ptr
Components::CCMHome_var::tao_duplicate (CCMHome_ptr p)
{
  return ::Components::CCMHome::_duplicate (p);
}

void
Components::CCMHome_var::tao_release (CCMHome_ptr p)
{
  CORBA::release (p);
}

::Components::CCMHome_ptr
Components::CCMHome_var::tao_nil (void)
{
  return ::Components::CCMHome::_nil ();
}

::Components::CCMHome_ptr
Components::CCMHome_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::CCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::CCMHome_var::tao_upcast (void *src)
{
  CCMHome **tmp =
    ACE_static_cast (CCMHome **, src);
  return *tmp;
}

// *************************************************************
// Components::CCMHome_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::CCMHome_out::CCMHome_out (CCMHome_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::CCMHome::_nil ();
}

Components::CCMHome_out::CCMHome_out (CCMHome_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMHome::_nil ();
}

Components::CCMHome_out::CCMHome_out (const ::Components::CCMHome_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CCMHome_out &, p).ptr_)
{}

::Components::CCMHome_out &
Components::CCMHome_out::operator= (const ::Components::CCMHome_out &p)
{
  this->ptr_ = ACE_const_cast (CCMHome_out&, p).ptr_;
  return *this;
}

Components::CCMHome_out &
Components::CCMHome_out::operator= (const ::Components::CCMHome_var &p)
{
  this->ptr_ = ::Components::CCMHome::_duplicate (p.ptr ());
  return *this;
}

Components::CCMHome_out &
Components::CCMHome_out::operator= (CCMHome_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::CCMHome_out::operator ::Components::CCMHome_ptr &() // cast
{
  return this->ptr_;
}

::Components::CCMHome_ptr &
Components::CCMHome_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::CCMHome_ptr
Components::CCMHome_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_CCMHome_get_component_def : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMHome_get_component_def (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IRObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMHome_get_component_def (const TAO_ClientRequestInfo_Components_CCMHome_get_component_def &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMHome_get_component_def &);

  CORBA::IRObject_ptr _result;
};

TAO_ClientRequestInfo_Components_CCMHome_get_component_def::TAO_ClientRequestInfo_Components_CCMHome_get_component_def (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMHome_get_component_def::result (::CORBA::IRObject_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_CCMHome_get_home_def : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMHome_get_home_def (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IRObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMHome_get_home_def (const TAO_ClientRequestInfo_Components_CCMHome_get_home_def &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMHome_get_home_def &);

  CORBA::IRObject_ptr _result;
};

TAO_ClientRequestInfo_Components_CCMHome_get_home_def::TAO_ClientRequestInfo_Components_CCMHome_get_home_def (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMHome_get_home_def::result (::CORBA::IRObject_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_CCMHome_remove_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMHome_remove_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::CCMObject_ptr comp);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_CCMHome_remove_component (const TAO_ClientRequestInfo_Components_CCMHome_remove_component &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMHome_remove_component &);

  Components::CCMObject_ptr comp_;
  
};

TAO_ClientRequestInfo_Components_CCMHome_remove_component::TAO_ClientRequestInfo_Components_CCMHome_remove_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::CCMObject_ptr comp    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    comp_ (comp)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMHome_remove_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->comp_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMHome_remove_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMHome_remove_component_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMHome_remove_component_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMHome_remove_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_CCMHome_Proxy_Impl::_TAO_CCMHome_Proxy_Impl (void)
{}

Components::_TAO_CCMHome_Remote_Proxy_Impl::_TAO_CCMHome_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::CORBA::IRObject_ptr Components::_TAO_CCMHome_Remote_Proxy_Impl::get_component_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::IRObject_var _tao_retval (CORBA::IRObject::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_component_def",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMHome_get_component_def _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IRObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::CORBA::IRObject_ptr Components::_TAO_CCMHome_Remote_Proxy_Impl::get_home_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::IRObject_var _tao_retval (CORBA::IRObject::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_home_def",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMHome_get_home_def _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IRObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::_TAO_CCMHome_Remote_Proxy_Impl::remove_component (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_CCMHome_remove_component_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove_component",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMHome_remove_component _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        comp
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << comp)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMHome_remove_component_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_CCMHome_Proxy_Broker::_TAO_CCMHome_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Proxy_Broker::~_TAO_CCMHome_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Proxy_Broker * (*Components__TAO_CCMHome_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_CCMHome_Remote_Proxy_Broker *
Components::_TAO_CCMHome_Remote_Proxy_Broker::the_TAO_CCMHome_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_CCMHome_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_CCMHome_Remote_Proxy_Broker::_TAO_CCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Remote_Proxy_Broker::~_TAO_CCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMHome_Proxy_Impl&
Components::_TAO_CCMHome_Remote_Proxy_Broker::select_proxy (
  ::Components::CCMHome *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::CCMHome::CCMHome (int collocated)
{
  this->Components_CCMHome_setup_collocation (collocated);
}

Components::CCMHome::~CCMHome (void)
{}

void
Components::CCMHome::Components_CCMHome_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CCMHome_Proxy_Broker_ =
      ::Components__TAO_CCMHome_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CCMHome_Proxy_Broker_ =
      ::Components::_TAO_CCMHome_Remote_Proxy_Broker::the_TAO_CCMHome_Remote_Proxy_Broker ();
}

void Components::CCMHome::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMHome *tmp = ACE_static_cast (CCMHome*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::CCMHome_ptr Components::CCMHome::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CCMHome::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/CCMHome:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CCMHome::_nil ());
      if (is_a == 0)
        return CCMHome::_nil ();
    }
  return CCMHome::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::CCMHome_ptr 
Components::CCMHome::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CCMHome::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CCMHome_ptr default_proxy = CCMHome::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_CCMHome_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMHome (
                  stub,
                  1,
                  obj->_servant ()
                ),
              CCMHome::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMHome (
                  stub,
                  0,
                  obj->_servant ()
                ),
              CCMHome::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          CCMHome_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &CCMHome::_tao_class_id
                  )
              )
        );
}

Components::CCMHome_ptr
Components::CCMHome::_duplicate (CCMHome_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::CCMHome::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/CCMHome:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::CCMHome::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMHome)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::CCMHome::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/CCMHome:1.0";
}

::CORBA::IRObject_ptr Components::CCMHome::get_component_def (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMHome_Proxy_Impl &proxy = 
    this->the_TAO_CCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_component_def (
      this
    );
}

::CORBA::IRObject_ptr Components::CCMHome::get_home_def (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMHome_Proxy_Impl &proxy = 
    this->the_TAO_CCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_home_def (
      this
    );
}

void Components::CCMHome::remove_component (
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMHome_Proxy_Impl &proxy = 
    this->the_TAO_CCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove_component (
      this,
      comp
    );
}

static const CORBA::Long _oc_Components_CCMHome[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d486f), 
  ACE_NTOHL (0x6d653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/CCMHome:1.0
  8,
  ACE_NTOHL (0x43434d48), 
  ACE_NTOHL (0x6f6d6500),  // name = CCMHome
};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMHome (
    CORBA::tk_objref,
    sizeof (_oc_Components_CCMHome),
    (char *) &_oc_Components_CCMHome,
    0,
    sizeof (Components::CCMHome)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCMHome, &_tc_TAO_tc_Components_CCMHome)
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMHOMES_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMHOMES_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_allocate_buffer (CORBA::ULong length)
{
  Components::CCMHome **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_Components_CCMHomes::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::CCMHome **old = ACE_reinterpret_cast (Components::CCMHome**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = Components::CCMHome::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::CCMHome **tmp = ACE_reinterpret_cast (Components::CCMHome**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMHome::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_Components_CCMHomes::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::~_TAO_Unbounded_Object_Sequence_Components_CCMHomes (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::CCMHome **tmp = ACE_reinterpret_cast (Components::CCMHome**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMHome::_nil ();
    }
}

void 
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  Components::CCMHome **tmp = ACE_static_cast (Components::CCMHome**, target);
  *tmp = Components::CCMHome::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
Components::_TAO_Unbounded_Object_Sequence_Components_CCMHomes::_upcast (void *src) const
{
  Components::CCMHome **tmp = ACE_static_cast (Components::CCMHome**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CCMHOMES_CS_)
#define _COMPONENTS_CCMHOMES_CS_

// *************************************************************
// Components::CCMHomes
// *************************************************************

Components::CCMHomes::CCMHomes (void)
{}
Components::CCMHomes::CCMHomes (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMHomes
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMHome,Components::CCMHome_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::CCMHomes::CCMHomes (CORBA::ULong max, CORBA::ULong length, Components::CCMHome_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMHomes
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMHome,Components::CCMHome_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::CCMHomes::CCMHomes (const CCMHomes &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMHomes
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMHome,Components::CCMHome_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::CCMHomes::~CCMHomes (void) // dtor
{}
void Components::CCMHomes::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMHomes *tmp = ACE_static_cast (CCMHomes*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_CCMHomes[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d486f), 
  ACE_NTOHL (0x6d65733a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/CCMHomes:1.0
  9,
  ACE_NTOHL (0x43434d48), 
  ACE_NTOHL (0x6f6d6573), 
  ACE_NTOHL (0x0),  // name = CCMHomes
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x434d486f), 
      ACE_NTOHL (0x6d653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/CCMHome:1.0
      8,
      ACE_NTOHL (0x43434d48), 
      ACE_NTOHL (0x6f6d6500),  // name = CCMHome

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMHomes (
    CORBA::tk_alias,
    sizeof (_oc_Components_CCMHomes),
    (char *) &_oc_Components_CCMHomes,
    0,
    sizeof (Components::CCMHomes)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCMHomes, &_tc_TAO_tc_Components_CCMHomes)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::KeylessCCMHome::_tao_class_id = 0;

Components::KeylessCCMHome_ptr
tao_Components_KeylessCCMHome_duplicate (
    Components::KeylessCCMHome_ptr p
  )
{
  return Components::KeylessCCMHome::_duplicate (p);
}

void
tao_Components_KeylessCCMHome_release (
    Components::KeylessCCMHome_ptr p
  )
{
  CORBA::release (p);
}

Components::KeylessCCMHome_ptr
tao_Components_KeylessCCMHome_nil (
    void
  )
{
  return Components::KeylessCCMHome::_nil ();
}

Components::KeylessCCMHome_ptr
tao_Components_KeylessCCMHome_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::KeylessCCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_KeylessCCMHome_upcast (
    void *src
  )
{
  Components::KeylessCCMHome **tmp =
    ACE_static_cast (Components::KeylessCCMHome **, src);
  return *tmp;
}

// *************************************************************
// Components::KeylessCCMHome_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::KeylessCCMHome_var::KeylessCCMHome_var (void) // default constructor
  : ptr_ (KeylessCCMHome::_nil ())
{}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::ptr (void) const
{
  return this->ptr_;
}

Components::KeylessCCMHome_var::KeylessCCMHome_var (const ::Components::KeylessCCMHome_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (KeylessCCMHome::_duplicate (p.ptr ()))
{}

Components::KeylessCCMHome_var::~KeylessCCMHome_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::KeylessCCMHome_var &
Components::KeylessCCMHome_var::operator= (KeylessCCMHome_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::KeylessCCMHome_var &
Components::KeylessCCMHome_var::operator= (const ::Components::KeylessCCMHome_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::KeylessCCMHome::_duplicate (p.ptr ());
  }
  return *this;
}

Components::KeylessCCMHome_var::operator const ::Components::KeylessCCMHome_ptr &() const // cast
{
  return this->ptr_;
}

Components::KeylessCCMHome_var::operator ::Components::KeylessCCMHome_ptr &() // cast 
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::in (void) const
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr &
Components::KeylessCCMHome_var::inout (void)
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr &
Components::KeylessCCMHome_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::KeylessCCMHome_ptr val = this->ptr_;
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
  return val;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::tao_duplicate (KeylessCCMHome_ptr p)
{
  return ::Components::KeylessCCMHome::_duplicate (p);
}

void
Components::KeylessCCMHome_var::tao_release (KeylessCCMHome_ptr p)
{
  CORBA::release (p);
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::tao_nil (void)
{
  return ::Components::KeylessCCMHome::_nil ();
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::KeylessCCMHome::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::KeylessCCMHome_var::tao_upcast (void *src)
{
  KeylessCCMHome **tmp =
    ACE_static_cast (KeylessCCMHome **, src);
  return *tmp;
}

// *************************************************************
// Components::KeylessCCMHome_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::KeylessCCMHome_out::KeylessCCMHome_out (KeylessCCMHome_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
}

Components::KeylessCCMHome_out::KeylessCCMHome_out (KeylessCCMHome_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::KeylessCCMHome::_nil ();
}

Components::KeylessCCMHome_out::KeylessCCMHome_out (const ::Components::KeylessCCMHome_out &p) // copy constructor
  : ptr_ (ACE_const_cast (KeylessCCMHome_out &, p).ptr_)
{}

::Components::KeylessCCMHome_out &
Components::KeylessCCMHome_out::operator= (const ::Components::KeylessCCMHome_out &p)
{
  this->ptr_ = ACE_const_cast (KeylessCCMHome_out&, p).ptr_;
  return *this;
}

Components::KeylessCCMHome_out &
Components::KeylessCCMHome_out::operator= (const ::Components::KeylessCCMHome_var &p)
{
  this->ptr_ = ::Components::KeylessCCMHome::_duplicate (p.ptr ());
  return *this;
}

Components::KeylessCCMHome_out &
Components::KeylessCCMHome_out::operator= (KeylessCCMHome_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::KeylessCCMHome_out::operator ::Components::KeylessCCMHome_ptr &() // cast
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr &
Components::KeylessCCMHome_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::KeylessCCMHome_ptr
Components::KeylessCCMHome_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component (const TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component &);
  void operator= (const TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component &);

  Components::CCMObject_ptr _result;
};

TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_KeylessCCMHome_create_component_exceptiondata[] = 
  {
    Components::_tc_CreateFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_KeylessCCMHome_create_component_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component::result (::Components::CCMObject_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_KeylessCCMHome_Proxy_Impl::_TAO_KeylessCCMHome_Proxy_Impl (void)
{}

Components::_TAO_KeylessCCMHome_Remote_Proxy_Impl::_TAO_KeylessCCMHome_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::CCMObject_ptr Components::_TAO_KeylessCCMHome_Remote_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_KeylessCCMHome_create_component_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/CreateFailure:1.0",
      Components::CreateFailure::_alloc
    }
  };

  Components::CCMObject_var _tao_retval (Components::CCMObject::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component",
      16,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_KeylessCCMHome_create_component _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (_tao_Components_KeylessCCMHome_create_component_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_KeylessCCMHome_Proxy_Broker::_TAO_KeylessCCMHome_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Proxy_Broker::~_TAO_KeylessCCMHome_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Proxy_Broker * (*Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker *
Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::the_TAO_KeylessCCMHome_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::_TAO_KeylessCCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::~_TAO_KeylessCCMHome_Remote_Proxy_Broker (void)
{
}

Components::_TAO_KeylessCCMHome_Proxy_Impl&
Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::select_proxy (
  ::Components::KeylessCCMHome *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::KeylessCCMHome::KeylessCCMHome (int collocated)
{
  this->Components_KeylessCCMHome_setup_collocation (collocated);
}

Components::KeylessCCMHome::~KeylessCCMHome (void)
{}

void
Components::KeylessCCMHome::Components_KeylessCCMHome_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_KeylessCCMHome_Proxy_Broker_ =
      ::Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_KeylessCCMHome_Proxy_Broker_ =
      ::Components::_TAO_KeylessCCMHome_Remote_Proxy_Broker::the_TAO_KeylessCCMHome_Remote_Proxy_Broker ();
}

void Components::KeylessCCMHome::_tao_any_destructor (void *_tao_void_pointer)
{
  KeylessCCMHome *tmp = ACE_static_cast (KeylessCCMHome*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::KeylessCCMHome_ptr Components::KeylessCCMHome::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return KeylessCCMHome::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/KeylessCCMHome:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (KeylessCCMHome::_nil ());
      if (is_a == 0)
        return KeylessCCMHome::_nil ();
    }
  return KeylessCCMHome::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::KeylessCCMHome_ptr 
Components::KeylessCCMHome::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return KeylessCCMHome::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      KeylessCCMHome_ptr default_proxy = KeylessCCMHome::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_KeylessCCMHome_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::KeylessCCMHome (
                  stub,
                  1,
                  obj->_servant ()
                ),
              KeylessCCMHome::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::KeylessCCMHome (
                  stub,
                  0,
                  obj->_servant ()
                ),
              KeylessCCMHome::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          KeylessCCMHome_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &KeylessCCMHome::_tao_class_id
                  )
              )
        );
}

Components::KeylessCCMHome_ptr
Components::KeylessCCMHome::_duplicate (KeylessCCMHome_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::KeylessCCMHome::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/KeylessCCMHome:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::KeylessCCMHome::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, KeylessCCMHome)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::KeylessCCMHome::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/KeylessCCMHome:1.0";
}

::Components::CCMObject_ptr Components::KeylessCCMHome::create_component (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_KeylessCCMHome_Proxy_Impl &proxy = 
    this->the_TAO_KeylessCCMHome_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_component (
      this
    );
}

static const CORBA::Long _oc_Components_KeylessCCMHome[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f4b), 
  ACE_NTOHL (0x65796c65), 
  ACE_NTOHL (0x73734343), 
  ACE_NTOHL (0x4d486f6d), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/KeylessCCMHome:1.0
  15,
  ACE_NTOHL (0x4b65796c), 
  ACE_NTOHL (0x65737343), 
  ACE_NTOHL (0x434d486f), 
  ACE_NTOHL (0x6d650000),  // name = KeylessCCMHome
};

static CORBA::TypeCode _tc_TAO_tc_Components_KeylessCCMHome (
    CORBA::tk_objref,
    sizeof (_oc_Components_KeylessCCMHome),
    (char *) &_oc_Components_KeylessCCMHome,
    0,
    sizeof (Components::KeylessCCMHome)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_KeylessCCMHome, &_tc_TAO_tc_Components_KeylessCCMHome)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::HomeFinder::_tao_class_id = 0;

Components::HomeFinder_ptr
tao_Components_HomeFinder_duplicate (
    Components::HomeFinder_ptr p
  )
{
  return Components::HomeFinder::_duplicate (p);
}

void
tao_Components_HomeFinder_release (
    Components::HomeFinder_ptr p
  )
{
  CORBA::release (p);
}

Components::HomeFinder_ptr
tao_Components_HomeFinder_nil (
    void
  )
{
  return Components::HomeFinder::_nil ();
}

Components::HomeFinder_ptr
tao_Components_HomeFinder_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::HomeFinder::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_HomeFinder_upcast (
    void *src
  )
{
  Components::HomeFinder **tmp =
    ACE_static_cast (Components::HomeFinder **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeFinder_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::HomeFinder_var::HomeFinder_var (void) // default constructor
  : ptr_ (HomeFinder::_nil ())
{}

::Components::HomeFinder_ptr
Components::HomeFinder_var::ptr (void) const
{
  return this->ptr_;
}

Components::HomeFinder_var::HomeFinder_var (const ::Components::HomeFinder_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (HomeFinder::_duplicate (p.ptr ()))
{}

Components::HomeFinder_var::~HomeFinder_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::HomeFinder_var &
Components::HomeFinder_var::operator= (HomeFinder_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::HomeFinder_var &
Components::HomeFinder_var::operator= (const ::Components::HomeFinder_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::HomeFinder::_duplicate (p.ptr ());
  }
  return *this;
}

Components::HomeFinder_var::operator const ::Components::HomeFinder_ptr &() const // cast
{
  return this->ptr_;
}

Components::HomeFinder_var::operator ::Components::HomeFinder_ptr &() // cast 
{
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::in (void) const
{
  return this->ptr_;
}

::Components::HomeFinder_ptr &
Components::HomeFinder_var::inout (void)
{
  return this->ptr_;
}

::Components::HomeFinder_ptr &
Components::HomeFinder_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeFinder::_nil ();
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::HomeFinder_ptr val = this->ptr_;
  this->ptr_ = ::Components::HomeFinder::_nil ();
  return val;
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::tao_duplicate (HomeFinder_ptr p)
{
  return ::Components::HomeFinder::_duplicate (p);
}

void
Components::HomeFinder_var::tao_release (HomeFinder_ptr p)
{
  CORBA::release (p);
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::tao_nil (void)
{
  return ::Components::HomeFinder::_nil ();
}

::Components::HomeFinder_ptr
Components::HomeFinder_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::HomeFinder::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::HomeFinder_var::tao_upcast (void *src)
{
  HomeFinder **tmp =
    ACE_static_cast (HomeFinder **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeFinder_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::HomeFinder_out::HomeFinder_out (HomeFinder_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::HomeFinder::_nil ();
}

Components::HomeFinder_out::HomeFinder_out (HomeFinder_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeFinder::_nil ();
}

Components::HomeFinder_out::HomeFinder_out (const ::Components::HomeFinder_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeFinder_out &, p).ptr_)
{}

::Components::HomeFinder_out &
Components::HomeFinder_out::operator= (const ::Components::HomeFinder_out &p)
{
  this->ptr_ = ACE_const_cast (HomeFinder_out&, p).ptr_;
  return *this;
}

Components::HomeFinder_out &
Components::HomeFinder_out::operator= (const ::Components::HomeFinder_var &p)
{
  this->ptr_ = ::Components::HomeFinder::_duplicate (p.ptr ());
  return *this;
}

Components::HomeFinder_out &
Components::HomeFinder_out::operator= (HomeFinder_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::HomeFinder_out::operator ::Components::HomeFinder_ptr &() // cast
{
  return this->ptr_;
}

::Components::HomeFinder_ptr &
Components::HomeFinder_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::HomeFinder_ptr
Components::HomeFinder_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * comp_repid);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type &);

  const char * comp_repid_;
  Components::CCMHome_ptr _result;
};

TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * comp_repid    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    comp_repid_ (comp_repid)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= comp_repid_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type::result (::Components::CCMHome_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * home_repid);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type &);

  const char * home_repid_;
  Components::CCMHome_ptr _result;
};

TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * home_repid    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    home_repid_ (home_repid)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= home_repid_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type::result (::Components::CCMHome_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * home_name);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name &);

  const char * home_name_;
  Components::CCMHome_ptr _result;
};

TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * home_name    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    home_name_ (home_name)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= home_name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_HomeFinder_find_home_by_name_exceptiondata[] = 
  {
    Components::_tc_HomeNotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_HomeFinder_find_home_by_name_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name::result (::Components::CCMHome_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_HomeFinder_Proxy_Impl::_TAO_HomeFinder_Proxy_Impl (void)
{}

Components::_TAO_HomeFinder_Remote_Proxy_Impl::_TAO_HomeFinder_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::CCMHome_ptr Components::_TAO_HomeFinder_Remote_Proxy_Impl::find_home_by_component_type (
    CORBA_Object *_collocated_tao_target_,
    const char * comp_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_HomeFinder_find_home_by_component_type_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/HomeNotFound:1.0",
      Components::HomeNotFound::_alloc
    }
  };

  Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "find_home_by_component_type",
      27,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_component_type _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        comp_repid
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << comp_repid)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_HomeFinder_find_home_by_component_type_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::CCMHome_ptr Components::_TAO_HomeFinder_Remote_Proxy_Impl::find_home_by_home_type (
    CORBA_Object *_collocated_tao_target_,
    const char * home_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_HomeFinder_find_home_by_home_type_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/HomeNotFound:1.0",
      Components::HomeNotFound::_alloc
    }
  };

  Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "find_home_by_home_type",
      22,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_home_type _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        home_repid
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << home_repid)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_HomeFinder_find_home_by_home_type_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::CCMHome_ptr Components::_TAO_HomeFinder_Remote_Proxy_Impl::find_home_by_name (
    CORBA_Object *_collocated_tao_target_,
    const char * home_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_HomeFinder_find_home_by_name_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/HomeNotFound:1.0",
      Components::HomeNotFound::_alloc
    }
  };

  Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "find_home_by_name",
      17,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeFinder_find_home_by_name _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        home_name
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << home_name)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_HomeFinder_find_home_by_name_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_HomeFinder_Proxy_Broker::_TAO_HomeFinder_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Proxy_Broker::~_TAO_HomeFinder_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Proxy_Broker * (*Components__TAO_HomeFinder_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_HomeFinder_Remote_Proxy_Broker *
Components::_TAO_HomeFinder_Remote_Proxy_Broker::the_TAO_HomeFinder_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_HomeFinder_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_HomeFinder_Remote_Proxy_Broker::_TAO_HomeFinder_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Remote_Proxy_Broker::~_TAO_HomeFinder_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeFinder_Proxy_Impl&
Components::_TAO_HomeFinder_Remote_Proxy_Broker::select_proxy (
  ::Components::HomeFinder *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::HomeFinder::HomeFinder (int collocated)
{
  this->Components_HomeFinder_setup_collocation (collocated);
}

Components::HomeFinder::~HomeFinder (void)
{}

void
Components::HomeFinder::Components_HomeFinder_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeFinder_Proxy_Broker_ =
      ::Components__TAO_HomeFinder_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeFinder_Proxy_Broker_ =
      ::Components::_TAO_HomeFinder_Remote_Proxy_Broker::the_TAO_HomeFinder_Remote_Proxy_Broker ();
}

void Components::HomeFinder::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeFinder *tmp = ACE_static_cast (HomeFinder*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::HomeFinder_ptr Components::HomeFinder::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return HomeFinder::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/HomeFinder:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (HomeFinder::_nil ());
      if (is_a == 0)
        return HomeFinder::_nil ();
    }
  return HomeFinder::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::HomeFinder_ptr 
Components::HomeFinder::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return HomeFinder::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      HomeFinder_ptr default_proxy = HomeFinder::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_HomeFinder_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeFinder (
                  stub,
                  1,
                  obj->_servant ()
                ),
              HomeFinder::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeFinder (
                  stub,
                  0,
                  obj->_servant ()
                ),
              HomeFinder::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          HomeFinder_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &HomeFinder::_tao_class_id
                  )
              )
        );
}

Components::HomeFinder_ptr
Components::HomeFinder::_duplicate (HomeFinder_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::HomeFinder::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/HomeFinder:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::HomeFinder::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, HomeFinder)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::HomeFinder::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/HomeFinder:1.0";
}

::Components::CCMHome_ptr Components::HomeFinder::find_home_by_component_type (
    const char * comp_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeFinder_Proxy_Impl &proxy = 
    this->the_TAO_HomeFinder_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.find_home_by_component_type (
      this,
      comp_repid
    );
}

::Components::CCMHome_ptr Components::HomeFinder::find_home_by_home_type (
    const char * home_repid
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeFinder_Proxy_Impl &proxy = 
    this->the_TAO_HomeFinder_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.find_home_by_home_type (
      this,
      home_repid
    );
}

::Components::CCMHome_ptr Components::HomeFinder::find_home_by_name (
    const char * home_name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::HomeNotFound
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeFinder_Proxy_Impl &proxy = 
    this->the_TAO_HomeFinder_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.find_home_by_name (
      this,
      home_name
    );
}

static const CORBA::Long _oc_Components_HomeFinder[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d6546), 
  ACE_NTOHL (0x696e6465), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/HomeFinder:1.0
  11,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x46696e64), 
  ACE_NTOHL (0x65720000),  // name = HomeFinder
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeFinder (
    CORBA::tk_objref,
    sizeof (_oc_Components_HomeFinder),
    (char *) &_oc_Components_HomeFinder,
    0,
    sizeof (Components::HomeFinder)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_HomeFinder, &_tc_TAO_tc_Components_HomeFinder)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Configurator::_tao_class_id = 0;

Components::Configurator_ptr
tao_Components_Configurator_duplicate (
    Components::Configurator_ptr p
  )
{
  return Components::Configurator::_duplicate (p);
}

void
tao_Components_Configurator_release (
    Components::Configurator_ptr p
  )
{
  CORBA::release (p);
}

Components::Configurator_ptr
tao_Components_Configurator_nil (
    void
  )
{
  return Components::Configurator::_nil ();
}

Components::Configurator_ptr
tao_Components_Configurator_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Configurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Configurator_upcast (
    void *src
  )
{
  Components::Configurator **tmp =
    ACE_static_cast (Components::Configurator **, src);
  return *tmp;
}

// *************************************************************
// Components::Configurator_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Configurator_var::Configurator_var (void) // default constructor
  : ptr_ (Configurator::_nil ())
{}

::Components::Configurator_ptr
Components::Configurator_var::ptr (void) const
{
  return this->ptr_;
}

Components::Configurator_var::Configurator_var (const ::Components::Configurator_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Configurator::_duplicate (p.ptr ()))
{}

Components::Configurator_var::~Configurator_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Configurator_var &
Components::Configurator_var::operator= (Configurator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Configurator_var &
Components::Configurator_var::operator= (const ::Components::Configurator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Configurator::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Configurator_var::operator const ::Components::Configurator_ptr &() const // cast
{
  return this->ptr_;
}

Components::Configurator_var::operator ::Components::Configurator_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_var::in (void) const
{
  return this->ptr_;
}

::Components::Configurator_ptr &
Components::Configurator_var::inout (void)
{
  return this->ptr_;
}

::Components::Configurator_ptr &
Components::Configurator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Configurator::_nil ();
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Configurator_ptr val = this->ptr_;
  this->ptr_ = ::Components::Configurator::_nil ();
  return val;
}

::Components::Configurator_ptr
Components::Configurator_var::tao_duplicate (Configurator_ptr p)
{
  return ::Components::Configurator::_duplicate (p);
}

void
Components::Configurator_var::tao_release (Configurator_ptr p)
{
  CORBA::release (p);
}

::Components::Configurator_ptr
Components::Configurator_var::tao_nil (void)
{
  return ::Components::Configurator::_nil ();
}

::Components::Configurator_ptr
Components::Configurator_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Configurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Configurator_var::tao_upcast (void *src)
{
  Configurator **tmp =
    ACE_static_cast (Configurator **, src);
  return *tmp;
}

// *************************************************************
// Components::Configurator_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Configurator_out::Configurator_out (Configurator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Configurator::_nil ();
}

Components::Configurator_out::Configurator_out (Configurator_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Configurator::_nil ();
}

Components::Configurator_out::Configurator_out (const ::Components::Configurator_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Configurator_out &, p).ptr_)
{}

::Components::Configurator_out &
Components::Configurator_out::operator= (const ::Components::Configurator_out &p)
{
  this->ptr_ = ACE_const_cast (Configurator_out&, p).ptr_;
  return *this;
}

Components::Configurator_out &
Components::Configurator_out::operator= (const ::Components::Configurator_var &p)
{
  this->ptr_ = ::Components::Configurator::_duplicate (p.ptr ());
  return *this;
}

Components::Configurator_out &
Components::Configurator_out::operator= (Configurator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Configurator_out::operator ::Components::Configurator_ptr &() // cast
{
  return this->ptr_;
}

::Components::Configurator_ptr &
Components::Configurator_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Configurator_ptr
Components::Configurator_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Configurator_configure : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Configurator_configure (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::CCMObject_ptr comp);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Configurator_configure (const TAO_ClientRequestInfo_Components_Configurator_configure &);
  void operator= (const TAO_ClientRequestInfo_Components_Configurator_configure &);

  Components::CCMObject_ptr comp_;
  
};

TAO_ClientRequestInfo_Components_Configurator_configure::TAO_ClientRequestInfo_Components_Configurator_configure (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::CCMObject_ptr comp    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    comp_ (comp)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Configurator_configure::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->comp_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Configurator_configure::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Configurator_configure_exceptiondata[] = 
  {
    Components::_tc_WrongComponentType
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Configurator_configure_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Configurator_configure::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_Configurator_Proxy_Impl::_TAO_Configurator_Proxy_Impl (void)
{}

Components::_TAO_Configurator_Remote_Proxy_Impl::_TAO_Configurator_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

void Components::_TAO_Configurator_Remote_Proxy_Impl::configure (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::WrongComponentType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Configurator_configure_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/WrongComponentType:1.0",
      Components::WrongComponentType::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "configure",
      9,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Configurator_configure _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        comp
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << comp)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Configurator_configure_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_Configurator_Proxy_Broker::_TAO_Configurator_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Proxy_Broker::~_TAO_Configurator_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Proxy_Broker * (*Components__TAO_Configurator_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_Configurator_Remote_Proxy_Broker *
Components::_TAO_Configurator_Remote_Proxy_Broker::the_TAO_Configurator_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_Configurator_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_Configurator_Remote_Proxy_Broker::_TAO_Configurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Remote_Proxy_Broker::~_TAO_Configurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_Configurator_Proxy_Impl&
Components::_TAO_Configurator_Remote_Proxy_Broker::select_proxy (
  ::Components::Configurator *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Configurator::Configurator (int collocated)
{
  this->Components_Configurator_setup_collocation (collocated);
}

Components::Configurator::~Configurator (void)
{}

void
Components::Configurator::Components_Configurator_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Configurator_Proxy_Broker_ =
      ::Components__TAO_Configurator_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Configurator_Proxy_Broker_ =
      ::Components::_TAO_Configurator_Remote_Proxy_Broker::the_TAO_Configurator_Remote_Proxy_Broker ();
}

void Components::Configurator::_tao_any_destructor (void *_tao_void_pointer)
{
  Configurator *tmp = ACE_static_cast (Configurator*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Configurator_ptr Components::Configurator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return Configurator::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Configurator:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (Configurator::_nil ());
      if (is_a == 0)
        return Configurator::_nil ();
    }
  return Configurator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Configurator_ptr 
Components::Configurator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Configurator::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Configurator_ptr default_proxy = Configurator::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_Configurator_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Configurator (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Configurator::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Configurator (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Configurator::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Configurator_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Configurator::_tao_class_id
                  )
              )
        );
}

Components::Configurator_ptr
Components::Configurator::_duplicate (Configurator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Configurator::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Configurator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Configurator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Configurator)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Configurator::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Configurator:1.0";
}

void Components::Configurator::configure (
    Components::CCMObject_ptr comp
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::WrongComponentType
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Configurator_Proxy_Impl &proxy = 
    this->the_TAO_Configurator_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.configure (
      this,
      comp
    );
}

static const CORBA::Long _oc_Components_Configurator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x746f723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Configurator:1.0
  13,
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69677572), 
  ACE_NTOHL (0x61746f72), 
  ACE_NTOHL (0x0),  // name = Configurator
};

static CORBA::TypeCode _tc_TAO_tc_Components_Configurator (
    CORBA::tk_objref,
    sizeof (_oc_Components_Configurator),
    (char *) &_oc_Components_Configurator,
    0,
    sizeof (Components::Configurator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Configurator, &_tc_TAO_tc_Components_Configurator)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_ConfigValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x6756616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ConfigValue:1.0
  12,
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69675661), 
  ACE_NTOHL (0x6c756500),  // name = ConfigValue
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  2, // member count
  5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x65617475), 
    ACE_NTOHL (0x72654e61), 
    ACE_NTOHL (0x6d653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
    12,
    ACE_NTOHL (0x46656174), 
    ACE_NTOHL (0x7572654e), 
    ACE_NTOHL (0x616d6500),  // name = FeatureName
    CORBA::tk_string, 
    0U, // string length

  1, // data memeber visibility marker

  6,
  ACE_NTOHL (0x76616c75), 
  ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConfigValue (
    CORBA::tk_value,
    sizeof (_oc_Components_ConfigValue),
    (char *) &_oc_Components_ConfigValue,
    0,
    sizeof (Components::ConfigValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ConfigValue, &_tc_TAO_tc_Components_ConfigValue)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::ConfigValue_var
// *************************************************************

Components::ConfigValue_var::ConfigValue_var (void) // default constructor
  : ptr_ (0)
{}

Components::ConfigValue_var::ConfigValue_var (ConfigValue* p)
  : ptr_ (p)
{}

Components::ConfigValue_var::ConfigValue_var (const ConfigValue* p)
  : ptr_ (ACE_const_cast(ConfigValue*, p))
{}

Components::ConfigValue* 
Components::ConfigValue_var::ptr (void) const
{
  return this->ptr_;
}

Components::ConfigValue_var::ConfigValue_var (const ConfigValue_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ConfigValue_var::~ConfigValue_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ConfigValue_var &
Components::ConfigValue_var::operator= (ConfigValue* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ConfigValue_var &
Components::ConfigValue_var::operator= (const ConfigValue_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ConfigValue* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::ConfigValue_var::operator const Components::ConfigValue* () const // cast
{
  return this->ptr_;
}

Components::ConfigValue_var::operator Components::ConfigValue* () // cast 
{
  return this->ptr_;
}

Components::ConfigValue* 
Components::ConfigValue_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ConfigValue*
Components::ConfigValue_var::in (void) const
{
  return this->ptr_;
}

Components::ConfigValue* &
Components::ConfigValue_var::inout (void)
{
  return this->ptr_;
}

Components::ConfigValue* &
Components::ConfigValue_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ConfigValue* 
Components::ConfigValue_var::_retn (void)
{
  // yield ownership of managed obj reference
  ConfigValue* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::ConfigValue_out
// *************************************************************

Components::ConfigValue_out::ConfigValue_out (ConfigValue* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ConfigValue_out::ConfigValue_out (ConfigValue_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ConfigValue_out::ConfigValue_out (const ConfigValue_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ConfigValue_out&,p).ptr_)
{}

Components::ConfigValue_out &
Components::ConfigValue_out::operator= (const ConfigValue_out &p)
{
  this->ptr_ = ACE_const_cast (ConfigValue_out&,p).ptr_;
  return *this;
}

Components::ConfigValue_out &
Components::ConfigValue_out::operator= (const ConfigValue_var &p)
{
  ConfigValue* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ConfigValue_out &
Components::ConfigValue_out::operator= (ConfigValue* p)
{
  this->ptr_ = p;
  return *this;
}

Components::ConfigValue_out::operator Components::ConfigValue* &() // cast
{
  return this->ptr_;
}

Components::ConfigValue* &
Components::ConfigValue_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ConfigValue* 
Components::ConfigValue_out::operator-> (void)
{
  return this->ptr_;
}

Components::ConfigValue* Components::ConfigValue::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ConfigValue* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::ConfigValue::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::ConfigValue::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::ConfigValue::_tao_any_destructor (void *_tao_void_pointer)
{
  ConfigValue *tmp = ACE_static_cast (ConfigValue*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::ConfigValue::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ConfigValue (strm);
}

CORBA::Boolean Components::ConfigValue::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ConfigValue (strm);
}

CORBA::Boolean Components::ConfigValue::_tao_unmarshal (TAO_InputCDR &strm, ConfigValue *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          ConfigValue::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ConfigValue::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ConfigValue::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ConfigValue::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::ConfigValue_init::ConfigValue_init ()
{
}

Components::ConfigValue_init::~ConfigValue_init ()
{
}

const char* 
Components::ConfigValue_init::tao_repository_id (void)
{
  return Components::ConfigValue::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::ConfigValue_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::ConfigValue, 
                 0);
  return ret_val;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONFIGVALUES_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_CONFIGVALUES_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_allocate_buffer (CORBA::ULong length)
{
  Components::ConfigValue **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::ConfigValue **old = ACE_reinterpret_cast (Components::ConfigValue**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::ConfigValue **tmp = ACE_reinterpret_cast (Components::ConfigValue**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::~_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::ConfigValue **tmp = ACE_reinterpret_cast (Components::ConfigValue**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CONFIGVALUES_CS_)
#define _COMPONENTS_CONFIGVALUES_CS_

// *************************************************************
// Components::ConfigValues
// *************************************************************

Components::ConfigValues::ConfigValues (void)
{}
Components::ConfigValues::ConfigValues (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConfigValue,Components::ConfigValue_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::ConfigValues::ConfigValues (CORBA::ULong max, CORBA::ULong length, Components::ConfigValue_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConfigValue,Components::ConfigValue_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::ConfigValues::ConfigValues (const ConfigValues &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_ConfigValues
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::ConfigValue,Components::ConfigValue_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::ConfigValues::~ConfigValues (void) // dtor
{}
void Components::ConfigValues::_tao_any_destructor (void *_tao_void_pointer)
{
  ConfigValues *tmp = ACE_static_cast (ConfigValues*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_ConfigValues[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x6756616c), 
  ACE_NTOHL (0x7565733a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/ConfigValues:1.0
  13,
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69675661), 
  ACE_NTOHL (0x6c756573), 
  ACE_NTOHL (0x0),  // name = ConfigValues
  CORBA::tk_sequence, // typecode kind
  208, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    192, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x6f6e6669), 
      ACE_NTOHL (0x6756616c), 
      ACE_NTOHL (0x75653a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ConfigValue:1.0
      12,
      ACE_NTOHL (0x436f6e66), 
      ACE_NTOHL (0x69675661), 
      ACE_NTOHL (0x6c756500),  // name = ConfigValue
      0, // value modifier
      CORBA::tk_null, // no stateful base valuetype

      2, // member count
      5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        39,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f46), 
        ACE_NTOHL (0x65617475), 
        ACE_NTOHL (0x72654e61), 
        ACE_NTOHL (0x6d653a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
        12,
        ACE_NTOHL (0x46656174), 
        ACE_NTOHL (0x7572654e), 
        ACE_NTOHL (0x616d6500),  // name = FeatureName
        CORBA::tk_string, 
        0U, // string length

      1, // data memeber visibility marker

      6,
      ACE_NTOHL (0x76616c75), 
      ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,

      1, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_ConfigValues (
    CORBA::tk_alias,
    sizeof (_oc_Components_ConfigValues),
    (char *) &_oc_Components_ConfigValues,
    0,
    sizeof (Components::ConfigValues)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ConfigValues, &_tc_TAO_tc_Components_ConfigValues)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::StandardConfigurator::_tao_class_id = 0;

Components::StandardConfigurator_ptr
tao_Components_StandardConfigurator_duplicate (
    Components::StandardConfigurator_ptr p
  )
{
  return Components::StandardConfigurator::_duplicate (p);
}

void
tao_Components_StandardConfigurator_release (
    Components::StandardConfigurator_ptr p
  )
{
  CORBA::release (p);
}

Components::StandardConfigurator_ptr
tao_Components_StandardConfigurator_nil (
    void
  )
{
  return Components::StandardConfigurator::_nil ();
}

Components::StandardConfigurator_ptr
tao_Components_StandardConfigurator_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::StandardConfigurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_StandardConfigurator_upcast (
    void *src
  )
{
  Components::StandardConfigurator **tmp =
    ACE_static_cast (Components::StandardConfigurator **, src);
  return *tmp;
}

// *************************************************************
// Components::StandardConfigurator_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::StandardConfigurator_var::StandardConfigurator_var (void) // default constructor
  : ptr_ (StandardConfigurator::_nil ())
{}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::ptr (void) const
{
  return this->ptr_;
}

Components::StandardConfigurator_var::StandardConfigurator_var (const ::Components::StandardConfigurator_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (StandardConfigurator::_duplicate (p.ptr ()))
{}

Components::StandardConfigurator_var::~StandardConfigurator_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::StandardConfigurator_var &
Components::StandardConfigurator_var::operator= (StandardConfigurator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::StandardConfigurator_var &
Components::StandardConfigurator_var::operator= (const ::Components::StandardConfigurator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::StandardConfigurator::_duplicate (p.ptr ());
  }
  return *this;
}

Components::StandardConfigurator_var::operator const ::Components::StandardConfigurator_ptr &() const // cast
{
  return this->ptr_;
}

Components::StandardConfigurator_var::operator ::Components::StandardConfigurator_ptr &() // cast 
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::in (void) const
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr &
Components::StandardConfigurator_var::inout (void)
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr &
Components::StandardConfigurator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::StandardConfigurator_ptr val = this->ptr_;
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
  return val;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::tao_duplicate (StandardConfigurator_ptr p)
{
  return ::Components::StandardConfigurator::_duplicate (p);
}

void
Components::StandardConfigurator_var::tao_release (StandardConfigurator_ptr p)
{
  CORBA::release (p);
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::tao_nil (void)
{
  return ::Components::StandardConfigurator::_nil ();
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::StandardConfigurator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::StandardConfigurator_var::tao_upcast (void *src)
{
  StandardConfigurator **tmp =
    ACE_static_cast (StandardConfigurator **, src);
  return *tmp;
}

// *************************************************************
// Components::StandardConfigurator_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::StandardConfigurator_out::StandardConfigurator_out (StandardConfigurator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
}

Components::StandardConfigurator_out::StandardConfigurator_out (StandardConfigurator_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::StandardConfigurator::_nil ();
}

Components::StandardConfigurator_out::StandardConfigurator_out (const ::Components::StandardConfigurator_out &p) // copy constructor
  : ptr_ (ACE_const_cast (StandardConfigurator_out &, p).ptr_)
{}

::Components::StandardConfigurator_out &
Components::StandardConfigurator_out::operator= (const ::Components::StandardConfigurator_out &p)
{
  this->ptr_ = ACE_const_cast (StandardConfigurator_out&, p).ptr_;
  return *this;
}

Components::StandardConfigurator_out &
Components::StandardConfigurator_out::operator= (const ::Components::StandardConfigurator_var &p)
{
  this->ptr_ = ::Components::StandardConfigurator::_duplicate (p.ptr ());
  return *this;
}

Components::StandardConfigurator_out &
Components::StandardConfigurator_out::operator= (StandardConfigurator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::StandardConfigurator_out::operator ::Components::StandardConfigurator_ptr &() // cast
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr &
Components::StandardConfigurator_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::StandardConfigurator_ptr
Components::StandardConfigurator_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::ConfigValues & descr);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration (const TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration &);
  void operator= (const TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration &);

  const Components::ConfigValues & descr_;
  
};

TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::ConfigValues & descr    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    descr_ (descr)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->descr_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_StandardConfigurator_Proxy_Impl::_TAO_StandardConfigurator_Proxy_Impl (void)
{}

Components::_TAO_StandardConfigurator_Remote_Proxy_Impl::_TAO_StandardConfigurator_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

void Components::_TAO_StandardConfigurator_Remote_Proxy_Impl::set_configuration (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & descr
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_configuration",
      17,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_StandardConfigurator_set_configuration _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        descr
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << descr)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_StandardConfigurator_Proxy_Broker::_TAO_StandardConfigurator_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Proxy_Broker::~_TAO_StandardConfigurator_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Proxy_Broker * (*Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_StandardConfigurator_Remote_Proxy_Broker *
Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::the_TAO_StandardConfigurator_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_StandardConfigurator_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::_TAO_StandardConfigurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::~_TAO_StandardConfigurator_Remote_Proxy_Broker (void)
{
}

Components::_TAO_StandardConfigurator_Proxy_Impl&
Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::select_proxy (
  ::Components::StandardConfigurator *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::StandardConfigurator::StandardConfigurator (int collocated)
{
  this->Components_StandardConfigurator_setup_collocation (collocated);
}

Components::StandardConfigurator::~StandardConfigurator (void)
{}

void
Components::StandardConfigurator::Components_StandardConfigurator_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_StandardConfigurator_Proxy_Broker_ =
      ::Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_StandardConfigurator_Proxy_Broker_ =
      ::Components::_TAO_StandardConfigurator_Remote_Proxy_Broker::the_TAO_StandardConfigurator_Remote_Proxy_Broker ();
  
  this->Components_Configurator_setup_collocation (collocated);
}

void Components::StandardConfigurator::_tao_any_destructor (void *_tao_void_pointer)
{
  StandardConfigurator *tmp = ACE_static_cast (StandardConfigurator*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::StandardConfigurator_ptr Components::StandardConfigurator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return StandardConfigurator::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/StandardConfigurator:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (StandardConfigurator::_nil ());
      if (is_a == 0)
        return StandardConfigurator::_nil ();
    }
  return StandardConfigurator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::StandardConfigurator_ptr 
Components::StandardConfigurator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return StandardConfigurator::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      StandardConfigurator_ptr default_proxy = StandardConfigurator::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_StandardConfigurator_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::StandardConfigurator (
                  stub,
                  1,
                  obj->_servant ()
                ),
              StandardConfigurator::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::StandardConfigurator (
                  stub,
                  0,
                  obj->_servant ()
                ),
              StandardConfigurator::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          StandardConfigurator_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &StandardConfigurator::_tao_class_id
                  )
              )
        );
}

Components::StandardConfigurator_ptr
Components::StandardConfigurator::_duplicate (StandardConfigurator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::StandardConfigurator::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/StandardConfigurator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Configurator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::StandardConfigurator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, StandardConfigurator)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Configurator)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::Configurator_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::StandardConfigurator::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/StandardConfigurator:1.0";
}

void Components::StandardConfigurator::set_configuration (
    const Components::ConfigValues & descr
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_StandardConfigurator_Proxy_Impl &proxy = 
    this->the_TAO_StandardConfigurator_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.set_configuration (
      this,
      descr
    );
}

static const CORBA::Long _oc_Components_StandardConfigurator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x74616e64), 
  ACE_NTOHL (0x61726443), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x746f723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/StandardConfigurator:1.0
  21,
  ACE_NTOHL (0x5374616e), 
  ACE_NTOHL (0x64617264), 
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69677572), 
  ACE_NTOHL (0x61746f72), 
  ACE_NTOHL (0x0),  // name = StandardConfigurator
};

static CORBA::TypeCode _tc_TAO_tc_Components_StandardConfigurator (
    CORBA::tk_objref,
    sizeof (_oc_Components_StandardConfigurator),
    (char *) &_oc_Components_StandardConfigurator,
    0,
    sizeof (Components::StandardConfigurator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_StandardConfigurator, &_tc_TAO_tc_Components_StandardConfigurator)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::HomeConfiguration::_tao_class_id = 0;

Components::HomeConfiguration_ptr
tao_Components_HomeConfiguration_duplicate (
    Components::HomeConfiguration_ptr p
  )
{
  return Components::HomeConfiguration::_duplicate (p);
}

void
tao_Components_HomeConfiguration_release (
    Components::HomeConfiguration_ptr p
  )
{
  CORBA::release (p);
}

Components::HomeConfiguration_ptr
tao_Components_HomeConfiguration_nil (
    void
  )
{
  return Components::HomeConfiguration::_nil ();
}

Components::HomeConfiguration_ptr
tao_Components_HomeConfiguration_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::HomeConfiguration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_HomeConfiguration_upcast (
    void *src
  )
{
  Components::HomeConfiguration **tmp =
    ACE_static_cast (Components::HomeConfiguration **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeConfiguration_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::HomeConfiguration_var::HomeConfiguration_var (void) // default constructor
  : ptr_ (HomeConfiguration::_nil ())
{}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::ptr (void) const
{
  return this->ptr_;
}

Components::HomeConfiguration_var::HomeConfiguration_var (const ::Components::HomeConfiguration_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (HomeConfiguration::_duplicate (p.ptr ()))
{}

Components::HomeConfiguration_var::~HomeConfiguration_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::HomeConfiguration_var &
Components::HomeConfiguration_var::operator= (HomeConfiguration_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::HomeConfiguration_var &
Components::HomeConfiguration_var::operator= (const ::Components::HomeConfiguration_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::HomeConfiguration::_duplicate (p.ptr ());
  }
  return *this;
}

Components::HomeConfiguration_var::operator const ::Components::HomeConfiguration_ptr &() const // cast
{
  return this->ptr_;
}

Components::HomeConfiguration_var::operator ::Components::HomeConfiguration_ptr &() // cast 
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::in (void) const
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr &
Components::HomeConfiguration_var::inout (void)
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr &
Components::HomeConfiguration_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::HomeConfiguration_ptr val = this->ptr_;
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
  return val;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::tao_duplicate (HomeConfiguration_ptr p)
{
  return ::Components::HomeConfiguration::_duplicate (p);
}

void
Components::HomeConfiguration_var::tao_release (HomeConfiguration_ptr p)
{
  CORBA::release (p);
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::tao_nil (void)
{
  return ::Components::HomeConfiguration::_nil ();
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::HomeConfiguration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::HomeConfiguration_var::tao_upcast (void *src)
{
  HomeConfiguration **tmp =
    ACE_static_cast (HomeConfiguration **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeConfiguration_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::HomeConfiguration_out::HomeConfiguration_out (HomeConfiguration_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
}

Components::HomeConfiguration_out::HomeConfiguration_out (HomeConfiguration_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeConfiguration::_nil ();
}

Components::HomeConfiguration_out::HomeConfiguration_out (const ::Components::HomeConfiguration_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeConfiguration_out &, p).ptr_)
{}

::Components::HomeConfiguration_out &
Components::HomeConfiguration_out::operator= (const ::Components::HomeConfiguration_out &p)
{
  this->ptr_ = ACE_const_cast (HomeConfiguration_out&, p).ptr_;
  return *this;
}

Components::HomeConfiguration_out &
Components::HomeConfiguration_out::operator= (const ::Components::HomeConfiguration_var &p)
{
  this->ptr_ = ::Components::HomeConfiguration::_duplicate (p.ptr ());
  return *this;
}

Components::HomeConfiguration_out &
Components::HomeConfiguration_out::operator= (HomeConfiguration_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::HomeConfiguration_out::operator ::Components::HomeConfiguration_ptr &() // cast
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr &
Components::HomeConfiguration_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::HomeConfiguration_ptr
Components::HomeConfiguration_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::Configurator_ptr cfg);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator &);

  Components::Configurator_ptr cfg_;
  
};

TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::Configurator_ptr cfg    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    cfg_ (cfg)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->cfg_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::ConfigValues & config);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values &);

  const Components::ConfigValues & config_;
  
};

TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::ConfigValues & config    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    config_ (config)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->config_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & b);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration (const TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration &);

  const CORBA::Boolean & b_;
  
};

TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Boolean & b    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    b_ (b)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->b_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration (const TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration &);
  void operator= (const TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration &);

  
};

TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_HomeConfiguration_Proxy_Impl::_TAO_HomeConfiguration_Proxy_Impl (void)
{}

Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::_TAO_HomeConfiguration_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::set_configurator (
    CORBA_Object *_collocated_tao_target_,
    Components::Configurator_ptr cfg
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_configurator",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_set_configurator _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        cfg
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << cfg)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::set_configuration_values (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_configuration_values",
      24,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_set_configuration_values _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        config
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << config)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::complete_component_configuration (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean b
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "complete_component_configuration",
      32,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_complete_component_configuration _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        b
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << CORBA::Any::from_boolean (b))
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::_TAO_HomeConfiguration_Remote_Proxy_Impl::disable_home_configuration (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "disable_home_configuration",
      26,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_HomeConfiguration_disable_home_configuration _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_HomeConfiguration_Proxy_Broker::_TAO_HomeConfiguration_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Proxy_Broker::~_TAO_HomeConfiguration_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Proxy_Broker * (*Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_HomeConfiguration_Remote_Proxy_Broker *
Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::the_TAO_HomeConfiguration_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_HomeConfiguration_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::_TAO_HomeConfiguration_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::~_TAO_HomeConfiguration_Remote_Proxy_Broker (void)
{
}

Components::_TAO_HomeConfiguration_Proxy_Impl&
Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::select_proxy (
  ::Components::HomeConfiguration *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::HomeConfiguration::HomeConfiguration (int collocated)
{
  this->Components_HomeConfiguration_setup_collocation (collocated);
}

Components::HomeConfiguration::~HomeConfiguration (void)
{}

void
Components::HomeConfiguration::Components_HomeConfiguration_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeConfiguration_Proxy_Broker_ =
      ::Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeConfiguration_Proxy_Broker_ =
      ::Components::_TAO_HomeConfiguration_Remote_Proxy_Broker::the_TAO_HomeConfiguration_Remote_Proxy_Broker ();
  
  this->Components_CCMHome_setup_collocation (collocated);
}

void Components::HomeConfiguration::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeConfiguration *tmp = ACE_static_cast (HomeConfiguration*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::HomeConfiguration_ptr Components::HomeConfiguration::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return HomeConfiguration::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/HomeConfiguration:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (HomeConfiguration::_nil ());
      if (is_a == 0)
        return HomeConfiguration::_nil ();
    }
  return HomeConfiguration::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::HomeConfiguration_ptr 
Components::HomeConfiguration::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return HomeConfiguration::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      HomeConfiguration_ptr default_proxy = HomeConfiguration::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_HomeConfiguration_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeConfiguration (
                  stub,
                  1,
                  obj->_servant ()
                ),
              HomeConfiguration::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::HomeConfiguration (
                  stub,
                  0,
                  obj->_servant ()
                ),
              HomeConfiguration::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          HomeConfiguration_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &HomeConfiguration::_tao_class_id
                  )
              )
        );
}

Components::HomeConfiguration_ptr
Components::HomeConfiguration::_duplicate (HomeConfiguration_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::HomeConfiguration::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/HomeConfiguration:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/CCMHome:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::HomeConfiguration::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, HomeConfiguration)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMHome)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCMHome_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::HomeConfiguration::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/HomeConfiguration:1.0";
}

void Components::HomeConfiguration::set_configurator (
    Components::Configurator_ptr cfg
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.set_configurator (
      this,
      cfg
    );
}

void Components::HomeConfiguration::set_configuration_values (
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.set_configuration_values (
      this,
      config
    );
}

void Components::HomeConfiguration::complete_component_configuration (
    CORBA::Boolean b
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.complete_component_configuration (
      this,
      b
    );
}

void Components::HomeConfiguration::disable_home_configuration (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_HomeConfiguration_Proxy_Impl &proxy = 
    this->the_TAO_HomeConfiguration_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.disable_home_configuration (
      this
    );
}

static const CORBA::Long _oc_Components_HomeConfiguration[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d6543), 
  ACE_NTOHL (0x6f6e6669), 
  ACE_NTOHL (0x67757261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/HomeConfiguration:1.0
  18,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x436f6e66), 
  ACE_NTOHL (0x69677572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e000000),  // name = HomeConfiguration
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeConfiguration (
    CORBA::tk_objref,
    sizeof (_oc_Components_HomeConfiguration),
    (char *) &_oc_Components_HomeConfiguration,
    0,
    sizeof (Components::HomeConfiguration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_HomeConfiguration, &_tc_TAO_tc_Components_HomeConfiguration)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_ComponentPortDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/ComponentPortDescription:1.0
  25,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74506f72), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ComponentPortDescription
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  5, // member count
  7,
  ACE_NTOHL (0x66616365), 
  ACE_NTOHL (0x74730000),  // name = facets
  CORBA::tk_alias, // typecode kind for typedefs
  552, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    45,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61636574), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e73), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FacetDescriptions:1.0
    18,
    ACE_NTOHL (0x46616365), 
    ACE_NTOHL (0x74446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x73000000),  // name = FacetDescriptions
    CORBA::tk_sequence, // typecode kind
    464, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      448, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        44,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f46), 
        ACE_NTOHL (0x61636574), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e3a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/FacetDescription:1.0
        17,
        ACE_NTOHL (0x46616365), 
        ACE_NTOHL (0x74446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = FacetDescription
        0, // value modifier
        CORBA::tk_value, // typecode kind
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          43,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f50), 
          ACE_NTOHL (0x6f727444), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e3a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PortDescription:1.0
          16,
          ACE_NTOHL (0x506f7274), 
          ACE_NTOHL (0x44657363), 
          ACE_NTOHL (0x72697074), 
          ACE_NTOHL (0x696f6e00),  // name = PortDescription
          0, // value modifier
          CORBA::tk_null, // no stateful base valuetype

          2, // member count
          5,
          ACE_NTOHL (0x4e616d65), 
          ACE_NTOHL (0x0),  // name = Name
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            39,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x436f6d70), 
            ACE_NTOHL (0x6f6e656e), 
            ACE_NTOHL (0x74732f46), 
            ACE_NTOHL (0x65617475), 
            ACE_NTOHL (0x72654e61), 
            ACE_NTOHL (0x6d653a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FeatureName:1.0
            12,
            ACE_NTOHL (0x46656174), 
            ACE_NTOHL (0x7572654e), 
            ACE_NTOHL (0x616d6500),  // name = FeatureName
            CORBA::tk_string, 
            0U, // string length

          1, // data memeber visibility marker

          8,
          ACE_NTOHL (0x74797065), 
          ACE_NTOHL (0x5f696400),  // name = type_id
          CORBA::tk_alias, // typecode kind for typedefs
          72, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35,
            ACE_NTOHL (0x49444c3a), 
            ACE_NTOHL (0x6f6d672e), 
            ACE_NTOHL (0x6f72672f), 
            ACE_NTOHL (0x434f5242), 
            ACE_NTOHL (0x412f5265), 
            ACE_NTOHL (0x706f7369), 
            ACE_NTOHL (0x746f7279), 
            ACE_NTOHL (0x49643a31), 
            ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
            13,
            ACE_NTOHL (0x5265706f), 
            ACE_NTOHL (0x7369746f), 
            ACE_NTOHL (0x72794964), 
            ACE_NTOHL (0x0),  // name = RepositoryId
            CORBA::tk_string, 
            0U, // string length

          1, // data memeber visibility marker


        1, // member count
        10,
        ACE_NTOHL (0x66616365), 
        ACE_NTOHL (0x745f7265), 
        ACE_NTOHL (0x66000000),  // name = facet_ref
        CORBA::tk_objref,
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          29,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f62), 
          ACE_NTOHL (0x6a656374), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
          7,
          ACE_NTOHL (0x4f626a65), 
          ACE_NTOHL (0x63740000),  // name = Object

        1, // data memeber visibility marker


      0U,


  1, // data memeber visibility marker

  12,
  ACE_NTOHL (0x72656365), 
  ACE_NTOHL (0x70746163), 
  ACE_NTOHL (0x6c657300),  // name = receptacles
  CORBA::tk_alias, // typecode kind for typedefs
  696, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    50,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f52), 
    ACE_NTOHL (0x65636570), 
    ACE_NTOHL (0x7461636c), 
    ACE_NTOHL (0x65446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x733a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ReceptacleDescriptions:1.0
    23,
    ACE_NTOHL (0x52656365), 
    ACE_NTOHL (0x70746163), 
    ACE_NTOHL (0x6c654465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e730000),  // name = ReceptacleDescriptions
    CORBA::tk_sequence, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      584, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        49,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f52), 
        ACE_NTOHL (0x65636570), 
        ACE_NTOHL (0x7461636c), 
        ACE_NTOHL (0x65446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ReceptacleDescription:1.0
        22,
        ACE_NTOHL (0x52656365), 
        ACE_NTOHL (0x70746163), 
        ACE_NTOHL (0x6c654465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e000000),  // name = ReceptacleDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffffda4, // negative offset (-604)
        2, // member count
        12,
        ACE_NTOHL (0x69735f6d), 
        ACE_NTOHL (0x756c7469), 
        ACE_NTOHL (0x706c6500),  // name = is_multiple
        CORBA::tk_boolean,

        1, // data memeber visibility marker

        12,
        ACE_NTOHL (0x636f6e6e), 
        ACE_NTOHL (0x65637469), 
        ACE_NTOHL (0x6f6e7300),  // name = connections
        CORBA::tk_alias, // typecode kind for typedefs
        428, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          50,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f43), 
          ACE_NTOHL (0x6f6e6e65), 
          ACE_NTOHL (0x6374696f), 
          ACE_NTOHL (0x6e446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x733a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/ConnectionDescriptions:1.0
          23,
          ACE_NTOHL (0x436f6e6e), 
          ACE_NTOHL (0x65637469), 
          ACE_NTOHL (0x6f6e4465), 
          ACE_NTOHL (0x73637269), 
          ACE_NTOHL (0x7074696f), 
          ACE_NTOHL (0x6e730000),  // name = ConnectionDescriptions
          CORBA::tk_sequence, // typecode kind
          332, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_value, // typecode kind
            316, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              49,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f43), 
              ACE_NTOHL (0x6f6e6e65), 
              ACE_NTOHL (0x6374696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ConnectionDescription:1.0
              22,
              ACE_NTOHL (0x436f6e6e), 
              ACE_NTOHL (0x65637469), 
              ACE_NTOHL (0x6f6e4465), 
              ACE_NTOHL (0x73637269), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e000000),  // name = ConnectionDescription
              0, // value modifier
              CORBA::tk_null, // no stateful base valuetype

              2, // member count
              3,
              ACE_NTOHL (0x636b0000),  // name = ck
              CORBA::tk_value, // typecode kind
              172, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x436f6d70), 
                ACE_NTOHL (0x6f6e656e), 
                ACE_NTOHL (0x74732f43), 
                ACE_NTOHL (0x6f6f6b69), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Cookie:1.0
                7,
                ACE_NTOHL (0x436f6f6b), 
                ACE_NTOHL (0x69650000),  // name = Cookie
                0, // value modifier
                CORBA::tk_null, // no stateful base valuetype

                1, // member count
                12,
                ACE_NTOHL (0x636f6f6b), 
                ACE_NTOHL (0x69655661), 
                ACE_NTOHL (0x6c756500),  // name = cookieValue
                CORBA::tk_alias, // typecode kind for typedefs
                76, // encapsulation length
                  TAO_ENCAP_BYTE_ORDER, // byte order
                  31,
                  ACE_NTOHL (0x49444c3a), 
                  ACE_NTOHL (0x6f6d672e), 
                  ACE_NTOHL (0x6f72672f), 
                  ACE_NTOHL (0x434f5242), 
                  ACE_NTOHL (0x412f4f63), 
                  ACE_NTOHL (0x74657453), 
                  ACE_NTOHL (0x65713a31), 
                  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
                  9,
                  ACE_NTOHL (0x4f637465), 
                  ACE_NTOHL (0x74536571), 
                  ACE_NTOHL (0x0),  // name = OctetSeq
                  CORBA::tk_sequence, // typecode kind
                  12, // encapsulation length
                    TAO_ENCAP_BYTE_ORDER, // byte order
                    CORBA::tk_octet,

                    0U,


                0, // data memeber visibility marker


              1, // data memeber visibility marker

              7,
              ACE_NTOHL (0x6f626a72), 
              ACE_NTOHL (0x65660000),  // name = objref
              0xffffffff, // indirection
              0xfffffcfc, // negative offset (-772)
              1, // data memeber visibility marker


            0U,


        1, // data memeber visibility marker


      0U,


  1, // data memeber visibility marker

  10,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x73000000),  // name = consumers
  CORBA::tk_alias, // typecode kind for typedefs
  312, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    48,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x6f6e7375), 
    ACE_NTOHL (0x6d657244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e733a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/ConsumerDescriptions:1.0
    21,
    ACE_NTOHL (0x436f6e73), 
    ACE_NTOHL (0x756d6572), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e73), 
    ACE_NTOHL (0x0),  // name = ConsumerDescriptions
    CORBA::tk_sequence, // typecode kind
    220, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      204, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        47,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x6f6e7375), 
        ACE_NTOHL (0x6d657244), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ConsumerDescription:1.0
        20,
        ACE_NTOHL (0x436f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = ConsumerDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffffad8, // negative offset (-1320)
        1, // member count
        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        CORBA::tk_objref, // typecode kind
        80, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          45,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f45), 
          ACE_NTOHL (0x76656e74), 
          ACE_NTOHL (0x436f6e73), 
          ACE_NTOHL (0x756d6572), 
          ACE_NTOHL (0x42617365), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EventConsumerBase:1.0
          18,
          ACE_NTOHL (0x4576656e), 
          ACE_NTOHL (0x74436f6e), 
          ACE_NTOHL (0x73756d65), 
          ACE_NTOHL (0x72426173), 
          ACE_NTOHL (0x65000000),  // name = EventConsumerBase

        1, // data memeber visibility marker


      0U,


  1, // data memeber visibility marker

  9,
  ACE_NTOHL (0x656d6974), 
  ACE_NTOHL (0x74657273), 
  ACE_NTOHL (0x0),  // name = emitters
  CORBA::tk_alias, // typecode kind for typedefs
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    47,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f45), 
    ACE_NTOHL (0x6d697474), 
    ACE_NTOHL (0x65724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e733a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/EmitterDescriptions:1.0
    20,
    ACE_NTOHL (0x456d6974), 
    ACE_NTOHL (0x74657244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e7300),  // name = EmitterDescriptions
    CORBA::tk_sequence, // typecode kind
    140, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      124, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        46,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f45), 
        ACE_NTOHL (0x6d697474), 
        ACE_NTOHL (0x65724465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/EmitterDescription:1.0
        19,
        ACE_NTOHL (0x456d6974), 
        ACE_NTOHL (0x74657244), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e0000),  // name = EmitterDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffff988, // negative offset (-1656)
        1, // member count
        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        0xffffffff, // indirection
        0xfffffeac, // negative offset (-340)
        1, // data memeber visibility marker


      0U,


  1, // data memeber visibility marker

  11,
  ACE_NTOHL (0x7075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x72730000),  // name = publishers
  CORBA::tk_alias, // typecode kind for typedefs
  504, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    49,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x75626c69), 
    ACE_NTOHL (0x73686572), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e73), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/PublisherDescriptions:1.0
    22,
    ACE_NTOHL (0x5075626c), 
    ACE_NTOHL (0x69736865), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x73000000),  // name = PublisherDescriptions
    CORBA::tk_sequence, // typecode kind
    408, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_value, // typecode kind
      392, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        48,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f50), 
        ACE_NTOHL (0x75626c69), 
        ACE_NTOHL (0x73686572), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e3a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/PublisherDescription:1.0
        21,
        ACE_NTOHL (0x5075626c), 
        ACE_NTOHL (0x69736865), 
        ACE_NTOHL (0x72446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = PublisherDescription
        0, // value modifier
        0xffffffff, // indirection
        0xfffff87c, // negative offset (-1924)
        1, // member count
        9,
        ACE_NTOHL (0x636f6e73), 
        ACE_NTOHL (0x756d6572), 
        ACE_NTOHL (0x0),  // name = consumer
        CORBA::tk_alias, // typecode kind for typedefs
        264, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          50,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x436f6d70), 
          ACE_NTOHL (0x6f6e656e), 
          ACE_NTOHL (0x74732f53), 
          ACE_NTOHL (0x75627363), 
          ACE_NTOHL (0x72696265), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x733a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/SubscriberDescriptions:1.0
          23,
          ACE_NTOHL (0x53756273), 
          ACE_NTOHL (0x63726962), 
          ACE_NTOHL (0x65724465), 
          ACE_NTOHL (0x73637269), 
          ACE_NTOHL (0x7074696f), 
          ACE_NTOHL (0x6e730000),  // name = SubscriberDescriptions
          CORBA::tk_sequence, // typecode kind
          168, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_value, // typecode kind
            152, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              49,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x436f6d70), 
              ACE_NTOHL (0x6f6e656e), 
              ACE_NTOHL (0x74732f53), 
              ACE_NTOHL (0x75627363), 
              ACE_NTOHL (0x72696265), 
              ACE_NTOHL (0x72446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x3a312e30), 
              ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SubscriberDescription:1.0
              22,
              ACE_NTOHL (0x53756273), 
              ACE_NTOHL (0x63726962), 
              ACE_NTOHL (0x65724465), 
              ACE_NTOHL (0x73637269), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e000000),  // name = SubscriberDescription
              0, // value modifier
              0xffffffff, // indirection
              0xfffff790, // negative offset (-2160)
              2, // member count
              3,
              ACE_NTOHL (0x636b0000),  // name = ck
              0xffffffff, // indirection
              0xfffffae8, // negative offset (-1304)
              1, // data memeber visibility marker

              9,
              ACE_NTOHL (0x636f6e73), 
              ACE_NTOHL (0x756d6572), 
              ACE_NTOHL (0x0),  // name = consumer
              0xffffffff, // indirection
              0xfffffca0, // negative offset (-864)
              1, // data memeber visibility marker


            0U,


        1, // data memeber visibility marker


      0U,


  1, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_ComponentPortDescription (
    CORBA::tk_value,
    sizeof (_oc_Components_ComponentPortDescription),
    (char *) &_oc_Components_ComponentPortDescription,
    0,
    sizeof (Components::ComponentPortDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ComponentPortDescription, &_tc_TAO_tc_Components_ComponentPortDescription)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::ComponentPortDescription_var
// *************************************************************

Components::ComponentPortDescription_var::ComponentPortDescription_var (void) // default constructor
  : ptr_ (0)
{}

Components::ComponentPortDescription_var::ComponentPortDescription_var (ComponentPortDescription* p)
  : ptr_ (p)
{}

Components::ComponentPortDescription_var::ComponentPortDescription_var (const ComponentPortDescription* p)
  : ptr_ (ACE_const_cast(ComponentPortDescription*, p))
{}

Components::ComponentPortDescription* 
Components::ComponentPortDescription_var::ptr (void) const
{
  return this->ptr_;
}

Components::ComponentPortDescription_var::ComponentPortDescription_var (const ComponentPortDescription_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::ComponentPortDescription_var::~ComponentPortDescription_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::ComponentPortDescription_var &
Components::ComponentPortDescription_var::operator= (ComponentPortDescription* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ComponentPortDescription_var &
Components::ComponentPortDescription_var::operator= (const ComponentPortDescription_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ComponentPortDescription* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::ComponentPortDescription_var::operator const Components::ComponentPortDescription* () const // cast
{
  return this->ptr_;
}

Components::ComponentPortDescription_var::operator Components::ComponentPortDescription* () // cast 
{
  return this->ptr_;
}

Components::ComponentPortDescription* 
Components::ComponentPortDescription_var::operator-> (void) const
{
  return this->ptr_;
}

Components::ComponentPortDescription*
Components::ComponentPortDescription_var::in (void) const
{
  return this->ptr_;
}

Components::ComponentPortDescription* &
Components::ComponentPortDescription_var::inout (void)
{
  return this->ptr_;
}

Components::ComponentPortDescription* &
Components::ComponentPortDescription_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::ComponentPortDescription* 
Components::ComponentPortDescription_var::_retn (void)
{
  // yield ownership of managed obj reference
  ComponentPortDescription* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::ComponentPortDescription_out
// *************************************************************

Components::ComponentPortDescription_out::ComponentPortDescription_out (ComponentPortDescription* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::ComponentPortDescription_out::ComponentPortDescription_out (ComponentPortDescription_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::ComponentPortDescription_out::ComponentPortDescription_out (const ComponentPortDescription_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentPortDescription_out&,p).ptr_)
{}

Components::ComponentPortDescription_out &
Components::ComponentPortDescription_out::operator= (const ComponentPortDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentPortDescription_out&,p).ptr_;
  return *this;
}

Components::ComponentPortDescription_out &
Components::ComponentPortDescription_out::operator= (const ComponentPortDescription_var &p)
{
  ComponentPortDescription* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::ComponentPortDescription_out &
Components::ComponentPortDescription_out::operator= (ComponentPortDescription* p)
{
  this->ptr_ = p;
  return *this;
}

Components::ComponentPortDescription_out::operator Components::ComponentPortDescription* &() // cast
{
  return this->ptr_;
}

Components::ComponentPortDescription* &
Components::ComponentPortDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::ComponentPortDescription* 
Components::ComponentPortDescription_out::operator-> (void)
{
  return this->ptr_;
}

Components::ComponentPortDescription* Components::ComponentPortDescription::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ComponentPortDescription* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::ComponentPortDescription::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::ComponentPortDescription::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::ComponentPortDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentPortDescription *tmp = ACE_static_cast (ComponentPortDescription*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::ComponentPortDescription::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_ComponentPortDescription (strm);
}

CORBA::Boolean Components::ComponentPortDescription::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_ComponentPortDescription (strm);
}

CORBA::Boolean Components::ComponentPortDescription::_tao_unmarshal (TAO_InputCDR &strm, ComponentPortDescription *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          ComponentPortDescription::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ComponentPortDescription::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::ComponentPortDescription::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ComponentPortDescription::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::ComponentPortDescription_init::ComponentPortDescription_init ()
{
}

Components::ComponentPortDescription_init::~ComponentPortDescription_init ()
{
}

const char* 
Components::ComponentPortDescription_init::tao_repository_id (void)
{
  return Components::ComponentPortDescription::_tao_obv_static_repository_id ();
}

CORBA_ValueBase* 
Components::ComponentPortDescription_init::create_for_unmarshal (void)
{
  CORBA_ValueBase* ret_val = 0;
  ACE_NEW_RETURN(ret_val, 
                 OBV_Components::ComponentPortDescription, 
                 0);
  return ret_val;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::CCMObject::_tao_class_id = 0;

Components::CCMObject_ptr
tao_Components_CCMObject_duplicate (
    Components::CCMObject_ptr p
  )
{
  return Components::CCMObject::_duplicate (p);
}

void
tao_Components_CCMObject_release (
    Components::CCMObject_ptr p
  )
{
  CORBA::release (p);
}

Components::CCMObject_ptr
tao_Components_CCMObject_nil (
    void
  )
{
  return Components::CCMObject::_nil ();
}

Components::CCMObject_ptr
tao_Components_CCMObject_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::CCMObject::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_CCMObject_upcast (
    void *src
  )
{
  Components::CCMObject **tmp =
    ACE_static_cast (Components::CCMObject **, src);
  return *tmp;
}

// *************************************************************
// Components::CCMObject_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::CCMObject_var::CCMObject_var (void) // default constructor
  : ptr_ (CCMObject::_nil ())
{}

::Components::CCMObject_ptr
Components::CCMObject_var::ptr (void) const
{
  return this->ptr_;
}

Components::CCMObject_var::CCMObject_var (const ::Components::CCMObject_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CCMObject::_duplicate (p.ptr ()))
{}

Components::CCMObject_var::~CCMObject_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::CCMObject_var &
Components::CCMObject_var::operator= (CCMObject_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::CCMObject_var &
Components::CCMObject_var::operator= (const ::Components::CCMObject_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::CCMObject::_duplicate (p.ptr ());
  }
  return *this;
}

Components::CCMObject_var::operator const ::Components::CCMObject_ptr &() const // cast
{
  return this->ptr_;
}

Components::CCMObject_var::operator ::Components::CCMObject_ptr &() // cast 
{
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_var::in (void) const
{
  return this->ptr_;
}

::Components::CCMObject_ptr &
Components::CCMObject_var::inout (void)
{
  return this->ptr_;
}

::Components::CCMObject_ptr &
Components::CCMObject_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMObject::_nil ();
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::CCMObject_ptr val = this->ptr_;
  this->ptr_ = ::Components::CCMObject::_nil ();
  return val;
}

::Components::CCMObject_ptr
Components::CCMObject_var::tao_duplicate (CCMObject_ptr p)
{
  return ::Components::CCMObject::_duplicate (p);
}

void
Components::CCMObject_var::tao_release (CCMObject_ptr p)
{
  CORBA::release (p);
}

::Components::CCMObject_ptr
Components::CCMObject_var::tao_nil (void)
{
  return ::Components::CCMObject::_nil ();
}

::Components::CCMObject_ptr
Components::CCMObject_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::CCMObject::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::CCMObject_var::tao_upcast (void *src)
{
  CCMObject **tmp =
    ACE_static_cast (CCMObject **, src);
  return *tmp;
}

// *************************************************************
// Components::CCMObject_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::CCMObject_out::CCMObject_out (CCMObject_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::CCMObject::_nil ();
}

Components::CCMObject_out::CCMObject_out (CCMObject_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMObject::_nil ();
}

Components::CCMObject_out::CCMObject_out (const ::Components::CCMObject_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CCMObject_out &, p).ptr_)
{}

::Components::CCMObject_out &
Components::CCMObject_out::operator= (const ::Components::CCMObject_out &p)
{
  this->ptr_ = ACE_const_cast (CCMObject_out&, p).ptr_;
  return *this;
}

Components::CCMObject_out &
Components::CCMObject_out::operator= (const ::Components::CCMObject_var &p)
{
  this->ptr_ = ::Components::CCMObject::_duplicate (p.ptr ());
  return *this;
}

Components::CCMObject_out &
Components::CCMObject_out::operator= (CCMObject_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::CCMObject_out::operator ::Components::CCMObject_ptr &() // cast
{
  return this->ptr_;
}

::Components::CCMObject_ptr &
Components::CCMObject_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::CCMObject_ptr
Components::CCMObject_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_CCMObject_get_component_def : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_component_def (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IRObject_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_component_def (const TAO_ClientRequestInfo_Components_CCMObject_get_component_def &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_component_def &);

  CORBA::IRObject_ptr _result;
};

TAO_ClientRequestInfo_Components_CCMObject_get_component_def::TAO_ClientRequestInfo_Components_CCMObject_get_component_def (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_component_def::result (::CORBA::IRObject_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home (const TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home &);

  Components::CCMHome_ptr _result;
};

TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home::result (::Components::CCMHome_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_CCMObject_get_primary_key : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_primary_key (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::PrimaryKeyBase * result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_primary_key (const TAO_ClientRequestInfo_Components_CCMObject_get_primary_key &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_primary_key &);

  Components::PrimaryKeyBase * _result;
};

TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::TAO_ClientRequestInfo_Components_CCMObject_get_primary_key (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_get_primary_key_exceptiondata[] = 
  {
    Components::_tc_NoKeyAvailable
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_get_primary_key_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_primary_key::result (::Components::PrimaryKeyBase * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_CCMObject_configuration_complete : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_configuration_complete (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_CCMObject_configuration_complete (const TAO_ClientRequestInfo_Components_CCMObject_configuration_complete &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_configuration_complete &);

  
};

TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::TAO_ClientRequestInfo_Components_CCMObject_configuration_complete (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_configuration_complete_exceptiondata[] = 
  {
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_configuration_complete_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_configuration_complete::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_CCMObject_remove : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_remove (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_CCMObject_remove (const TAO_ClientRequestInfo_Components_CCMObject_remove &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_remove &);

  
};

TAO_ClientRequestInfo_Components_CCMObject_remove::TAO_ClientRequestInfo_Components_CCMObject_remove (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_CCMObject_remove_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_CCMObject_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_CCMObject_get_all_ports : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_CCMObject_get_all_ports (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ComponentPortDescription * result);

private:
  TAO_ClientRequestInfo_Components_CCMObject_get_all_ports (const TAO_ClientRequestInfo_Components_CCMObject_get_all_ports &);
  void operator= (const TAO_ClientRequestInfo_Components_CCMObject_get_all_ports &);

  Components::ComponentPortDescription * _result;
};

TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::TAO_ClientRequestInfo_Components_CCMObject_get_all_ports (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_CCMObject_get_all_ports::result (::Components::ComponentPortDescription * result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::_TAO_CCMObject_Proxy_Impl::_TAO_CCMObject_Proxy_Impl (void)
{}

Components::_TAO_CCMObject_Remote_Proxy_Impl::_TAO_CCMObject_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::CORBA::IRObject_ptr Components::_TAO_CCMObject_Remote_Proxy_Impl::get_component_def (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  CORBA::IRObject_var _tao_retval (CORBA::IRObject::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_component_def",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_component_def _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IRObject_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::CCMHome_ptr Components::_TAO_CCMObject_Remote_Proxy_Impl::get_ccm_home (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_ccm_home",
      12,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_ccm_home _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::PrimaryKeyBase * Components::_TAO_CCMObject_Remote_Proxy_Impl::get_primary_key (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::NoKeyAvailable
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_CCMObject_get_primary_key_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/NoKeyAvailable:1.0",
      Components::NoKeyAvailable::_alloc
    }
  };

  ::Components::PrimaryKeyBase_var _tao_retval;


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primary_key",
      15,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_primary_key _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMObject_get_primary_key_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::PrimaryKeyBase * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::_TAO_CCMObject_Remote_Proxy_Impl::configuration_complete (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_CCMObject_configuration_complete_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/InvalidConfiguration:1.0",
      Components::InvalidConfiguration::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "configuration_complete",
      22,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_configuration_complete _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMObject_configuration_complete_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::_TAO_CCMObject_Remote_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_CCMObject_remove_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove",
      6,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_remove _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          _invoke_status =
            _tao_call.invoke (_tao_Components_CCMObject_remove_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

::Components::ComponentPortDescription * Components::_TAO_CCMObject_Remote_Proxy_Impl::get_all_ports (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  ::Components::ComponentPortDescription_var _tao_retval;


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_all_ports",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_CCMObject_get_all_ports _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ComponentPortDescription * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::_TAO_CCMObject_Proxy_Broker::_TAO_CCMObject_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Proxy_Broker::~_TAO_CCMObject_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Proxy_Broker * (*Components__TAO_CCMObject_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::_TAO_CCMObject_Remote_Proxy_Broker *
Components::_TAO_CCMObject_Remote_Proxy_Broker::the_TAO_CCMObject_Remote_Proxy_Broker (void)
{
  static ::Components::_TAO_CCMObject_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::_TAO_CCMObject_Remote_Proxy_Broker::_TAO_CCMObject_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Remote_Proxy_Broker::~_TAO_CCMObject_Remote_Proxy_Broker (void)
{
}

Components::_TAO_CCMObject_Proxy_Impl&
Components::_TAO_CCMObject_Remote_Proxy_Broker::select_proxy (
  ::Components::CCMObject *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::CCMObject::CCMObject (int collocated)
{
  this->Components_CCMObject_setup_collocation (collocated);
}

Components::CCMObject::~CCMObject (void)
{}

void
Components::CCMObject::Components_CCMObject_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_CCMObject_Proxy_Broker_ =
      ::Components__TAO_CCMObject_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_CCMObject_Proxy_Broker_ =
      ::Components::_TAO_CCMObject_Remote_Proxy_Broker::the_TAO_CCMObject_Remote_Proxy_Broker ();
  
  this->Components_Navigation_setup_collocation (collocated);
  
  this->Components_Receptacles_setup_collocation (collocated);
  
  this->Components_Events_setup_collocation (collocated);
}

void Components::CCMObject::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMObject *tmp = ACE_static_cast (CCMObject*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::CCMObject_ptr Components::CCMObject::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return CCMObject::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/CCMObject:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (CCMObject::_nil ());
      if (is_a == 0)
        return CCMObject::_nil ();
    }
  return CCMObject::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::CCMObject_ptr 
Components::CCMObject::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CCMObject::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CCMObject_ptr default_proxy = CCMObject::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components__TAO_CCMObject_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMObject (
                  stub,
                  1,
                  obj->_servant ()
                ),
              CCMObject::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::CCMObject (
                  stub,
                  0,
                  obj->_servant ()
                ),
              CCMObject::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          CCMObject_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &CCMObject::_tao_class_id
                  )
              )
        );
}

Components::CCMObject_ptr
Components::CCMObject::_duplicate (CCMObject_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::CCMObject::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/CCMObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Navigation:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Receptacles:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Events:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::CCMObject::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMObject)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Navigation)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::Navigation_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Receptacles)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::Receptacles_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Events)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::Events_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::CCMObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/CCMObject:1.0";
}

::CORBA::IRObject_ptr Components::CCMObject::get_component_def (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_component_def (
      this
    );
}

::Components::CCMHome_ptr Components::CCMObject::get_ccm_home (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_ccm_home (
      this
    );
}

::Components::PrimaryKeyBase * Components::CCMObject::get_primary_key (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::NoKeyAvailable
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_primary_key (
      this
    );
}

void Components::CCMObject::configuration_complete (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.configuration_complete (
      this
    );
}

void Components::CCMObject::remove (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove (
      this
    );
}

::Components::ComponentPortDescription * Components::CCMObject::get_all_ports (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_CCMObject_Proxy_Impl &proxy = 
    this->the_TAO_CCMObject_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_all_ports (
      this
    );
}

static const CORBA::Long _oc_Components_CCMObject[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/CCMObject:1.0
  10,
  ACE_NTOHL (0x43434d4f), 
  ACE_NTOHL (0x626a6563), 
  ACE_NTOHL (0x74000000),  // name = CCMObject
};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMObject (
    CORBA::tk_objref,
    sizeof (_oc_Components_CCMObject),
    (char *) &_oc_Components_CCMObject,
    0,
    sizeof (Components::CCMObject)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCMObject, &_tc_TAO_tc_Components_CCMObject)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_Enumeration[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6e756d65), 
  ACE_NTOHL (0x72617469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Enumeration:1.0
  12,
  ACE_NTOHL (0x456e756d), 
  ACE_NTOHL (0x65726174), 
  ACE_NTOHL (0x696f6e00),  // name = Enumeration
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Enumeration (
    CORBA::tk_value,
    sizeof (_oc_Components_Enumeration),
    (char *) &_oc_Components_Enumeration,
    0,
    sizeof (Components::Enumeration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Enumeration, &_tc_TAO_tc_Components_Enumeration)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::Enumeration_var
// *************************************************************

Components::Enumeration_var::Enumeration_var (void) // default constructor
  : ptr_ (0)
{}

Components::Enumeration_var::Enumeration_var (Enumeration* p)
  : ptr_ (p)
{}

Components::Enumeration_var::Enumeration_var (const Enumeration* p)
  : ptr_ (ACE_const_cast(Enumeration*, p))
{}

Components::Enumeration* 
Components::Enumeration_var::ptr (void) const
{
  return this->ptr_;
}

Components::Enumeration_var::Enumeration_var (const Enumeration_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::Enumeration_var::~Enumeration_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::Enumeration_var &
Components::Enumeration_var::operator= (Enumeration* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Enumeration_var &
Components::Enumeration_var::operator= (const Enumeration_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    Enumeration* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::Enumeration_var::operator const Components::Enumeration* () const // cast
{
  return this->ptr_;
}

Components::Enumeration_var::operator Components::Enumeration* () // cast 
{
  return this->ptr_;
}

Components::Enumeration* 
Components::Enumeration_var::operator-> (void) const
{
  return this->ptr_;
}

Components::Enumeration*
Components::Enumeration_var::in (void) const
{
  return this->ptr_;
}

Components::Enumeration* &
Components::Enumeration_var::inout (void)
{
  return this->ptr_;
}

Components::Enumeration* &
Components::Enumeration_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::Enumeration* 
Components::Enumeration_var::_retn (void)
{
  // yield ownership of managed obj reference
  Enumeration* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::Enumeration_out
// *************************************************************

Components::Enumeration_out::Enumeration_out (Enumeration* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::Enumeration_out::Enumeration_out (Enumeration_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::Enumeration_out::Enumeration_out (const Enumeration_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Enumeration_out&,p).ptr_)
{}

Components::Enumeration_out &
Components::Enumeration_out::operator= (const Enumeration_out &p)
{
  this->ptr_ = ACE_const_cast (Enumeration_out&,p).ptr_;
  return *this;
}

Components::Enumeration_out &
Components::Enumeration_out::operator= (const Enumeration_var &p)
{
  Enumeration* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::Enumeration_out &
Components::Enumeration_out::operator= (Enumeration* p)
{
  this->ptr_ = p;
  return *this;
}

Components::Enumeration_out::operator Components::Enumeration* &() // cast
{
  return this->ptr_;
}

Components::Enumeration* &
Components::Enumeration_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::Enumeration* 
Components::Enumeration_out::operator-> (void)
{
  return this->ptr_;
}

Components::Enumeration* Components::Enumeration::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (Enumeration* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::Enumeration::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::Enumeration::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::Enumeration::_tao_any_destructor (void *_tao_void_pointer)
{
  Enumeration *tmp = ACE_static_cast (Enumeration*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::Enumeration::_tao_unmarshal (TAO_InputCDR &strm, Enumeration *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          Enumeration::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::Enumeration::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::Enumeration::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = Enumeration::_downcast (base);
  // %! unmarshal_post
  return 1;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMOBJECTSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_CCMOBJECTSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_allocate_buffer (CORBA::ULong length)
{
  Components::CCMObject **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::CCMObject **old = ACE_reinterpret_cast (Components::CCMObject**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = Components::CCMObject::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::CCMObject **tmp = ACE_reinterpret_cast (Components::CCMObject**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMObject::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::~_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::CCMObject **tmp = ACE_reinterpret_cast (Components::CCMObject**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::CCMObject::_nil ();
    }
}

void 
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  Components::CCMObject **tmp = ACE_static_cast (Components::CCMObject**, target);
  *tmp = Components::CCMObject::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
Components::_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq::_upcast (void *src) const
{
  Components::CCMObject **tmp = ACE_static_cast (Components::CCMObject**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_CCMOBJECTSEQ_CS_)
#define _COMPONENTS_CCMOBJECTSEQ_CS_

// *************************************************************
// Components::CCMObjectSeq
// *************************************************************

Components::CCMObjectSeq::CCMObjectSeq (void)
{}
Components::CCMObjectSeq::CCMObjectSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMObject,Components::CCMObject_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::CCMObjectSeq::CCMObjectSeq (CORBA::ULong max, CORBA::ULong length, Components::CCMObject_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMObject,Components::CCMObject_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::CCMObjectSeq::CCMObjectSeq (const CCMObjectSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_CCMObjectSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::CCMObject,Components::CCMObject_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::CCMObjectSeq::~CCMObjectSeq (void) // dtor
{}
void Components::CCMObjectSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMObjectSeq *tmp = ACE_static_cast (CCMObjectSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_CCMObjectSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d4f62), 
  ACE_NTOHL (0x6a656374), 
  ACE_NTOHL (0x5365713a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/CCMObjectSeq:1.0
  13,
  ACE_NTOHL (0x43434d4f), 
  ACE_NTOHL (0x626a6563), 
  ACE_NTOHL (0x74536571), 
  ACE_NTOHL (0x0),  // name = CCMObjectSeq
  CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      37,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f43), 
      ACE_NTOHL (0x434d4f62), 
      ACE_NTOHL (0x6a656374), 
      ACE_NTOHL (0x3a312e30), 
      ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/CCMObject:1.0
      10,
      ACE_NTOHL (0x43434d4f), 
      ACE_NTOHL (0x626a6563), 
      ACE_NTOHL (0x74000000),  // name = CCMObject

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMObjectSeq (
    CORBA::tk_alias,
    sizeof (_oc_Components_CCMObjectSeq),
    (char *) &_oc_Components_CCMObjectSeq,
    0,
    sizeof (Components::CCMObjectSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCMObjectSeq, &_tc_TAO_tc_Components_CCMObjectSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_DefaultEnumeration[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65666175), 
  ACE_NTOHL (0x6c74456e), 
  ACE_NTOHL (0x756d6572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/DefaultEnumeration:1.0
  19,
  ACE_NTOHL (0x44656661), 
  ACE_NTOHL (0x756c7445), 
  ACE_NTOHL (0x6e756d65), 
  ACE_NTOHL (0x72617469), 
  ACE_NTOHL (0x6f6e0000),  // name = DefaultEnumeration
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  1, // member count
  8,
  ACE_NTOHL (0x6f626a65), 
  ACE_NTOHL (0x63747300),  // name = objects
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x434d4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/CCMObjectSeq:1.0
    13,
    ACE_NTOHL (0x43434d4f), 
    ACE_NTOHL (0x626a6563), 
    ACE_NTOHL (0x74536571), 
    ACE_NTOHL (0x0),  // name = CCMObjectSeq
    CORBA::tk_sequence, // typecode kind
    80, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f43), 
        ACE_NTOHL (0x434d4f62), 
        ACE_NTOHL (0x6a656374), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/CCMObject:1.0
        10,
        ACE_NTOHL (0x43434d4f), 
        ACE_NTOHL (0x626a6563), 
        ACE_NTOHL (0x74000000),  // name = CCMObject

      0U,


  0, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_DefaultEnumeration (
    CORBA::tk_value,
    sizeof (_oc_Components_DefaultEnumeration),
    (char *) &_oc_Components_DefaultEnumeration,
    0,
    sizeof (Components::DefaultEnumeration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_DefaultEnumeration, &_tc_TAO_tc_Components_DefaultEnumeration)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::DefaultEnumeration_var
// *************************************************************

Components::DefaultEnumeration_var::DefaultEnumeration_var (void) // default constructor
  : ptr_ (0)
{}

Components::DefaultEnumeration_var::DefaultEnumeration_var (DefaultEnumeration* p)
  : ptr_ (p)
{}

Components::DefaultEnumeration_var::DefaultEnumeration_var (const DefaultEnumeration* p)
  : ptr_ (ACE_const_cast(DefaultEnumeration*, p))
{}

Components::DefaultEnumeration* 
Components::DefaultEnumeration_var::ptr (void) const
{
  return this->ptr_;
}

Components::DefaultEnumeration_var::DefaultEnumeration_var (const DefaultEnumeration_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::DefaultEnumeration_var::~DefaultEnumeration_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::DefaultEnumeration_var &
Components::DefaultEnumeration_var::operator= (DefaultEnumeration* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::DefaultEnumeration_var &
Components::DefaultEnumeration_var::operator= (const DefaultEnumeration_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    DefaultEnumeration* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::DefaultEnumeration_var::operator const Components::DefaultEnumeration* () const // cast
{
  return this->ptr_;
}

Components::DefaultEnumeration_var::operator Components::DefaultEnumeration* () // cast 
{
  return this->ptr_;
}

Components::DefaultEnumeration* 
Components::DefaultEnumeration_var::operator-> (void) const
{
  return this->ptr_;
}

Components::DefaultEnumeration*
Components::DefaultEnumeration_var::in (void) const
{
  return this->ptr_;
}

Components::DefaultEnumeration* &
Components::DefaultEnumeration_var::inout (void)
{
  return this->ptr_;
}

Components::DefaultEnumeration* &
Components::DefaultEnumeration_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::DefaultEnumeration* 
Components::DefaultEnumeration_var::_retn (void)
{
  // yield ownership of managed obj reference
  DefaultEnumeration* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::DefaultEnumeration_out
// *************************************************************

Components::DefaultEnumeration_out::DefaultEnumeration_out (DefaultEnumeration* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::DefaultEnumeration_out::DefaultEnumeration_out (DefaultEnumeration_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::DefaultEnumeration_out::DefaultEnumeration_out (const DefaultEnumeration_out &p) // copy constructor
  : ptr_ (ACE_const_cast (DefaultEnumeration_out&,p).ptr_)
{}

Components::DefaultEnumeration_out &
Components::DefaultEnumeration_out::operator= (const DefaultEnumeration_out &p)
{
  this->ptr_ = ACE_const_cast (DefaultEnumeration_out&,p).ptr_;
  return *this;
}

Components::DefaultEnumeration_out &
Components::DefaultEnumeration_out::operator= (const DefaultEnumeration_var &p)
{
  DefaultEnumeration* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::DefaultEnumeration_out &
Components::DefaultEnumeration_out::operator= (DefaultEnumeration* p)
{
  this->ptr_ = p;
  return *this;
}

Components::DefaultEnumeration_out::operator Components::DefaultEnumeration* &() // cast
{
  return this->ptr_;
}

Components::DefaultEnumeration* &
Components::DefaultEnumeration_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::DefaultEnumeration* 
Components::DefaultEnumeration_out::operator-> (void)
{
  return this->ptr_;
}

Components::DefaultEnumeration* Components::DefaultEnumeration::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (DefaultEnumeration* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::DefaultEnumeration::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::DefaultEnumeration::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,Enumeration)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::DefaultEnumeration::_tao_any_destructor (void *_tao_void_pointer)
{
  DefaultEnumeration *tmp = ACE_static_cast (DefaultEnumeration*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::DefaultEnumeration::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_DefaultEnumeration (strm);
}

CORBA::Boolean Components::DefaultEnumeration::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_DefaultEnumeration (strm);
}

CORBA::Boolean Components::DefaultEnumeration::_tao_unmarshal (TAO_InputCDR &strm, DefaultEnumeration *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          DefaultEnumeration::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::DefaultEnumeration::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::DefaultEnumeration::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = DefaultEnumeration::_downcast (base);
  // %! unmarshal_post
  return 1;
}


#if !defined (_COMPONENTS_TRANSACTION_TRANTOKEN_CS_)
#define _COMPONENTS_TRANSACTION_TRANTOKEN_CS_

// *************************************************************
// Components::Transaction::TranToken
// *************************************************************

Components::Transaction::TranToken::TranToken (void)
{}
Components::Transaction::TranToken::TranToken (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::Transaction::TranToken::TranToken (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::Transaction::TranToken::TranToken (const TranToken &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::Transaction::TranToken::~TranToken (void) // dtor
{}
void Components::Transaction::TranToken::_tao_any_destructor (void *_tao_void_pointer)
{
  TranToken *tmp = ACE_static_cast (TranToken*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_Transaction_TranToken[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f54), 
  ACE_NTOHL (0x72616e54), 
  ACE_NTOHL (0x6f6b656e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/Transaction/TranToken:1.0
  10,
  ACE_NTOHL (0x5472616e), 
  ACE_NTOHL (0x546f6b65), 
  ACE_NTOHL (0x6e000000),  // name = TranToken
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_TranToken (
    CORBA::tk_alias,
    sizeof (_oc_Components_Transaction_TranToken),
    (char *) &_oc_Components_Transaction_TranToken,
    0,
    sizeof (Components::Transaction::TranToken)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_TranToken, &_tc_TAO_tc_Components_Transaction_TranToken)
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::NoTransaction::NoTransaction (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/NoTransaction:1.0",
        "NoTransaction"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::NoTransaction::~NoTransaction (void)
{
}

// Copy constructor.
Components::Transaction::NoTransaction::NoTransaction (const ::Components::Transaction::NoTransaction &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::NoTransaction&
Components::Transaction::NoTransaction::operator= (const ::Components::Transaction::NoTransaction &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::NoTransaction::_tao_any_destructor (void *_tao_void_pointer)
{
  NoTransaction *tmp = ACE_static_cast (NoTransaction*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::NoTransaction *
Components::Transaction::NoTransaction::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/NoTransaction:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NoTransaction *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::NoTransaction::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::NoTransaction, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::NoTransaction::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::NoTransaction (*this),
      0
    );
  return result;
}

void Components::Transaction::NoTransaction::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::NoTransaction::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::NoTransaction::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_NoTransaction[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  53,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f4e), 
  ACE_NTOHL (0x6f547261), 
  ACE_NTOHL (0x6e736163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/Transaction/NoTransaction:1.0
  14,
  ACE_NTOHL (0x4e6f5472), 
  ACE_NTOHL (0x616e7361), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e000000),  // name = NoTransaction
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_NoTransaction (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_NoTransaction),
    (char *) &_oc_Components_Transaction_NoTransaction,
    0,
    sizeof (Components::Transaction::NoTransaction)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_NoTransaction, &_tc_TAO_tc_Components_Transaction_NoTransaction)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::NoTransaction::_type (void) const
{
  return ::Components::Transaction::_tc_NoTransaction;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::NotSupported::NotSupported (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/NotSupported:1.0",
        "NotSupported"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::NotSupported::~NotSupported (void)
{
}

// Copy constructor.
Components::Transaction::NotSupported::NotSupported (const ::Components::Transaction::NotSupported &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::NotSupported&
Components::Transaction::NotSupported::operator= (const ::Components::Transaction::NotSupported &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::NotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  NotSupported *tmp = ACE_static_cast (NotSupported*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::NotSupported *
Components::Transaction::NotSupported::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/NotSupported:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NotSupported *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::NotSupported::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::NotSupported, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::NotSupported::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::NotSupported (*this),
      0
    );
  return result;
}

void Components::Transaction::NotSupported::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::NotSupported::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::NotSupported::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_NotSupported[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f4e), 
  ACE_NTOHL (0x6f745375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x7465643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Transaction/NotSupported:1.0
  13,
  ACE_NTOHL (0x4e6f7453), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x72746564), 
  ACE_NTOHL (0x0),  // name = NotSupported
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_NotSupported (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_NotSupported),
    (char *) &_oc_Components_Transaction_NotSupported,
    0,
    sizeof (Components::Transaction::NotSupported)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_NotSupported, &_tc_TAO_tc_Components_Transaction_NotSupported)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::NotSupported::_type (void) const
{
  return ::Components::Transaction::_tc_NotSupported;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::SystemError::SystemError (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/SystemError:1.0",
        "SystemError"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::SystemError::~SystemError (void)
{
}

// Copy constructor.
Components::Transaction::SystemError::SystemError (const ::Components::Transaction::SystemError &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::SystemError&
Components::Transaction::SystemError::operator= (const ::Components::Transaction::SystemError &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::SystemError::_tao_any_destructor (void *_tao_void_pointer)
{
  SystemError *tmp = ACE_static_cast (SystemError*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::SystemError *
Components::Transaction::SystemError::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/SystemError:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (SystemError *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::SystemError::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::SystemError, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::SystemError::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::SystemError (*this),
      0
    );
  return result;
}

void Components::Transaction::SystemError::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::SystemError::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::SystemError::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_SystemError[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f53), 
  ACE_NTOHL (0x79737465), 
  ACE_NTOHL (0x6d457272), 
  ACE_NTOHL (0x6f723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Transaction/SystemError:1.0
  12,
  ACE_NTOHL (0x53797374), 
  ACE_NTOHL (0x656d4572), 
  ACE_NTOHL (0x726f7200),  // name = SystemError
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_SystemError (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_SystemError),
    (char *) &_oc_Components_Transaction_SystemError,
    0,
    sizeof (Components::Transaction::SystemError)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SystemError, &_tc_TAO_tc_Components_Transaction_SystemError)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::SystemError::_type (void) const
{
  return ::Components::Transaction::_tc_SystemError;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::RollbackError::RollbackError (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/RollbackError:1.0",
        "RollbackError"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::RollbackError::~RollbackError (void)
{
}

// Copy constructor.
Components::Transaction::RollbackError::RollbackError (const ::Components::Transaction::RollbackError &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::RollbackError&
Components::Transaction::RollbackError::operator= (const ::Components::Transaction::RollbackError &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::RollbackError::_tao_any_destructor (void *_tao_void_pointer)
{
  RollbackError *tmp = ACE_static_cast (RollbackError*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::RollbackError *
Components::Transaction::RollbackError::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/RollbackError:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (RollbackError *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::RollbackError::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::RollbackError, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::RollbackError::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::RollbackError (*this),
      0
    );
  return result;
}

void Components::Transaction::RollbackError::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::RollbackError::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::RollbackError::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_RollbackError[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  53,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f52), 
  ACE_NTOHL (0x6f6c6c62), 
  ACE_NTOHL (0x61636b45), 
  ACE_NTOHL (0x72726f72), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/Transaction/RollbackError:1.0
  14,
  ACE_NTOHL (0x526f6c6c), 
  ACE_NTOHL (0x6261636b), 
  ACE_NTOHL (0x4572726f), 
  ACE_NTOHL (0x72000000),  // name = RollbackError
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_RollbackError (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_RollbackError),
    (char *) &_oc_Components_Transaction_RollbackError,
    0,
    sizeof (Components::Transaction::RollbackError)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_RollbackError, &_tc_TAO_tc_Components_Transaction_RollbackError)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::RollbackError::_type (void) const
{
  return ::Components::Transaction::_tc_RollbackError;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::HeuristicMixed::HeuristicMixed (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/HeuristicMixed:1.0",
        "HeuristicMixed"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::HeuristicMixed::~HeuristicMixed (void)
{
}

// Copy constructor.
Components::Transaction::HeuristicMixed::HeuristicMixed (const ::Components::Transaction::HeuristicMixed &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::HeuristicMixed&
Components::Transaction::HeuristicMixed::operator= (const ::Components::Transaction::HeuristicMixed &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::HeuristicMixed::_tao_any_destructor (void *_tao_void_pointer)
{
  HeuristicMixed *tmp = ACE_static_cast (HeuristicMixed*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::HeuristicMixed *
Components::Transaction::HeuristicMixed::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/HeuristicMixed:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (HeuristicMixed *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::HeuristicMixed::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::HeuristicMixed, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::HeuristicMixed::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::HeuristicMixed (*this),
      0
    );
  return result;
}

void Components::Transaction::HeuristicMixed::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::HeuristicMixed::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::HeuristicMixed::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_HeuristicMixed[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f48), 
  ACE_NTOHL (0x65757269), 
  ACE_NTOHL (0x73746963), 
  ACE_NTOHL (0x4d697865), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Transaction/HeuristicMixed:1.0
  15,
  ACE_NTOHL (0x48657572), 
  ACE_NTOHL (0x69737469), 
  ACE_NTOHL (0x634d6978), 
  ACE_NTOHL (0x65640000),  // name = HeuristicMixed
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_HeuristicMixed (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_HeuristicMixed),
    (char *) &_oc_Components_Transaction_HeuristicMixed,
    0,
    sizeof (Components::Transaction::HeuristicMixed)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_HeuristicMixed, &_tc_TAO_tc_Components_Transaction_HeuristicMixed)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::HeuristicMixed::_type (void) const
{
  return ::Components::Transaction::_tc_HeuristicMixed;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::HeuristicRollback::HeuristicRollback (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/HeuristicRollback:1.0",
        "HeuristicRollback"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::HeuristicRollback::~HeuristicRollback (void)
{
}

// Copy constructor.
Components::Transaction::HeuristicRollback::HeuristicRollback (const ::Components::Transaction::HeuristicRollback &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::HeuristicRollback&
Components::Transaction::HeuristicRollback::operator= (const ::Components::Transaction::HeuristicRollback &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::HeuristicRollback::_tao_any_destructor (void *_tao_void_pointer)
{
  HeuristicRollback *tmp = ACE_static_cast (HeuristicRollback*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::HeuristicRollback *
Components::Transaction::HeuristicRollback::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/HeuristicRollback:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (HeuristicRollback *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::HeuristicRollback::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::HeuristicRollback, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::HeuristicRollback::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::HeuristicRollback (*this),
      0
    );
  return result;
}

void Components::Transaction::HeuristicRollback::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::HeuristicRollback::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::HeuristicRollback::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_HeuristicRollback[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  57,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f48), 
  ACE_NTOHL (0x65757269), 
  ACE_NTOHL (0x73746963), 
  ACE_NTOHL (0x526f6c6c), 
  ACE_NTOHL (0x6261636b), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/Transaction/HeuristicRollback:1.0
  18,
  ACE_NTOHL (0x48657572), 
  ACE_NTOHL (0x69737469), 
  ACE_NTOHL (0x63526f6c), 
  ACE_NTOHL (0x6c626163), 
  ACE_NTOHL (0x6b000000),  // name = HeuristicRollback
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_HeuristicRollback (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_HeuristicRollback),
    (char *) &_oc_Components_Transaction_HeuristicRollback,
    0,
    sizeof (Components::Transaction::HeuristicRollback)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_HeuristicRollback, &_tc_TAO_tc_Components_Transaction_HeuristicRollback)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::HeuristicRollback::_type (void) const
{
  return ::Components::Transaction::_tc_HeuristicRollback;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::Security::Security (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/Security:1.0",
        "Security"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::Security::~Security (void)
{
}

// Copy constructor.
Components::Transaction::Security::Security (const ::Components::Transaction::Security &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::Security&
Components::Transaction::Security::operator= (const ::Components::Transaction::Security &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::Security::_tao_any_destructor (void *_tao_void_pointer)
{
  Security *tmp = ACE_static_cast (Security*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::Security *
Components::Transaction::Security::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/Security:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (Security *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::Security::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::Security, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::Security::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::Security (*this),
      0
    );
  return result;
}

void Components::Transaction::Security::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::Security::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::Security::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_Security[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f53), 
  ACE_NTOHL (0x65637572), 
  ACE_NTOHL (0x6974793a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Transaction/Security:1.0
  9,
  ACE_NTOHL (0x53656375), 
  ACE_NTOHL (0x72697479), 
  ACE_NTOHL (0x0),  // name = Security
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_Security (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_Security),
    (char *) &_oc_Components_Transaction_Security,
    0,
    sizeof (Components::Transaction::Security)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Security, &_tc_TAO_tc_Components_Transaction_Security)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::Security::_type (void) const
{
  return ::Components::Transaction::_tc_Security;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Transaction::InvalidToken::InvalidToken (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Transaction/InvalidToken:1.0",
        "InvalidToken"
      )
{
}

// Destructor - all members are of self managing types.
Components::Transaction::InvalidToken::~InvalidToken (void)
{
}

// Copy constructor.
Components::Transaction::InvalidToken::InvalidToken (const ::Components::Transaction::InvalidToken &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Transaction::InvalidToken&
Components::Transaction::InvalidToken::operator= (const ::Components::Transaction::InvalidToken &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::InvalidToken::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidToken *tmp = ACE_static_cast (InvalidToken*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::InvalidToken *
Components::Transaction::InvalidToken::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Transaction/InvalidToken:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidToken *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::InvalidToken::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::InvalidToken, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::InvalidToken::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::InvalidToken (*this),
      0
    );
  return result;
}

void Components::Transaction::InvalidToken::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Transaction::InvalidToken::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::InvalidToken::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Transaction_InvalidToken[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964546f), 
  ACE_NTOHL (0x6b656e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Transaction/InvalidToken:1.0
  13,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696454), 
  ACE_NTOHL (0x6f6b656e), 
  ACE_NTOHL (0x0),  // name = InvalidToken
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_InvalidToken (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_InvalidToken),
    (char *) &_oc_Components_Transaction_InvalidToken,
    0,
    sizeof (Components::Transaction::InvalidToken)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidToken, &_tc_TAO_tc_Components_Transaction_InvalidToken)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::InvalidToken::_type (void) const
{
  return ::Components::Transaction::_tc_InvalidToken;
}

static const CORBA::Long _oc_Components_Transaction_Status[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f53), 
  ACE_NTOHL (0x74617475), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Transaction/Status:1.0
  7,
  ACE_NTOHL (0x53746174), 
  ACE_NTOHL (0x75730000),  // name = Status
  9, // member count
  7,
  ACE_NTOHL (0x41435449), 
  ACE_NTOHL (0x56450000),  // name = ACTIVE
  16,
  ACE_NTOHL (0x4d41524b), 
  ACE_NTOHL (0x45445f52), 
  ACE_NTOHL (0x4f4c4c42), 
  ACE_NTOHL (0x41434b00),  // name = MARKED_ROLLBACK
  9,
  ACE_NTOHL (0x50524550), 
  ACE_NTOHL (0x41524544), 
  ACE_NTOHL (0x0),  // name = PREPARED
  10,
  ACE_NTOHL (0x434f4d4d), 
  ACE_NTOHL (0x49545445), 
  ACE_NTOHL (0x44000000),  // name = COMMITTED
  12,
  ACE_NTOHL (0x524f4c4c), 
  ACE_NTOHL (0x45445f42), 
  ACE_NTOHL (0x41434b00),  // name = ROLLED_BACK
  15,
  ACE_NTOHL (0x4e4f5f54), 
  ACE_NTOHL (0x52414e53), 
  ACE_NTOHL (0x41435449), 
  ACE_NTOHL (0x4f4e0000),  // name = NO_TRANSACTION
  10,
  ACE_NTOHL (0x50524550), 
  ACE_NTOHL (0x4152494e), 
  ACE_NTOHL (0x47000000),  // name = PREPARING
  11,
  ACE_NTOHL (0x434f4d4d), 
  ACE_NTOHL (0x49545449), 
  ACE_NTOHL (0x4e470000),  // name = COMMITTING
  13,
  ACE_NTOHL (0x524f4c4c), 
  ACE_NTOHL (0x494e475f), 
  ACE_NTOHL (0x4241434b), 
  ACE_NTOHL (0x0),  // name = ROLLING_BACK
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_Status (
    CORBA::tk_enum,
    sizeof (_oc_Components_Transaction_Status),
    (char *) &_oc_Components_Transaction_Status,
    0,
    sizeof (Components::Transaction::Status)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Status, &_tc_TAO_tc_Components_Transaction_Status)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Transaction::UserTransaction::_tao_class_id = 0;

Components::Transaction::UserTransaction_ptr
tao_Components_Transaction_UserTransaction_duplicate (
    Components::Transaction::UserTransaction_ptr p
  )
{
  return Components::Transaction::UserTransaction::_duplicate (p);
}

void
tao_Components_Transaction_UserTransaction_release (
    Components::Transaction::UserTransaction_ptr p
  )
{
  CORBA::release (p);
}

Components::Transaction::UserTransaction_ptr
tao_Components_Transaction_UserTransaction_nil (
    void
  )
{
  return Components::Transaction::UserTransaction::_nil ();
}

Components::Transaction::UserTransaction_ptr
tao_Components_Transaction_UserTransaction_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Transaction::UserTransaction::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Transaction_UserTransaction_upcast (
    void *src
  )
{
  Components::Transaction::UserTransaction **tmp =
    ACE_static_cast (Components::Transaction::UserTransaction **, src);
  return *tmp;
}

// *************************************************************
// Components::Transaction::UserTransaction_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Transaction::UserTransaction_var::UserTransaction_var (void) // default constructor
  : ptr_ (UserTransaction::_nil ())
{}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::ptr (void) const
{
  return this->ptr_;
}

Components::Transaction::UserTransaction_var::UserTransaction_var (const ::Components::Transaction::UserTransaction_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (UserTransaction::_duplicate (p.ptr ()))
{}

Components::Transaction::UserTransaction_var::~UserTransaction_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Transaction::UserTransaction_var &
Components::Transaction::UserTransaction_var::operator= (UserTransaction_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Transaction::UserTransaction_var &
Components::Transaction::UserTransaction_var::operator= (const ::Components::Transaction::UserTransaction_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Transaction::UserTransaction::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Transaction::UserTransaction_var::operator const ::Components::Transaction::UserTransaction_ptr &() const // cast
{
  return this->ptr_;
}

Components::Transaction::UserTransaction_var::operator ::Components::Transaction::UserTransaction_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::in (void) const
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr &
Components::Transaction::UserTransaction_var::inout (void)
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr &
Components::Transaction::UserTransaction_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Transaction::UserTransaction_ptr val = this->ptr_;
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
  return val;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::tao_duplicate (UserTransaction_ptr p)
{
  return ::Components::Transaction::UserTransaction::_duplicate (p);
}

void
Components::Transaction::UserTransaction_var::tao_release (UserTransaction_ptr p)
{
  CORBA::release (p);
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::tao_nil (void)
{
  return ::Components::Transaction::UserTransaction::_nil ();
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Transaction::UserTransaction::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Transaction::UserTransaction_var::tao_upcast (void *src)
{
  UserTransaction **tmp =
    ACE_static_cast (UserTransaction **, src);
  return *tmp;
}

// *************************************************************
// Components::Transaction::UserTransaction_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Transaction::UserTransaction_out::UserTransaction_out (UserTransaction_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
}

Components::Transaction::UserTransaction_out::UserTransaction_out (UserTransaction_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
}

Components::Transaction::UserTransaction_out::UserTransaction_out (const ::Components::Transaction::UserTransaction_out &p) // copy constructor
  : ptr_ (ACE_const_cast (UserTransaction_out &, p).ptr_)
{}

::Components::Transaction::UserTransaction_out &
Components::Transaction::UserTransaction_out::operator= (const ::Components::Transaction::UserTransaction_out &p)
{
  this->ptr_ = ACE_const_cast (UserTransaction_out&, p).ptr_;
  return *this;
}

Components::Transaction::UserTransaction_out &
Components::Transaction::UserTransaction_out::operator= (const ::Components::Transaction::UserTransaction_var &p)
{
  this->ptr_ = ::Components::Transaction::UserTransaction::_duplicate (p.ptr ());
  return *this;
}

Components::Transaction::UserTransaction_out &
Components::Transaction::UserTransaction_out::operator= (UserTransaction_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Transaction::UserTransaction_out::operator ::Components::Transaction::UserTransaction_ptr &() // cast
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr &
Components::Transaction::UserTransaction_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Transaction::UserTransaction::UserTransaction (void)
{}

Components::Transaction::UserTransaction::~UserTransaction (void)
{}

void Components::Transaction::UserTransaction::_tao_any_destructor (void *_tao_void_pointer)
{
  UserTransaction *tmp = ACE_static_cast (UserTransaction*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Transaction::UserTransaction_ptr Components::Transaction::UserTransaction::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return UserTransaction::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Transaction::UserTransaction_ptr 
Components::Transaction::UserTransaction::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return UserTransaction::_nil ();
  return
      ACE_reinterpret_cast
        (
          UserTransaction_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &UserTransaction::_tao_class_id
                  )
              )
        );
}

Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction::_duplicate (UserTransaction_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::Transaction::UserTransaction::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components::Transaction, UserTransaction)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Transaction::UserTransaction::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Transaction/UserTransaction:1.0";
}

static const CORBA::Long _oc_Components_Transaction_UserTransaction[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f55), 
  ACE_NTOHL (0x73657254), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Transaction/UserTransaction:1.0
  16,
  ACE_NTOHL (0x55736572), 
  ACE_NTOHL (0x5472616e), 
  ACE_NTOHL (0x73616374), 
  ACE_NTOHL (0x696f6e00),  // name = UserTransaction
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_UserTransaction (
    CORBA::tk_objref,
    sizeof (_oc_Components_Transaction_UserTransaction),
    (char *) &_oc_Components_Transaction_UserTransaction,
    0,
    sizeof (Components::Transaction::UserTransaction)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_UserTransaction, &_tc_TAO_tc_Components_Transaction_UserTransaction)
TAO_NAMESPACE_END
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_Principal[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x72696e63), 
  ACE_NTOHL (0x6970616c), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/Principal:1.0
  10,
  ACE_NTOHL (0x5072696e), 
  ACE_NTOHL (0x63697061), 
  ACE_NTOHL (0x6c000000),  // name = Principal
  CORBA::tk_objref, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    43,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x53656375), 
    ACE_NTOHL (0x72697479), 
    ACE_NTOHL (0x4c657665), 
    ACE_NTOHL (0x6c322f43), 
    ACE_NTOHL (0x72656465), 
    ACE_NTOHL (0x6e746961), 
    ACE_NTOHL (0x6c733a31), 
    ACE_NTOHL (0x2e380000),  // repository ID = IDL:omg.org/SecurityLevel2/Credentials:1.8
    12,
    ACE_NTOHL (0x43726564), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x616c7300),  // name = Credentials

};

static CORBA::TypeCode _tc_TAO_tc_Components_Principal (
    CORBA::tk_alias,
    sizeof (_oc_Components_Principal),
    (char *) &_oc_Components_Principal,
    0,
    sizeof (Components::Principal)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Principal, &_tc_TAO_tc_Components_Principal)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::CCMContext::_tao_class_id = 0;

Components::CCMContext_ptr
tao_Components_CCMContext_duplicate (
    Components::CCMContext_ptr p
  )
{
  return Components::CCMContext::_duplicate (p);
}

void
tao_Components_CCMContext_release (
    Components::CCMContext_ptr p
  )
{
  CORBA::release (p);
}

Components::CCMContext_ptr
tao_Components_CCMContext_nil (
    void
  )
{
  return Components::CCMContext::_nil ();
}

Components::CCMContext_ptr
tao_Components_CCMContext_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::CCMContext::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_CCMContext_upcast (
    void *src
  )
{
  Components::CCMContext **tmp =
    ACE_static_cast (Components::CCMContext **, src);
  return *tmp;
}

// *************************************************************
// Components::CCMContext_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::CCMContext_var::CCMContext_var (void) // default constructor
  : ptr_ (CCMContext::_nil ())
{}

::Components::CCMContext_ptr
Components::CCMContext_var::ptr (void) const
{
  return this->ptr_;
}

Components::CCMContext_var::CCMContext_var (const ::Components::CCMContext_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CCMContext::_duplicate (p.ptr ()))
{}

Components::CCMContext_var::~CCMContext_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::CCMContext_var &
Components::CCMContext_var::operator= (CCMContext_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::CCMContext_var &
Components::CCMContext_var::operator= (const ::Components::CCMContext_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::CCMContext::_duplicate (p.ptr ());
  }
  return *this;
}

Components::CCMContext_var::operator const ::Components::CCMContext_ptr &() const // cast
{
  return this->ptr_;
}

Components::CCMContext_var::operator ::Components::CCMContext_ptr &() // cast 
{
  return this->ptr_;
}

::Components::CCMContext_ptr
Components::CCMContext_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::CCMContext_ptr
Components::CCMContext_var::in (void) const
{
  return this->ptr_;
}

::Components::CCMContext_ptr &
Components::CCMContext_var::inout (void)
{
  return this->ptr_;
}

::Components::CCMContext_ptr &
Components::CCMContext_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMContext::_nil ();
  return this->ptr_;
}

::Components::CCMContext_ptr
Components::CCMContext_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::CCMContext_ptr val = this->ptr_;
  this->ptr_ = ::Components::CCMContext::_nil ();
  return val;
}

::Components::CCMContext_ptr
Components::CCMContext_var::tao_duplicate (CCMContext_ptr p)
{
  return ::Components::CCMContext::_duplicate (p);
}

void
Components::CCMContext_var::tao_release (CCMContext_ptr p)
{
  CORBA::release (p);
}

::Components::CCMContext_ptr
Components::CCMContext_var::tao_nil (void)
{
  return ::Components::CCMContext::_nil ();
}

::Components::CCMContext_ptr
Components::CCMContext_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::CCMContext::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::CCMContext_var::tao_upcast (void *src)
{
  CCMContext **tmp =
    ACE_static_cast (CCMContext **, src);
  return *tmp;
}

// *************************************************************
// Components::CCMContext_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::CCMContext_out::CCMContext_out (CCMContext_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::CCMContext::_nil ();
}

Components::CCMContext_out::CCMContext_out (CCMContext_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCMContext::_nil ();
}

Components::CCMContext_out::CCMContext_out (const ::Components::CCMContext_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CCMContext_out &, p).ptr_)
{}

::Components::CCMContext_out &
Components::CCMContext_out::operator= (const ::Components::CCMContext_out &p)
{
  this->ptr_ = ACE_const_cast (CCMContext_out&, p).ptr_;
  return *this;
}

Components::CCMContext_out &
Components::CCMContext_out::operator= (const ::Components::CCMContext_var &p)
{
  this->ptr_ = ::Components::CCMContext::_duplicate (p.ptr ());
  return *this;
}

Components::CCMContext_out &
Components::CCMContext_out::operator= (CCMContext_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::CCMContext_out::operator ::Components::CCMContext_ptr &() // cast
{
  return this->ptr_;
}

::Components::CCMContext_ptr &
Components::CCMContext_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::CCMContext_ptr
Components::CCMContext_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::CCMContext::CCMContext (void)
{}

Components::CCMContext::~CCMContext (void)
{}

void Components::CCMContext::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMContext *tmp = ACE_static_cast (CCMContext*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::CCMContext_ptr Components::CCMContext::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return CCMContext::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::CCMContext_ptr 
Components::CCMContext::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CCMContext::_nil ();
  return
      ACE_reinterpret_cast
        (
          CCMContext_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &CCMContext::_tao_class_id
                  )
              )
        );
}

Components::CCMContext_ptr
Components::CCMContext::_duplicate (CCMContext_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::CCMContext::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMContext)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::CCMContext::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/CCMContext:1.0";
}

static const CORBA::Long _oc_Components_CCMContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d436f), 
  ACE_NTOHL (0x6e746578), 
  ACE_NTOHL (0x743a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/CCMContext:1.0
  11,
  ACE_NTOHL (0x43434d43), 
  ACE_NTOHL (0x6f6e7465), 
  ACE_NTOHL (0x78740000),  // name = CCMContext
};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMContext (
    CORBA::tk_objref,
    sizeof (_oc_Components_CCMContext),
    (char *) &_oc_Components_CCMContext,
    0,
    sizeof (Components::CCMContext)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCMContext, &_tc_TAO_tc_Components_CCMContext)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_CCMExceptionReason[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d4578), 
  ACE_NTOHL (0x63657074), 
  ACE_NTOHL (0x696f6e52), 
  ACE_NTOHL (0x6561736f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/CCMExceptionReason:1.0
  19,
  ACE_NTOHL (0x43434d45), 
  ACE_NTOHL (0x78636570), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x52656173), 
  ACE_NTOHL (0x6f6e0000),  // name = CCMExceptionReason
  7, // member count
  13,
  ACE_NTOHL (0x53595354), 
  ACE_NTOHL (0x454d5f45), 
  ACE_NTOHL (0x52524f52), 
  ACE_NTOHL (0x0),  // name = SYSTEM_ERROR
  13,
  ACE_NTOHL (0x43524541), 
  ACE_NTOHL (0x54455f45), 
  ACE_NTOHL (0x52524f52), 
  ACE_NTOHL (0x0),  // name = CREATE_ERROR
  13,
  ACE_NTOHL (0x52454d4f), 
  ACE_NTOHL (0x56455f45), 
  ACE_NTOHL (0x52524f52), 
  ACE_NTOHL (0x0),  // name = REMOVE_ERROR
  14,
  ACE_NTOHL (0x4455504c), 
  ACE_NTOHL (0x49434154), 
  ACE_NTOHL (0x455f4b45), 
  ACE_NTOHL (0x59000000),  // name = DUPLICATE_KEY
  11,
  ACE_NTOHL (0x46494e44), 
  ACE_NTOHL (0x5f455252), 
  ACE_NTOHL (0x4f520000),  // name = FIND_ERROR
  17,
  ACE_NTOHL (0x4f424a45), 
  ACE_NTOHL (0x43545f4e), 
  ACE_NTOHL (0x4f545f46), 
  ACE_NTOHL (0x4f554e44), 
  ACE_NTOHL (0x0),  // name = OBJECT_NOT_FOUND
  15,
  ACE_NTOHL (0x4e4f5f53), 
  ACE_NTOHL (0x5543485f), 
  ACE_NTOHL (0x454e5449), 
  ACE_NTOHL (0x54590000),  // name = NO_SUCH_ENTITY
};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMExceptionReason (
    CORBA::tk_enum,
    sizeof (_oc_Components_CCMExceptionReason),
    (char *) &_oc_Components_CCMExceptionReason,
    0,
    sizeof (Components::CCMExceptionReason)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCMExceptionReason, &_tc_TAO_tc_Components_CCMExceptionReason)
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::CCMException::CCMException (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/CCMException:1.0",
        "CCMException"
      )
{
}

// Destructor - all members are of self managing types.
Components::CCMException::~CCMException (void)
{
}

// Copy constructor.
Components::CCMException::CCMException (const ::Components::CCMException &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

// Assignment operator.
Components::CCMException&
Components::CCMException::operator= (const ::Components::CCMException &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::CCMException::_tao_any_destructor (void *_tao_void_pointer)
{
  CCMException *tmp = ACE_static_cast (CCMException*, _tao_void_pointer);
  delete tmp;
}

Components::CCMException *
Components::CCMException::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/CCMException:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (CCMException *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::CCMException::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::CCMException, 0);
  return retval;
}

CORBA::Exception *
Components::CCMException::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::CCMException (*this),
      0
    );
  return result;
}

void Components::CCMException::_raise ()
{
  TAO_RAISE (*this);
}

void Components::CCMException::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::CCMException::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::CCMException::CCMException (
    Components::CCMExceptionReason _tao_reason
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/CCMException:1.0",
        "CCMException"
      )
{
  this->reason = _tao_reason;
}

static const CORBA::Long _oc_Components_CCMException[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d4578), 
  ACE_NTOHL (0x63657074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/CCMException:1.0
  13,
  ACE_NTOHL (0x43434d45), 
  ACE_NTOHL (0x78636570), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = CCMException
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_enum, // typecode kind
  224, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    46,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f43), 
    ACE_NTOHL (0x434d4578), 
    ACE_NTOHL (0x63657074), 
    ACE_NTOHL (0x696f6e52), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e3a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/CCMExceptionReason:1.0
    19,
    ACE_NTOHL (0x43434d45), 
    ACE_NTOHL (0x78636570), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x52656173), 
    ACE_NTOHL (0x6f6e0000),  // name = CCMExceptionReason
    7, // member count
    13,
    ACE_NTOHL (0x53595354), 
    ACE_NTOHL (0x454d5f45), 
    ACE_NTOHL (0x52524f52), 
    ACE_NTOHL (0x0),  // name = SYSTEM_ERROR
    13,
    ACE_NTOHL (0x43524541), 
    ACE_NTOHL (0x54455f45), 
    ACE_NTOHL (0x52524f52), 
    ACE_NTOHL (0x0),  // name = CREATE_ERROR
    13,
    ACE_NTOHL (0x52454d4f), 
    ACE_NTOHL (0x56455f45), 
    ACE_NTOHL (0x52524f52), 
    ACE_NTOHL (0x0),  // name = REMOVE_ERROR
    14,
    ACE_NTOHL (0x4455504c), 
    ACE_NTOHL (0x49434154), 
    ACE_NTOHL (0x455f4b45), 
    ACE_NTOHL (0x59000000),  // name = DUPLICATE_KEY
    11,
    ACE_NTOHL (0x46494e44), 
    ACE_NTOHL (0x5f455252), 
    ACE_NTOHL (0x4f520000),  // name = FIND_ERROR
    17,
    ACE_NTOHL (0x4f424a45), 
    ACE_NTOHL (0x43545f4e), 
    ACE_NTOHL (0x4f545f46), 
    ACE_NTOHL (0x4f554e44), 
    ACE_NTOHL (0x0),  // name = OBJECT_NOT_FOUND
    15,
    ACE_NTOHL (0x4e4f5f53), 
    ACE_NTOHL (0x5543485f), 
    ACE_NTOHL (0x454e5449), 
    ACE_NTOHL (0x54590000),  // name = NO_SUCH_ENTITY

};

static CORBA::TypeCode _tc_TAO_tc_Components_CCMException (
    CORBA::tk_except,
    sizeof (_oc_Components_CCMException),
    (char *) &_oc_Components_CCMException,
    0,
    sizeof (Components::CCMException)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCMException, &_tc_TAO_tc_Components_CCMException)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::CCMException::_type (void) const
{
  return ::Components::_tc_CCMException;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::EnterpriseComponent::_tao_class_id = 0;

Components::EnterpriseComponent_ptr
tao_Components_EnterpriseComponent_duplicate (
    Components::EnterpriseComponent_ptr p
  )
{
  return Components::EnterpriseComponent::_duplicate (p);
}

void
tao_Components_EnterpriseComponent_release (
    Components::EnterpriseComponent_ptr p
  )
{
  CORBA::release (p);
}

Components::EnterpriseComponent_ptr
tao_Components_EnterpriseComponent_nil (
    void
  )
{
  return Components::EnterpriseComponent::_nil ();
}

Components::EnterpriseComponent_ptr
tao_Components_EnterpriseComponent_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::EnterpriseComponent::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_EnterpriseComponent_upcast (
    void *src
  )
{
  Components::EnterpriseComponent **tmp =
    ACE_static_cast (Components::EnterpriseComponent **, src);
  return *tmp;
}

// *************************************************************
// Components::EnterpriseComponent_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::EnterpriseComponent_var::EnterpriseComponent_var (void) // default constructor
  : ptr_ (EnterpriseComponent::_nil ())
{}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_var::ptr (void) const
{
  return this->ptr_;
}

Components::EnterpriseComponent_var::EnterpriseComponent_var (const ::Components::EnterpriseComponent_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EnterpriseComponent::_duplicate (p.ptr ()))
{}

Components::EnterpriseComponent_var::~EnterpriseComponent_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::EnterpriseComponent_var &
Components::EnterpriseComponent_var::operator= (EnterpriseComponent_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EnterpriseComponent_var &
Components::EnterpriseComponent_var::operator= (const ::Components::EnterpriseComponent_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::EnterpriseComponent::_duplicate (p.ptr ());
  }
  return *this;
}

Components::EnterpriseComponent_var::operator const ::Components::EnterpriseComponent_ptr &() const // cast
{
  return this->ptr_;
}

Components::EnterpriseComponent_var::operator ::Components::EnterpriseComponent_ptr &() // cast 
{
  return this->ptr_;
}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_var::in (void) const
{
  return this->ptr_;
}

::Components::EnterpriseComponent_ptr &
Components::EnterpriseComponent_var::inout (void)
{
  return this->ptr_;
}

::Components::EnterpriseComponent_ptr &
Components::EnterpriseComponent_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EnterpriseComponent::_nil ();
  return this->ptr_;
}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::EnterpriseComponent_ptr val = this->ptr_;
  this->ptr_ = ::Components::EnterpriseComponent::_nil ();
  return val;
}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_var::tao_duplicate (EnterpriseComponent_ptr p)
{
  return ::Components::EnterpriseComponent::_duplicate (p);
}

void
Components::EnterpriseComponent_var::tao_release (EnterpriseComponent_ptr p)
{
  CORBA::release (p);
}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_var::tao_nil (void)
{
  return ::Components::EnterpriseComponent::_nil ();
}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::EnterpriseComponent::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::EnterpriseComponent_var::tao_upcast (void *src)
{
  EnterpriseComponent **tmp =
    ACE_static_cast (EnterpriseComponent **, src);
  return *tmp;
}

// *************************************************************
// Components::EnterpriseComponent_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::EnterpriseComponent_out::EnterpriseComponent_out (EnterpriseComponent_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::EnterpriseComponent::_nil ();
}

Components::EnterpriseComponent_out::EnterpriseComponent_out (EnterpriseComponent_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EnterpriseComponent::_nil ();
}

Components::EnterpriseComponent_out::EnterpriseComponent_out (const ::Components::EnterpriseComponent_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EnterpriseComponent_out &, p).ptr_)
{}

::Components::EnterpriseComponent_out &
Components::EnterpriseComponent_out::operator= (const ::Components::EnterpriseComponent_out &p)
{
  this->ptr_ = ACE_const_cast (EnterpriseComponent_out&, p).ptr_;
  return *this;
}

Components::EnterpriseComponent_out &
Components::EnterpriseComponent_out::operator= (const ::Components::EnterpriseComponent_var &p)
{
  this->ptr_ = ::Components::EnterpriseComponent::_duplicate (p.ptr ());
  return *this;
}

Components::EnterpriseComponent_out &
Components::EnterpriseComponent_out::operator= (EnterpriseComponent_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::EnterpriseComponent_out::operator ::Components::EnterpriseComponent_ptr &() // cast
{
  return this->ptr_;
}

::Components::EnterpriseComponent_ptr &
Components::EnterpriseComponent_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::EnterpriseComponent_ptr
Components::EnterpriseComponent_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::EnterpriseComponent::EnterpriseComponent (void)
{}

Components::EnterpriseComponent::~EnterpriseComponent (void)
{}

void Components::EnterpriseComponent::_tao_any_destructor (void *_tao_void_pointer)
{
  EnterpriseComponent *tmp = ACE_static_cast (EnterpriseComponent*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::EnterpriseComponent_ptr Components::EnterpriseComponent::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return EnterpriseComponent::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::EnterpriseComponent_ptr 
Components::EnterpriseComponent::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return EnterpriseComponent::_nil ();
  return
      ACE_reinterpret_cast
        (
          EnterpriseComponent_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &EnterpriseComponent::_tao_class_id
                  )
              )
        );
}

Components::EnterpriseComponent_ptr
Components::EnterpriseComponent::_duplicate (EnterpriseComponent_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::EnterpriseComponent::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, EnterpriseComponent)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::EnterpriseComponent::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/EnterpriseComponent:1.0";
}

static const CORBA::Long _oc_Components_EnterpriseComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6e746572), 
  ACE_NTOHL (0x70726973), 
  ACE_NTOHL (0x65436f6d), 
  ACE_NTOHL (0x706f6e65), 
  ACE_NTOHL (0x6e743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/EnterpriseComponent:1.0
  20,
  ACE_NTOHL (0x456e7465), 
  ACE_NTOHL (0x72707269), 
  ACE_NTOHL (0x7365436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7400),  // name = EnterpriseComponent
};

static CORBA::TypeCode _tc_TAO_tc_Components_EnterpriseComponent (
    CORBA::tk_objref,
    sizeof (_oc_Components_EnterpriseComponent),
    (char *) &_oc_Components_EnterpriseComponent,
    0,
    sizeof (Components::EnterpriseComponent)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_EnterpriseComponent, &_tc_TAO_tc_Components_EnterpriseComponent)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::SessionContext::_tao_class_id = 0;

Components::SessionContext_ptr
tao_Components_SessionContext_duplicate (
    Components::SessionContext_ptr p
  )
{
  return Components::SessionContext::_duplicate (p);
}

void
tao_Components_SessionContext_release (
    Components::SessionContext_ptr p
  )
{
  CORBA::release (p);
}

Components::SessionContext_ptr
tao_Components_SessionContext_nil (
    void
  )
{
  return Components::SessionContext::_nil ();
}

Components::SessionContext_ptr
tao_Components_SessionContext_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::SessionContext::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_SessionContext_upcast (
    void *src
  )
{
  Components::SessionContext **tmp =
    ACE_static_cast (Components::SessionContext **, src);
  return *tmp;
}

// *************************************************************
// Components::SessionContext_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::SessionContext_var::SessionContext_var (void) // default constructor
  : ptr_ (SessionContext::_nil ())
{}

::Components::SessionContext_ptr
Components::SessionContext_var::ptr (void) const
{
  return this->ptr_;
}

Components::SessionContext_var::SessionContext_var (const ::Components::SessionContext_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (SessionContext::_duplicate (p.ptr ()))
{}

Components::SessionContext_var::~SessionContext_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::SessionContext_var &
Components::SessionContext_var::operator= (SessionContext_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::SessionContext_var &
Components::SessionContext_var::operator= (const ::Components::SessionContext_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::SessionContext::_duplicate (p.ptr ());
  }
  return *this;
}

Components::SessionContext_var::operator const ::Components::SessionContext_ptr &() const // cast
{
  return this->ptr_;
}

Components::SessionContext_var::operator ::Components::SessionContext_ptr &() // cast 
{
  return this->ptr_;
}

::Components::SessionContext_ptr
Components::SessionContext_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::SessionContext_ptr
Components::SessionContext_var::in (void) const
{
  return this->ptr_;
}

::Components::SessionContext_ptr &
Components::SessionContext_var::inout (void)
{
  return this->ptr_;
}

::Components::SessionContext_ptr &
Components::SessionContext_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::SessionContext::_nil ();
  return this->ptr_;
}

::Components::SessionContext_ptr
Components::SessionContext_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::SessionContext_ptr val = this->ptr_;
  this->ptr_ = ::Components::SessionContext::_nil ();
  return val;
}

::Components::SessionContext_ptr
Components::SessionContext_var::tao_duplicate (SessionContext_ptr p)
{
  return ::Components::SessionContext::_duplicate (p);
}

void
Components::SessionContext_var::tao_release (SessionContext_ptr p)
{
  CORBA::release (p);
}

::Components::SessionContext_ptr
Components::SessionContext_var::tao_nil (void)
{
  return ::Components::SessionContext::_nil ();
}

::Components::SessionContext_ptr
Components::SessionContext_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::SessionContext::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::SessionContext_var::tao_upcast (void *src)
{
  SessionContext **tmp =
    ACE_static_cast (SessionContext **, src);
  return *tmp;
}

// *************************************************************
// Components::SessionContext_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::SessionContext_out::SessionContext_out (SessionContext_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::SessionContext::_nil ();
}

Components::SessionContext_out::SessionContext_out (SessionContext_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::SessionContext::_nil ();
}

Components::SessionContext_out::SessionContext_out (const ::Components::SessionContext_out &p) // copy constructor
  : ptr_ (ACE_const_cast (SessionContext_out &, p).ptr_)
{}

::Components::SessionContext_out &
Components::SessionContext_out::operator= (const ::Components::SessionContext_out &p)
{
  this->ptr_ = ACE_const_cast (SessionContext_out&, p).ptr_;
  return *this;
}

Components::SessionContext_out &
Components::SessionContext_out::operator= (const ::Components::SessionContext_var &p)
{
  this->ptr_ = ::Components::SessionContext::_duplicate (p.ptr ());
  return *this;
}

Components::SessionContext_out &
Components::SessionContext_out::operator= (SessionContext_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::SessionContext_out::operator ::Components::SessionContext_ptr &() // cast
{
  return this->ptr_;
}

::Components::SessionContext_ptr &
Components::SessionContext_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::SessionContext_ptr
Components::SessionContext_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::SessionContext::SessionContext (void)
{}

Components::SessionContext::~SessionContext (void)
{}

void Components::SessionContext::_tao_any_destructor (void *_tao_void_pointer)
{
  SessionContext *tmp = ACE_static_cast (SessionContext*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::SessionContext_ptr Components::SessionContext::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return SessionContext::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::SessionContext_ptr 
Components::SessionContext::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return SessionContext::_nil ();
  return
      ACE_reinterpret_cast
        (
          SessionContext_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &SessionContext::_tao_class_id
                  )
              )
        );
}

Components::SessionContext_ptr
Components::SessionContext::_duplicate (SessionContext_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::SessionContext::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, SessionContext)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMContext)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCMContext_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::SessionContext::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/SessionContext:1.0";
}

static const CORBA::Long _oc_Components_SessionContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x65737369), 
  ACE_NTOHL (0x6f6e436f), 
  ACE_NTOHL (0x6e746578), 
  ACE_NTOHL (0x743a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/SessionContext:1.0
  15,
  ACE_NTOHL (0x53657373), 
  ACE_NTOHL (0x696f6e43), 
  ACE_NTOHL (0x6f6e7465), 
  ACE_NTOHL (0x78740000),  // name = SessionContext
};

static CORBA::TypeCode _tc_TAO_tc_Components_SessionContext (
    CORBA::tk_objref,
    sizeof (_oc_Components_SessionContext),
    (char *) &_oc_Components_SessionContext,
    0,
    sizeof (Components::SessionContext)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SessionContext, &_tc_TAO_tc_Components_SessionContext)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::SessionComponent::_tao_class_id = 0;

Components::SessionComponent_ptr
tao_Components_SessionComponent_duplicate (
    Components::SessionComponent_ptr p
  )
{
  return Components::SessionComponent::_duplicate (p);
}

void
tao_Components_SessionComponent_release (
    Components::SessionComponent_ptr p
  )
{
  CORBA::release (p);
}

Components::SessionComponent_ptr
tao_Components_SessionComponent_nil (
    void
  )
{
  return Components::SessionComponent::_nil ();
}

Components::SessionComponent_ptr
tao_Components_SessionComponent_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::SessionComponent::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_SessionComponent_upcast (
    void *src
  )
{
  Components::SessionComponent **tmp =
    ACE_static_cast (Components::SessionComponent **, src);
  return *tmp;
}

// *************************************************************
// Components::SessionComponent_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::SessionComponent_var::SessionComponent_var (void) // default constructor
  : ptr_ (SessionComponent::_nil ())
{}

::Components::SessionComponent_ptr
Components::SessionComponent_var::ptr (void) const
{
  return this->ptr_;
}

Components::SessionComponent_var::SessionComponent_var (const ::Components::SessionComponent_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (SessionComponent::_duplicate (p.ptr ()))
{}

Components::SessionComponent_var::~SessionComponent_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::SessionComponent_var &
Components::SessionComponent_var::operator= (SessionComponent_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::SessionComponent_var &
Components::SessionComponent_var::operator= (const ::Components::SessionComponent_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::SessionComponent::_duplicate (p.ptr ());
  }
  return *this;
}

Components::SessionComponent_var::operator const ::Components::SessionComponent_ptr &() const // cast
{
  return this->ptr_;
}

Components::SessionComponent_var::operator ::Components::SessionComponent_ptr &() // cast 
{
  return this->ptr_;
}

::Components::SessionComponent_ptr
Components::SessionComponent_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::SessionComponent_ptr
Components::SessionComponent_var::in (void) const
{
  return this->ptr_;
}

::Components::SessionComponent_ptr &
Components::SessionComponent_var::inout (void)
{
  return this->ptr_;
}

::Components::SessionComponent_ptr &
Components::SessionComponent_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::SessionComponent::_nil ();
  return this->ptr_;
}

::Components::SessionComponent_ptr
Components::SessionComponent_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::SessionComponent_ptr val = this->ptr_;
  this->ptr_ = ::Components::SessionComponent::_nil ();
  return val;
}

::Components::SessionComponent_ptr
Components::SessionComponent_var::tao_duplicate (SessionComponent_ptr p)
{
  return ::Components::SessionComponent::_duplicate (p);
}

void
Components::SessionComponent_var::tao_release (SessionComponent_ptr p)
{
  CORBA::release (p);
}

::Components::SessionComponent_ptr
Components::SessionComponent_var::tao_nil (void)
{
  return ::Components::SessionComponent::_nil ();
}

::Components::SessionComponent_ptr
Components::SessionComponent_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::SessionComponent::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::SessionComponent_var::tao_upcast (void *src)
{
  SessionComponent **tmp =
    ACE_static_cast (SessionComponent **, src);
  return *tmp;
}

// *************************************************************
// Components::SessionComponent_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::SessionComponent_out::SessionComponent_out (SessionComponent_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::SessionComponent::_nil ();
}

Components::SessionComponent_out::SessionComponent_out (SessionComponent_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::SessionComponent::_nil ();
}

Components::SessionComponent_out::SessionComponent_out (const ::Components::SessionComponent_out &p) // copy constructor
  : ptr_ (ACE_const_cast (SessionComponent_out &, p).ptr_)
{}

::Components::SessionComponent_out &
Components::SessionComponent_out::operator= (const ::Components::SessionComponent_out &p)
{
  this->ptr_ = ACE_const_cast (SessionComponent_out&, p).ptr_;
  return *this;
}

Components::SessionComponent_out &
Components::SessionComponent_out::operator= (const ::Components::SessionComponent_var &p)
{
  this->ptr_ = ::Components::SessionComponent::_duplicate (p.ptr ());
  return *this;
}

Components::SessionComponent_out &
Components::SessionComponent_out::operator= (SessionComponent_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::SessionComponent_out::operator ::Components::SessionComponent_ptr &() // cast
{
  return this->ptr_;
}

::Components::SessionComponent_ptr &
Components::SessionComponent_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::SessionComponent_ptr
Components::SessionComponent_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::SessionComponent::SessionComponent (void)
{}

Components::SessionComponent::~SessionComponent (void)
{}

void Components::SessionComponent::_tao_any_destructor (void *_tao_void_pointer)
{
  SessionComponent *tmp = ACE_static_cast (SessionComponent*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::SessionComponent_ptr Components::SessionComponent::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return SessionComponent::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::SessionComponent_ptr 
Components::SessionComponent::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return SessionComponent::_nil ();
  return
      ACE_reinterpret_cast
        (
          SessionComponent_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &SessionComponent::_tao_class_id
                  )
              )
        );
}

Components::SessionComponent_ptr
Components::SessionComponent::_duplicate (SessionComponent_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::SessionComponent::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, SessionComponent)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, EnterpriseComponent)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::EnterpriseComponent_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::SessionComponent::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/SessionComponent:1.0";
}

static const CORBA::Long _oc_Components_SessionComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x65737369), 
  ACE_NTOHL (0x6f6e436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e743a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/SessionComponent:1.0
  17,
  ACE_NTOHL (0x53657373), 
  ACE_NTOHL (0x696f6e43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x0),  // name = SessionComponent
};

static CORBA::TypeCode _tc_TAO_tc_Components_SessionComponent (
    CORBA::tk_objref,
    sizeof (_oc_Components_SessionComponent),
    (char *) &_oc_Components_SessionComponent,
    0,
    sizeof (Components::SessionComponent)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SessionComponent, &_tc_TAO_tc_Components_SessionComponent)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::SessionSynchronization::_tao_class_id = 0;

Components::SessionSynchronization_ptr
tao_Components_SessionSynchronization_duplicate (
    Components::SessionSynchronization_ptr p
  )
{
  return Components::SessionSynchronization::_duplicate (p);
}

void
tao_Components_SessionSynchronization_release (
    Components::SessionSynchronization_ptr p
  )
{
  CORBA::release (p);
}

Components::SessionSynchronization_ptr
tao_Components_SessionSynchronization_nil (
    void
  )
{
  return Components::SessionSynchronization::_nil ();
}

Components::SessionSynchronization_ptr
tao_Components_SessionSynchronization_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::SessionSynchronization::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_SessionSynchronization_upcast (
    void *src
  )
{
  Components::SessionSynchronization **tmp =
    ACE_static_cast (Components::SessionSynchronization **, src);
  return *tmp;
}

// *************************************************************
// Components::SessionSynchronization_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::SessionSynchronization_var::SessionSynchronization_var (void) // default constructor
  : ptr_ (SessionSynchronization::_nil ())
{}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_var::ptr (void) const
{
  return this->ptr_;
}

Components::SessionSynchronization_var::SessionSynchronization_var (const ::Components::SessionSynchronization_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (SessionSynchronization::_duplicate (p.ptr ()))
{}

Components::SessionSynchronization_var::~SessionSynchronization_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::SessionSynchronization_var &
Components::SessionSynchronization_var::operator= (SessionSynchronization_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::SessionSynchronization_var &
Components::SessionSynchronization_var::operator= (const ::Components::SessionSynchronization_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::SessionSynchronization::_duplicate (p.ptr ());
  }
  return *this;
}

Components::SessionSynchronization_var::operator const ::Components::SessionSynchronization_ptr &() const // cast
{
  return this->ptr_;
}

Components::SessionSynchronization_var::operator ::Components::SessionSynchronization_ptr &() // cast 
{
  return this->ptr_;
}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_var::in (void) const
{
  return this->ptr_;
}

::Components::SessionSynchronization_ptr &
Components::SessionSynchronization_var::inout (void)
{
  return this->ptr_;
}

::Components::SessionSynchronization_ptr &
Components::SessionSynchronization_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::SessionSynchronization::_nil ();
  return this->ptr_;
}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::SessionSynchronization_ptr val = this->ptr_;
  this->ptr_ = ::Components::SessionSynchronization::_nil ();
  return val;
}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_var::tao_duplicate (SessionSynchronization_ptr p)
{
  return ::Components::SessionSynchronization::_duplicate (p);
}

void
Components::SessionSynchronization_var::tao_release (SessionSynchronization_ptr p)
{
  CORBA::release (p);
}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_var::tao_nil (void)
{
  return ::Components::SessionSynchronization::_nil ();
}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::SessionSynchronization::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::SessionSynchronization_var::tao_upcast (void *src)
{
  SessionSynchronization **tmp =
    ACE_static_cast (SessionSynchronization **, src);
  return *tmp;
}

// *************************************************************
// Components::SessionSynchronization_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::SessionSynchronization_out::SessionSynchronization_out (SessionSynchronization_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::SessionSynchronization::_nil ();
}

Components::SessionSynchronization_out::SessionSynchronization_out (SessionSynchronization_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::SessionSynchronization::_nil ();
}

Components::SessionSynchronization_out::SessionSynchronization_out (const ::Components::SessionSynchronization_out &p) // copy constructor
  : ptr_ (ACE_const_cast (SessionSynchronization_out &, p).ptr_)
{}

::Components::SessionSynchronization_out &
Components::SessionSynchronization_out::operator= (const ::Components::SessionSynchronization_out &p)
{
  this->ptr_ = ACE_const_cast (SessionSynchronization_out&, p).ptr_;
  return *this;
}

Components::SessionSynchronization_out &
Components::SessionSynchronization_out::operator= (const ::Components::SessionSynchronization_var &p)
{
  this->ptr_ = ::Components::SessionSynchronization::_duplicate (p.ptr ());
  return *this;
}

Components::SessionSynchronization_out &
Components::SessionSynchronization_out::operator= (SessionSynchronization_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::SessionSynchronization_out::operator ::Components::SessionSynchronization_ptr &() // cast
{
  return this->ptr_;
}

::Components::SessionSynchronization_ptr &
Components::SessionSynchronization_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::SessionSynchronization_ptr
Components::SessionSynchronization_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::SessionSynchronization::SessionSynchronization (void)
{}

Components::SessionSynchronization::~SessionSynchronization (void)
{}

void Components::SessionSynchronization::_tao_any_destructor (void *_tao_void_pointer)
{
  SessionSynchronization *tmp = ACE_static_cast (SessionSynchronization*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::SessionSynchronization_ptr Components::SessionSynchronization::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return SessionSynchronization::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::SessionSynchronization_ptr 
Components::SessionSynchronization::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return SessionSynchronization::_nil ();
  return
      ACE_reinterpret_cast
        (
          SessionSynchronization_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &SessionSynchronization::_tao_class_id
                  )
              )
        );
}

Components::SessionSynchronization_ptr
Components::SessionSynchronization::_duplicate (SessionSynchronization_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::SessionSynchronization::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, SessionSynchronization)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::SessionSynchronization::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/SessionSynchronization:1.0";
}

static const CORBA::Long _oc_Components_SessionSynchronization[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x65737369), 
  ACE_NTOHL (0x6f6e5379), 
  ACE_NTOHL (0x6e636872), 
  ACE_NTOHL (0x6f6e697a), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/SessionSynchronization:1.0
  23,
  ACE_NTOHL (0x53657373), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x796e6368), 
  ACE_NTOHL (0x726f6e69), 
  ACE_NTOHL (0x7a617469), 
  ACE_NTOHL (0x6f6e0000),  // name = SessionSynchronization
};

static CORBA::TypeCode _tc_TAO_tc_Components_SessionSynchronization (
    CORBA::tk_objref,
    sizeof (_oc_Components_SessionSynchronization),
    (char *) &_oc_Components_SessionSynchronization,
    0,
    sizeof (Components::SessionSynchronization)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SessionSynchronization, &_tc_TAO_tc_Components_SessionSynchronization)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::EntityContext::_tao_class_id = 0;

Components::EntityContext_ptr
tao_Components_EntityContext_duplicate (
    Components::EntityContext_ptr p
  )
{
  return Components::EntityContext::_duplicate (p);
}

void
tao_Components_EntityContext_release (
    Components::EntityContext_ptr p
  )
{
  CORBA::release (p);
}

Components::EntityContext_ptr
tao_Components_EntityContext_nil (
    void
  )
{
  return Components::EntityContext::_nil ();
}

Components::EntityContext_ptr
tao_Components_EntityContext_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::EntityContext::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_EntityContext_upcast (
    void *src
  )
{
  Components::EntityContext **tmp =
    ACE_static_cast (Components::EntityContext **, src);
  return *tmp;
}

// *************************************************************
// Components::EntityContext_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::EntityContext_var::EntityContext_var (void) // default constructor
  : ptr_ (EntityContext::_nil ())
{}

::Components::EntityContext_ptr
Components::EntityContext_var::ptr (void) const
{
  return this->ptr_;
}

Components::EntityContext_var::EntityContext_var (const ::Components::EntityContext_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EntityContext::_duplicate (p.ptr ()))
{}

Components::EntityContext_var::~EntityContext_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::EntityContext_var &
Components::EntityContext_var::operator= (EntityContext_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EntityContext_var &
Components::EntityContext_var::operator= (const ::Components::EntityContext_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::EntityContext::_duplicate (p.ptr ());
  }
  return *this;
}

Components::EntityContext_var::operator const ::Components::EntityContext_ptr &() const // cast
{
  return this->ptr_;
}

Components::EntityContext_var::operator ::Components::EntityContext_ptr &() // cast 
{
  return this->ptr_;
}

::Components::EntityContext_ptr
Components::EntityContext_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::EntityContext_ptr
Components::EntityContext_var::in (void) const
{
  return this->ptr_;
}

::Components::EntityContext_ptr &
Components::EntityContext_var::inout (void)
{
  return this->ptr_;
}

::Components::EntityContext_ptr &
Components::EntityContext_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EntityContext::_nil ();
  return this->ptr_;
}

::Components::EntityContext_ptr
Components::EntityContext_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::EntityContext_ptr val = this->ptr_;
  this->ptr_ = ::Components::EntityContext::_nil ();
  return val;
}

::Components::EntityContext_ptr
Components::EntityContext_var::tao_duplicate (EntityContext_ptr p)
{
  return ::Components::EntityContext::_duplicate (p);
}

void
Components::EntityContext_var::tao_release (EntityContext_ptr p)
{
  CORBA::release (p);
}

::Components::EntityContext_ptr
Components::EntityContext_var::tao_nil (void)
{
  return ::Components::EntityContext::_nil ();
}

::Components::EntityContext_ptr
Components::EntityContext_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::EntityContext::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::EntityContext_var::tao_upcast (void *src)
{
  EntityContext **tmp =
    ACE_static_cast (EntityContext **, src);
  return *tmp;
}

// *************************************************************
// Components::EntityContext_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::EntityContext_out::EntityContext_out (EntityContext_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::EntityContext::_nil ();
}

Components::EntityContext_out::EntityContext_out (EntityContext_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EntityContext::_nil ();
}

Components::EntityContext_out::EntityContext_out (const ::Components::EntityContext_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EntityContext_out &, p).ptr_)
{}

::Components::EntityContext_out &
Components::EntityContext_out::operator= (const ::Components::EntityContext_out &p)
{
  this->ptr_ = ACE_const_cast (EntityContext_out&, p).ptr_;
  return *this;
}

Components::EntityContext_out &
Components::EntityContext_out::operator= (const ::Components::EntityContext_var &p)
{
  this->ptr_ = ::Components::EntityContext::_duplicate (p.ptr ());
  return *this;
}

Components::EntityContext_out &
Components::EntityContext_out::operator= (EntityContext_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::EntityContext_out::operator ::Components::EntityContext_ptr &() // cast
{
  return this->ptr_;
}

::Components::EntityContext_ptr &
Components::EntityContext_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::EntityContext_ptr
Components::EntityContext_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::EntityContext::EntityContext (void)
{}

Components::EntityContext::~EntityContext (void)
{}

void Components::EntityContext::_tao_any_destructor (void *_tao_void_pointer)
{
  EntityContext *tmp = ACE_static_cast (EntityContext*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::EntityContext_ptr Components::EntityContext::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return EntityContext::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::EntityContext_ptr 
Components::EntityContext::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return EntityContext::_nil ();
  return
      ACE_reinterpret_cast
        (
          EntityContext_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &EntityContext::_tao_class_id
                  )
              )
        );
}

Components::EntityContext_ptr
Components::EntityContext::_duplicate (EntityContext_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::EntityContext::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, EntityContext)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMContext)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCMContext_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::EntityContext::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/EntityContext:1.0";
}

static const CORBA::Long _oc_Components_EntityContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6e746974), 
  ACE_NTOHL (0x79436f6e), 
  ACE_NTOHL (0x74657874), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/EntityContext:1.0
  14,
  ACE_NTOHL (0x456e7469), 
  ACE_NTOHL (0x7479436f), 
  ACE_NTOHL (0x6e746578), 
  ACE_NTOHL (0x74000000),  // name = EntityContext
};

static CORBA::TypeCode _tc_TAO_tc_Components_EntityContext (
    CORBA::tk_objref,
    sizeof (_oc_Components_EntityContext),
    (char *) &_oc_Components_EntityContext,
    0,
    sizeof (Components::EntityContext)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_EntityContext, &_tc_TAO_tc_Components_EntityContext)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::EntityComponent::_tao_class_id = 0;

Components::EntityComponent_ptr
tao_Components_EntityComponent_duplicate (
    Components::EntityComponent_ptr p
  )
{
  return Components::EntityComponent::_duplicate (p);
}

void
tao_Components_EntityComponent_release (
    Components::EntityComponent_ptr p
  )
{
  CORBA::release (p);
}

Components::EntityComponent_ptr
tao_Components_EntityComponent_nil (
    void
  )
{
  return Components::EntityComponent::_nil ();
}

Components::EntityComponent_ptr
tao_Components_EntityComponent_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::EntityComponent::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_EntityComponent_upcast (
    void *src
  )
{
  Components::EntityComponent **tmp =
    ACE_static_cast (Components::EntityComponent **, src);
  return *tmp;
}

// *************************************************************
// Components::EntityComponent_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::EntityComponent_var::EntityComponent_var (void) // default constructor
  : ptr_ (EntityComponent::_nil ())
{}

::Components::EntityComponent_ptr
Components::EntityComponent_var::ptr (void) const
{
  return this->ptr_;
}

Components::EntityComponent_var::EntityComponent_var (const ::Components::EntityComponent_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (EntityComponent::_duplicate (p.ptr ()))
{}

Components::EntityComponent_var::~EntityComponent_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::EntityComponent_var &
Components::EntityComponent_var::operator= (EntityComponent_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::EntityComponent_var &
Components::EntityComponent_var::operator= (const ::Components::EntityComponent_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::EntityComponent::_duplicate (p.ptr ());
  }
  return *this;
}

Components::EntityComponent_var::operator const ::Components::EntityComponent_ptr &() const // cast
{
  return this->ptr_;
}

Components::EntityComponent_var::operator ::Components::EntityComponent_ptr &() // cast 
{
  return this->ptr_;
}

::Components::EntityComponent_ptr
Components::EntityComponent_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::EntityComponent_ptr
Components::EntityComponent_var::in (void) const
{
  return this->ptr_;
}

::Components::EntityComponent_ptr &
Components::EntityComponent_var::inout (void)
{
  return this->ptr_;
}

::Components::EntityComponent_ptr &
Components::EntityComponent_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EntityComponent::_nil ();
  return this->ptr_;
}

::Components::EntityComponent_ptr
Components::EntityComponent_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::EntityComponent_ptr val = this->ptr_;
  this->ptr_ = ::Components::EntityComponent::_nil ();
  return val;
}

::Components::EntityComponent_ptr
Components::EntityComponent_var::tao_duplicate (EntityComponent_ptr p)
{
  return ::Components::EntityComponent::_duplicate (p);
}

void
Components::EntityComponent_var::tao_release (EntityComponent_ptr p)
{
  CORBA::release (p);
}

::Components::EntityComponent_ptr
Components::EntityComponent_var::tao_nil (void)
{
  return ::Components::EntityComponent::_nil ();
}

::Components::EntityComponent_ptr
Components::EntityComponent_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::EntityComponent::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::EntityComponent_var::tao_upcast (void *src)
{
  EntityComponent **tmp =
    ACE_static_cast (EntityComponent **, src);
  return *tmp;
}

// *************************************************************
// Components::EntityComponent_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::EntityComponent_out::EntityComponent_out (EntityComponent_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::EntityComponent::_nil ();
}

Components::EntityComponent_out::EntityComponent_out (EntityComponent_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::EntityComponent::_nil ();
}

Components::EntityComponent_out::EntityComponent_out (const ::Components::EntityComponent_out &p) // copy constructor
  : ptr_ (ACE_const_cast (EntityComponent_out &, p).ptr_)
{}

::Components::EntityComponent_out &
Components::EntityComponent_out::operator= (const ::Components::EntityComponent_out &p)
{
  this->ptr_ = ACE_const_cast (EntityComponent_out&, p).ptr_;
  return *this;
}

Components::EntityComponent_out &
Components::EntityComponent_out::operator= (const ::Components::EntityComponent_var &p)
{
  this->ptr_ = ::Components::EntityComponent::_duplicate (p.ptr ());
  return *this;
}

Components::EntityComponent_out &
Components::EntityComponent_out::operator= (EntityComponent_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::EntityComponent_out::operator ::Components::EntityComponent_ptr &() // cast
{
  return this->ptr_;
}

::Components::EntityComponent_ptr &
Components::EntityComponent_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::EntityComponent_ptr
Components::EntityComponent_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::EntityComponent::EntityComponent (void)
{}

Components::EntityComponent::~EntityComponent (void)
{}

void Components::EntityComponent::_tao_any_destructor (void *_tao_void_pointer)
{
  EntityComponent *tmp = ACE_static_cast (EntityComponent*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::EntityComponent_ptr Components::EntityComponent::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return EntityComponent::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::EntityComponent_ptr 
Components::EntityComponent::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return EntityComponent::_nil ();
  return
      ACE_reinterpret_cast
        (
          EntityComponent_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &EntityComponent::_tao_class_id
                  )
              )
        );
}

Components::EntityComponent_ptr
Components::EntityComponent::_duplicate (EntityComponent_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::EntityComponent::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, EntityComponent)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, EnterpriseComponent)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::EnterpriseComponent_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::EntityComponent::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/EntityComponent:1.0";
}

static const CORBA::Long _oc_Components_EntityComponent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6e746974), 
  ACE_NTOHL (0x79436f6d), 
  ACE_NTOHL (0x706f6e65), 
  ACE_NTOHL (0x6e743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/EntityComponent:1.0
  16,
  ACE_NTOHL (0x456e7469), 
  ACE_NTOHL (0x7479436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7400),  // name = EntityComponent
};

static CORBA::TypeCode _tc_TAO_tc_Components_EntityComponent (
    CORBA::tk_objref,
    sizeof (_oc_Components_EntityComponent),
    (char *) &_oc_Components_EntityComponent,
    0,
    sizeof (Components::EntityComponent)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_EntityComponent, &_tc_TAO_tc_Components_EntityComponent)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_BadComponentReferenceReason[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f42), 
  ACE_NTOHL (0x6164436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7452), 
  ACE_NTOHL (0x65666572), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x52656173), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/BadComponentReferenceReason:1.0
  28,
  ACE_NTOHL (0x42616443), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x52656665), 
  ACE_NTOHL (0x72656e63), 
  ACE_NTOHL (0x65526561), 
  ACE_NTOHL (0x736f6e00),  // name = BadComponentReferenceReason
  3, // member count
  20,
  ACE_NTOHL (0x4e4f4e5f), 
  ACE_NTOHL (0x4c4f4341), 
  ACE_NTOHL (0x4c5f5245), 
  ACE_NTOHL (0x46455245), 
  ACE_NTOHL (0x4e434500),  // name = NON_LOCAL_REFERENCE
  24,
  ACE_NTOHL (0x4e4f4e5f), 
  ACE_NTOHL (0x434f4d50), 
  ACE_NTOHL (0x4f4e454e), 
  ACE_NTOHL (0x545f5245), 
  ACE_NTOHL (0x46455245), 
  ACE_NTOHL (0x4e434500),  // name = NON_COMPONENT_REFERENCE
  16,
  ACE_NTOHL (0x57524f4e), 
  ACE_NTOHL (0x475f434f), 
  ACE_NTOHL (0x4e544149), 
  ACE_NTOHL (0x4e455200),  // name = WRONG_CONTAINER
};

static CORBA::TypeCode _tc_TAO_tc_Components_BadComponentReferenceReason (
    CORBA::tk_enum,
    sizeof (_oc_Components_BadComponentReferenceReason),
    (char *) &_oc_Components_BadComponentReferenceReason,
    0,
    sizeof (Components::BadComponentReferenceReason)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_BadComponentReferenceReason, &_tc_TAO_tc_Components_BadComponentReferenceReason)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_CatalogBase[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6174616c), 
  ACE_NTOHL (0x6f674261), 
  ACE_NTOHL (0x73653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/CatalogBase:1.0
  12,
  ACE_NTOHL (0x43617461), 
  ACE_NTOHL (0x6c6f6742), 
  ACE_NTOHL (0x61736500),  // name = CatalogBase
  CORBA::tk_objref, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f7350), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x7374656e), 
    ACE_NTOHL (0x74537461), 
    ACE_NTOHL (0x74652f43), 
    ACE_NTOHL (0x6174616c), 
    ACE_NTOHL (0x6f674261), 
    ACE_NTOHL (0x73653a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:CosPersistentState/CatalogBase:1.0
    12,
    ACE_NTOHL (0x43617461), 
    ACE_NTOHL (0x6c6f6742), 
    ACE_NTOHL (0x61736500),  // name = CatalogBase

};

static CORBA::TypeCode _tc_TAO_tc_Components_CatalogBase (
    CORBA::tk_alias,
    sizeof (_oc_Components_CatalogBase),
    (char *) &_oc_Components_CatalogBase,
    0,
    sizeof (Components::CatalogBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CatalogBase, &_tc_TAO_tc_Components_CatalogBase)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_TypeId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x79706549), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/TypeId:1.0
  7,
  ACE_NTOHL (0x54797065), 
  ACE_NTOHL (0x49640000),  // name = TypeId
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f7350), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x7374656e), 
    ACE_NTOHL (0x74537461), 
    ACE_NTOHL (0x74652f54), 
    ACE_NTOHL (0x79706549), 
    ACE_NTOHL (0x643a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:CosPersistentState/TypeId:1.0
    7,
    ACE_NTOHL (0x54797065), 
    ACE_NTOHL (0x49640000),  // name = TypeId
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      0U,


};

static CORBA::TypeCode _tc_TAO_tc_Components_TypeId (
    CORBA::tk_alias,
    sizeof (_oc_Components_TypeId),
    (char *) &_oc_Components_TypeId,
    0,
    sizeof (Components::TypeId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_TypeId, &_tc_TAO_tc_Components_TypeId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_SegmentId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x65676d65), 
  ACE_NTOHL (0x6e744964), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SegmentId:1.0
  10,
  ACE_NTOHL (0x5365676d), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x64000000),  // name = SegmentId
  CORBA::tk_short,

};

static CORBA::TypeCode _tc_TAO_tc_Components_SegmentId (
    CORBA::tk_alias,
    sizeof (_oc_Components_SegmentId),
    (char *) &_oc_Components_SegmentId,
    0,
    sizeof (Components::SegmentId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SegmentId, &_tc_TAO_tc_Components_SegmentId)
TAO_NAMESPACE_END

TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (const CORBA::Short, COMPONENT_SEGMENT, 0)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Components_FacetId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f46), 
  ACE_NTOHL (0x61636574), 
  ACE_NTOHL (0x49643a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/FacetId:1.0
  8,
  ACE_NTOHL (0x46616365), 
  ACE_NTOHL (0x74496400),  // name = FacetId
  CORBA::tk_short,

};

static CORBA::TypeCode _tc_TAO_tc_Components_FacetId (
    CORBA::tk_alias,
    sizeof (_oc_Components_FacetId),
    (char *) &_oc_Components_FacetId,
    0,
    sizeof (Components::FacetId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_FacetId, &_tc_TAO_tc_Components_FacetId)
TAO_NAMESPACE_END

TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (const CORBA::Short, COMPONENT_FACET, 0)
TAO_NAMESPACE_END

#if !defined (_COMPONENTS_IDDATA_CS_)
#define _COMPONENTS_IDDATA_CS_

// *************************************************************
// Components::IdData
// *************************************************************

Components::IdData::IdData (void)
{}
Components::IdData::IdData (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::IdData::IdData (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::IdData::IdData (const IdData &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::IdData::~IdData (void) // dtor
{}
void Components::IdData::_tao_any_destructor (void *_tao_void_pointer)
{
  IdData *tmp = ACE_static_cast (IdData*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_IdData[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x64446174), 
  ACE_NTOHL (0x613a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/IdData:1.0
  7,
  ACE_NTOHL (0x49644461), 
  ACE_NTOHL (0x74610000),  // name = IdData
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_IdData (
    CORBA::tk_alias,
    sizeof (_oc_Components_IdData),
    (char *) &_oc_Components_IdData,
    0,
    sizeof (Components::IdData)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_IdData, &_tc_TAO_tc_Components_IdData)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_PersistentId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x65727369), 
  ACE_NTOHL (0x7374656e), 
  ACE_NTOHL (0x7449643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/PersistentId:1.0
  13,
  ACE_NTOHL (0x50657273), 
  ACE_NTOHL (0x69737465), 
  ACE_NTOHL (0x6e744964), 
  ACE_NTOHL (0x0),  // name = PersistentId
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x436f7350), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x7374656e), 
    ACE_NTOHL (0x74537461), 
    ACE_NTOHL (0x74652f50), 
    ACE_NTOHL (0x69643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:CosPersistentState/Pid:1.0
    4,
    ACE_NTOHL (0x50696400),  // name = Pid
    CORBA::tk_string, 
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_Components_PersistentId (
    CORBA::tk_alias,
    sizeof (_oc_Components_PersistentId),
    (char *) &_oc_Components_PersistentId,
    0,
    sizeof (Components::PersistentId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PersistentId, &_tc_TAO_tc_Components_PersistentId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_StateIdType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x49645479), 
  ACE_NTOHL (0x70653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/StateIdType:1.0
  12,
  ACE_NTOHL (0x53746174), 
  ACE_NTOHL (0x65496454), 
  ACE_NTOHL (0x79706500),  // name = StateIdType
  CORBA::tk_short,

};

static CORBA::TypeCode _tc_TAO_tc_Components_StateIdType (
    CORBA::tk_alias,
    sizeof (_oc_Components_StateIdType),
    (char *) &_oc_Components_StateIdType,
    0,
    sizeof (Components::StateIdType)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_StateIdType, &_tc_TAO_tc_Components_StateIdType)
TAO_NAMESPACE_END

TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (const CORBA::Short, PERSISTENT_ID, 0)
TAO_NAMESPACE_END
// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::BadComponentReference::BadComponentReference (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/BadComponentReference:1.0",
        "BadComponentReference"
      )
{
}

// Destructor - all members are of self managing types.
Components::BadComponentReference::~BadComponentReference (void)
{
}

// Copy constructor.
Components::BadComponentReference::BadComponentReference (const ::Components::BadComponentReference &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

// Assignment operator.
Components::BadComponentReference&
Components::BadComponentReference::operator= (const ::Components::BadComponentReference &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::BadComponentReference::_tao_any_destructor (void *_tao_void_pointer)
{
  BadComponentReference *tmp = ACE_static_cast (BadComponentReference*, _tao_void_pointer);
  delete tmp;
}

Components::BadComponentReference *
Components::BadComponentReference::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/BadComponentReference:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (BadComponentReference *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::BadComponentReference::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::BadComponentReference, 0);
  return retval;
}

CORBA::Exception *
Components::BadComponentReference::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::BadComponentReference (*this),
      0
    );
  return result;
}

void Components::BadComponentReference::_raise ()
{
  TAO_RAISE (*this);
}

void Components::BadComponentReference::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::BadComponentReference::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::BadComponentReference::BadComponentReference (
    Components::BadComponentReferenceReason _tao_reason
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/BadComponentReference:1.0",
        "BadComponentReference"
      )
{
  this->reason = _tao_reason;
}

static const CORBA::Long _oc_Components_BadComponentReference[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f42), 
  ACE_NTOHL (0x6164436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7452), 
  ACE_NTOHL (0x65666572), 
  ACE_NTOHL (0x656e6365), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/BadComponentReference:1.0
  22,
  ACE_NTOHL (0x42616443), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x52656665), 
  ACE_NTOHL (0x72656e63), 
  ACE_NTOHL (0x65000000),  // name = BadComponentReference
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_enum, // typecode kind
  172, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    55,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f42), 
    ACE_NTOHL (0x6164436f), 
    ACE_NTOHL (0x6d706f6e), 
    ACE_NTOHL (0x656e7452), 
    ACE_NTOHL (0x65666572), 
    ACE_NTOHL (0x656e6365), 
    ACE_NTOHL (0x52656173), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/BadComponentReferenceReason:1.0
    28,
    ACE_NTOHL (0x42616443), 
    ACE_NTOHL (0x6f6d706f), 
    ACE_NTOHL (0x6e656e74), 
    ACE_NTOHL (0x52656665), 
    ACE_NTOHL (0x72656e63), 
    ACE_NTOHL (0x65526561), 
    ACE_NTOHL (0x736f6e00),  // name = BadComponentReferenceReason
    3, // member count
    20,
    ACE_NTOHL (0x4e4f4e5f), 
    ACE_NTOHL (0x4c4f4341), 
    ACE_NTOHL (0x4c5f5245), 
    ACE_NTOHL (0x46455245), 
    ACE_NTOHL (0x4e434500),  // name = NON_LOCAL_REFERENCE
    24,
    ACE_NTOHL (0x4e4f4e5f), 
    ACE_NTOHL (0x434f4d50), 
    ACE_NTOHL (0x4f4e454e), 
    ACE_NTOHL (0x545f5245), 
    ACE_NTOHL (0x46455245), 
    ACE_NTOHL (0x4e434500),  // name = NON_COMPONENT_REFERENCE
    16,
    ACE_NTOHL (0x57524f4e), 
    ACE_NTOHL (0x475f434f), 
    ACE_NTOHL (0x4e544149), 
    ACE_NTOHL (0x4e455200),  // name = WRONG_CONTAINER

};

static CORBA::TypeCode _tc_TAO_tc_Components_BadComponentReference (
    CORBA::tk_except,
    sizeof (_oc_Components_BadComponentReference),
    (char *) &_oc_Components_BadComponentReference,
    0,
    sizeof (Components::BadComponentReference)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_BadComponentReference, &_tc_TAO_tc_Components_BadComponentReference)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::BadComponentReference::_type (void) const
{
  return ::Components::_tc_BadComponentReference;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::PolicyMismatch::PolicyMismatch (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/PolicyMismatch:1.0",
        "PolicyMismatch"
      )
{
}

// Destructor - all members are of self managing types.
Components::PolicyMismatch::~PolicyMismatch (void)
{
}

// Copy constructor.
Components::PolicyMismatch::PolicyMismatch (const ::Components::PolicyMismatch &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::PolicyMismatch&
Components::PolicyMismatch::operator= (const ::Components::PolicyMismatch &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::PolicyMismatch::_tao_any_destructor (void *_tao_void_pointer)
{
  PolicyMismatch *tmp = ACE_static_cast (PolicyMismatch*, _tao_void_pointer);
  delete tmp;
}

Components::PolicyMismatch *
Components::PolicyMismatch::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/PolicyMismatch:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (PolicyMismatch *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::PolicyMismatch::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::PolicyMismatch, 0);
  return retval;
}

CORBA::Exception *
Components::PolicyMismatch::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::PolicyMismatch (*this),
      0
    );
  return result;
}

void Components::PolicyMismatch::_raise ()
{
  TAO_RAISE (*this);
}

void Components::PolicyMismatch::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::PolicyMismatch::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_PolicyMismatch[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x6f6c6963), 
  ACE_NTOHL (0x794d6973), 
  ACE_NTOHL (0x6d617463), 
  ACE_NTOHL (0x683a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/PolicyMismatch:1.0
  15,
  ACE_NTOHL (0x506f6c69), 
  ACE_NTOHL (0x63794d69), 
  ACE_NTOHL (0x736d6174), 
  ACE_NTOHL (0x63680000),  // name = PolicyMismatch
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_PolicyMismatch (
    CORBA::tk_except,
    sizeof (_oc_Components_PolicyMismatch),
    (char *) &_oc_Components_PolicyMismatch,
    0,
    sizeof (Components::PolicyMismatch)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PolicyMismatch, &_tc_TAO_tc_Components_PolicyMismatch)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::PolicyMismatch::_type (void) const
{
  return ::Components::_tc_PolicyMismatch;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::PersistenceNotAvailable::PersistenceNotAvailable (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/PersistenceNotAvailable:1.0",
        "PersistenceNotAvailable"
      )
{
}

// Destructor - all members are of self managing types.
Components::PersistenceNotAvailable::~PersistenceNotAvailable (void)
{
}

// Copy constructor.
Components::PersistenceNotAvailable::PersistenceNotAvailable (const ::Components::PersistenceNotAvailable &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::PersistenceNotAvailable&
Components::PersistenceNotAvailable::operator= (const ::Components::PersistenceNotAvailable &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::PersistenceNotAvailable::_tao_any_destructor (void *_tao_void_pointer)
{
  PersistenceNotAvailable *tmp = ACE_static_cast (PersistenceNotAvailable*, _tao_void_pointer);
  delete tmp;
}

Components::PersistenceNotAvailable *
Components::PersistenceNotAvailable::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/PersistenceNotAvailable:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (PersistenceNotAvailable *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::PersistenceNotAvailable::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::PersistenceNotAvailable, 0);
  return retval;
}

CORBA::Exception *
Components::PersistenceNotAvailable::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::PersistenceNotAvailable (*this),
      0
    );
  return result;
}

void Components::PersistenceNotAvailable::_raise ()
{
  TAO_RAISE (*this);
}

void Components::PersistenceNotAvailable::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::PersistenceNotAvailable::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_PersistenceNotAvailable[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x65727369), 
  ACE_NTOHL (0x7374656e), 
  ACE_NTOHL (0x63654e6f), 
  ACE_NTOHL (0x74417661), 
  ACE_NTOHL (0x696c6162), 
  ACE_NTOHL (0x6c653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/PersistenceNotAvailable:1.0
  24,
  ACE_NTOHL (0x50657273), 
  ACE_NTOHL (0x69737465), 
  ACE_NTOHL (0x6e63654e), 
  ACE_NTOHL (0x6f744176), 
  ACE_NTOHL (0x61696c61), 
  ACE_NTOHL (0x626c6500),  // name = PersistenceNotAvailable
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_PersistenceNotAvailable (
    CORBA::tk_except,
    sizeof (_oc_Components_PersistenceNotAvailable),
    (char *) &_oc_Components_PersistenceNotAvailable,
    0,
    sizeof (Components::PersistenceNotAvailable)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PersistenceNotAvailable, &_tc_TAO_tc_Components_PersistenceNotAvailable)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::PersistenceNotAvailable::_type (void) const
{
  return ::Components::_tc_PersistenceNotAvailable;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::UnknownActualHome::UnknownActualHome (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/UnknownActualHome:1.0",
        "UnknownActualHome"
      )
{
}

// Destructor - all members are of self managing types.
Components::UnknownActualHome::~UnknownActualHome (void)
{
}

// Copy constructor.
Components::UnknownActualHome::UnknownActualHome (const ::Components::UnknownActualHome &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::UnknownActualHome&
Components::UnknownActualHome::operator= (const ::Components::UnknownActualHome &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::UnknownActualHome::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownActualHome *tmp = ACE_static_cast (UnknownActualHome*, _tao_void_pointer);
  delete tmp;
}

Components::UnknownActualHome *
Components::UnknownActualHome::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/UnknownActualHome:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (UnknownActualHome *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::UnknownActualHome::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::UnknownActualHome, 0);
  return retval;
}

CORBA::Exception *
Components::UnknownActualHome::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::UnknownActualHome (*this),
      0
    );
  return result;
}

void Components::UnknownActualHome::_raise ()
{
  TAO_RAISE (*this);
}

void Components::UnknownActualHome::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::UnknownActualHome::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_UnknownActualHome[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f55), 
  ACE_NTOHL (0x6e6b6e6f), 
  ACE_NTOHL (0x776e4163), 
  ACE_NTOHL (0x7475616c), 
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/UnknownActualHome:1.0
  18,
  ACE_NTOHL (0x556e6b6e), 
  ACE_NTOHL (0x6f776e41), 
  ACE_NTOHL (0x63747561), 
  ACE_NTOHL (0x6c486f6d), 
  ACE_NTOHL (0x65000000),  // name = UnknownActualHome
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_UnknownActualHome (
    CORBA::tk_except,
    sizeof (_oc_Components_UnknownActualHome),
    (char *) &_oc_Components_UnknownActualHome,
    0,
    sizeof (Components::UnknownActualHome)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_UnknownActualHome, &_tc_TAO_tc_Components_UnknownActualHome)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::UnknownActualHome::_type (void) const
{
  return ::Components::_tc_UnknownActualHome;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::ProxyHomeNotSupported::ProxyHomeNotSupported (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/ProxyHomeNotSupported:1.0",
        "ProxyHomeNotSupported"
      )
{
}

// Destructor - all members are of self managing types.
Components::ProxyHomeNotSupported::~ProxyHomeNotSupported (void)
{
}

// Copy constructor.
Components::ProxyHomeNotSupported::ProxyHomeNotSupported (const ::Components::ProxyHomeNotSupported &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::ProxyHomeNotSupported&
Components::ProxyHomeNotSupported::operator= (const ::Components::ProxyHomeNotSupported &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::ProxyHomeNotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  ProxyHomeNotSupported *tmp = ACE_static_cast (ProxyHomeNotSupported*, _tao_void_pointer);
  delete tmp;
}

Components::ProxyHomeNotSupported *
Components::ProxyHomeNotSupported::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/ProxyHomeNotSupported:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (ProxyHomeNotSupported *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::ProxyHomeNotSupported::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::ProxyHomeNotSupported, 0);
  return retval;
}

CORBA::Exception *
Components::ProxyHomeNotSupported::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::ProxyHomeNotSupported (*this),
      0
    );
  return result;
}

void Components::ProxyHomeNotSupported::_raise ()
{
  TAO_RAISE (*this);
}

void Components::ProxyHomeNotSupported::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::ProxyHomeNotSupported::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_ProxyHomeNotSupported[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x726f7879), 
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x4e6f7453), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x72746564), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ProxyHomeNotSupported:1.0
  22,
  ACE_NTOHL (0x50726f78), 
  ACE_NTOHL (0x79486f6d), 
  ACE_NTOHL (0x654e6f74), 
  ACE_NTOHL (0x53757070), 
  ACE_NTOHL (0x6f727465), 
  ACE_NTOHL (0x64000000),  // name = ProxyHomeNotSupported
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_ProxyHomeNotSupported (
    CORBA::tk_except,
    sizeof (_oc_Components_ProxyHomeNotSupported),
    (char *) &_oc_Components_ProxyHomeNotSupported,
    0,
    sizeof (Components::ProxyHomeNotSupported)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ProxyHomeNotSupported, &_tc_TAO_tc_Components_ProxyHomeNotSupported)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::ProxyHomeNotSupported::_type (void) const
{
  return ::Components::_tc_ProxyHomeNotSupported;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::InvalidStateIdData::InvalidStateIdData (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/InvalidStateIdData:1.0",
        "InvalidStateIdData"
      )
{
}

// Destructor - all members are of self managing types.
Components::InvalidStateIdData::~InvalidStateIdData (void)
{
}

// Copy constructor.
Components::InvalidStateIdData::InvalidStateIdData (const ::Components::InvalidStateIdData &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::InvalidStateIdData&
Components::InvalidStateIdData::operator= (const ::Components::InvalidStateIdData &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::InvalidStateIdData::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidStateIdData *tmp = ACE_static_cast (InvalidStateIdData*, _tao_void_pointer);
  delete tmp;
}

Components::InvalidStateIdData *
Components::InvalidStateIdData::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/InvalidStateIdData:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidStateIdData *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::InvalidStateIdData::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::InvalidStateIdData, 0);
  return retval;
}

CORBA::Exception *
Components::InvalidStateIdData::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::InvalidStateIdData (*this),
      0
    );
  return result;
}

void Components::InvalidStateIdData::_raise ()
{
  TAO_RAISE (*this);
}

void Components::InvalidStateIdData::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::InvalidStateIdData::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_InvalidStateIdData[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x69645374), 
  ACE_NTOHL (0x61746549), 
  ACE_NTOHL (0x64446174), 
  ACE_NTOHL (0x613a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/InvalidStateIdData:1.0
  19,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696453), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x49644461), 
  ACE_NTOHL (0x74610000),  // name = InvalidStateIdData
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_InvalidStateIdData (
    CORBA::tk_except,
    sizeof (_oc_Components_InvalidStateIdData),
    (char *) &_oc_Components_InvalidStateIdData,
    0,
    sizeof (Components::InvalidStateIdData)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidStateIdData, &_tc_TAO_tc_Components_InvalidStateIdData)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::InvalidStateIdData::_type (void) const
{
  return ::Components::_tc_InvalidStateIdData;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::HomeRegistration::_tao_class_id = 0;

Components::HomeRegistration_ptr
tao_Components_HomeRegistration_duplicate (
    Components::HomeRegistration_ptr p
  )
{
  return Components::HomeRegistration::_duplicate (p);
}

void
tao_Components_HomeRegistration_release (
    Components::HomeRegistration_ptr p
  )
{
  CORBA::release (p);
}

Components::HomeRegistration_ptr
tao_Components_HomeRegistration_nil (
    void
  )
{
  return Components::HomeRegistration::_nil ();
}

Components::HomeRegistration_ptr
tao_Components_HomeRegistration_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::HomeRegistration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_HomeRegistration_upcast (
    void *src
  )
{
  Components::HomeRegistration **tmp =
    ACE_static_cast (Components::HomeRegistration **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeRegistration_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::HomeRegistration_var::HomeRegistration_var (void) // default constructor
  : ptr_ (HomeRegistration::_nil ())
{}

::Components::HomeRegistration_ptr
Components::HomeRegistration_var::ptr (void) const
{
  return this->ptr_;
}

Components::HomeRegistration_var::HomeRegistration_var (const ::Components::HomeRegistration_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (HomeRegistration::_duplicate (p.ptr ()))
{}

Components::HomeRegistration_var::~HomeRegistration_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::HomeRegistration_var &
Components::HomeRegistration_var::operator= (HomeRegistration_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::HomeRegistration_var &
Components::HomeRegistration_var::operator= (const ::Components::HomeRegistration_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::HomeRegistration::_duplicate (p.ptr ());
  }
  return *this;
}

Components::HomeRegistration_var::operator const ::Components::HomeRegistration_ptr &() const // cast
{
  return this->ptr_;
}

Components::HomeRegistration_var::operator ::Components::HomeRegistration_ptr &() // cast 
{
  return this->ptr_;
}

::Components::HomeRegistration_ptr
Components::HomeRegistration_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::HomeRegistration_ptr
Components::HomeRegistration_var::in (void) const
{
  return this->ptr_;
}

::Components::HomeRegistration_ptr &
Components::HomeRegistration_var::inout (void)
{
  return this->ptr_;
}

::Components::HomeRegistration_ptr &
Components::HomeRegistration_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeRegistration::_nil ();
  return this->ptr_;
}

::Components::HomeRegistration_ptr
Components::HomeRegistration_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::HomeRegistration_ptr val = this->ptr_;
  this->ptr_ = ::Components::HomeRegistration::_nil ();
  return val;
}

::Components::HomeRegistration_ptr
Components::HomeRegistration_var::tao_duplicate (HomeRegistration_ptr p)
{
  return ::Components::HomeRegistration::_duplicate (p);
}

void
Components::HomeRegistration_var::tao_release (HomeRegistration_ptr p)
{
  CORBA::release (p);
}

::Components::HomeRegistration_ptr
Components::HomeRegistration_var::tao_nil (void)
{
  return ::Components::HomeRegistration::_nil ();
}

::Components::HomeRegistration_ptr
Components::HomeRegistration_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::HomeRegistration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::HomeRegistration_var::tao_upcast (void *src)
{
  HomeRegistration **tmp =
    ACE_static_cast (HomeRegistration **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeRegistration_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::HomeRegistration_out::HomeRegistration_out (HomeRegistration_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::HomeRegistration::_nil ();
}

Components::HomeRegistration_out::HomeRegistration_out (HomeRegistration_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeRegistration::_nil ();
}

Components::HomeRegistration_out::HomeRegistration_out (const ::Components::HomeRegistration_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeRegistration_out &, p).ptr_)
{}

::Components::HomeRegistration_out &
Components::HomeRegistration_out::operator= (const ::Components::HomeRegistration_out &p)
{
  this->ptr_ = ACE_const_cast (HomeRegistration_out&, p).ptr_;
  return *this;
}

Components::HomeRegistration_out &
Components::HomeRegistration_out::operator= (const ::Components::HomeRegistration_var &p)
{
  this->ptr_ = ::Components::HomeRegistration::_duplicate (p.ptr ());
  return *this;
}

Components::HomeRegistration_out &
Components::HomeRegistration_out::operator= (HomeRegistration_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::HomeRegistration_out::operator ::Components::HomeRegistration_ptr &() // cast
{
  return this->ptr_;
}

::Components::HomeRegistration_ptr &
Components::HomeRegistration_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::HomeRegistration_ptr
Components::HomeRegistration_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::HomeRegistration::HomeRegistration (void)
{}

Components::HomeRegistration::~HomeRegistration (void)
{}

void Components::HomeRegistration::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeRegistration *tmp = ACE_static_cast (HomeRegistration*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::HomeRegistration_ptr Components::HomeRegistration::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return HomeRegistration::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::HomeRegistration_ptr 
Components::HomeRegistration::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return HomeRegistration::_nil ();
  return
      ACE_reinterpret_cast
        (
          HomeRegistration_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &HomeRegistration::_tao_class_id
                  )
              )
        );
}

Components::HomeRegistration_ptr
Components::HomeRegistration::_duplicate (HomeRegistration_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::HomeRegistration::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, HomeRegistration)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::HomeRegistration::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/HomeRegistration:1.0";
}

static const CORBA::Long _oc_Components_HomeRegistration[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d6552), 
  ACE_NTOHL (0x65676973), 
  ACE_NTOHL (0x74726174), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/HomeRegistration:1.0
  17,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x52656769), 
  ACE_NTOHL (0x73747261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = HomeRegistration
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeRegistration (
    CORBA::tk_objref,
    sizeof (_oc_Components_HomeRegistration),
    (char *) &_oc_Components_HomeRegistration,
    0,
    sizeof (Components::HomeRegistration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_HomeRegistration, &_tc_TAO_tc_Components_HomeRegistration)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::CCM2Context::_tao_class_id = 0;

Components::CCM2Context_ptr
tao_Components_CCM2Context_duplicate (
    Components::CCM2Context_ptr p
  )
{
  return Components::CCM2Context::_duplicate (p);
}

void
tao_Components_CCM2Context_release (
    Components::CCM2Context_ptr p
  )
{
  CORBA::release (p);
}

Components::CCM2Context_ptr
tao_Components_CCM2Context_nil (
    void
  )
{
  return Components::CCM2Context::_nil ();
}

Components::CCM2Context_ptr
tao_Components_CCM2Context_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::CCM2Context::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_CCM2Context_upcast (
    void *src
  )
{
  Components::CCM2Context **tmp =
    ACE_static_cast (Components::CCM2Context **, src);
  return *tmp;
}

// *************************************************************
// Components::CCM2Context_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::CCM2Context_var::CCM2Context_var (void) // default constructor
  : ptr_ (CCM2Context::_nil ())
{}

::Components::CCM2Context_ptr
Components::CCM2Context_var::ptr (void) const
{
  return this->ptr_;
}

Components::CCM2Context_var::CCM2Context_var (const ::Components::CCM2Context_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (CCM2Context::_duplicate (p.ptr ()))
{}

Components::CCM2Context_var::~CCM2Context_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::CCM2Context_var &
Components::CCM2Context_var::operator= (CCM2Context_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::CCM2Context_var &
Components::CCM2Context_var::operator= (const ::Components::CCM2Context_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::CCM2Context::_duplicate (p.ptr ());
  }
  return *this;
}

Components::CCM2Context_var::operator const ::Components::CCM2Context_ptr &() const // cast
{
  return this->ptr_;
}

Components::CCM2Context_var::operator ::Components::CCM2Context_ptr &() // cast 
{
  return this->ptr_;
}

::Components::CCM2Context_ptr
Components::CCM2Context_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::CCM2Context_ptr
Components::CCM2Context_var::in (void) const
{
  return this->ptr_;
}

::Components::CCM2Context_ptr &
Components::CCM2Context_var::inout (void)
{
  return this->ptr_;
}

::Components::CCM2Context_ptr &
Components::CCM2Context_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCM2Context::_nil ();
  return this->ptr_;
}

::Components::CCM2Context_ptr
Components::CCM2Context_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::CCM2Context_ptr val = this->ptr_;
  this->ptr_ = ::Components::CCM2Context::_nil ();
  return val;
}

::Components::CCM2Context_ptr
Components::CCM2Context_var::tao_duplicate (CCM2Context_ptr p)
{
  return ::Components::CCM2Context::_duplicate (p);
}

void
Components::CCM2Context_var::tao_release (CCM2Context_ptr p)
{
  CORBA::release (p);
}

::Components::CCM2Context_ptr
Components::CCM2Context_var::tao_nil (void)
{
  return ::Components::CCM2Context::_nil ();
}

::Components::CCM2Context_ptr
Components::CCM2Context_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::CCM2Context::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::CCM2Context_var::tao_upcast (void *src)
{
  CCM2Context **tmp =
    ACE_static_cast (CCM2Context **, src);
  return *tmp;
}

// *************************************************************
// Components::CCM2Context_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::CCM2Context_out::CCM2Context_out (CCM2Context_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::CCM2Context::_nil ();
}

Components::CCM2Context_out::CCM2Context_out (CCM2Context_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::CCM2Context::_nil ();
}

Components::CCM2Context_out::CCM2Context_out (const ::Components::CCM2Context_out &p) // copy constructor
  : ptr_ (ACE_const_cast (CCM2Context_out &, p).ptr_)
{}

::Components::CCM2Context_out &
Components::CCM2Context_out::operator= (const ::Components::CCM2Context_out &p)
{
  this->ptr_ = ACE_const_cast (CCM2Context_out&, p).ptr_;
  return *this;
}

Components::CCM2Context_out &
Components::CCM2Context_out::operator= (const ::Components::CCM2Context_var &p)
{
  this->ptr_ = ::Components::CCM2Context::_duplicate (p.ptr ());
  return *this;
}

Components::CCM2Context_out &
Components::CCM2Context_out::operator= (CCM2Context_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::CCM2Context_out::operator ::Components::CCM2Context_ptr &() // cast
{
  return this->ptr_;
}

::Components::CCM2Context_ptr &
Components::CCM2Context_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::CCM2Context_ptr
Components::CCM2Context_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::CCM2Context::CCM2Context (void)
{}

Components::CCM2Context::~CCM2Context (void)
{}

void Components::CCM2Context::_tao_any_destructor (void *_tao_void_pointer)
{
  CCM2Context *tmp = ACE_static_cast (CCM2Context*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::CCM2Context_ptr Components::CCM2Context::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return CCM2Context::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::CCM2Context_ptr 
Components::CCM2Context::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return CCM2Context::_nil ();
  return
      ACE_reinterpret_cast
        (
          CCM2Context_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &CCM2Context::_tao_class_id
                  )
              )
        );
}

Components::CCM2Context_ptr
Components::CCM2Context::_duplicate (CCM2Context_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::CCM2Context::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCM2Context)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMContext)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCMContext_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::CCM2Context::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/CCM2Context:1.0";
}

static const CORBA::Long _oc_Components_CCM2Context[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x434d3243), 
  ACE_NTOHL (0x6f6e7465), 
  ACE_NTOHL (0x78743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/CCM2Context:1.0
  12,
  ACE_NTOHL (0x43434d32), 
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x65787400),  // name = CCM2Context
};

static CORBA::TypeCode _tc_TAO_tc_Components_CCM2Context (
    CORBA::tk_objref,
    sizeof (_oc_Components_CCM2Context),
    (char *) &_oc_Components_CCM2Context,
    0,
    sizeof (Components::CCM2Context)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_CCM2Context, &_tc_TAO_tc_Components_CCM2Context)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::ProxyHomeRegistration::_tao_class_id = 0;

Components::ProxyHomeRegistration_ptr
tao_Components_ProxyHomeRegistration_duplicate (
    Components::ProxyHomeRegistration_ptr p
  )
{
  return Components::ProxyHomeRegistration::_duplicate (p);
}

void
tao_Components_ProxyHomeRegistration_release (
    Components::ProxyHomeRegistration_ptr p
  )
{
  CORBA::release (p);
}

Components::ProxyHomeRegistration_ptr
tao_Components_ProxyHomeRegistration_nil (
    void
  )
{
  return Components::ProxyHomeRegistration::_nil ();
}

Components::ProxyHomeRegistration_ptr
tao_Components_ProxyHomeRegistration_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::ProxyHomeRegistration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_ProxyHomeRegistration_upcast (
    void *src
  )
{
  Components::ProxyHomeRegistration **tmp =
    ACE_static_cast (Components::ProxyHomeRegistration **, src);
  return *tmp;
}

// *************************************************************
// Components::ProxyHomeRegistration_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::ProxyHomeRegistration_var::ProxyHomeRegistration_var (void) // default constructor
  : ptr_ (ProxyHomeRegistration::_nil ())
{}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_var::ptr (void) const
{
  return this->ptr_;
}

Components::ProxyHomeRegistration_var::ProxyHomeRegistration_var (const ::Components::ProxyHomeRegistration_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ProxyHomeRegistration::_duplicate (p.ptr ()))
{}

Components::ProxyHomeRegistration_var::~ProxyHomeRegistration_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::ProxyHomeRegistration_var &
Components::ProxyHomeRegistration_var::operator= (ProxyHomeRegistration_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ProxyHomeRegistration_var &
Components::ProxyHomeRegistration_var::operator= (const ::Components::ProxyHomeRegistration_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::ProxyHomeRegistration::_duplicate (p.ptr ());
  }
  return *this;
}

Components::ProxyHomeRegistration_var::operator const ::Components::ProxyHomeRegistration_ptr &() const // cast
{
  return this->ptr_;
}

Components::ProxyHomeRegistration_var::operator ::Components::ProxyHomeRegistration_ptr &() // cast 
{
  return this->ptr_;
}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_var::in (void) const
{
  return this->ptr_;
}

::Components::ProxyHomeRegistration_ptr &
Components::ProxyHomeRegistration_var::inout (void)
{
  return this->ptr_;
}

::Components::ProxyHomeRegistration_ptr &
Components::ProxyHomeRegistration_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::ProxyHomeRegistration::_nil ();
  return this->ptr_;
}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::ProxyHomeRegistration_ptr val = this->ptr_;
  this->ptr_ = ::Components::ProxyHomeRegistration::_nil ();
  return val;
}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_var::tao_duplicate (ProxyHomeRegistration_ptr p)
{
  return ::Components::ProxyHomeRegistration::_duplicate (p);
}

void
Components::ProxyHomeRegistration_var::tao_release (ProxyHomeRegistration_ptr p)
{
  CORBA::release (p);
}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_var::tao_nil (void)
{
  return ::Components::ProxyHomeRegistration::_nil ();
}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::ProxyHomeRegistration::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::ProxyHomeRegistration_var::tao_upcast (void *src)
{
  ProxyHomeRegistration **tmp =
    ACE_static_cast (ProxyHomeRegistration **, src);
  return *tmp;
}

// *************************************************************
// Components::ProxyHomeRegistration_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::ProxyHomeRegistration_out::ProxyHomeRegistration_out (ProxyHomeRegistration_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::ProxyHomeRegistration::_nil ();
}

Components::ProxyHomeRegistration_out::ProxyHomeRegistration_out (ProxyHomeRegistration_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::ProxyHomeRegistration::_nil ();
}

Components::ProxyHomeRegistration_out::ProxyHomeRegistration_out (const ::Components::ProxyHomeRegistration_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ProxyHomeRegistration_out &, p).ptr_)
{}

::Components::ProxyHomeRegistration_out &
Components::ProxyHomeRegistration_out::operator= (const ::Components::ProxyHomeRegistration_out &p)
{
  this->ptr_ = ACE_const_cast (ProxyHomeRegistration_out&, p).ptr_;
  return *this;
}

Components::ProxyHomeRegistration_out &
Components::ProxyHomeRegistration_out::operator= (const ::Components::ProxyHomeRegistration_var &p)
{
  this->ptr_ = ::Components::ProxyHomeRegistration::_duplicate (p.ptr ());
  return *this;
}

Components::ProxyHomeRegistration_out &
Components::ProxyHomeRegistration_out::operator= (ProxyHomeRegistration_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::ProxyHomeRegistration_out::operator ::Components::ProxyHomeRegistration_ptr &() // cast
{
  return this->ptr_;
}

::Components::ProxyHomeRegistration_ptr &
Components::ProxyHomeRegistration_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::ProxyHomeRegistration::ProxyHomeRegistration (void)
{}

Components::ProxyHomeRegistration::~ProxyHomeRegistration (void)
{}

void Components::ProxyHomeRegistration::_tao_any_destructor (void *_tao_void_pointer)
{
  ProxyHomeRegistration *tmp = ACE_static_cast (ProxyHomeRegistration*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::ProxyHomeRegistration_ptr Components::ProxyHomeRegistration::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ProxyHomeRegistration::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::ProxyHomeRegistration_ptr 
Components::ProxyHomeRegistration::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ProxyHomeRegistration::_nil ();
  return
      ACE_reinterpret_cast
        (
          ProxyHomeRegistration_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ProxyHomeRegistration::_tao_class_id
                  )
              )
        );
}

Components::ProxyHomeRegistration_ptr
Components::ProxyHomeRegistration::_duplicate (ProxyHomeRegistration_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::ProxyHomeRegistration::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, ProxyHomeRegistration)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, HomeRegistration)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::HomeRegistration_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::ProxyHomeRegistration::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/ProxyHomeRegistration:1.0";
}

static const CORBA::Long _oc_Components_ProxyHomeRegistration[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x726f7879), 
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x52656769), 
  ACE_NTOHL (0x73747261), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/ProxyHomeRegistration:1.0
  22,
  ACE_NTOHL (0x50726f78), 
  ACE_NTOHL (0x79486f6d), 
  ACE_NTOHL (0x65526567), 
  ACE_NTOHL (0x69737472), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e000000),  // name = ProxyHomeRegistration
};

static CORBA::TypeCode _tc_TAO_tc_Components_ProxyHomeRegistration (
    CORBA::tk_objref,
    sizeof (_oc_Components_ProxyHomeRegistration),
    (char *) &_oc_Components_ProxyHomeRegistration,
    0,
    sizeof (Components::ProxyHomeRegistration)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ProxyHomeRegistration, &_tc_TAO_tc_Components_ProxyHomeRegistration)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Session2Context::_tao_class_id = 0;

Components::Session2Context_ptr
tao_Components_Session2Context_duplicate (
    Components::Session2Context_ptr p
  )
{
  return Components::Session2Context::_duplicate (p);
}

void
tao_Components_Session2Context_release (
    Components::Session2Context_ptr p
  )
{
  CORBA::release (p);
}

Components::Session2Context_ptr
tao_Components_Session2Context_nil (
    void
  )
{
  return Components::Session2Context::_nil ();
}

Components::Session2Context_ptr
tao_Components_Session2Context_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Session2Context::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Session2Context_upcast (
    void *src
  )
{
  Components::Session2Context **tmp =
    ACE_static_cast (Components::Session2Context **, src);
  return *tmp;
}

// *************************************************************
// Components::Session2Context_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Session2Context_var::Session2Context_var (void) // default constructor
  : ptr_ (Session2Context::_nil ())
{}

::Components::Session2Context_ptr
Components::Session2Context_var::ptr (void) const
{
  return this->ptr_;
}

Components::Session2Context_var::Session2Context_var (const ::Components::Session2Context_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Session2Context::_duplicate (p.ptr ()))
{}

Components::Session2Context_var::~Session2Context_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Session2Context_var &
Components::Session2Context_var::operator= (Session2Context_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Session2Context_var &
Components::Session2Context_var::operator= (const ::Components::Session2Context_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Session2Context::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Session2Context_var::operator const ::Components::Session2Context_ptr &() const // cast
{
  return this->ptr_;
}

Components::Session2Context_var::operator ::Components::Session2Context_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Session2Context_ptr
Components::Session2Context_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Session2Context_ptr
Components::Session2Context_var::in (void) const
{
  return this->ptr_;
}

::Components::Session2Context_ptr &
Components::Session2Context_var::inout (void)
{
  return this->ptr_;
}

::Components::Session2Context_ptr &
Components::Session2Context_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Session2Context::_nil ();
  return this->ptr_;
}

::Components::Session2Context_ptr
Components::Session2Context_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Session2Context_ptr val = this->ptr_;
  this->ptr_ = ::Components::Session2Context::_nil ();
  return val;
}

::Components::Session2Context_ptr
Components::Session2Context_var::tao_duplicate (Session2Context_ptr p)
{
  return ::Components::Session2Context::_duplicate (p);
}

void
Components::Session2Context_var::tao_release (Session2Context_ptr p)
{
  CORBA::release (p);
}

::Components::Session2Context_ptr
Components::Session2Context_var::tao_nil (void)
{
  return ::Components::Session2Context::_nil ();
}

::Components::Session2Context_ptr
Components::Session2Context_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Session2Context::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Session2Context_var::tao_upcast (void *src)
{
  Session2Context **tmp =
    ACE_static_cast (Session2Context **, src);
  return *tmp;
}

// *************************************************************
// Components::Session2Context_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Session2Context_out::Session2Context_out (Session2Context_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Session2Context::_nil ();
}

Components::Session2Context_out::Session2Context_out (Session2Context_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Session2Context::_nil ();
}

Components::Session2Context_out::Session2Context_out (const ::Components::Session2Context_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Session2Context_out &, p).ptr_)
{}

::Components::Session2Context_out &
Components::Session2Context_out::operator= (const ::Components::Session2Context_out &p)
{
  this->ptr_ = ACE_const_cast (Session2Context_out&, p).ptr_;
  return *this;
}

Components::Session2Context_out &
Components::Session2Context_out::operator= (const ::Components::Session2Context_var &p)
{
  this->ptr_ = ::Components::Session2Context::_duplicate (p.ptr ());
  return *this;
}

Components::Session2Context_out &
Components::Session2Context_out::operator= (Session2Context_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Session2Context_out::operator ::Components::Session2Context_ptr &() // cast
{
  return this->ptr_;
}

::Components::Session2Context_ptr &
Components::Session2Context_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Session2Context_ptr
Components::Session2Context_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Session2Context::Session2Context (void)
{}

Components::Session2Context::~Session2Context (void)
{}

void Components::Session2Context::_tao_any_destructor (void *_tao_void_pointer)
{
  Session2Context *tmp = ACE_static_cast (Session2Context*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Session2Context_ptr Components::Session2Context::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return Session2Context::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Session2Context_ptr 
Components::Session2Context::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Session2Context::_nil ();
  return
      ACE_reinterpret_cast
        (
          Session2Context_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Session2Context::_tao_class_id
                  )
              )
        );
}

Components::Session2Context_ptr
Components::Session2Context::_duplicate (Session2Context_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::Session2Context::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Session2Context)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, SessionContext)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::SessionContext_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCM2Context)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCM2Context_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMContext)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCMContext_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Session2Context::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Session2Context:1.0";
}

static const CORBA::Long _oc_Components_Session2Context[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x65737369), 
  ACE_NTOHL (0x6f6e3243), 
  ACE_NTOHL (0x6f6e7465), 
  ACE_NTOHL (0x78743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Session2Context:1.0
  16,
  ACE_NTOHL (0x53657373), 
  ACE_NTOHL (0x696f6e32), 
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x65787400),  // name = Session2Context
};

static CORBA::TypeCode _tc_TAO_tc_Components_Session2Context (
    CORBA::tk_objref,
    sizeof (_oc_Components_Session2Context),
    (char *) &_oc_Components_Session2Context,
    0,
    sizeof (Components::Session2Context)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Session2Context, &_tc_TAO_tc_Components_Session2Context)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_StateIdValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x49645661), 
  ACE_NTOHL (0x6c75653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/StateIdValue:1.0
  13,
  ACE_NTOHL (0x53746174), 
  ACE_NTOHL (0x65496456), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x0),  // name = StateIdValue
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_StateIdValue (
    CORBA::tk_value,
    sizeof (_oc_Components_StateIdValue),
    (char *) &_oc_Components_StateIdValue,
    0,
    sizeof (Components::StateIdValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_StateIdValue, &_tc_TAO_tc_Components_StateIdValue)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::StateIdValue_var
// *************************************************************

Components::StateIdValue_var::StateIdValue_var (void) // default constructor
  : ptr_ (0)
{}

Components::StateIdValue_var::StateIdValue_var (StateIdValue* p)
  : ptr_ (p)
{}

Components::StateIdValue_var::StateIdValue_var (const StateIdValue* p)
  : ptr_ (ACE_const_cast(StateIdValue*, p))
{}

Components::StateIdValue* 
Components::StateIdValue_var::ptr (void) const
{
  return this->ptr_;
}

Components::StateIdValue_var::StateIdValue_var (const StateIdValue_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::StateIdValue_var::~StateIdValue_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::StateIdValue_var &
Components::StateIdValue_var::operator= (StateIdValue* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::StateIdValue_var &
Components::StateIdValue_var::operator= (const StateIdValue_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    StateIdValue* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::StateIdValue_var::operator const Components::StateIdValue* () const // cast
{
  return this->ptr_;
}

Components::StateIdValue_var::operator Components::StateIdValue* () // cast 
{
  return this->ptr_;
}

Components::StateIdValue* 
Components::StateIdValue_var::operator-> (void) const
{
  return this->ptr_;
}

Components::StateIdValue*
Components::StateIdValue_var::in (void) const
{
  return this->ptr_;
}

Components::StateIdValue* &
Components::StateIdValue_var::inout (void)
{
  return this->ptr_;
}

Components::StateIdValue* &
Components::StateIdValue_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::StateIdValue* 
Components::StateIdValue_var::_retn (void)
{
  // yield ownership of managed obj reference
  StateIdValue* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::StateIdValue_out
// *************************************************************

Components::StateIdValue_out::StateIdValue_out (StateIdValue* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::StateIdValue_out::StateIdValue_out (StateIdValue_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::StateIdValue_out::StateIdValue_out (const StateIdValue_out &p) // copy constructor
  : ptr_ (ACE_const_cast (StateIdValue_out&,p).ptr_)
{}

Components::StateIdValue_out &
Components::StateIdValue_out::operator= (const StateIdValue_out &p)
{
  this->ptr_ = ACE_const_cast (StateIdValue_out&,p).ptr_;
  return *this;
}

Components::StateIdValue_out &
Components::StateIdValue_out::operator= (const StateIdValue_var &p)
{
  StateIdValue* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::StateIdValue_out &
Components::StateIdValue_out::operator= (StateIdValue* p)
{
  this->ptr_ = p;
  return *this;
}

Components::StateIdValue_out::operator Components::StateIdValue* &() // cast
{
  return this->ptr_;
}

Components::StateIdValue* &
Components::StateIdValue_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::StateIdValue* 
Components::StateIdValue_out::operator-> (void)
{
  return this->ptr_;
}

Components::StateIdValue* Components::StateIdValue::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (StateIdValue* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::StateIdValue::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::StateIdValue::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::StateIdValue::_tao_any_destructor (void *_tao_void_pointer)
{
  StateIdValue *tmp = ACE_static_cast (StateIdValue*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::StateIdValue::_tao_unmarshal (TAO_InputCDR &strm, StateIdValue *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          StateIdValue::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::StateIdValue::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::StateIdValue::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = StateIdValue::_downcast (base);
  // %! unmarshal_post
  return 1;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::StateIdFactory::_tao_class_id = 0;

Components::StateIdFactory_ptr
tao_Components_StateIdFactory_duplicate (
    Components::StateIdFactory_ptr p
  )
{
  return Components::StateIdFactory::_duplicate (p);
}

void
tao_Components_StateIdFactory_release (
    Components::StateIdFactory_ptr p
  )
{
  CORBA::release (p);
}

Components::StateIdFactory_ptr
tao_Components_StateIdFactory_nil (
    void
  )
{
  return Components::StateIdFactory::_nil ();
}

Components::StateIdFactory_ptr
tao_Components_StateIdFactory_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::StateIdFactory::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_StateIdFactory_upcast (
    void *src
  )
{
  Components::StateIdFactory **tmp =
    ACE_static_cast (Components::StateIdFactory **, src);
  return *tmp;
}

// *************************************************************
// Components::StateIdFactory_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::StateIdFactory_var::StateIdFactory_var (void) // default constructor
  : ptr_ (StateIdFactory::_nil ())
{}

::Components::StateIdFactory_ptr
Components::StateIdFactory_var::ptr (void) const
{
  return this->ptr_;
}

Components::StateIdFactory_var::StateIdFactory_var (const ::Components::StateIdFactory_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (StateIdFactory::_duplicate (p.ptr ()))
{}

Components::StateIdFactory_var::~StateIdFactory_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::StateIdFactory_var &
Components::StateIdFactory_var::operator= (StateIdFactory_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::StateIdFactory_var &
Components::StateIdFactory_var::operator= (const ::Components::StateIdFactory_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::StateIdFactory::_duplicate (p.ptr ());
  }
  return *this;
}

Components::StateIdFactory_var::operator const ::Components::StateIdFactory_ptr &() const // cast
{
  return this->ptr_;
}

Components::StateIdFactory_var::operator ::Components::StateIdFactory_ptr &() // cast 
{
  return this->ptr_;
}

::Components::StateIdFactory_ptr
Components::StateIdFactory_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::StateIdFactory_ptr
Components::StateIdFactory_var::in (void) const
{
  return this->ptr_;
}

::Components::StateIdFactory_ptr &
Components::StateIdFactory_var::inout (void)
{
  return this->ptr_;
}

::Components::StateIdFactory_ptr &
Components::StateIdFactory_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::StateIdFactory::_nil ();
  return this->ptr_;
}

::Components::StateIdFactory_ptr
Components::StateIdFactory_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::StateIdFactory_ptr val = this->ptr_;
  this->ptr_ = ::Components::StateIdFactory::_nil ();
  return val;
}

::Components::StateIdFactory_ptr
Components::StateIdFactory_var::tao_duplicate (StateIdFactory_ptr p)
{
  return ::Components::StateIdFactory::_duplicate (p);
}

void
Components::StateIdFactory_var::tao_release (StateIdFactory_ptr p)
{
  CORBA::release (p);
}

::Components::StateIdFactory_ptr
Components::StateIdFactory_var::tao_nil (void)
{
  return ::Components::StateIdFactory::_nil ();
}

::Components::StateIdFactory_ptr
Components::StateIdFactory_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::StateIdFactory::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::StateIdFactory_var::tao_upcast (void *src)
{
  StateIdFactory **tmp =
    ACE_static_cast (StateIdFactory **, src);
  return *tmp;
}

// *************************************************************
// Components::StateIdFactory_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::StateIdFactory_out::StateIdFactory_out (StateIdFactory_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::StateIdFactory::_nil ();
}

Components::StateIdFactory_out::StateIdFactory_out (StateIdFactory_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::StateIdFactory::_nil ();
}

Components::StateIdFactory_out::StateIdFactory_out (const ::Components::StateIdFactory_out &p) // copy constructor
  : ptr_ (ACE_const_cast (StateIdFactory_out &, p).ptr_)
{}

::Components::StateIdFactory_out &
Components::StateIdFactory_out::operator= (const ::Components::StateIdFactory_out &p)
{
  this->ptr_ = ACE_const_cast (StateIdFactory_out&, p).ptr_;
  return *this;
}

Components::StateIdFactory_out &
Components::StateIdFactory_out::operator= (const ::Components::StateIdFactory_var &p)
{
  this->ptr_ = ::Components::StateIdFactory::_duplicate (p.ptr ());
  return *this;
}

Components::StateIdFactory_out &
Components::StateIdFactory_out::operator= (StateIdFactory_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::StateIdFactory_out::operator ::Components::StateIdFactory_ptr &() // cast
{
  return this->ptr_;
}

::Components::StateIdFactory_ptr &
Components::StateIdFactory_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::StateIdFactory_ptr
Components::StateIdFactory_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::StateIdFactory::StateIdFactory (void)
{}

Components::StateIdFactory::~StateIdFactory (void)
{}

void Components::StateIdFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  StateIdFactory *tmp = ACE_static_cast (StateIdFactory*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::StateIdFactory_ptr Components::StateIdFactory::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return StateIdFactory::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::StateIdFactory_ptr 
Components::StateIdFactory::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return StateIdFactory::_nil ();
  return
      ACE_reinterpret_cast
        (
          StateIdFactory_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &StateIdFactory::_tao_class_id
                  )
              )
        );
}

Components::StateIdFactory_ptr
Components::StateIdFactory::_duplicate (StateIdFactory_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::StateIdFactory::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, StateIdFactory)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::StateIdFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/StateIdFactory:1.0";
}

static const CORBA::Long _oc_Components_StateIdFactory[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x49644661), 
  ACE_NTOHL (0x63746f72), 
  ACE_NTOHL (0x793a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/StateIdFactory:1.0
  15,
  ACE_NTOHL (0x53746174), 
  ACE_NTOHL (0x65496446), 
  ACE_NTOHL (0x6163746f), 
  ACE_NTOHL (0x72790000),  // name = StateIdFactory
};

static CORBA::TypeCode _tc_TAO_tc_Components_StateIdFactory (
    CORBA::tk_objref,
    sizeof (_oc_Components_StateIdFactory),
    (char *) &_oc_Components_StateIdFactory,
    0,
    sizeof (Components::StateIdFactory)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_StateIdFactory, &_tc_TAO_tc_Components_StateIdFactory)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_PersistentIdValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f50), 
  ACE_NTOHL (0x65727369), 
  ACE_NTOHL (0x7374656e), 
  ACE_NTOHL (0x74496456), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/PersistentIdValue:1.0
  18,
  ACE_NTOHL (0x50657273), 
  ACE_NTOHL (0x69737465), 
  ACE_NTOHL (0x6e744964), 
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65000000),  // name = PersistentIdValue
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  1, // member count
  4,
  ACE_NTOHL (0x70696400),  // name = pid
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f50), 
    ACE_NTOHL (0x65727369), 
    ACE_NTOHL (0x7374656e), 
    ACE_NTOHL (0x7449643a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/PersistentId:1.0
    13,
    ACE_NTOHL (0x50657273), 
    ACE_NTOHL (0x69737465), 
    ACE_NTOHL (0x6e744964), 
    ACE_NTOHL (0x0),  // name = PersistentId
    CORBA::tk_alias, // typecode kind for typedefs
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x436f7350), 
      ACE_NTOHL (0x65727369), 
      ACE_NTOHL (0x7374656e), 
      ACE_NTOHL (0x74537461), 
      ACE_NTOHL (0x74652f50), 
      ACE_NTOHL (0x69643a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:CosPersistentState/Pid:1.0
      4,
      ACE_NTOHL (0x50696400),  // name = Pid
      CORBA::tk_string, 
      0U, // string length


  0, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_PersistentIdValue (
    CORBA::tk_value,
    sizeof (_oc_Components_PersistentIdValue),
    (char *) &_oc_Components_PersistentIdValue,
    0,
    sizeof (Components::PersistentIdValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_PersistentIdValue, &_tc_TAO_tc_Components_PersistentIdValue)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::PersistentIdValue_var
// *************************************************************

Components::PersistentIdValue_var::PersistentIdValue_var (void) // default constructor
  : ptr_ (0)
{}

Components::PersistentIdValue_var::PersistentIdValue_var (PersistentIdValue* p)
  : ptr_ (p)
{}

Components::PersistentIdValue_var::PersistentIdValue_var (const PersistentIdValue* p)
  : ptr_ (ACE_const_cast(PersistentIdValue*, p))
{}

Components::PersistentIdValue* 
Components::PersistentIdValue_var::ptr (void) const
{
  return this->ptr_;
}

Components::PersistentIdValue_var::PersistentIdValue_var (const PersistentIdValue_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::PersistentIdValue_var::~PersistentIdValue_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::PersistentIdValue_var &
Components::PersistentIdValue_var::operator= (PersistentIdValue* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::PersistentIdValue_var &
Components::PersistentIdValue_var::operator= (const PersistentIdValue_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    PersistentIdValue* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::PersistentIdValue_var::operator const Components::PersistentIdValue* () const // cast
{
  return this->ptr_;
}

Components::PersistentIdValue_var::operator Components::PersistentIdValue* () // cast 
{
  return this->ptr_;
}

Components::PersistentIdValue* 
Components::PersistentIdValue_var::operator-> (void) const
{
  return this->ptr_;
}

Components::PersistentIdValue*
Components::PersistentIdValue_var::in (void) const
{
  return this->ptr_;
}

Components::PersistentIdValue* &
Components::PersistentIdValue_var::inout (void)
{
  return this->ptr_;
}

Components::PersistentIdValue* &
Components::PersistentIdValue_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::PersistentIdValue* 
Components::PersistentIdValue_var::_retn (void)
{
  // yield ownership of managed obj reference
  PersistentIdValue* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::PersistentIdValue_out
// *************************************************************

Components::PersistentIdValue_out::PersistentIdValue_out (PersistentIdValue* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::PersistentIdValue_out::PersistentIdValue_out (PersistentIdValue_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::PersistentIdValue_out::PersistentIdValue_out (const PersistentIdValue_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PersistentIdValue_out&,p).ptr_)
{}

Components::PersistentIdValue_out &
Components::PersistentIdValue_out::operator= (const PersistentIdValue_out &p)
{
  this->ptr_ = ACE_const_cast (PersistentIdValue_out&,p).ptr_;
  return *this;
}

Components::PersistentIdValue_out &
Components::PersistentIdValue_out::operator= (const PersistentIdValue_var &p)
{
  PersistentIdValue* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::PersistentIdValue_out &
Components::PersistentIdValue_out::operator= (PersistentIdValue* p)
{
  this->ptr_ = p;
  return *this;
}

Components::PersistentIdValue_out::operator Components::PersistentIdValue* &() // cast
{
  return this->ptr_;
}

Components::PersistentIdValue* &
Components::PersistentIdValue_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::PersistentIdValue* 
Components::PersistentIdValue_out::operator-> (void)
{
  return this->ptr_;
}

Components::PersistentIdValue* Components::PersistentIdValue::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (PersistentIdValue* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::PersistentIdValue::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::PersistentIdValue::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (Components,StateIdValue)::_tao_obv_narrow (type_id);
  return rval;
}

void
Components::PersistentIdValue::_tao_any_destructor (void *_tao_void_pointer)
{
  PersistentIdValue *tmp = ACE_static_cast (PersistentIdValue*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::PersistentIdValue::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_PersistentIdValue (strm);
}

CORBA::Boolean Components::PersistentIdValue::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_PersistentIdValue (strm);
}

CORBA::Boolean Components::PersistentIdValue::_tao_unmarshal (TAO_InputCDR &strm, PersistentIdValue *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          PersistentIdValue::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PersistentIdValue::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::PersistentIdValue::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = PersistentIdValue::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::PersistentIdValue_init::PersistentIdValue_init ()
{
}

Components::PersistentIdValue_init::~PersistentIdValue_init ()
{
}

const char* 
Components::PersistentIdValue_init::tao_repository_id (void)
{
  return Components::PersistentIdValue::_tao_obv_static_repository_id ();
}
static const CORBA::Long _oc_Components_SegmentDescr[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x65676d65), 
  ACE_NTOHL (0x6e744465), 
  ACE_NTOHL (0x7363723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/SegmentDescr:1.0
  13,
  ACE_NTOHL (0x5365676d), 
  ACE_NTOHL (0x656e7444), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x0),  // name = SegmentDescr
  0, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  2, // member count
  4,
  ACE_NTOHL (0x73696400),  // name = sid
  CORBA::tk_value, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f53), 
    ACE_NTOHL (0x74617465), 
    ACE_NTOHL (0x49645661), 
    ACE_NTOHL (0x6c75653a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/StateIdValue:1.0
    13,
    ACE_NTOHL (0x53746174), 
    ACE_NTOHL (0x65496456), 
    ACE_NTOHL (0x616c7565), 
    ACE_NTOHL (0x0),  // name = StateIdValue
    2, // value modifier
    CORBA::tk_null, // no stateful base valuetype

    0, // member count

  0, // data memeber visibility marker

  4,
  ACE_NTOHL (0x73656700),  // name = seg
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f53), 
    ACE_NTOHL (0x65676d65), 
    ACE_NTOHL (0x6e744964), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SegmentId:1.0
    10,
    ACE_NTOHL (0x5365676d), 
    ACE_NTOHL (0x656e7449), 
    ACE_NTOHL (0x64000000),  // name = SegmentId
    CORBA::tk_short,


  0, // data memeber visibility marker

};

static CORBA::TypeCode _tc_TAO_tc_Components_SegmentDescr (
    CORBA::tk_value,
    sizeof (_oc_Components_SegmentDescr),
    (char *) &_oc_Components_SegmentDescr,
    0,
    sizeof (Components::SegmentDescr)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SegmentDescr, &_tc_TAO_tc_Components_SegmentDescr)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class Components::SegmentDescr_var
// *************************************************************

Components::SegmentDescr_var::SegmentDescr_var (void) // default constructor
  : ptr_ (0)
{}

Components::SegmentDescr_var::SegmentDescr_var (SegmentDescr* p)
  : ptr_ (p)
{}

Components::SegmentDescr_var::SegmentDescr_var (const SegmentDescr* p)
  : ptr_ (ACE_const_cast(SegmentDescr*, p))
{}

Components::SegmentDescr* 
Components::SegmentDescr_var::ptr (void) const
{
  return this->ptr_;
}

Components::SegmentDescr_var::SegmentDescr_var (const SegmentDescr_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

Components::SegmentDescr_var::~SegmentDescr_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

Components::SegmentDescr_var &
Components::SegmentDescr_var::operator= (SegmentDescr* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::SegmentDescr_var &
Components::SegmentDescr_var::operator= (const SegmentDescr_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    SegmentDescr* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

Components::SegmentDescr_var::operator const Components::SegmentDescr* () const // cast
{
  return this->ptr_;
}

Components::SegmentDescr_var::operator Components::SegmentDescr* () // cast 
{
  return this->ptr_;
}

Components::SegmentDescr* 
Components::SegmentDescr_var::operator-> (void) const
{
  return this->ptr_;
}

Components::SegmentDescr*
Components::SegmentDescr_var::in (void) const
{
  return this->ptr_;
}

Components::SegmentDescr* &
Components::SegmentDescr_var::inout (void)
{
  return this->ptr_;
}

Components::SegmentDescr* &
Components::SegmentDescr_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

Components::SegmentDescr* 
Components::SegmentDescr_var::_retn (void)
{
  // yield ownership of managed obj reference
  SegmentDescr* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class Components::SegmentDescr_out
// *************************************************************

Components::SegmentDescr_out::SegmentDescr_out (SegmentDescr* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

Components::SegmentDescr_out::SegmentDescr_out (SegmentDescr_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

Components::SegmentDescr_out::SegmentDescr_out (const SegmentDescr_out &p) // copy constructor
  : ptr_ (ACE_const_cast (SegmentDescr_out&,p).ptr_)
{}

Components::SegmentDescr_out &
Components::SegmentDescr_out::operator= (const SegmentDescr_out &p)
{
  this->ptr_ = ACE_const_cast (SegmentDescr_out&,p).ptr_;
  return *this;
}

Components::SegmentDescr_out &
Components::SegmentDescr_out::operator= (const SegmentDescr_var &p)
{
  SegmentDescr* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

Components::SegmentDescr_out &
Components::SegmentDescr_out::operator= (SegmentDescr* p)
{
  this->ptr_ = p;
  return *this;
}

Components::SegmentDescr_out::operator Components::SegmentDescr* &() // cast
{
  return this->ptr_;
}

Components::SegmentDescr* &
Components::SegmentDescr_out::ptr (void) // ptr
{
  return this->ptr_;
}

Components::SegmentDescr* 
Components::SegmentDescr_out::operator-> (void)
{
  return this->ptr_;
}

Components::SegmentDescr* Components::SegmentDescr::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (SegmentDescr* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* Components::SegmentDescr::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* Components::SegmentDescr::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
Components::SegmentDescr::_tao_any_destructor (void *_tao_void_pointer)
{
  SegmentDescr *tmp = ACE_static_cast (SegmentDescr*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean Components::SegmentDescr::_tao_marshal_v (TAO_OutputCDR & strm)
{
  return this->_tao_marshal__Components_SegmentDescr (strm);
}

CORBA::Boolean Components::SegmentDescr::_tao_unmarshal_v (TAO_InputCDR & strm)
{
  return this->_tao_unmarshal__Components_SegmentDescr (strm);
}

CORBA::Boolean Components::SegmentDescr::_tao_unmarshal (TAO_InputCDR &strm, SegmentDescr *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          SegmentDescr::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "Components::SegmentDescr::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "Components::SegmentDescr::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = SegmentDescr::_downcast (base);
  // %! unmarshal_post
  return 1;
}

Components::SegmentDescr_init::SegmentDescr_init ()
{
}

Components::SegmentDescr_init::~SegmentDescr_init ()
{
}

const char* 
Components::SegmentDescr_init::tao_repository_id (void)
{
  return Components::SegmentDescr::_tao_obv_static_repository_id ();
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SEGMENTDESCRSEQ_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_COMPONENTS_SEGMENTDESCRSEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::_allocate_buffer (CORBA::ULong length)
{
  Components::SegmentDescr **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::SegmentDescr **old = ACE_reinterpret_cast (Components::SegmentDescr**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::SegmentDescr **tmp = ACE_reinterpret_cast (Components::SegmentDescr**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::freebuf (tmp);
  this->buffer_ = 0;
}

Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::~_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq (void)
{
  this->_deallocate_buffer ();
}

void
Components::_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::SegmentDescr **tmp = ACE_reinterpret_cast (Components::SegmentDescr**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_SEGMENTDESCRSEQ_CS_)
#define _COMPONENTS_SEGMENTDESCRSEQ_CS_

// *************************************************************
// Components::SegmentDescrSeq
// *************************************************************

Components::SegmentDescrSeq::SegmentDescrSeq (void)
{}
Components::SegmentDescrSeq::SegmentDescrSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SegmentDescr,Components::SegmentDescr_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::SegmentDescrSeq::SegmentDescrSeq (CORBA::ULong max, CORBA::ULong length, Components::SegmentDescr_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SegmentDescr,Components::SegmentDescr_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::SegmentDescrSeq::SegmentDescrSeq (const SegmentDescrSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_Components_SegmentDescrSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<Components::SegmentDescr,Components::SegmentDescr_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::SegmentDescrSeq::~SegmentDescrSeq (void) // dtor
{}
void Components::SegmentDescrSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  SegmentDescrSeq *tmp = ACE_static_cast (SegmentDescrSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_SegmentDescrSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f53), 
  ACE_NTOHL (0x65676d65), 
  ACE_NTOHL (0x6e744465), 
  ACE_NTOHL (0x73637253), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/SegmentDescrSeq:1.0
  16,
  ACE_NTOHL (0x5365676d), 
  ACE_NTOHL (0x656e7444), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x53657100),  // name = SegmentDescrSeq
  CORBA::tk_sequence, // typecode kind
  284, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    268, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f53), 
      ACE_NTOHL (0x65676d65), 
      ACE_NTOHL (0x6e744465), 
      ACE_NTOHL (0x7363723a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/SegmentDescr:1.0
      13,
      ACE_NTOHL (0x5365676d), 
      ACE_NTOHL (0x656e7444), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x0),  // name = SegmentDescr
      0, // value modifier
      CORBA::tk_null, // no stateful base valuetype

      2, // member count
      4,
      ACE_NTOHL (0x73696400),  // name = sid
      CORBA::tk_value, // typecode kind
      80, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f53), 
        ACE_NTOHL (0x74617465), 
        ACE_NTOHL (0x49645661), 
        ACE_NTOHL (0x6c75653a), 
        ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/StateIdValue:1.0
        13,
        ACE_NTOHL (0x53746174), 
        ACE_NTOHL (0x65496456), 
        ACE_NTOHL (0x616c7565), 
        ACE_NTOHL (0x0),  // name = StateIdValue
        2, // value modifier
        CORBA::tk_null, // no stateful base valuetype

        0, // member count

      0, // data memeber visibility marker

      4,
      ACE_NTOHL (0x73656700),  // name = seg
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x436f6d70), 
        ACE_NTOHL (0x6f6e656e), 
        ACE_NTOHL (0x74732f53), 
        ACE_NTOHL (0x65676d65), 
        ACE_NTOHL (0x6e744964), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/SegmentId:1.0
        10,
        ACE_NTOHL (0x5365676d), 
        ACE_NTOHL (0x656e7449), 
        ACE_NTOHL (0x64000000),  // name = SegmentId
        CORBA::tk_short,


      0, // data memeber visibility marker


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_SegmentDescrSeq (
    CORBA::tk_alias,
    sizeof (_oc_Components_SegmentDescrSeq),
    (char *) &_oc_Components_SegmentDescrSeq,
    0,
    sizeof (Components::SegmentDescrSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_SegmentDescrSeq, &_tc_TAO_tc_Components_SegmentDescrSeq)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::ComponentId::_tao_class_id = 0;

Components::ComponentId_ptr
tao_Components_ComponentId_duplicate (
    Components::ComponentId_ptr p
  )
{
  return Components::ComponentId::_duplicate (p);
}

void
tao_Components_ComponentId_release (
    Components::ComponentId_ptr p
  )
{
  CORBA::release (p);
}

Components::ComponentId_ptr
tao_Components_ComponentId_nil (
    void
  )
{
  return Components::ComponentId::_nil ();
}

Components::ComponentId_ptr
tao_Components_ComponentId_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::ComponentId::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_ComponentId_upcast (
    void *src
  )
{
  Components::ComponentId **tmp =
    ACE_static_cast (Components::ComponentId **, src);
  return *tmp;
}

// *************************************************************
// Components::ComponentId_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::ComponentId_var::ComponentId_var (void) // default constructor
  : ptr_ (ComponentId::_nil ())
{}

::Components::ComponentId_ptr
Components::ComponentId_var::ptr (void) const
{
  return this->ptr_;
}

Components::ComponentId_var::ComponentId_var (const ::Components::ComponentId_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ComponentId::_duplicate (p.ptr ()))
{}

Components::ComponentId_var::~ComponentId_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::ComponentId_var &
Components::ComponentId_var::operator= (ComponentId_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::ComponentId_var &
Components::ComponentId_var::operator= (const ::Components::ComponentId_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::ComponentId::_duplicate (p.ptr ());
  }
  return *this;
}

Components::ComponentId_var::operator const ::Components::ComponentId_ptr &() const // cast
{
  return this->ptr_;
}

Components::ComponentId_var::operator ::Components::ComponentId_ptr &() // cast 
{
  return this->ptr_;
}

::Components::ComponentId_ptr
Components::ComponentId_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::ComponentId_ptr
Components::ComponentId_var::in (void) const
{
  return this->ptr_;
}

::Components::ComponentId_ptr &
Components::ComponentId_var::inout (void)
{
  return this->ptr_;
}

::Components::ComponentId_ptr &
Components::ComponentId_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::ComponentId::_nil ();
  return this->ptr_;
}

::Components::ComponentId_ptr
Components::ComponentId_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::ComponentId_ptr val = this->ptr_;
  this->ptr_ = ::Components::ComponentId::_nil ();
  return val;
}

::Components::ComponentId_ptr
Components::ComponentId_var::tao_duplicate (ComponentId_ptr p)
{
  return ::Components::ComponentId::_duplicate (p);
}

void
Components::ComponentId_var::tao_release (ComponentId_ptr p)
{
  CORBA::release (p);
}

::Components::ComponentId_ptr
Components::ComponentId_var::tao_nil (void)
{
  return ::Components::ComponentId::_nil ();
}

::Components::ComponentId_ptr
Components::ComponentId_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::ComponentId::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::ComponentId_var::tao_upcast (void *src)
{
  ComponentId **tmp =
    ACE_static_cast (ComponentId **, src);
  return *tmp;
}

// *************************************************************
// Components::ComponentId_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::ComponentId_out::ComponentId_out (ComponentId_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::ComponentId::_nil ();
}

Components::ComponentId_out::ComponentId_out (ComponentId_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::ComponentId::_nil ();
}

Components::ComponentId_out::ComponentId_out (const ::Components::ComponentId_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentId_out &, p).ptr_)
{}

::Components::ComponentId_out &
Components::ComponentId_out::operator= (const ::Components::ComponentId_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentId_out&, p).ptr_;
  return *this;
}

Components::ComponentId_out &
Components::ComponentId_out::operator= (const ::Components::ComponentId_var &p)
{
  this->ptr_ = ::Components::ComponentId::_duplicate (p.ptr ());
  return *this;
}

Components::ComponentId_out &
Components::ComponentId_out::operator= (ComponentId_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::ComponentId_out::operator ::Components::ComponentId_ptr &() // cast
{
  return this->ptr_;
}

::Components::ComponentId_ptr &
Components::ComponentId_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::ComponentId_ptr
Components::ComponentId_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::ComponentId::ComponentId (void)
{}

Components::ComponentId::~ComponentId (void)
{}

void Components::ComponentId::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentId *tmp = ACE_static_cast (ComponentId*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::ComponentId_ptr Components::ComponentId::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ComponentId::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::ComponentId_ptr 
Components::ComponentId::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ComponentId::_nil ();
  return
      ACE_reinterpret_cast
        (
          ComponentId_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ComponentId::_tao_class_id
                  )
              )
        );
}

Components::ComponentId_ptr
Components::ComponentId::_duplicate (ComponentId_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::ComponentId::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, ComponentId)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::ComponentId::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/ComponentId:1.0";
}

static const CORBA::Long _oc_Components_ComponentId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f43), 
  ACE_NTOHL (0x6f6d706f), 
  ACE_NTOHL (0x6e656e74), 
  ACE_NTOHL (0x49643a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/ComponentId:1.0
  12,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74496400),  // name = ComponentId
};

static CORBA::TypeCode _tc_TAO_tc_Components_ComponentId (
    CORBA::tk_objref,
    sizeof (_oc_Components_ComponentId),
    (char *) &_oc_Components_ComponentId,
    0,
    sizeof (Components::ComponentId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ComponentId, &_tc_TAO_tc_Components_ComponentId)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Entity2Context::_tao_class_id = 0;

Components::Entity2Context_ptr
tao_Components_Entity2Context_duplicate (
    Components::Entity2Context_ptr p
  )
{
  return Components::Entity2Context::_duplicate (p);
}

void
tao_Components_Entity2Context_release (
    Components::Entity2Context_ptr p
  )
{
  CORBA::release (p);
}

Components::Entity2Context_ptr
tao_Components_Entity2Context_nil (
    void
  )
{
  return Components::Entity2Context::_nil ();
}

Components::Entity2Context_ptr
tao_Components_Entity2Context_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Entity2Context::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Entity2Context_upcast (
    void *src
  )
{
  Components::Entity2Context **tmp =
    ACE_static_cast (Components::Entity2Context **, src);
  return *tmp;
}

// *************************************************************
// Components::Entity2Context_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Entity2Context_var::Entity2Context_var (void) // default constructor
  : ptr_ (Entity2Context::_nil ())
{}

::Components::Entity2Context_ptr
Components::Entity2Context_var::ptr (void) const
{
  return this->ptr_;
}

Components::Entity2Context_var::Entity2Context_var (const ::Components::Entity2Context_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Entity2Context::_duplicate (p.ptr ()))
{}

Components::Entity2Context_var::~Entity2Context_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Entity2Context_var &
Components::Entity2Context_var::operator= (Entity2Context_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Entity2Context_var &
Components::Entity2Context_var::operator= (const ::Components::Entity2Context_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Entity2Context::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Entity2Context_var::operator const ::Components::Entity2Context_ptr &() const // cast
{
  return this->ptr_;
}

Components::Entity2Context_var::operator ::Components::Entity2Context_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Entity2Context_ptr
Components::Entity2Context_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Entity2Context_ptr
Components::Entity2Context_var::in (void) const
{
  return this->ptr_;
}

::Components::Entity2Context_ptr &
Components::Entity2Context_var::inout (void)
{
  return this->ptr_;
}

::Components::Entity2Context_ptr &
Components::Entity2Context_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Entity2Context::_nil ();
  return this->ptr_;
}

::Components::Entity2Context_ptr
Components::Entity2Context_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Entity2Context_ptr val = this->ptr_;
  this->ptr_ = ::Components::Entity2Context::_nil ();
  return val;
}

::Components::Entity2Context_ptr
Components::Entity2Context_var::tao_duplicate (Entity2Context_ptr p)
{
  return ::Components::Entity2Context::_duplicate (p);
}

void
Components::Entity2Context_var::tao_release (Entity2Context_ptr p)
{
  CORBA::release (p);
}

::Components::Entity2Context_ptr
Components::Entity2Context_var::tao_nil (void)
{
  return ::Components::Entity2Context::_nil ();
}

::Components::Entity2Context_ptr
Components::Entity2Context_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Entity2Context::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Entity2Context_var::tao_upcast (void *src)
{
  Entity2Context **tmp =
    ACE_static_cast (Entity2Context **, src);
  return *tmp;
}

// *************************************************************
// Components::Entity2Context_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Entity2Context_out::Entity2Context_out (Entity2Context_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Entity2Context::_nil ();
}

Components::Entity2Context_out::Entity2Context_out (Entity2Context_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Entity2Context::_nil ();
}

Components::Entity2Context_out::Entity2Context_out (const ::Components::Entity2Context_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Entity2Context_out &, p).ptr_)
{}

::Components::Entity2Context_out &
Components::Entity2Context_out::operator= (const ::Components::Entity2Context_out &p)
{
  this->ptr_ = ACE_const_cast (Entity2Context_out&, p).ptr_;
  return *this;
}

Components::Entity2Context_out &
Components::Entity2Context_out::operator= (const ::Components::Entity2Context_var &p)
{
  this->ptr_ = ::Components::Entity2Context::_duplicate (p.ptr ());
  return *this;
}

Components::Entity2Context_out &
Components::Entity2Context_out::operator= (Entity2Context_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Entity2Context_out::operator ::Components::Entity2Context_ptr &() // cast
{
  return this->ptr_;
}

::Components::Entity2Context_ptr &
Components::Entity2Context_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Entity2Context_ptr
Components::Entity2Context_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Entity2Context::Entity2Context (void)
{}

Components::Entity2Context::~Entity2Context (void)
{}

void Components::Entity2Context::_tao_any_destructor (void *_tao_void_pointer)
{
  Entity2Context *tmp = ACE_static_cast (Entity2Context*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Entity2Context_ptr Components::Entity2Context::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return Entity2Context::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Entity2Context_ptr 
Components::Entity2Context::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Entity2Context::_nil ();
  return
      ACE_reinterpret_cast
        (
          Entity2Context_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Entity2Context::_tao_class_id
                  )
              )
        );
}

Components::Entity2Context_ptr
Components::Entity2Context::_duplicate (Entity2Context_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::Entity2Context::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, Entity2Context)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, EntityContext)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::EntityContext_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCM2Context)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCM2Context_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, CCMContext)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            Components::CCMContext_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Entity2Context::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Entity2Context:1.0";
}

static const CORBA::Long _oc_Components_Entity2Context[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f45), 
  ACE_NTOHL (0x6e746974), 
  ACE_NTOHL (0x7932436f), 
  ACE_NTOHL (0x6e746578), 
  ACE_NTOHL (0x743a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Entity2Context:1.0
  15,
  ACE_NTOHL (0x456e7469), 
  ACE_NTOHL (0x74793243), 
  ACE_NTOHL (0x6f6e7465), 
  ACE_NTOHL (0x78740000),  // name = Entity2Context
};

static CORBA::TypeCode _tc_TAO_tc_Components_Entity2Context (
    CORBA::tk_objref,
    sizeof (_oc_Components_Entity2Context),
    (char *) &_oc_Components_Entity2Context,
    0,
    sizeof (Components::Entity2Context)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Entity2Context, &_tc_TAO_tc_Components_Entity2Context)
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::HomeExecutorBase::_tao_class_id = 0;

Components::HomeExecutorBase_ptr
tao_Components_HomeExecutorBase_duplicate (
    Components::HomeExecutorBase_ptr p
  )
{
  return Components::HomeExecutorBase::_duplicate (p);
}

void
tao_Components_HomeExecutorBase_release (
    Components::HomeExecutorBase_ptr p
  )
{
  CORBA::release (p);
}

Components::HomeExecutorBase_ptr
tao_Components_HomeExecutorBase_nil (
    void
  )
{
  return Components::HomeExecutorBase::_nil ();
}

Components::HomeExecutorBase_ptr
tao_Components_HomeExecutorBase_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::HomeExecutorBase::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_HomeExecutorBase_upcast (
    void *src
  )
{
  Components::HomeExecutorBase **tmp =
    ACE_static_cast (Components::HomeExecutorBase **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeExecutorBase_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::HomeExecutorBase_var::HomeExecutorBase_var (void) // default constructor
  : ptr_ (HomeExecutorBase::_nil ())
{}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_var::ptr (void) const
{
  return this->ptr_;
}

Components::HomeExecutorBase_var::HomeExecutorBase_var (const ::Components::HomeExecutorBase_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (HomeExecutorBase::_duplicate (p.ptr ()))
{}

Components::HomeExecutorBase_var::~HomeExecutorBase_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::HomeExecutorBase_var &
Components::HomeExecutorBase_var::operator= (HomeExecutorBase_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::HomeExecutorBase_var &
Components::HomeExecutorBase_var::operator= (const ::Components::HomeExecutorBase_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::HomeExecutorBase::_duplicate (p.ptr ());
  }
  return *this;
}

Components::HomeExecutorBase_var::operator const ::Components::HomeExecutorBase_ptr &() const // cast
{
  return this->ptr_;
}

Components::HomeExecutorBase_var::operator ::Components::HomeExecutorBase_ptr &() // cast 
{
  return this->ptr_;
}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_var::in (void) const
{
  return this->ptr_;
}

::Components::HomeExecutorBase_ptr &
Components::HomeExecutorBase_var::inout (void)
{
  return this->ptr_;
}

::Components::HomeExecutorBase_ptr &
Components::HomeExecutorBase_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeExecutorBase::_nil ();
  return this->ptr_;
}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::HomeExecutorBase_ptr val = this->ptr_;
  this->ptr_ = ::Components::HomeExecutorBase::_nil ();
  return val;
}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_var::tao_duplicate (HomeExecutorBase_ptr p)
{
  return ::Components::HomeExecutorBase::_duplicate (p);
}

void
Components::HomeExecutorBase_var::tao_release (HomeExecutorBase_ptr p)
{
  CORBA::release (p);
}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_var::tao_nil (void)
{
  return ::Components::HomeExecutorBase::_nil ();
}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::HomeExecutorBase::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::HomeExecutorBase_var::tao_upcast (void *src)
{
  HomeExecutorBase **tmp =
    ACE_static_cast (HomeExecutorBase **, src);
  return *tmp;
}

// *************************************************************
// Components::HomeExecutorBase_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::HomeExecutorBase_out::HomeExecutorBase_out (HomeExecutorBase_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::HomeExecutorBase::_nil ();
}

Components::HomeExecutorBase_out::HomeExecutorBase_out (HomeExecutorBase_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::HomeExecutorBase::_nil ();
}

Components::HomeExecutorBase_out::HomeExecutorBase_out (const ::Components::HomeExecutorBase_out &p) // copy constructor
  : ptr_ (ACE_const_cast (HomeExecutorBase_out &, p).ptr_)
{}

::Components::HomeExecutorBase_out &
Components::HomeExecutorBase_out::operator= (const ::Components::HomeExecutorBase_out &p)
{
  this->ptr_ = ACE_const_cast (HomeExecutorBase_out&, p).ptr_;
  return *this;
}

Components::HomeExecutorBase_out &
Components::HomeExecutorBase_out::operator= (const ::Components::HomeExecutorBase_var &p)
{
  this->ptr_ = ::Components::HomeExecutorBase::_duplicate (p.ptr ());
  return *this;
}

Components::HomeExecutorBase_out &
Components::HomeExecutorBase_out::operator= (HomeExecutorBase_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::HomeExecutorBase_out::operator ::Components::HomeExecutorBase_ptr &() // cast
{
  return this->ptr_;
}

::Components::HomeExecutorBase_ptr &
Components::HomeExecutorBase_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::HomeExecutorBase_ptr
Components::HomeExecutorBase_out::operator-> (void)
{
  return this->ptr_;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::HomeExecutorBase::HomeExecutorBase (void)
{}

Components::HomeExecutorBase::~HomeExecutorBase (void)
{}

void Components::HomeExecutorBase::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeExecutorBase *tmp = ACE_static_cast (HomeExecutorBase*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::HomeExecutorBase_ptr Components::HomeExecutorBase::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return HomeExecutorBase::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::HomeExecutorBase_ptr 
Components::HomeExecutorBase::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return HomeExecutorBase::_nil ();
  return
      ACE_reinterpret_cast
        (
          HomeExecutorBase_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &HomeExecutorBase::_tao_class_id
                  )
              )
        );
}

Components::HomeExecutorBase_ptr
Components::HomeExecutorBase::_duplicate (HomeExecutorBase_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *Components::HomeExecutorBase::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components, HomeExecutorBase)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::HomeExecutorBase::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/HomeExecutorBase:1.0";
}

static const CORBA::Long _oc_Components_HomeExecutorBase[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f48), 
  ACE_NTOHL (0x6f6d6545), 
  ACE_NTOHL (0x78656375), 
  ACE_NTOHL (0x746f7242), 
  ACE_NTOHL (0x6173653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/HomeExecutorBase:1.0
  17,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x45786563), 
  ACE_NTOHL (0x75746f72), 
  ACE_NTOHL (0x42617365), 
  ACE_NTOHL (0x0),  // name = HomeExecutorBase
};

static CORBA::TypeCode _tc_TAO_tc_Components_HomeExecutorBase (
    CORBA::tk_objref,
    sizeof (_oc_Components_HomeExecutorBase),
    (char *) &_oc_Components_HomeExecutorBase,
    0,
    sizeof (Components::HomeExecutorBase)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_HomeExecutorBase, &_tc_TAO_tc_Components_HomeExecutorBase)
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_Deployment_UUID[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f5555), 
  ACE_NTOHL (0x49443a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Deployment/UUID:1.0
  5,
  ACE_NTOHL (0x55554944), 
  ACE_NTOHL (0x0),  // name = UUID
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_UUID (
    CORBA::tk_alias,
    sizeof (_oc_Components_Deployment_UUID),
    (char *) &_oc_Components_Deployment_UUID,
    0,
    sizeof (Components::Deployment::UUID)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_UUID, &_tc_TAO_tc_Components_Deployment_UUID)
TAO_NAMESPACE_END
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_Deployment_Location[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f4c6f), 
  ACE_NTOHL (0x63617469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Deployment/Location:1.0
  9,
  ACE_NTOHL (0x4c6f6361), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = Location
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_Location (
    CORBA::tk_alias,
    sizeof (_oc_Components_Deployment_Location),
    (char *) &_oc_Components_Deployment_Location,
    0,
    sizeof (Components::Deployment::Location)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Location, &_tc_TAO_tc_Components_Deployment_Location)
TAO_NAMESPACE_END
TAO_NAMESPACE_END

static const CORBA::Long _oc_Components_Deployment_AssemblyState[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f4173), 
  ACE_NTOHL (0x73656d62), 
  ACE_NTOHL (0x6c795374), 
  ACE_NTOHL (0x6174653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Deployment/AssemblyState:1.0
  14,
  ACE_NTOHL (0x41737365), 
  ACE_NTOHL (0x6d626c79), 
  ACE_NTOHL (0x53746174), 
  ACE_NTOHL (0x65000000),  // name = AssemblyState
  2, // member count
  9,
  ACE_NTOHL (0x494e4143), 
  ACE_NTOHL (0x54495645), 
  ACE_NTOHL (0x0),  // name = INACTIVE
  10,
  ACE_NTOHL (0x494e5345), 
  ACE_NTOHL (0x52564943), 
  ACE_NTOHL (0x45000000),  // name = INSERVICE
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_AssemblyState (
    CORBA::tk_enum,
    sizeof (_oc_Components_Deployment_AssemblyState),
    (char *) &_oc_Components_Deployment_AssemblyState,
    0,
    sizeof (Components::Deployment::AssemblyState)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_AssemblyState, &_tc_TAO_tc_Components_Deployment_AssemblyState)
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Deployment::UnknownImplId::UnknownImplId (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Deployment/UnknownImplId:1.0",
        "UnknownImplId"
      )
{
}

// Destructor - all members are of self managing types.
Components::Deployment::UnknownImplId::~UnknownImplId (void)
{
}

// Copy constructor.
Components::Deployment::UnknownImplId::UnknownImplId (const ::Components::Deployment::UnknownImplId &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Deployment::UnknownImplId&
Components::Deployment::UnknownImplId::operator= (const ::Components::Deployment::UnknownImplId &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Deployment::UnknownImplId::_tao_any_destructor (void *_tao_void_pointer)
{
  UnknownImplId *tmp = ACE_static_cast (UnknownImplId*, _tao_void_pointer);
  delete tmp;
}

Components::Deployment::UnknownImplId *
Components::Deployment::UnknownImplId::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Deployment/UnknownImplId:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (UnknownImplId *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Deployment::UnknownImplId::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Deployment::UnknownImplId, 0);
  return retval;
}

CORBA::Exception *
Components::Deployment::UnknownImplId::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Deployment::UnknownImplId (*this),
      0
    );
  return result;
}

void Components::Deployment::UnknownImplId::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Deployment::UnknownImplId::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Deployment::UnknownImplId::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Deployment_UnknownImplId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f556e), 
  ACE_NTOHL (0x6b6e6f77), 
  ACE_NTOHL (0x6e496d70), 
  ACE_NTOHL (0x6c49643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Deployment/UnknownImplId:1.0
  14,
  ACE_NTOHL (0x556e6b6e), 
  ACE_NTOHL (0x6f776e49), 
  ACE_NTOHL (0x6d706c49), 
  ACE_NTOHL (0x64000000),  // name = UnknownImplId
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_UnknownImplId (
    CORBA::tk_except,
    sizeof (_oc_Components_Deployment_UnknownImplId),
    (char *) &_oc_Components_Deployment_UnknownImplId,
    0,
    sizeof (Components::Deployment::UnknownImplId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_UnknownImplId, &_tc_TAO_tc_Components_Deployment_UnknownImplId)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Deployment::UnknownImplId::_type (void) const
{
  return ::Components::Deployment::_tc_UnknownImplId;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Deployment::InvalidLocation::InvalidLocation (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Deployment/InvalidLocation:1.0",
        "InvalidLocation"
      )
{
}

// Destructor - all members are of self managing types.
Components::Deployment::InvalidLocation::~InvalidLocation (void)
{
}

// Copy constructor.
Components::Deployment::InvalidLocation::InvalidLocation (const ::Components::Deployment::InvalidLocation &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Deployment::InvalidLocation&
Components::Deployment::InvalidLocation::operator= (const ::Components::Deployment::InvalidLocation &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Deployment::InvalidLocation::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidLocation *tmp = ACE_static_cast (InvalidLocation*, _tao_void_pointer);
  delete tmp;
}

Components::Deployment::InvalidLocation *
Components::Deployment::InvalidLocation::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Deployment/InvalidLocation:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidLocation *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Deployment::InvalidLocation::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Deployment::InvalidLocation, 0);
  return retval;
}

CORBA::Exception *
Components::Deployment::InvalidLocation::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Deployment::InvalidLocation (*this),
      0
    );
  return result;
}

void Components::Deployment::InvalidLocation::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Deployment::InvalidLocation::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Deployment::InvalidLocation::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Deployment_InvalidLocation[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f496e), 
  ACE_NTOHL (0x76616c69), 
  ACE_NTOHL (0x644c6f63), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Deployment/InvalidLocation:1.0
  16,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c69644c), 
  ACE_NTOHL (0x6f636174), 
  ACE_NTOHL (0x696f6e00),  // name = InvalidLocation
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_InvalidLocation (
    CORBA::tk_except,
    sizeof (_oc_Components_Deployment_InvalidLocation),
    (char *) &_oc_Components_Deployment_InvalidLocation,
    0,
    sizeof (Components::Deployment::InvalidLocation)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidLocation, &_tc_TAO_tc_Components_Deployment_InvalidLocation)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Deployment::InvalidLocation::_type (void) const
{
  return ::Components::Deployment::_tc_InvalidLocation;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Deployment::InstallationFailure::InstallationFailure (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Deployment/InstallationFailure:1.0",
        "InstallationFailure"
      )
{
}

// Destructor - all members are of self managing types.
Components::Deployment::InstallationFailure::~InstallationFailure (void)
{
}

// Copy constructor.
Components::Deployment::InstallationFailure::InstallationFailure (const ::Components::Deployment::InstallationFailure &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = _tao_excp.reason;
}

// Assignment operator.
Components::Deployment::InstallationFailure&
Components::Deployment::InstallationFailure::operator= (const ::Components::Deployment::InstallationFailure &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = _tao_excp.reason;
  return *this;
}

void Components::Deployment::InstallationFailure::_tao_any_destructor (void *_tao_void_pointer)
{
  InstallationFailure *tmp = ACE_static_cast (InstallationFailure*, _tao_void_pointer);
  delete tmp;
}

Components::Deployment::InstallationFailure *
Components::Deployment::InstallationFailure::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Deployment/InstallationFailure:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InstallationFailure *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Deployment::InstallationFailure::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Deployment::InstallationFailure, 0);
  return retval;
}

CORBA::Exception *
Components::Deployment::InstallationFailure::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Deployment::InstallationFailure (*this),
      0
    );
  return result;
}

void Components::Deployment::InstallationFailure::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Deployment::InstallationFailure::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Deployment::InstallationFailure::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

Components::Deployment::InstallationFailure::InstallationFailure (
    Components::FailureReason _tao_reason
  )
  : CORBA_UserException (
        "IDL:omg.org/Components/Deployment/InstallationFailure:1.0",
        "InstallationFailure"
      )
{
  this->reason = _tao_reason;
}

static const CORBA::Long _oc_Components_Deployment_InstallationFailure[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  58,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f496e), 
  ACE_NTOHL (0x7374616c), 
  ACE_NTOHL (0x6c617469), 
  ACE_NTOHL (0x6f6e4661), 
  ACE_NTOHL (0x696c7572), 
  ACE_NTOHL (0x653a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Deployment/InstallationFailure:1.0
  20,
  ACE_NTOHL (0x496e7374), 
  ACE_NTOHL (0x616c6c61), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x4661696c), 
  ACE_NTOHL (0x75726500),  // name = InstallationFailure
  1, // member count
  7,
  ACE_NTOHL (0x72656173), 
  ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x436f6d70), 
    ACE_NTOHL (0x6f6e656e), 
    ACE_NTOHL (0x74732f46), 
    ACE_NTOHL (0x61696c75), 
    ACE_NTOHL (0x72655265), 
    ACE_NTOHL (0x61736f6e), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/FailureReason:1.0
    14,
    ACE_NTOHL (0x4661696c), 
    ACE_NTOHL (0x75726552), 
    ACE_NTOHL (0x6561736f), 
    ACE_NTOHL (0x6e000000),  // name = FailureReason
    CORBA::tk_ulong,


};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_InstallationFailure (
    CORBA::tk_except,
    sizeof (_oc_Components_Deployment_InstallationFailure),
    (char *) &_oc_Components_Deployment_InstallationFailure,
    0,
    sizeof (Components::Deployment::InstallationFailure)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InstallationFailure, &_tc_TAO_tc_Components_Deployment_InstallationFailure)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Deployment::InstallationFailure::_type (void) const
{
  return ::Components::Deployment::_tc_InstallationFailure;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Deployment::InvalidAssembly::InvalidAssembly (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Deployment/InvalidAssembly:1.0",
        "InvalidAssembly"
      )
{
}

// Destructor - all members are of self managing types.
Components::Deployment::InvalidAssembly::~InvalidAssembly (void)
{
}

// Copy constructor.
Components::Deployment::InvalidAssembly::InvalidAssembly (const ::Components::Deployment::InvalidAssembly &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Deployment::InvalidAssembly&
Components::Deployment::InvalidAssembly::operator= (const ::Components::Deployment::InvalidAssembly &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Deployment::InvalidAssembly::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidAssembly *tmp = ACE_static_cast (InvalidAssembly*, _tao_void_pointer);
  delete tmp;
}

Components::Deployment::InvalidAssembly *
Components::Deployment::InvalidAssembly::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Deployment/InvalidAssembly:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidAssembly *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Deployment::InvalidAssembly::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Deployment::InvalidAssembly, 0);
  return retval;
}

CORBA::Exception *
Components::Deployment::InvalidAssembly::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Deployment::InvalidAssembly (*this),
      0
    );
  return result;
}

void Components::Deployment::InvalidAssembly::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Deployment::InvalidAssembly::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Deployment::InvalidAssembly::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Deployment_InvalidAssembly[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f496e), 
  ACE_NTOHL (0x76616c69), 
  ACE_NTOHL (0x64417373), 
  ACE_NTOHL (0x656d626c), 
  ACE_NTOHL (0x793a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Deployment/InvalidAssembly:1.0
  16,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696441), 
  ACE_NTOHL (0x7373656d), 
  ACE_NTOHL (0x626c7900),  // name = InvalidAssembly
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_InvalidAssembly (
    CORBA::tk_except,
    sizeof (_oc_Components_Deployment_InvalidAssembly),
    (char *) &_oc_Components_Deployment_InvalidAssembly,
    0,
    sizeof (Components::Deployment::InvalidAssembly)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_InvalidAssembly, &_tc_TAO_tc_Components_Deployment_InvalidAssembly)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Deployment::InvalidAssembly::_type (void) const
{
  return ::Components::Deployment::_tc_InvalidAssembly;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Deployment::ComponentInstallation::_tao_class_id = 0;

Components::Deployment::ComponentInstallation_ptr
tao_Components_Deployment_ComponentInstallation_duplicate (
    Components::Deployment::ComponentInstallation_ptr p
  )
{
  return Components::Deployment::ComponentInstallation::_duplicate (p);
}

void
tao_Components_Deployment_ComponentInstallation_release (
    Components::Deployment::ComponentInstallation_ptr p
  )
{
  CORBA::release (p);
}

Components::Deployment::ComponentInstallation_ptr
tao_Components_Deployment_ComponentInstallation_nil (
    void
  )
{
  return Components::Deployment::ComponentInstallation::_nil ();
}

Components::Deployment::ComponentInstallation_ptr
tao_Components_Deployment_ComponentInstallation_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Deployment::ComponentInstallation::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Deployment_ComponentInstallation_upcast (
    void *src
  )
{
  Components::Deployment::ComponentInstallation **tmp =
    ACE_static_cast (Components::Deployment::ComponentInstallation **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::ComponentInstallation_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Deployment::ComponentInstallation_var::ComponentInstallation_var (void) // default constructor
  : ptr_ (ComponentInstallation::_nil ())
{}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_var::ptr (void) const
{
  return this->ptr_;
}

Components::Deployment::ComponentInstallation_var::ComponentInstallation_var (const ::Components::Deployment::ComponentInstallation_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ComponentInstallation::_duplicate (p.ptr ()))
{}

Components::Deployment::ComponentInstallation_var::~ComponentInstallation_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Deployment::ComponentInstallation_var &
Components::Deployment::ComponentInstallation_var::operator= (ComponentInstallation_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Deployment::ComponentInstallation_var &
Components::Deployment::ComponentInstallation_var::operator= (const ::Components::Deployment::ComponentInstallation_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Deployment::ComponentInstallation::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Deployment::ComponentInstallation_var::operator const ::Components::Deployment::ComponentInstallation_ptr &() const // cast
{
  return this->ptr_;
}

Components::Deployment::ComponentInstallation_var::operator ::Components::Deployment::ComponentInstallation_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_var::in (void) const
{
  return this->ptr_;
}

::Components::Deployment::ComponentInstallation_ptr &
Components::Deployment::ComponentInstallation_var::inout (void)
{
  return this->ptr_;
}

::Components::Deployment::ComponentInstallation_ptr &
Components::Deployment::ComponentInstallation_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::ComponentInstallation::_nil ();
  return this->ptr_;
}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Deployment::ComponentInstallation_ptr val = this->ptr_;
  this->ptr_ = ::Components::Deployment::ComponentInstallation::_nil ();
  return val;
}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_var::tao_duplicate (ComponentInstallation_ptr p)
{
  return ::Components::Deployment::ComponentInstallation::_duplicate (p);
}

void
Components::Deployment::ComponentInstallation_var::tao_release (ComponentInstallation_ptr p)
{
  CORBA::release (p);
}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_var::tao_nil (void)
{
  return ::Components::Deployment::ComponentInstallation::_nil ();
}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Deployment::ComponentInstallation::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Deployment::ComponentInstallation_var::tao_upcast (void *src)
{
  ComponentInstallation **tmp =
    ACE_static_cast (ComponentInstallation **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::ComponentInstallation_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Deployment::ComponentInstallation_out::ComponentInstallation_out (ComponentInstallation_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Deployment::ComponentInstallation::_nil ();
}

Components::Deployment::ComponentInstallation_out::ComponentInstallation_out (ComponentInstallation_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::ComponentInstallation::_nil ();
}

Components::Deployment::ComponentInstallation_out::ComponentInstallation_out (const ::Components::Deployment::ComponentInstallation_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentInstallation_out &, p).ptr_)
{}

::Components::Deployment::ComponentInstallation_out &
Components::Deployment::ComponentInstallation_out::operator= (const ::Components::Deployment::ComponentInstallation_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentInstallation_out&, p).ptr_;
  return *this;
}

Components::Deployment::ComponentInstallation_out &
Components::Deployment::ComponentInstallation_out::operator= (const ::Components::Deployment::ComponentInstallation_var &p)
{
  this->ptr_ = ::Components::Deployment::ComponentInstallation::_duplicate (p.ptr ());
  return *this;
}

Components::Deployment::ComponentInstallation_out &
Components::Deployment::ComponentInstallation_out::operator= (ComponentInstallation_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Deployment::ComponentInstallation_out::operator ::Components::Deployment::ComponentInstallation_ptr &() // cast
{
  return this->ptr_;
}

::Components::Deployment::ComponentInstallation_ptr &
Components::Deployment::ComponentInstallation_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * implUUID,
      const char * component_loc);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install &);

  const char * implUUID_;
  const char * component_loc_;
  
};

TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install::TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * implUUID,
    const char * component_loc    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    implUUID_ (implUUID),
    component_loc_ (component_loc)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= implUUID_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= component_loc_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_install_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidLocation,
    Components::Deployment::_tc_InstallationFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_install_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * implUUID,
      const char * component_loc);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace &);

  const char * implUUID_;
  const char * component_loc_;
  
};

TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace::TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * implUUID,
    const char * component_loc    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    implUUID_ (implUUID),
    component_loc_ (component_loc)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= implUUID_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= component_loc_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_replace_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidLocation,
    Components::Deployment::_tc_InstallationFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_replace_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * implUUID);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove &);

  const char * implUUID_;
  
};

TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove::TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * implUUID    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    implUUID_ (implUUID)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= implUUID_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_remove_exceptiondata[] = 
  {
    Components::Deployment::_tc_UnknownImplId,
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * implUUID);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation &);

  const char * implUUID_;
  char * _result;
};

TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * implUUID    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    implUUID_ (implUUID)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= implUUID_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentInstallation_get_implementation_exceptiondata[] = 
  {
    Components::Deployment::_tc_UnknownImplId,
    Components::Deployment::_tc_InstallationFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentInstallation_get_implementation_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation::result (char * result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::Deployment::_TAO_ComponentInstallation_Proxy_Impl::_TAO_ComponentInstallation_Proxy_Impl (void)
{}

Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Impl::_TAO_ComponentInstallation_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

void Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Impl::install (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID,
    const char * component_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::Deployment::InstallationFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ComponentInstallation_install_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/InvalidLocation:1.0",
      Components::Deployment::InvalidLocation::_alloc
    },
    {
      "IDL:omg.org/Components/Deployment/InstallationFailure:1.0",
      Components::Deployment::InstallationFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "install",
      7,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_install _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        implUUID,
        component_loc
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << implUUID) &&
              (_tao_out << component_loc)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ComponentInstallation_install_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Impl::replace (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID,
    const char * component_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::Deployment::InstallationFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ComponentInstallation_replace_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/InvalidLocation:1.0",
      Components::Deployment::InvalidLocation::_alloc
    },
    {
      "IDL:omg.org/Components/Deployment/InstallationFailure:1.0",
      Components::Deployment::InstallationFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "replace",
      7,
      2,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_replace _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        implUUID,
        component_loc
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << implUUID) &&
              (_tao_out << component_loc)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ComponentInstallation_replace_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ComponentInstallation_remove_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/UnknownImplId:1.0",
      Components::Deployment::UnknownImplId::_alloc
    },
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove",
      6,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_remove _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        implUUID
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << implUUID)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ComponentInstallation_remove_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

char * Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Impl::get_implementation (
    CORBA_Object *_collocated_tao_target_,
    const char * implUUID
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::Deployment::InstallationFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ComponentInstallation_get_implementation_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/UnknownImplId:1.0",
      Components::Deployment::UnknownImplId::_alloc
    },
    {
      "IDL:omg.org/Components/Deployment/InstallationFailure:1.0",
      Components::Deployment::InstallationFailure::_alloc
    }
  };

  CORBA::String_var _tao_retval;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_implementation",
      18,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentInstallation_get_implementation _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        implUUID
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << implUUID)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ComponentInstallation_get_implementation_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          char * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::Deployment::_TAO_ComponentInstallation_Proxy_Broker::_TAO_ComponentInstallation_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentInstallation_Proxy_Broker::~_TAO_ComponentInstallation_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentInstallation_Proxy_Broker * (*Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Broker *
Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Broker::the_TAO_ComponentInstallation_Remote_Proxy_Broker (void)
{
  static ::Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Broker::_TAO_ComponentInstallation_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Broker::~_TAO_ComponentInstallation_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentInstallation_Proxy_Impl&
Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Broker::select_proxy (
  ::Components::Deployment::ComponentInstallation *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Deployment::ComponentInstallation::ComponentInstallation (int collocated)
{
  this->Components_Deployment_ComponentInstallation_setup_collocation (collocated);
}

Components::Deployment::ComponentInstallation::~ComponentInstallation (void)
{}

void
Components::Deployment::ComponentInstallation::Components_Deployment_ComponentInstallation_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentInstallation_Proxy_Broker_ =
      ::Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentInstallation_Proxy_Broker_ =
      ::Components::Deployment::_TAO_ComponentInstallation_Remote_Proxy_Broker::the_TAO_ComponentInstallation_Remote_Proxy_Broker ();
}

void Components::Deployment::ComponentInstallation::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentInstallation *tmp = ACE_static_cast (ComponentInstallation*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Deployment::ComponentInstallation_ptr Components::Deployment::ComponentInstallation::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return ComponentInstallation::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Deployment/ComponentInstallation:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (ComponentInstallation::_nil ());
      if (is_a == 0)
        return ComponentInstallation::_nil ();
    }
  return ComponentInstallation::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Deployment::ComponentInstallation_ptr 
Components::Deployment::ComponentInstallation::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ComponentInstallation::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ComponentInstallation_ptr default_proxy = ComponentInstallation::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components_Deployment__TAO_ComponentInstallation_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::ComponentInstallation (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ComponentInstallation::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::ComponentInstallation (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ComponentInstallation::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          ComponentInstallation_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ComponentInstallation::_tao_class_id
                  )
              )
        );
}

Components::Deployment::ComponentInstallation_ptr
Components::Deployment::ComponentInstallation::_duplicate (ComponentInstallation_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Deployment::ComponentInstallation::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Deployment::ComponentInstallation::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components::Deployment, ComponentInstallation)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Deployment::ComponentInstallation::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/ComponentInstallation:1.0";
}

void Components::Deployment::ComponentInstallation::install (
    const char * implUUID,
    const char * component_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::Deployment::InstallationFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentInstallation_Proxy_Impl &proxy = 
    this->the_TAO_ComponentInstallation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.install (
      this,
      implUUID,
      component_loc
    );
}

void Components::Deployment::ComponentInstallation::replace (
    const char * implUUID,
    const char * component_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::Deployment::InstallationFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentInstallation_Proxy_Impl &proxy = 
    this->the_TAO_ComponentInstallation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.replace (
      this,
      implUUID,
      component_loc
    );
}

void Components::Deployment::ComponentInstallation::remove (
    const char * implUUID
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentInstallation_Proxy_Impl &proxy = 
    this->the_TAO_ComponentInstallation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove (
      this,
      implUUID
    );
}

char * Components::Deployment::ComponentInstallation::get_implementation (
    const char * implUUID
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::Deployment::InstallationFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentInstallation_Proxy_Impl &proxy = 
    this->the_TAO_ComponentInstallation_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_implementation (
      this,
      implUUID
    );
}

static const CORBA::Long _oc_Components_Deployment_ComponentInstallation[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  60,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x6e737461), 
  ACE_NTOHL (0x6c6c6174), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Deployment/ComponentInstallation:1.0
  22,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74496e73), 
  ACE_NTOHL (0x74616c6c), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e000000),  // name = ComponentInstallation
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_ComponentInstallation (
    CORBA::tk_objref,
    sizeof (_oc_Components_Deployment_ComponentInstallation),
    (char *) &_oc_Components_Deployment_ComponentInstallation,
    0,
    sizeof (Components::Deployment::ComponentInstallation)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ComponentInstallation, &_tc_TAO_tc_Components_Deployment_ComponentInstallation)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Deployment::Assembly::_tao_class_id = 0;

Components::Deployment::Assembly_ptr
tao_Components_Deployment_Assembly_duplicate (
    Components::Deployment::Assembly_ptr p
  )
{
  return Components::Deployment::Assembly::_duplicate (p);
}

void
tao_Components_Deployment_Assembly_release (
    Components::Deployment::Assembly_ptr p
  )
{
  CORBA::release (p);
}

Components::Deployment::Assembly_ptr
tao_Components_Deployment_Assembly_nil (
    void
  )
{
  return Components::Deployment::Assembly::_nil ();
}

Components::Deployment::Assembly_ptr
tao_Components_Deployment_Assembly_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Deployment::Assembly::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Deployment_Assembly_upcast (
    void *src
  )
{
  Components::Deployment::Assembly **tmp =
    ACE_static_cast (Components::Deployment::Assembly **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::Assembly_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Deployment::Assembly_var::Assembly_var (void) // default constructor
  : ptr_ (Assembly::_nil ())
{}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_var::ptr (void) const
{
  return this->ptr_;
}

Components::Deployment::Assembly_var::Assembly_var (const ::Components::Deployment::Assembly_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Assembly::_duplicate (p.ptr ()))
{}

Components::Deployment::Assembly_var::~Assembly_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Deployment::Assembly_var &
Components::Deployment::Assembly_var::operator= (Assembly_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Deployment::Assembly_var &
Components::Deployment::Assembly_var::operator= (const ::Components::Deployment::Assembly_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Deployment::Assembly::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Deployment::Assembly_var::operator const ::Components::Deployment::Assembly_ptr &() const // cast
{
  return this->ptr_;
}

Components::Deployment::Assembly_var::operator ::Components::Deployment::Assembly_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_var::in (void) const
{
  return this->ptr_;
}

::Components::Deployment::Assembly_ptr &
Components::Deployment::Assembly_var::inout (void)
{
  return this->ptr_;
}

::Components::Deployment::Assembly_ptr &
Components::Deployment::Assembly_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::Assembly::_nil ();
  return this->ptr_;
}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Deployment::Assembly_ptr val = this->ptr_;
  this->ptr_ = ::Components::Deployment::Assembly::_nil ();
  return val;
}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_var::tao_duplicate (Assembly_ptr p)
{
  return ::Components::Deployment::Assembly::_duplicate (p);
}

void
Components::Deployment::Assembly_var::tao_release (Assembly_ptr p)
{
  CORBA::release (p);
}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_var::tao_nil (void)
{
  return ::Components::Deployment::Assembly::_nil ();
}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Deployment::Assembly::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Deployment::Assembly_var::tao_upcast (void *src)
{
  Assembly **tmp =
    ACE_static_cast (Assembly **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::Assembly_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Deployment::Assembly_out::Assembly_out (Assembly_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Deployment::Assembly::_nil ();
}

Components::Deployment::Assembly_out::Assembly_out (Assembly_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::Assembly::_nil ();
}

Components::Deployment::Assembly_out::Assembly_out (const ::Components::Deployment::Assembly_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Assembly_out &, p).ptr_)
{}

::Components::Deployment::Assembly_out &
Components::Deployment::Assembly_out::operator= (const ::Components::Deployment::Assembly_out &p)
{
  this->ptr_ = ACE_const_cast (Assembly_out&, p).ptr_;
  return *this;
}

Components::Deployment::Assembly_out &
Components::Deployment::Assembly_out::operator= (const ::Components::Deployment::Assembly_var &p)
{
  this->ptr_ = ::Components::Deployment::Assembly::_duplicate (p.ptr ());
  return *this;
}

Components::Deployment::Assembly_out &
Components::Deployment::Assembly_out::operator= (Assembly_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Deployment::Assembly_out::operator ::Components::Deployment::Assembly_ptr &() // cast
{
  return this->ptr_;
}

::Components::Deployment::Assembly_ptr &
Components::Deployment::Assembly_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Deployment::Assembly_ptr
Components::Deployment::Assembly_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Deployment_Assembly_build : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Assembly_build (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_Assembly_build (const TAO_ClientRequestInfo_Components_Deployment_Assembly_build &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Assembly_build &);

  
};

TAO_ClientRequestInfo_Components_Deployment_Assembly_build::TAO_ClientRequestInfo_Components_Deployment_Assembly_build (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Assembly_build::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Assembly_build::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Assembly_build::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down (const TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down &);

  
};

TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down::TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Assembly_tear_down_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Assembly_tear_down_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::AssemblyState result);

private:
  TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state (const TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state &);

  Components::Deployment::AssemblyState _result;
};

TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state::TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state::result (::Components::Deployment::AssemblyState result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::Deployment::_TAO_Assembly_Proxy_Impl::_TAO_Assembly_Proxy_Impl (void)
{}

Components::Deployment::_TAO_Assembly_Remote_Proxy_Impl::_TAO_Assembly_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

void Components::Deployment::_TAO_Assembly_Remote_Proxy_Impl::build (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "build",
      5,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Assembly_build _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

void Components::Deployment::_TAO_Assembly_Remote_Proxy_Impl::tear_down (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_Assembly_tear_down_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "tear_down",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Assembly_tear_down _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_Assembly_tear_down_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

::Components::Deployment::AssemblyState Components::Deployment::_TAO_Assembly_Remote_Proxy_Impl::get_state (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::Deployment::AssemblyState _tao_retval = (Components::Deployment::AssemblyState)0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_state",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Assembly_get_state _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval);

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::AssemblyState _tao_retval_info = _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval);

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval);

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval;
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::Deployment::_TAO_Assembly_Proxy_Broker::_TAO_Assembly_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Assembly_Proxy_Broker::~_TAO_Assembly_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Assembly_Proxy_Broker * (*Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::Deployment::_TAO_Assembly_Remote_Proxy_Broker *
Components::Deployment::_TAO_Assembly_Remote_Proxy_Broker::the_TAO_Assembly_Remote_Proxy_Broker (void)
{
  static ::Components::Deployment::_TAO_Assembly_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::Deployment::_TAO_Assembly_Remote_Proxy_Broker::_TAO_Assembly_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Assembly_Remote_Proxy_Broker::~_TAO_Assembly_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Assembly_Proxy_Impl&
Components::Deployment::_TAO_Assembly_Remote_Proxy_Broker::select_proxy (
  ::Components::Deployment::Assembly *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Deployment::Assembly::Assembly (int collocated)
{
  this->Components_Deployment_Assembly_setup_collocation (collocated);
}

Components::Deployment::Assembly::~Assembly (void)
{}

void
Components::Deployment::Assembly::Components_Deployment_Assembly_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Assembly_Proxy_Broker_ =
      ::Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Assembly_Proxy_Broker_ =
      ::Components::Deployment::_TAO_Assembly_Remote_Proxy_Broker::the_TAO_Assembly_Remote_Proxy_Broker ();
}

void Components::Deployment::Assembly::_tao_any_destructor (void *_tao_void_pointer)
{
  Assembly *tmp = ACE_static_cast (Assembly*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Deployment::Assembly_ptr Components::Deployment::Assembly::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return Assembly::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Deployment/Assembly:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (Assembly::_nil ());
      if (is_a == 0)
        return Assembly::_nil ();
    }
  return Assembly::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Deployment::Assembly_ptr 
Components::Deployment::Assembly::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Assembly::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Assembly_ptr default_proxy = Assembly::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components_Deployment__TAO_Assembly_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::Assembly (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Assembly::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::Assembly (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Assembly::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Assembly_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Assembly::_tao_class_id
                  )
              )
        );
}

Components::Deployment::Assembly_ptr
Components::Deployment::Assembly::_duplicate (Assembly_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Deployment::Assembly::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/Assembly:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Deployment::Assembly::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components::Deployment, Assembly)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Deployment::Assembly::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/Assembly:1.0";
}

void Components::Deployment::Assembly::build (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Assembly_Proxy_Impl &proxy = 
    this->the_TAO_Assembly_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.build (
      this
    );
}

void Components::Deployment::Assembly::tear_down (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Assembly_Proxy_Impl &proxy = 
    this->the_TAO_Assembly_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.tear_down (
      this
    );
}

::Components::Deployment::AssemblyState Components::Deployment::Assembly::get_state (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Assembly_Proxy_Impl &proxy = 
    this->the_TAO_Assembly_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN ((Components::Deployment::AssemblyState)0);
  
  return proxy.get_state (
      this
    );
}

static const CORBA::Long _oc_Components_Deployment_Assembly[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f4173), 
  ACE_NTOHL (0x73656d62), 
  ACE_NTOHL (0x6c793a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Deployment/Assembly:1.0
  9,
  ACE_NTOHL (0x41737365), 
  ACE_NTOHL (0x6d626c79), 
  ACE_NTOHL (0x0),  // name = Assembly
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_Assembly (
    CORBA::tk_objref,
    sizeof (_oc_Components_Deployment_Assembly),
    (char *) &_oc_Components_Deployment_Assembly,
    0,
    sizeof (Components::Deployment::Assembly)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Assembly, &_tc_TAO_tc_Components_Deployment_Assembly)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Deployment::AssemblyFactory::_tao_class_id = 0;

Components::Deployment::AssemblyFactory_ptr
tao_Components_Deployment_AssemblyFactory_duplicate (
    Components::Deployment::AssemblyFactory_ptr p
  )
{
  return Components::Deployment::AssemblyFactory::_duplicate (p);
}

void
tao_Components_Deployment_AssemblyFactory_release (
    Components::Deployment::AssemblyFactory_ptr p
  )
{
  CORBA::release (p);
}

Components::Deployment::AssemblyFactory_ptr
tao_Components_Deployment_AssemblyFactory_nil (
    void
  )
{
  return Components::Deployment::AssemblyFactory::_nil ();
}

Components::Deployment::AssemblyFactory_ptr
tao_Components_Deployment_AssemblyFactory_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Deployment::AssemblyFactory::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Deployment_AssemblyFactory_upcast (
    void *src
  )
{
  Components::Deployment::AssemblyFactory **tmp =
    ACE_static_cast (Components::Deployment::AssemblyFactory **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::AssemblyFactory_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Deployment::AssemblyFactory_var::AssemblyFactory_var (void) // default constructor
  : ptr_ (AssemblyFactory::_nil ())
{}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_var::ptr (void) const
{
  return this->ptr_;
}

Components::Deployment::AssemblyFactory_var::AssemblyFactory_var (const ::Components::Deployment::AssemblyFactory_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (AssemblyFactory::_duplicate (p.ptr ()))
{}

Components::Deployment::AssemblyFactory_var::~AssemblyFactory_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Deployment::AssemblyFactory_var &
Components::Deployment::AssemblyFactory_var::operator= (AssemblyFactory_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Deployment::AssemblyFactory_var &
Components::Deployment::AssemblyFactory_var::operator= (const ::Components::Deployment::AssemblyFactory_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Deployment::AssemblyFactory::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Deployment::AssemblyFactory_var::operator const ::Components::Deployment::AssemblyFactory_ptr &() const // cast
{
  return this->ptr_;
}

Components::Deployment::AssemblyFactory_var::operator ::Components::Deployment::AssemblyFactory_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_var::in (void) const
{
  return this->ptr_;
}

::Components::Deployment::AssemblyFactory_ptr &
Components::Deployment::AssemblyFactory_var::inout (void)
{
  return this->ptr_;
}

::Components::Deployment::AssemblyFactory_ptr &
Components::Deployment::AssemblyFactory_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::AssemblyFactory::_nil ();
  return this->ptr_;
}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Deployment::AssemblyFactory_ptr val = this->ptr_;
  this->ptr_ = ::Components::Deployment::AssemblyFactory::_nil ();
  return val;
}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_var::tao_duplicate (AssemblyFactory_ptr p)
{
  return ::Components::Deployment::AssemblyFactory::_duplicate (p);
}

void
Components::Deployment::AssemblyFactory_var::tao_release (AssemblyFactory_ptr p)
{
  CORBA::release (p);
}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_var::tao_nil (void)
{
  return ::Components::Deployment::AssemblyFactory::_nil ();
}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Deployment::AssemblyFactory::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Deployment::AssemblyFactory_var::tao_upcast (void *src)
{
  AssemblyFactory **tmp =
    ACE_static_cast (AssemblyFactory **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::AssemblyFactory_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Deployment::AssemblyFactory_out::AssemblyFactory_out (AssemblyFactory_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Deployment::AssemblyFactory::_nil ();
}

Components::Deployment::AssemblyFactory_out::AssemblyFactory_out (AssemblyFactory_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::AssemblyFactory::_nil ();
}

Components::Deployment::AssemblyFactory_out::AssemblyFactory_out (const ::Components::Deployment::AssemblyFactory_out &p) // copy constructor
  : ptr_ (ACE_const_cast (AssemblyFactory_out &, p).ptr_)
{}

::Components::Deployment::AssemblyFactory_out &
Components::Deployment::AssemblyFactory_out::operator= (const ::Components::Deployment::AssemblyFactory_out &p)
{
  this->ptr_ = ACE_const_cast (AssemblyFactory_out&, p).ptr_;
  return *this;
}

Components::Deployment::AssemblyFactory_out &
Components::Deployment::AssemblyFactory_out::operator= (const ::Components::Deployment::AssemblyFactory_var &p)
{
  this->ptr_ = ::Components::Deployment::AssemblyFactory::_duplicate (p.ptr ());
  return *this;
}

Components::Deployment::AssemblyFactory_out &
Components::Deployment::AssemblyFactory_out::operator= (AssemblyFactory_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Deployment::AssemblyFactory_out::operator ::Components::Deployment::AssemblyFactory_ptr &() // cast
{
  return this->ptr_;
}

::Components::Deployment::AssemblyFactory_ptr &
Components::Deployment::AssemblyFactory_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * assembly_loc);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Cookie * result);

private:
  TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create (const TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create &);

  const char * assembly_loc_;
  Components::Cookie * _result;
};

TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create::TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * assembly_loc    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    assembly_loc_ (assembly_loc)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= assembly_loc_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_AssemblyFactory_create_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidLocation,
    Components::_tc_CreateFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_AssemblyFactory_create_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create::result (::Components::Cookie * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::Cookie * c);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::Assembly_ptr result);

private:
  TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup (const TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup &);

  Components::Cookie * c_;
  Components::Deployment::Assembly_ptr _result;
};

TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup::TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::Cookie * c    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    c_ (c)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_AssemblyFactory_lookup_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidAssembly
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_AssemblyFactory_lookup_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup::result (::Components::Deployment::Assembly_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::Cookie * c);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy (const TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy &);

  Components::Cookie * c_;
  
};

TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy::TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::Cookie * c    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    c_ (c)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_AssemblyFactory_destroy_exceptiondata[] = 
  {
    Components::Deployment::_tc_InvalidAssembly,
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_AssemblyFactory_destroy_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::Deployment::_TAO_AssemblyFactory_Proxy_Impl::_TAO_AssemblyFactory_Proxy_Impl (void)
{}

Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Impl::_TAO_AssemblyFactory_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::Cookie * Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Impl::create (
    CORBA_Object *_collocated_tao_target_,
    const char * assembly_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::CreateFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_AssemblyFactory_create_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/InvalidLocation:1.0",
      Components::Deployment::InvalidLocation::_alloc
    },
    {
      "IDL:omg.org/Components/CreateFailure:1.0",
      Components::CreateFailure::_alloc
    }
  };

  ::Components::Cookie_var _tao_retval;


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create",
      6,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_create _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        assembly_loc
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << assembly_loc)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_AssemblyFactory_create_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Cookie * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::Deployment::Assembly_ptr Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    Components::Cookie * c
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidAssembly
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_AssemblyFactory_lookup_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/InvalidAssembly:1.0",
      Components::Deployment::InvalidAssembly::_alloc
    }
  };

  Components::Deployment::Assembly_var _tao_retval (Components::Deployment::Assembly::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup",
      6,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_lookup _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        c
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << c)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_AssemblyFactory_lookup_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::Assembly_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    Components::Cookie * c
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidAssembly
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_AssemblyFactory_destroy_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/InvalidAssembly:1.0",
      Components::Deployment::InvalidAssembly::_alloc
    },
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      7,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_AssemblyFactory_destroy _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        c
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << c)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_AssemblyFactory_destroy_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::Deployment::_TAO_AssemblyFactory_Proxy_Broker::_TAO_AssemblyFactory_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_AssemblyFactory_Proxy_Broker::~_TAO_AssemblyFactory_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_AssemblyFactory_Proxy_Broker * (*Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Broker *
Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Broker::the_TAO_AssemblyFactory_Remote_Proxy_Broker (void)
{
  static ::Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Broker::_TAO_AssemblyFactory_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Broker::~_TAO_AssemblyFactory_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_AssemblyFactory_Proxy_Impl&
Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Broker::select_proxy (
  ::Components::Deployment::AssemblyFactory *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Deployment::AssemblyFactory::AssemblyFactory (int collocated)
{
  this->Components_Deployment_AssemblyFactory_setup_collocation (collocated);
}

Components::Deployment::AssemblyFactory::~AssemblyFactory (void)
{}

void
Components::Deployment::AssemblyFactory::Components_Deployment_AssemblyFactory_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_AssemblyFactory_Proxy_Broker_ =
      ::Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_AssemblyFactory_Proxy_Broker_ =
      ::Components::Deployment::_TAO_AssemblyFactory_Remote_Proxy_Broker::the_TAO_AssemblyFactory_Remote_Proxy_Broker ();
}

void Components::Deployment::AssemblyFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  AssemblyFactory *tmp = ACE_static_cast (AssemblyFactory*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Deployment::AssemblyFactory_ptr Components::Deployment::AssemblyFactory::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return AssemblyFactory::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Deployment/AssemblyFactory:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (AssemblyFactory::_nil ());
      if (is_a == 0)
        return AssemblyFactory::_nil ();
    }
  return AssemblyFactory::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Deployment::AssemblyFactory_ptr 
Components::Deployment::AssemblyFactory::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return AssemblyFactory::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      AssemblyFactory_ptr default_proxy = AssemblyFactory::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components_Deployment__TAO_AssemblyFactory_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::AssemblyFactory (
                  stub,
                  1,
                  obj->_servant ()
                ),
              AssemblyFactory::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::AssemblyFactory (
                  stub,
                  0,
                  obj->_servant ()
                ),
              AssemblyFactory::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          AssemblyFactory_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &AssemblyFactory::_tao_class_id
                  )
              )
        );
}

Components::Deployment::AssemblyFactory_ptr
Components::Deployment::AssemblyFactory::_duplicate (AssemblyFactory_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Deployment::AssemblyFactory::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Deployment::AssemblyFactory::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components::Deployment, AssemblyFactory)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Deployment::AssemblyFactory::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/AssemblyFactory:1.0";
}

::Components::Cookie * Components::Deployment::AssemblyFactory::create (
    const char * assembly_loc
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidLocation
    , Components::CreateFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_AssemblyFactory_Proxy_Impl &proxy = 
    this->the_TAO_AssemblyFactory_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create (
      this,
      assembly_loc
    );
}

::Components::Deployment::Assembly_ptr Components::Deployment::AssemblyFactory::lookup (
    Components::Cookie * c
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidAssembly
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_AssemblyFactory_Proxy_Impl &proxy = 
    this->the_TAO_AssemblyFactory_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.lookup (
      this,
      c
    );
}

void Components::Deployment::AssemblyFactory::destroy (
    Components::Cookie * c
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::InvalidAssembly
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_AssemblyFactory_Proxy_Impl &proxy = 
    this->the_TAO_AssemblyFactory_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.destroy (
      this,
      c
    );
}

static const CORBA::Long _oc_Components_Deployment_AssemblyFactory[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f4173), 
  ACE_NTOHL (0x73656d62), 
  ACE_NTOHL (0x6c794661), 
  ACE_NTOHL (0x63746f72), 
  ACE_NTOHL (0x793a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Deployment/AssemblyFactory:1.0
  16,
  ACE_NTOHL (0x41737365), 
  ACE_NTOHL (0x6d626c79), 
  ACE_NTOHL (0x46616374), 
  ACE_NTOHL (0x6f727900),  // name = AssemblyFactory
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_AssemblyFactory (
    CORBA::tk_objref,
    sizeof (_oc_Components_Deployment_AssemblyFactory),
    (char *) &_oc_Components_Deployment_AssemblyFactory,
    0,
    sizeof (Components::Deployment::AssemblyFactory)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_AssemblyFactory, &_tc_TAO_tc_Components_Deployment_AssemblyFactory)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_allocate_buffer (CORBA::ULong length)
{
  Components::Deployment::ComponentServer **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::Deployment::ComponentServer **old = ACE_reinterpret_cast (Components::Deployment::ComponentServer**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = Components::Deployment::ComponentServer::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::Deployment::ComponentServer **tmp = ACE_reinterpret_cast (Components::Deployment::ComponentServer**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::Deployment::ComponentServer::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::freebuf (tmp);
  this->buffer_ = 0;
}

Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::~_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers (void)
{
  this->_deallocate_buffer ();
}

void
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::Deployment::ComponentServer **tmp = ACE_reinterpret_cast (Components::Deployment::ComponentServer**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::Deployment::ComponentServer::_nil ();
    }
}

void 
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  Components::Deployment::ComponentServer **tmp = ACE_static_cast (Components::Deployment::ComponentServer**, target);
  *tmp = Components::Deployment::ComponentServer::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers::_upcast (void *src) const
{
  Components::Deployment::ComponentServer **tmp = ACE_static_cast (Components::Deployment::ComponentServer**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CS_)
#define _COMPONENTS_DEPLOYMENT_COMPONENTSERVERS_CS_

// *************************************************************
// Components::Deployment::ComponentServers
// *************************************************************

Components::Deployment::ComponentServers::ComponentServers (void)
{}
Components::Deployment::ComponentServers::ComponentServers (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::Deployment::ComponentServer,Components::Deployment::ComponentServer_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::Deployment::ComponentServers::ComponentServers (CORBA::ULong max, CORBA::ULong length, Components::Deployment::ComponentServer_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::Deployment::ComponentServer,Components::Deployment::ComponentServer_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::Deployment::ComponentServers::ComponentServers (const ComponentServers &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_Deployment_ComponentServers
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::Deployment::ComponentServer,Components::Deployment::ComponentServer_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::Deployment::ComponentServers::~ComponentServers (void) // dtor
{}
void Components::Deployment::ComponentServers::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentServers *tmp = ACE_static_cast (ComponentServers*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_Deployment_ComponentServers[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7453), 
  ACE_NTOHL (0x65727665), 
  ACE_NTOHL (0x72733a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/Components/Deployment/ComponentServers:1.0
  17,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74536572), 
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x0),  // name = ComponentServers
  CORBA::tk_sequence, // typecode kind
  100, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      54,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f44), 
      ACE_NTOHL (0x65706c6f), 
      ACE_NTOHL (0x796d656e), 
      ACE_NTOHL (0x742f436f), 
      ACE_NTOHL (0x6d706f6e), 
      ACE_NTOHL (0x656e7453), 
      ACE_NTOHL (0x65727665), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Deployment/ComponentServer:1.0
      16,
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74536572), 
      ACE_NTOHL (0x76657200),  // name = ComponentServer

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_ComponentServers (
    CORBA::tk_alias,
    sizeof (_oc_Components_Deployment_ComponentServers),
    (char *) &_oc_Components_Deployment_ComponentServers,
    0,
    sizeof (Components::Deployment::ComponentServers)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ComponentServers, &_tc_TAO_tc_Components_Deployment_ComponentServers)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Deployment::ServerActivator::_tao_class_id = 0;

Components::Deployment::ServerActivator_ptr
tao_Components_Deployment_ServerActivator_duplicate (
    Components::Deployment::ServerActivator_ptr p
  )
{
  return Components::Deployment::ServerActivator::_duplicate (p);
}

void
tao_Components_Deployment_ServerActivator_release (
    Components::Deployment::ServerActivator_ptr p
  )
{
  CORBA::release (p);
}

Components::Deployment::ServerActivator_ptr
tao_Components_Deployment_ServerActivator_nil (
    void
  )
{
  return Components::Deployment::ServerActivator::_nil ();
}

Components::Deployment::ServerActivator_ptr
tao_Components_Deployment_ServerActivator_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Deployment::ServerActivator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Deployment_ServerActivator_upcast (
    void *src
  )
{
  Components::Deployment::ServerActivator **tmp =
    ACE_static_cast (Components::Deployment::ServerActivator **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::ServerActivator_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Deployment::ServerActivator_var::ServerActivator_var (void) // default constructor
  : ptr_ (ServerActivator::_nil ())
{}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_var::ptr (void) const
{
  return this->ptr_;
}

Components::Deployment::ServerActivator_var::ServerActivator_var (const ::Components::Deployment::ServerActivator_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ServerActivator::_duplicate (p.ptr ()))
{}

Components::Deployment::ServerActivator_var::~ServerActivator_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Deployment::ServerActivator_var &
Components::Deployment::ServerActivator_var::operator= (ServerActivator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Deployment::ServerActivator_var &
Components::Deployment::ServerActivator_var::operator= (const ::Components::Deployment::ServerActivator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Deployment::ServerActivator::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Deployment::ServerActivator_var::operator const ::Components::Deployment::ServerActivator_ptr &() const // cast
{
  return this->ptr_;
}

Components::Deployment::ServerActivator_var::operator ::Components::Deployment::ServerActivator_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_var::in (void) const
{
  return this->ptr_;
}

::Components::Deployment::ServerActivator_ptr &
Components::Deployment::ServerActivator_var::inout (void)
{
  return this->ptr_;
}

::Components::Deployment::ServerActivator_ptr &
Components::Deployment::ServerActivator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::ServerActivator::_nil ();
  return this->ptr_;
}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Deployment::ServerActivator_ptr val = this->ptr_;
  this->ptr_ = ::Components::Deployment::ServerActivator::_nil ();
  return val;
}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_var::tao_duplicate (ServerActivator_ptr p)
{
  return ::Components::Deployment::ServerActivator::_duplicate (p);
}

void
Components::Deployment::ServerActivator_var::tao_release (ServerActivator_ptr p)
{
  CORBA::release (p);
}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_var::tao_nil (void)
{
  return ::Components::Deployment::ServerActivator::_nil ();
}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Deployment::ServerActivator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Deployment::ServerActivator_var::tao_upcast (void *src)
{
  ServerActivator **tmp =
    ACE_static_cast (ServerActivator **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::ServerActivator_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Deployment::ServerActivator_out::ServerActivator_out (ServerActivator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Deployment::ServerActivator::_nil ();
}

Components::Deployment::ServerActivator_out::ServerActivator_out (ServerActivator_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::ServerActivator::_nil ();
}

Components::Deployment::ServerActivator_out::ServerActivator_out (const ::Components::Deployment::ServerActivator_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ServerActivator_out &, p).ptr_)
{}

::Components::Deployment::ServerActivator_out &
Components::Deployment::ServerActivator_out::operator= (const ::Components::Deployment::ServerActivator_out &p)
{
  this->ptr_ = ACE_const_cast (ServerActivator_out&, p).ptr_;
  return *this;
}

Components::Deployment::ServerActivator_out &
Components::Deployment::ServerActivator_out::operator= (const ::Components::Deployment::ServerActivator_var &p)
{
  this->ptr_ = ::Components::Deployment::ServerActivator::_duplicate (p.ptr ());
  return *this;
}

Components::Deployment::ServerActivator_out &
Components::Deployment::ServerActivator_out::operator= (ServerActivator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Deployment::ServerActivator_out::operator ::Components::Deployment::ServerActivator_ptr &() // cast
{
  return this->ptr_;
}

::Components::Deployment::ServerActivator_ptr &
Components::Deployment::ServerActivator_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::ConfigValues & config);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::ComponentServer_ptr result);

private:
  TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server (const TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server &);

  const Components::ConfigValues & config_;
  Components::Deployment::ComponentServer_ptr _result;
};

TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server::TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::ConfigValues & config    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    config_ (config)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->config_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ServerActivator_create_component_server_exceptiondata[] = 
  {
    Components::_tc_CreateFailure,
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ServerActivator_create_component_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server::result (::Components::Deployment::ComponentServer_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::Deployment::ComponentServer_ptr server);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server (const TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server &);

  Components::Deployment::ComponentServer_ptr server_;
  
};

TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server::TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::Deployment::ComponentServer_ptr server    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    server_ (server)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ServerActivator_remove_component_server_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ServerActivator_remove_component_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::ComponentServers * result);

private:
  TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers (const TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers &);

  Components::Deployment::ComponentServers * _result;
};

TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers::TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers::result (::Components::Deployment::ComponentServers * result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::Deployment::_TAO_ServerActivator_Proxy_Impl::_TAO_ServerActivator_Proxy_Impl (void)
{}

Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Impl::_TAO_ServerActivator_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::Deployment::ComponentServer_ptr Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Impl::create_component_server (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ServerActivator_create_component_server_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/CreateFailure:1.0",
      Components::CreateFailure::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConfiguration:1.0",
      Components::InvalidConfiguration::_alloc
    }
  };

  Components::Deployment::ComponentServer_var _tao_retval (Components::Deployment::ComponentServer::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component_server",
      23,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ServerActivator_create_component_server _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        config
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << config)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ServerActivator_create_component_server_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::ComponentServer_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Impl::remove_component_server (
    CORBA_Object *_collocated_tao_target_,
    Components::Deployment::ComponentServer_ptr server
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ServerActivator_remove_component_server_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove_component_server",
      23,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ServerActivator_remove_component_server _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        server
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << server)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ServerActivator_remove_component_server_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

::Components::Deployment::ComponentServers * Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Impl::get_component_servers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::Deployment::ComponentServers_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::Deployment::ComponentServers *tmp;
    ACE_NEW_RETURN (tmp, Components::Deployment::ComponentServers, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_component_servers",
      21,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ServerActivator_get_component_servers _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::ComponentServers * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::Deployment::_TAO_ServerActivator_Proxy_Broker::_TAO_ServerActivator_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ServerActivator_Proxy_Broker::~_TAO_ServerActivator_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ServerActivator_Proxy_Broker * (*Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Broker *
Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Broker::the_TAO_ServerActivator_Remote_Proxy_Broker (void)
{
  static ::Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Broker::_TAO_ServerActivator_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Broker::~_TAO_ServerActivator_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ServerActivator_Proxy_Impl&
Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Broker::select_proxy (
  ::Components::Deployment::ServerActivator *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Deployment::ServerActivator::ServerActivator (int collocated)
{
  this->Components_Deployment_ServerActivator_setup_collocation (collocated);
}

Components::Deployment::ServerActivator::~ServerActivator (void)
{}

void
Components::Deployment::ServerActivator::Components_Deployment_ServerActivator_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ServerActivator_Proxy_Broker_ =
      ::Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ServerActivator_Proxy_Broker_ =
      ::Components::Deployment::_TAO_ServerActivator_Remote_Proxy_Broker::the_TAO_ServerActivator_Remote_Proxy_Broker ();
}

void Components::Deployment::ServerActivator::_tao_any_destructor (void *_tao_void_pointer)
{
  ServerActivator *tmp = ACE_static_cast (ServerActivator*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Deployment::ServerActivator_ptr Components::Deployment::ServerActivator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return ServerActivator::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Deployment/ServerActivator:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (ServerActivator::_nil ());
      if (is_a == 0)
        return ServerActivator::_nil ();
    }
  return ServerActivator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Deployment::ServerActivator_ptr 
Components::Deployment::ServerActivator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ServerActivator::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ServerActivator_ptr default_proxy = ServerActivator::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components_Deployment__TAO_ServerActivator_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::ServerActivator (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ServerActivator::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::ServerActivator (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ServerActivator::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          ServerActivator_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ServerActivator::_tao_class_id
                  )
              )
        );
}

Components::Deployment::ServerActivator_ptr
Components::Deployment::ServerActivator::_duplicate (ServerActivator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Deployment::ServerActivator::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/ServerActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Deployment::ServerActivator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components::Deployment, ServerActivator)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Deployment::ServerActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/ServerActivator:1.0";
}

::Components::Deployment::ComponentServer_ptr Components::Deployment::ServerActivator::create_component_server (
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ServerActivator_Proxy_Impl &proxy = 
    this->the_TAO_ServerActivator_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_component_server (
      this,
      config
    );
}

void Components::Deployment::ServerActivator::remove_component_server (
    Components::Deployment::ComponentServer_ptr server
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ServerActivator_Proxy_Impl &proxy = 
    this->the_TAO_ServerActivator_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove_component_server (
      this,
      server
    );
}

::Components::Deployment::ComponentServers * Components::Deployment::ServerActivator::get_component_servers (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ServerActivator_Proxy_Impl &proxy = 
    this->the_TAO_ServerActivator_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_component_servers (
      this
    );
}

static const CORBA::Long _oc_Components_Deployment_ServerActivator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f5365), 
  ACE_NTOHL (0x72766572), 
  ACE_NTOHL (0x41637469), 
  ACE_NTOHL (0x7661746f), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Deployment/ServerActivator:1.0
  16,
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65724163), 
  ACE_NTOHL (0x74697661), 
  ACE_NTOHL (0x746f7200),  // name = ServerActivator
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_ServerActivator (
    CORBA::tk_objref,
    sizeof (_oc_Components_Deployment_ServerActivator),
    (char *) &_oc_Components_Deployment_ServerActivator,
    0,
    sizeof (Components::Deployment::ServerActivator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ServerActivator, &_tc_TAO_tc_Components_Deployment_ServerActivator)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_CONTAINERS_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_COMPONENTS_DEPLOYMENT_CONTAINERS_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_allocate_buffer (CORBA::ULong length)
{
  Components::Deployment::Container **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    Components::Deployment::Container **old = ACE_reinterpret_cast (Components::Deployment::Container**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = Components::Deployment::Container::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  Components::Deployment::Container **tmp = ACE_reinterpret_cast (Components::Deployment::Container**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::Deployment::Container::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::freebuf (tmp);
  this->buffer_ = 0;
}

Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::~_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers (void)
{
  this->_deallocate_buffer ();
}

void
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  Components::Deployment::Container **tmp = ACE_reinterpret_cast (Components::Deployment::Container**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = Components::Deployment::Container::_nil ();
    }
}

void 
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_downcast (
    void* target,
    CORBA_Object *src
    ACE_ENV_ARG_DECL
  )
{
  Components::Deployment::Container **tmp = ACE_static_cast (Components::Deployment::Container**, target);
  *tmp = Components::Deployment::Container::_narrow (src ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
Components::Deployment::_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers::_upcast (void *src) const
{
  Components::Deployment::Container **tmp = ACE_static_cast (Components::Deployment::Container**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_COMPONENTS_DEPLOYMENT_CONTAINERS_CS_)
#define _COMPONENTS_DEPLOYMENT_CONTAINERS_CS_

// *************************************************************
// Components::Deployment::Containers
// *************************************************************

Components::Deployment::Containers::Containers (void)
{}
Components::Deployment::Containers::Containers (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::Deployment::Container,Components::Deployment::Container_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Components::Deployment::Containers::Containers (CORBA::ULong max, CORBA::ULong length, Components::Deployment::Container_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::Deployment::Container,Components::Deployment::Container_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Components::Deployment::Containers::Containers (const Containers &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_Components_Deployment_Containers
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<Components::Deployment::Container,Components::Deployment::Container_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Components::Deployment::Containers::~Containers (void) // dtor
{}
void Components::Deployment::Containers::_tao_any_destructor (void *_tao_void_pointer)
{
  Containers *tmp = ACE_static_cast (Containers*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Components_Deployment_Containers[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e657273), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/Deployment/Containers:1.0
  11,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x72730000),  // name = Containers
  CORBA::tk_sequence, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      48,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x436f6d70), 
      ACE_NTOHL (0x6f6e656e), 
      ACE_NTOHL (0x74732f44), 
      ACE_NTOHL (0x65706c6f), 
      ACE_NTOHL (0x796d656e), 
      ACE_NTOHL (0x742f436f), 
      ACE_NTOHL (0x6e746169), 
      ACE_NTOHL (0x6e65723a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Deployment/Container:1.0
      10,
      ACE_NTOHL (0x436f6e74), 
      ACE_NTOHL (0x61696e65), 
      ACE_NTOHL (0x72000000),  // name = Container

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_Containers (
    CORBA::tk_alias,
    sizeof (_oc_Components_Deployment_Containers),
    (char *) &_oc_Components_Deployment_Containers,
    0,
    sizeof (Components::Deployment::Containers)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Containers, &_tc_TAO_tc_Components_Deployment_Containers)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Deployment::ComponentServer::_tao_class_id = 0;

Components::Deployment::ComponentServer_ptr
tao_Components_Deployment_ComponentServer_duplicate (
    Components::Deployment::ComponentServer_ptr p
  )
{
  return Components::Deployment::ComponentServer::_duplicate (p);
}

void
tao_Components_Deployment_ComponentServer_release (
    Components::Deployment::ComponentServer_ptr p
  )
{
  CORBA::release (p);
}

Components::Deployment::ComponentServer_ptr
tao_Components_Deployment_ComponentServer_nil (
    void
  )
{
  return Components::Deployment::ComponentServer::_nil ();
}

Components::Deployment::ComponentServer_ptr
tao_Components_Deployment_ComponentServer_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Deployment::ComponentServer::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Deployment_ComponentServer_upcast (
    void *src
  )
{
  Components::Deployment::ComponentServer **tmp =
    ACE_static_cast (Components::Deployment::ComponentServer **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::ComponentServer_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Deployment::ComponentServer_var::ComponentServer_var (void) // default constructor
  : ptr_ (ComponentServer::_nil ())
{}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_var::ptr (void) const
{
  return this->ptr_;
}

Components::Deployment::ComponentServer_var::ComponentServer_var (const ::Components::Deployment::ComponentServer_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ComponentServer::_duplicate (p.ptr ()))
{}

Components::Deployment::ComponentServer_var::~ComponentServer_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Deployment::ComponentServer_var &
Components::Deployment::ComponentServer_var::operator= (ComponentServer_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Deployment::ComponentServer_var &
Components::Deployment::ComponentServer_var::operator= (const ::Components::Deployment::ComponentServer_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Deployment::ComponentServer::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Deployment::ComponentServer_var::operator const ::Components::Deployment::ComponentServer_ptr &() const // cast
{
  return this->ptr_;
}

Components::Deployment::ComponentServer_var::operator ::Components::Deployment::ComponentServer_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_var::in (void) const
{
  return this->ptr_;
}

::Components::Deployment::ComponentServer_ptr &
Components::Deployment::ComponentServer_var::inout (void)
{
  return this->ptr_;
}

::Components::Deployment::ComponentServer_ptr &
Components::Deployment::ComponentServer_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::ComponentServer::_nil ();
  return this->ptr_;
}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Deployment::ComponentServer_ptr val = this->ptr_;
  this->ptr_ = ::Components::Deployment::ComponentServer::_nil ();
  return val;
}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_var::tao_duplicate (ComponentServer_ptr p)
{
  return ::Components::Deployment::ComponentServer::_duplicate (p);
}

void
Components::Deployment::ComponentServer_var::tao_release (ComponentServer_ptr p)
{
  CORBA::release (p);
}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_var::tao_nil (void)
{
  return ::Components::Deployment::ComponentServer::_nil ();
}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Deployment::ComponentServer::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Deployment::ComponentServer_var::tao_upcast (void *src)
{
  ComponentServer **tmp =
    ACE_static_cast (ComponentServer **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::ComponentServer_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Deployment::ComponentServer_out::ComponentServer_out (ComponentServer_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Deployment::ComponentServer::_nil ();
}

Components::Deployment::ComponentServer_out::ComponentServer_out (ComponentServer_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::ComponentServer::_nil ();
}

Components::Deployment::ComponentServer_out::ComponentServer_out (const ::Components::Deployment::ComponentServer_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ComponentServer_out &, p).ptr_)
{}

::Components::Deployment::ComponentServer_out &
Components::Deployment::ComponentServer_out::operator= (const ::Components::Deployment::ComponentServer_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentServer_out&, p).ptr_;
  return *this;
}

Components::Deployment::ComponentServer_out &
Components::Deployment::ComponentServer_out::operator= (const ::Components::Deployment::ComponentServer_var &p)
{
  this->ptr_ = ::Components::Deployment::ComponentServer::_duplicate (p.ptr ());
  return *this;
}

Components::Deployment::ComponentServer_out &
Components::Deployment::ComponentServer_out::operator= (ComponentServer_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Deployment::ComponentServer_out::operator ::Components::Deployment::ComponentServer_ptr &() // cast
{
  return this->ptr_;
}

::Components::Deployment::ComponentServer_ptr &
Components::Deployment::ComponentServer_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConfigValues * result);

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get &);

  Components::ConfigValues * _result;
};

TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get::TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get::result (::Components::ConfigValues * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::ServerActivator_ptr result);

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator &);

  Components::Deployment::ServerActivator_ptr _result;
};

TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator::TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator::result (::Components::Deployment::ServerActivator_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const Components::ConfigValues & config);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::Container_ptr result);

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container &);

  const Components::ConfigValues & config_;
  Components::Deployment::Container_ptr _result;
};

TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container::TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const Components::ConfigValues & config    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    config_ (config)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->config_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentServer_create_container_exceptiondata[] = 
  {
    Components::_tc_CreateFailure,
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentServer_create_container_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container::result (::Components::Deployment::Container_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::Deployment::Container_ptr cref);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container &);

  Components::Deployment::Container_ptr cref_;
  
};

TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container::TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::Deployment::Container_ptr cref    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    cref_ (cref)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->cref_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentServer_remove_container_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentServer_remove_container_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::Containers * result);

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers &);

  Components::Deployment::Containers * _result;
};

TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers::TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers::result (::Components::Deployment::Containers * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove &);

  
};

TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove::TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_ComponentServer_remove_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_ComponentServer_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::Deployment::_TAO_ComponentServer_Proxy_Impl::_TAO_ComponentServer_Proxy_Impl (void)
{}

Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl::_TAO_ComponentServer_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::ConfigValues * Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl::configuration (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::ConfigValues_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::ConfigValues *tmp;
    ACE_NEW_RETURN (tmp, Components::ConfigValues, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_configuration",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentServer_configuration_get _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConfigValues * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::Deployment::ServerActivator_ptr Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl::get_server_activator (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::Deployment::ServerActivator_var _tao_retval (Components::Deployment::ServerActivator::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_server_activator",
      20,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_server_activator _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::ServerActivator_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::Deployment::Container_ptr Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl::create_container (
    CORBA_Object *_collocated_tao_target_,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ComponentServer_create_container_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/CreateFailure:1.0",
      Components::CreateFailure::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConfiguration:1.0",
      Components::InvalidConfiguration::_alloc
    }
  };

  Components::Deployment::Container_var _tao_retval (Components::Deployment::Container::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_container",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentServer_create_container _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        config
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << config)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ComponentServer_create_container_exceptiondata, 2 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::Container_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl::remove_container (
    CORBA_Object *_collocated_tao_target_,
    Components::Deployment::Container_ptr cref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ComponentServer_remove_container_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove_container",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove_container _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        cref
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << cref)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ComponentServer_remove_container_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

::Components::Deployment::Containers * Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl::get_containers (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::Deployment::Containers_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::Deployment::Containers *tmp;
    ACE_NEW_RETURN (tmp, Components::Deployment::Containers, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_containers",
      14,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentServer_get_containers _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::Containers * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_ComponentServer_remove_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove",
      6,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_ComponentServer_remove _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_ComponentServer_remove_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::Deployment::_TAO_ComponentServer_Proxy_Broker::_TAO_ComponentServer_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentServer_Proxy_Broker::~_TAO_ComponentServer_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentServer_Proxy_Broker * (*Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Broker *
Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Broker::the_TAO_ComponentServer_Remote_Proxy_Broker (void)
{
  static ::Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Broker::_TAO_ComponentServer_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Broker::~_TAO_ComponentServer_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_ComponentServer_Proxy_Impl&
Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Broker::select_proxy (
  ::Components::Deployment::ComponentServer *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Deployment::ComponentServer::ComponentServer (int collocated)
{
  this->Components_Deployment_ComponentServer_setup_collocation (collocated);
}

Components::Deployment::ComponentServer::~ComponentServer (void)
{}

void
Components::Deployment::ComponentServer::Components_Deployment_ComponentServer_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentServer_Proxy_Broker_ =
      ::Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentServer_Proxy_Broker_ =
      ::Components::Deployment::_TAO_ComponentServer_Remote_Proxy_Broker::the_TAO_ComponentServer_Remote_Proxy_Broker ();
}

void Components::Deployment::ComponentServer::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentServer *tmp = ACE_static_cast (ComponentServer*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Deployment::ComponentServer_ptr Components::Deployment::ComponentServer::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return ComponentServer::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Deployment/ComponentServer:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (ComponentServer::_nil ());
      if (is_a == 0)
        return ComponentServer::_nil ();
    }
  return ComponentServer::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Deployment::ComponentServer_ptr 
Components::Deployment::ComponentServer::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return ComponentServer::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ComponentServer_ptr default_proxy = ComponentServer::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components_Deployment__TAO_ComponentServer_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::ComponentServer (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ComponentServer::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::ComponentServer (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ComponentServer::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          ComponentServer_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ComponentServer::_tao_class_id
                  )
              )
        );
}

Components::Deployment::ComponentServer_ptr
Components::Deployment::ComponentServer::_duplicate (ComponentServer_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Deployment::ComponentServer::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/ComponentServer:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Deployment::ComponentServer::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components::Deployment, ComponentServer)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Deployment::ComponentServer::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/ComponentServer:1.0";
}

::Components::ConfigValues * Components::Deployment::ComponentServer::configuration (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentServer_Proxy_Impl &proxy = 
    this->the_TAO_ComponentServer_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.configuration (
      this
    );
}

::Components::Deployment::ServerActivator_ptr Components::Deployment::ComponentServer::get_server_activator (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentServer_Proxy_Impl &proxy = 
    this->the_TAO_ComponentServer_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_server_activator (
      this
    );
}

::Components::Deployment::Container_ptr Components::Deployment::ComponentServer::create_container (
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::CreateFailure
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentServer_Proxy_Impl &proxy = 
    this->the_TAO_ComponentServer_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_container (
      this,
      config
    );
}

void Components::Deployment::ComponentServer::remove_container (
    Components::Deployment::Container_ptr cref
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentServer_Proxy_Impl &proxy = 
    this->the_TAO_ComponentServer_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove_container (
      this,
      cref
    );
}

::Components::Deployment::Containers * Components::Deployment::ComponentServer::get_containers (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentServer_Proxy_Impl &proxy = 
    this->the_TAO_ComponentServer_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_containers (
      this
    );
}

void Components::Deployment::ComponentServer::remove (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_ComponentServer_Proxy_Impl &proxy = 
    this->the_TAO_ComponentServer_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove (
      this
    );
}

static const CORBA::Long _oc_Components_Deployment_ComponentServer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7453), 
  ACE_NTOHL (0x65727665), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/Components/Deployment/ComponentServer:1.0
  16,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74536572), 
  ACE_NTOHL (0x76657200),  // name = ComponentServer
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_ComponentServer (
    CORBA::tk_objref,
    sizeof (_oc_Components_Deployment_ComponentServer),
    (char *) &_oc_Components_Deployment_ComponentServer,
    0,
    sizeof (Components::Deployment::ComponentServer)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ComponentServer, &_tc_TAO_tc_Components_Deployment_ComponentServer)
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

// Default constructor.
Components::Deployment::ImplEntryPointNotFound::ImplEntryPointNotFound (void)
  : CORBA_UserException (
        "IDL:omg.org/Components/Deployment/ImplEntryPointNotFound:1.0",
        "ImplEntryPointNotFound"
      )
{
}

// Destructor - all members are of self managing types.
Components::Deployment::ImplEntryPointNotFound::~ImplEntryPointNotFound (void)
{
}

// Copy constructor.
Components::Deployment::ImplEntryPointNotFound::ImplEntryPointNotFound (const ::Components::Deployment::ImplEntryPointNotFound &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

// Assignment operator.
Components::Deployment::ImplEntryPointNotFound&
Components::Deployment::ImplEntryPointNotFound::operator= (const ::Components::Deployment::ImplEntryPointNotFound &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Deployment::ImplEntryPointNotFound::_tao_any_destructor (void *_tao_void_pointer)
{
  ImplEntryPointNotFound *tmp = ACE_static_cast (ImplEntryPointNotFound*, _tao_void_pointer);
  delete tmp;
}

Components::Deployment::ImplEntryPointNotFound *
Components::Deployment::ImplEntryPointNotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/Components/Deployment/ImplEntryPointNotFound:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (ImplEntryPointNotFound *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Deployment::ImplEntryPointNotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Deployment::ImplEntryPointNotFound, 0);
  return retval;
}

CORBA::Exception *
Components::Deployment::ImplEntryPointNotFound::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Deployment::ImplEntryPointNotFound (*this),
      0
    );
  return result;
}

void Components::Deployment::ImplEntryPointNotFound::_raise ()
{
  TAO_RAISE (*this);
}

void Components::Deployment::ImplEntryPointNotFound::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Deployment::ImplEntryPointNotFound::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

static const CORBA::Long _oc_Components_Deployment_ImplEntryPointNotFound[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  61,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f496d), 
  ACE_NTOHL (0x706c456e), 
  ACE_NTOHL (0x74727950), 
  ACE_NTOHL (0x6f696e74), 
  ACE_NTOHL (0x4e6f7446), 
  ACE_NTOHL (0x6f756e64), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/Components/Deployment/ImplEntryPointNotFound:1.0
  23,
  ACE_NTOHL (0x496d706c), 
  ACE_NTOHL (0x456e7472), 
  ACE_NTOHL (0x79506f69), 
  ACE_NTOHL (0x6e744e6f), 
  ACE_NTOHL (0x74466f75), 
  ACE_NTOHL (0x6e640000),  // name = ImplEntryPointNotFound
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_ImplEntryPointNotFound (
    CORBA::tk_except,
    sizeof (_oc_Components_Deployment_ImplEntryPointNotFound),
    (char *) &_oc_Components_Deployment_ImplEntryPointNotFound,
    0,
    sizeof (Components::Deployment::ImplEntryPointNotFound)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ImplEntryPointNotFound, &_tc_TAO_tc_Components_Deployment_ImplEntryPointNotFound)
TAO_NAMESPACE_END
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Deployment::ImplEntryPointNotFound::_type (void) const
{
  return ::Components::Deployment::_tc_ImplEntryPointNotFound;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:67

int Components::Deployment::Container::_tao_class_id = 0;

Components::Deployment::Container_ptr
tao_Components_Deployment_Container_duplicate (
    Components::Deployment::Container_ptr p
  )
{
  return Components::Deployment::Container::_duplicate (p);
}

void
tao_Components_Deployment_Container_release (
    Components::Deployment::Container_ptr p
  )
{
  CORBA::release (p);
}

Components::Deployment::Container_ptr
tao_Components_Deployment_Container_nil (
    void
  )
{
  return Components::Deployment::Container::_nil ();
}

Components::Deployment::Container_ptr
tao_Components_Deployment_Container_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Deployment::Container::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Deployment_Container_upcast (
    void *src
  )
{
  Components::Deployment::Container **tmp =
    ACE_static_cast (Components::Deployment::Container **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::Container_var
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:654
// *************************************************************

Components::Deployment::Container_var::Container_var (void) // default constructor
  : ptr_ (Container::_nil ())
{}

::Components::Deployment::Container_ptr
Components::Deployment::Container_var::ptr (void) const
{
  return this->ptr_;
}

Components::Deployment::Container_var::Container_var (const ::Components::Deployment::Container_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Container::_duplicate (p.ptr ()))
{}

Components::Deployment::Container_var::~Container_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

Components::Deployment::Container_var &
Components::Deployment::Container_var::operator= (Container_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Deployment::Container_var &
Components::Deployment::Container_var::operator= (const ::Components::Deployment::Container_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Deployment::Container::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Deployment::Container_var::operator const ::Components::Deployment::Container_ptr &() const // cast
{
  return this->ptr_;
}

Components::Deployment::Container_var::operator ::Components::Deployment::Container_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Deployment::Container_ptr
Components::Deployment::Container_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Deployment::Container_ptr
Components::Deployment::Container_var::in (void) const
{
  return this->ptr_;
}

::Components::Deployment::Container_ptr &
Components::Deployment::Container_var::inout (void)
{
  return this->ptr_;
}

::Components::Deployment::Container_ptr &
Components::Deployment::Container_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::Container::_nil ();
  return this->ptr_;
}

::Components::Deployment::Container_ptr
Components::Deployment::Container_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Deployment::Container_ptr val = this->ptr_;
  this->ptr_ = ::Components::Deployment::Container::_nil ();
  return val;
}

::Components::Deployment::Container_ptr
Components::Deployment::Container_var::tao_duplicate (Container_ptr p)
{
  return ::Components::Deployment::Container::_duplicate (p);
}

void
Components::Deployment::Container_var::tao_release (Container_ptr p)
{
  CORBA::release (p);
}

::Components::Deployment::Container_ptr
Components::Deployment::Container_var::tao_nil (void)
{
  return ::Components::Deployment::Container::_nil ();
}

::Components::Deployment::Container_ptr
Components::Deployment::Container_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Deployment::Container::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Deployment::Container_var::tao_upcast (void *src)
{
  Container **tmp =
    ACE_static_cast (Container **, src);
  return *tmp;
}

// *************************************************************
// Components::Deployment::Container_out
// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:932
// *************************************************************

Components::Deployment::Container_out::Container_out (Container_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Deployment::Container::_nil ();
}

Components::Deployment::Container_out::Container_out (Container_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Deployment::Container::_nil ();
}

Components::Deployment::Container_out::Container_out (const ::Components::Deployment::Container_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Container_out &, p).ptr_)
{}

::Components::Deployment::Container_out &
Components::Deployment::Container_out::operator= (const ::Components::Deployment::Container_out &p)
{
  this->ptr_ = ACE_const_cast (Container_out&, p).ptr_;
  return *this;
}

Components::Deployment::Container_out &
Components::Deployment::Container_out::operator= (const ::Components::Deployment::Container_var &p)
{
  this->ptr_ = ::Components::Deployment::Container::_duplicate (p.ptr ());
  return *this;
}

Components::Deployment::Container_out &
Components::Deployment::Container_out::operator= (Container_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Deployment::Container_out::operator ::Components::Deployment::Container_ptr &() // cast
{
  return this->ptr_;
}

::Components::Deployment::Container_ptr &
Components::Deployment::Container_out::ptr (void) // ptr
{
  return this->ptr_;
}

::Components::Deployment::Container_ptr
Components::Deployment::Container_out::operator-> (void)
{
  return this->ptr_;
}


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::ConfigValues * result);

private:
  TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get (const TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get &);

  Components::ConfigValues * _result;
};

TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get::TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get::result (::Components::ConfigValues * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::Deployment::ComponentServer_ptr result);

private:
  TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server (const TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server &);

  Components::Deployment::ComponentServer_ptr _result;
};

TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server::TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server::result (::Components::Deployment::ComponentServer_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_Container_install_home : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Container_install_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * entrypt,
      const Components::ConfigValues & config);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHome_ptr result);

private:
  TAO_ClientRequestInfo_Components_Deployment_Container_install_home (const TAO_ClientRequestInfo_Components_Deployment_Container_install_home &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Container_install_home &);

  const char * id_;
  const char * entrypt_;
  const Components::ConfigValues & config_;
  Components::CCMHome_ptr _result;
};

TAO_ClientRequestInfo_Components_Deployment_Container_install_home::TAO_ClientRequestInfo_Components_Deployment_Container_install_home (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * entrypt,
    const Components::ConfigValues & config    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    id_ (id),
    entrypt_ (entrypt),
    config_ (config)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Container_install_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (3);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= entrypt_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->config_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Container_install_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Container_install_home_exceptiondata[] = 
  {
    Components::Deployment::_tc_UnknownImplId,
    Components::Deployment::_tc_ImplEntryPointNotFound,
    Components::Deployment::_tc_InstallationFailure,
    Components::_tc_InvalidConfiguration
  };
  
  exception_list->length (4);
  for (CORBA::ULong i = 0; i < 4; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Container_install_home_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Container_install_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_Container_install_home::result (::Components::CCMHome_ptr result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_Container_remove_home : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Container_remove_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      Components::CCMHome_ptr href);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_Container_remove_home (const TAO_ClientRequestInfo_Components_Deployment_Container_remove_home &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Container_remove_home &);

  Components::CCMHome_ptr href_;
  
};

TAO_ClientRequestInfo_Components_Deployment_Container_remove_home::TAO_ClientRequestInfo_Components_Deployment_Container_remove_home (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    Components::CCMHome_ptr href    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
    href_ (href)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Container_remove_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<=  this->href_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Container_remove_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Container_remove_home_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Container_remove_home_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Container_remove_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

class TAO_ClientRequestInfo_Components_Deployment_Container_get_homes : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Container_get_homes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (Components::CCMHomes * result);

private:
  TAO_ClientRequestInfo_Components_Deployment_Container_get_homes (const TAO_ClientRequestInfo_Components_Deployment_Container_get_homes &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Container_get_homes &);

  Components::CCMHomes * _result;
};

TAO_ClientRequestInfo_Components_Deployment_Container_get_homes::TAO_ClientRequestInfo_Components_Deployment_Container_get_homes (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Container_get_homes::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Container_get_homes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Container_get_homes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_Components_Deployment_Container_get_homes::result (::Components::CCMHomes * result)
{
  // update the result 
  this->_result = result;
}

class TAO_ClientRequestInfo_Components_Deployment_Container_remove : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_Components_Deployment_Container_remove (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target);

  virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
    ACE_THROW_SPEC ((CORBA::SystemException));

private:
  TAO_ClientRequestInfo_Components_Deployment_Container_remove (const TAO_ClientRequestInfo_Components_Deployment_Container_remove &);
  void operator= (const TAO_ClientRequestInfo_Components_Deployment_Container_remove &);

  
};

TAO_ClientRequestInfo_Components_Deployment_Container_remove::TAO_ClientRequestInfo_Components_Deployment_Container_remove (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target    
  )
  : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_Components_Deployment_Container_remove::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;

}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_Components_Deployment_Container_remove::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_Components_Deployment_Container_remove_exceptiondata[] = 
  {
    Components::_tc_RemoveFailure
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_Components_Deployment_Container_remove_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}

CORBA::Any * 
TAO_ClientRequestInfo_Components_Deployment_Container_remove::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

Components::Deployment::_TAO_Container_Proxy_Impl::_TAO_Container_Proxy_Impl (void)
{}

Components::Deployment::_TAO_Container_Remote_Proxy_Impl::_TAO_Container_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

::Components::ConfigValues * Components::Deployment::_TAO_Container_Remote_Proxy_Impl::configuration (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::ConfigValues_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::ConfigValues *tmp;
    ACE_NEW_RETURN (tmp, Components::ConfigValues, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_configuration",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Container_configuration_get _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::ConfigValues * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::Deployment::ComponentServer_ptr Components::Deployment::_TAO_Container_Remote_Proxy_Impl::get_component_server (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::Deployment::ComponentServer_var _tao_retval (Components::Deployment::ComponentServer::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_component_server",
      20,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Container_get_component_server _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::Deployment::ComponentServer_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

::Components::CCMHome_ptr Components::Deployment::_TAO_Container_Remote_Proxy_Impl::install_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * entrypt,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::Deployment::ImplEntryPointNotFound
    , Components::Deployment::InstallationFailure
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_Container_install_home_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/Deployment/UnknownImplId:1.0",
      Components::Deployment::UnknownImplId::_alloc
    },
    {
      "IDL:omg.org/Components/Deployment/ImplEntryPointNotFound:1.0",
      Components::Deployment::ImplEntryPointNotFound::_alloc
    },
    {
      "IDL:omg.org/Components/Deployment/InstallationFailure:1.0",
      Components::Deployment::InstallationFailure::_alloc
    },
    {
      "IDL:omg.org/Components/InvalidConfiguration:1.0",
      Components::InvalidConfiguration::_alloc
    }
  };

  Components::CCMHome_var _tao_retval (Components::CCMHome::_nil ());


  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "install_home",
      12,
      3,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Container_install_home _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        entrypt,
        config
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << entrypt) &&
              (_tao_out << config)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_Container_install_home_exceptiondata, 4 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHome_ptr _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::Deployment::_TAO_Container_Remote_Proxy_Impl::remove_home (
    CORBA_Object *_collocated_tao_target_,
    Components::CCMHome_ptr href
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_Container_remove_home_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove_home",
      11,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Container_remove_home _tao_ri (
        &_tao_call,
        _collocated_tao_target_,
        href
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << href)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_Container_remove_home_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}

::Components::CCMHomes * Components::Deployment::_TAO_Container_Remote_Proxy_Impl::get_homes (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  Components::CCMHomes_var _tao_retval;

  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());

  
  {
    Components::CCMHomes *tmp;
    ACE_NEW_RETURN (tmp, Components::CCMHomes, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_homes",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Container_get_homes _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK_RETURN (_tao_retval._retn ());

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES),
                0
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::Components::CCMHomes * _tao_retval_info = _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK_RETURN (_tao_retval._retn ());

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK_RETURN (_tao_retval._retn ());

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }
return _tao_retval._retn ();
}

void Components::Deployment::_TAO_Container_Remote_Proxy_Impl::remove (
    CORBA_Object *_collocated_tao_target_
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  static TAO_Exception_Data _tao_Components_Deployment_Container_remove_exceptiondata [] = 
  {
    {
      "IDL:omg.org/Components/RemoveFailure:1.0",
      Components::RemoveFailure::_alloc
    }
  };

  
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove",
      6,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_Components_Deployment_Container_remove _tao_ri (
        &_tao_call,
        _collocated_tao_target_
      );
            ACE_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
                    TAO_INTERCEPTOR_CHECK;

          _invoke_status =
            _tao_call.invoke (_tao_Components_Deployment_Container_remove_exceptiondata, 1 ACE_ENV_ARG_PARAMETER);
                    TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_OMG_VMCID | 1, CORBA::COMPLETED_YES)
              );
              
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                _tao_ri.reply_status (_invoke_status);
                _tao_vfr.receive_other (
                  &_tao_ri
                  ACE_ENV_ARG_PARAMETER
                );
                ACE_TRY_CHECK;
              )
              
              continue;
            }
          
          
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
            &_tao_ri
            ACE_ENV_ARG_PARAMETER
          );
          ACE_TRY_CHECK;
        
      }
    ACE_CATCHANY
      {
        _tao_ri.exception (&ACE_ANY_EXCEPTION);
        _tao_vfr.receive_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
        ACE_TRY_CHECK;
        
        PortableInterceptor::ReplyStatus _tao_status =
          _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
        if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
            || _tao_status == PortableInterceptor::USER_EXCEPTION)
          ACE_RE_THROW;
      }
    ACE_ENDTRY;
        ACE_CHECK;

    PortableInterceptor::ReplyStatus _tao_status =
      _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
        ACE_CHECK;

    if (_tao_status == PortableInterceptor::LOCATION_FORWARD
        || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
      continue;
    
#endif  /* TAO_HAS_INTERCEPTORS */
    
    break;
  }

}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

Components::Deployment::_TAO_Container_Proxy_Broker::_TAO_Container_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Container_Proxy_Broker::~_TAO_Container_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Container_Proxy_Broker * (*Components_Deployment__TAO_Container_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
Components::Deployment::_TAO_Container_Remote_Proxy_Broker *
Components::Deployment::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker (void)
{
  static ::Components::Deployment::_TAO_Container_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

Components::Deployment::_TAO_Container_Remote_Proxy_Broker::_TAO_Container_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Container_Remote_Proxy_Broker::~_TAO_Container_Remote_Proxy_Broker (void)
{
}

Components::Deployment::_TAO_Container_Proxy_Impl&
Components::Deployment::_TAO_Container_Remote_Proxy_Broker::select_proxy (
  ::Components::Deployment::Container *
  ACE_ENV_ARG_DECL_NOT_USED
)
{
  return this->remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:198

Components::Deployment::Container::Container (int collocated)
{
  this->Components_Deployment_Container_setup_collocation (collocated);
}

Components::Deployment::Container::~Container (void)
{}

void
Components::Deployment::Container::Components_Deployment_Container_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Container_Proxy_Broker_ =
      ::Components_Deployment__TAO_Container_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Container_Proxy_Broker_ =
      ::Components::Deployment::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker ();
}

void Components::Deployment::Container::_tao_any_destructor (void *_tao_void_pointer)
{
  Container *tmp = ACE_static_cast (Container*, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Deployment::Container_ptr Components::Deployment::Container::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    return Container::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/Components/Deployment/Container:1.0" ACE_ENV_ARG_PARAMETER);
      ACE_CHECK_RETURN (Container::_nil ());
      if (is_a == 0)
        return Container::_nil ();
    }
  return Container::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Deployment::Container_ptr 
Components::Deployment::Container::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    return Container::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Container_ptr default_proxy = Container::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          Components_Deployment__TAO_Container_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::Container (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Container::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::Components::Deployment::Container (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Container::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Container_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Container::_tao_class_id
                  )
              )
        );
}

Components::Deployment::Container_ptr
Components::Deployment::Container::_duplicate (Container_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean Components::Deployment::Container::_is_a (const CORBA::Char *value ACE_ENV_ARG_DECL)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/Components/Deployment/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value ACE_ENV_ARG_PARAMETER);
}

void *Components::Deployment::Container::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::Components::Deployment, Container)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Components::Deployment::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/Components/Deployment/Container:1.0";
}

::Components::ConfigValues * Components::Deployment::Container::configuration (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.configuration (
      this
    );
}

::Components::Deployment::ComponentServer_ptr Components::Deployment::Container::get_component_server (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_component_server (
      this
    );
}

::Components::CCMHome_ptr Components::Deployment::Container::install_home (
    const char * id,
    const char * entrypt,
    const Components::ConfigValues & config
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::Deployment::UnknownImplId
    , Components::Deployment::ImplEntryPointNotFound
    , Components::Deployment::InstallationFailure
    , Components::InvalidConfiguration
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.install_home (
      this,
      id,
      entrypt,
      config
    );
}

void Components::Deployment::Container::remove_home (
    Components::CCMHome_ptr href
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove_home (
      this,
      href
    );
}

::Components::CCMHomes * Components::Deployment::Container::get_homes (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.get_homes (
      this
    );
}

void Components::Deployment::Container::remove (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , Components::RemoveFailure
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;
  
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.remove (
      this
    );
}

static const CORBA::Long _oc_Components_Deployment_Container[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f44), 
  ACE_NTOHL (0x65706c6f), 
  ACE_NTOHL (0x796d656e), 
  ACE_NTOHL (0x742f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/Components/Deployment/Container:1.0
  10,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x72000000),  // name = Container
};

static CORBA::TypeCode _tc_TAO_tc_Components_Deployment_Container (
    CORBA::tk_objref,
    sizeof (_oc_Components_Deployment_Container),
    (char *) &_oc_Components_Deployment_Container,
    0,
    sizeof (Components::Deployment::Container)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Deployment)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_Container, &_tc_TAO_tc_Components_Deployment_Container)
TAO_NAMESPACE_END
TAO_NAMESPACE_END

CORBA::Boolean 
OBV_Components::Cookie::_tao_marshal__Components_Cookie (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::Cookie::_tao_unmarshal__Components_Cookie (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::Cookie::cookieValue (const CORBA::OctetSeq &val)
{
  this->_pd_cookieValue = val;
}

// readonly get method 
const CORBA::OctetSeq &
OBV_Components::Cookie::cookieValue (void) const
{
  return this->_pd_cookieValue;
}

// read/write get method 
CORBA::OctetSeq &
OBV_Components::Cookie::cookieValue (void)
{
  return this->_pd_cookieValue;
}

CORBA::Boolean 
OBV_Components::PortDescription::_tao_marshal__Components_PortDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::PortDescription::_tao_unmarshal__Components_PortDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::PortDescription::Name (char *val)
{
  // set the value
  this->_pd_Name = val;
}
// accessor to set the member
void
OBV_Components::PortDescription::Name (const char *val)
{
  // set the value
  this->_pd_Name = CORBA::string_dup (val);
}
// accessor to set the member
void
OBV_Components::PortDescription::Name (const CORBA::String_var &val)
{
  ;
  // set the value
  CORBA::String_var Name_var = val;
  this->_pd_Name = Name_var._retn ();
}
const char *
OBV_Components::PortDescription::Name (void) const // get method
{
  return this->_pd_Name;
}

// accessor to set the member
void
OBV_Components::PortDescription::type_id (char *val)
{
  // set the value
  this->_pd_type_id = val;
}
// accessor to set the member
void
OBV_Components::PortDescription::type_id (const char *val)
{
  // set the value
  this->_pd_type_id = CORBA::string_dup (val);
}
// accessor to set the member
void
OBV_Components::PortDescription::type_id (const CORBA::String_var &val)
{
  ;
  // set the value
  CORBA::String_var type_id_var = val;
  this->_pd_type_id = type_id_var._retn ();
}
const char *
OBV_Components::PortDescription::type_id (void) const // get method
{
  return this->_pd_type_id;
}

CORBA::Boolean 
OBV_Components::FacetDescription::_tao_marshal__Components_FacetDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::FacetDescription::_tao_unmarshal__Components_FacetDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::FacetDescription::facet_ref (CORBA::Object_ptr val) // set
{
  this->_pd_facet_ref = CORBA::Object::_duplicate (val);
}
// retrieve the member
CORBA::Object_ptr
OBV_Components::FacetDescription::facet_ref (void) const
{
  return this->_pd_facet_ref;
}

CORBA::Boolean 
OBV_Components::ConnectionDescription::_tao_marshal__Components_ConnectionDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::ConnectionDescription::_tao_unmarshal__Components_ConnectionDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::ConnectionDescription::ck (Components::Cookie* val)// set
{
  CORBA::add_ref (val);
  this->_pd_ck = val;
}
// retrieve the member
Components::Cookie* 
OBV_Components::ConnectionDescription::ck () const
{
  return this->_pd_ck.ptr ();
}

// accessor to set the member
void
OBV_Components::ConnectionDescription::objref (CORBA::Object_ptr val) // set
{
  this->_pd_objref = CORBA::Object::_duplicate (val);
}
// retrieve the member
CORBA::Object_ptr
OBV_Components::ConnectionDescription::objref (void) const
{
  return this->_pd_objref;
}

CORBA::Boolean 
OBV_Components::ReceptacleDescription::_tao_marshal__Components_ReceptacleDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::ReceptacleDescription::_tao_unmarshal__Components_ReceptacleDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::ReceptacleDescription::is_multiple (CORBA::Boolean val) // set
{
  // set the value
  this->_pd_is_multiple = val;
}
// retrieve the member
CORBA::Boolean
OBV_Components::ReceptacleDescription::is_multiple (void) const
{
  return this->_pd_is_multiple;
}

// accessor to set the member
void
OBV_Components::ReceptacleDescription::connections (const Components::ConnectionDescriptions &val)
{
  this->_pd_connections = val;
}

// readonly get method 
const Components::ConnectionDescriptions &
OBV_Components::ReceptacleDescription::connections (void) const
{
  return this->_pd_connections;
}

// read/write get method 
Components::ConnectionDescriptions &
OBV_Components::ReceptacleDescription::connections (void)
{
  return this->_pd_connections;
}

CORBA::Boolean 
OBV_Components::ConsumerDescription::_tao_marshal__Components_ConsumerDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::ConsumerDescription::_tao_unmarshal__Components_ConsumerDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::ConsumerDescription::consumer (Components::EventConsumerBase_ptr val)// set
{
  this->_pd_consumer = Components::EventConsumerBase::_duplicate (val);
}
// retrieve the member
Components::EventConsumerBase_ptr 
OBV_Components::ConsumerDescription::consumer () const
{
  return this->_pd_consumer.ptr ();
}

CORBA::Boolean 
OBV_Components::EmitterDescription::_tao_marshal__Components_EmitterDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::EmitterDescription::_tao_unmarshal__Components_EmitterDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::EmitterDescription::consumer (Components::EventConsumerBase_ptr val)// set
{
  this->_pd_consumer = Components::EventConsumerBase::_duplicate (val);
}
// retrieve the member
Components::EventConsumerBase_ptr 
OBV_Components::EmitterDescription::consumer () const
{
  return this->_pd_consumer.ptr ();
}

CORBA::Boolean 
OBV_Components::SubscriberDescription::_tao_marshal__Components_SubscriberDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::SubscriberDescription::_tao_unmarshal__Components_SubscriberDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::SubscriberDescription::ck (Components::Cookie* val)// set
{
  CORBA::add_ref (val);
  this->_pd_ck = val;
}
// retrieve the member
Components::Cookie* 
OBV_Components::SubscriberDescription::ck () const
{
  return this->_pd_ck.ptr ();
}

// accessor to set the member
void
OBV_Components::SubscriberDescription::consumer (Components::EventConsumerBase_ptr val)// set
{
  this->_pd_consumer = Components::EventConsumerBase::_duplicate (val);
}
// retrieve the member
Components::EventConsumerBase_ptr 
OBV_Components::SubscriberDescription::consumer () const
{
  return this->_pd_consumer.ptr ();
}

CORBA::Boolean 
OBV_Components::PublisherDescription::_tao_marshal__Components_PublisherDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::PublisherDescription::_tao_unmarshal__Components_PublisherDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::PublisherDescription::consumer (const Components::SubscriberDescriptions &val)
{
  this->_pd_consumer = val;
}

// readonly get method 
const Components::SubscriberDescriptions &
OBV_Components::PublisherDescription::consumer (void) const
{
  return this->_pd_consumer;
}

// read/write get method 
Components::SubscriberDescriptions &
OBV_Components::PublisherDescription::consumer (void)
{
  return this->_pd_consumer;
}

CORBA::Boolean 
OBV_Components::ConfigValue::_tao_marshal__Components_ConfigValue (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::ConfigValue::_tao_unmarshal__Components_ConfigValue (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::ConfigValue::name (char *val)
{
  // set the value
  this->_pd_name = val;
}
// accessor to set the member
void
OBV_Components::ConfigValue::name (const char *val)
{
  // set the value
  this->_pd_name = CORBA::string_dup (val);
}
// accessor to set the member
void
OBV_Components::ConfigValue::name (const CORBA::String_var &val)
{
  ;
  // set the value
  CORBA::String_var name_var = val;
  this->_pd_name = name_var._retn ();
}
const char *
OBV_Components::ConfigValue::name (void) const // get method
{
  return this->_pd_name;
}

// accessor to set the member
void
OBV_Components::ConfigValue::value (CORBA::Any &val) // set
{
  this->_pd_value = val;
}
// retrieve the member
const CORBA::Any *
OBV_Components::ConfigValue::value (void) const
{
  // @@ Shouldn't we return a duplicate here?
  return &this->_pd_value;
}
// retrieve the member
CORBA::Any *
OBV_Components::ConfigValue::value (void)
{
  // @@ Shouldn't we return a duplicate here?
  return &this->_pd_value;
}

CORBA::Boolean 
OBV_Components::ComponentPortDescription::_tao_marshal__Components_ComponentPortDescription (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::ComponentPortDescription::_tao_unmarshal__Components_ComponentPortDescription (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::ComponentPortDescription::facets (const Components::FacetDescriptions &val)
{
  this->_pd_facets = val;
}

// readonly get method 
const Components::FacetDescriptions &
OBV_Components::ComponentPortDescription::facets (void) const
{
  return this->_pd_facets;
}

// read/write get method 
Components::FacetDescriptions &
OBV_Components::ComponentPortDescription::facets (void)
{
  return this->_pd_facets;
}

// accessor to set the member
void
OBV_Components::ComponentPortDescription::receptacles (const Components::ReceptacleDescriptions &val)
{
  this->_pd_receptacles = val;
}

// readonly get method 
const Components::ReceptacleDescriptions &
OBV_Components::ComponentPortDescription::receptacles (void) const
{
  return this->_pd_receptacles;
}

// read/write get method 
Components::ReceptacleDescriptions &
OBV_Components::ComponentPortDescription::receptacles (void)
{
  return this->_pd_receptacles;
}

// accessor to set the member
void
OBV_Components::ComponentPortDescription::consumers (const Components::ConsumerDescriptions &val)
{
  this->_pd_consumers = val;
}

// readonly get method 
const Components::ConsumerDescriptions &
OBV_Components::ComponentPortDescription::consumers (void) const
{
  return this->_pd_consumers;
}

// read/write get method 
Components::ConsumerDescriptions &
OBV_Components::ComponentPortDescription::consumers (void)
{
  return this->_pd_consumers;
}

// accessor to set the member
void
OBV_Components::ComponentPortDescription::emitters (const Components::EmitterDescriptions &val)
{
  this->_pd_emitters = val;
}

// readonly get method 
const Components::EmitterDescriptions &
OBV_Components::ComponentPortDescription::emitters (void) const
{
  return this->_pd_emitters;
}

// read/write get method 
Components::EmitterDescriptions &
OBV_Components::ComponentPortDescription::emitters (void)
{
  return this->_pd_emitters;
}

// accessor to set the member
void
OBV_Components::ComponentPortDescription::publishers (const Components::PublisherDescriptions &val)
{
  this->_pd_publishers = val;
}

// readonly get method 
const Components::PublisherDescriptions &
OBV_Components::ComponentPortDescription::publishers (void) const
{
  return this->_pd_publishers;
}

// read/write get method 
Components::PublisherDescriptions &
OBV_Components::ComponentPortDescription::publishers (void)
{
  return this->_pd_publishers;
}

CORBA::Boolean 
OBV_Components::DefaultEnumeration::_tao_marshal__Components_DefaultEnumeration (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::DefaultEnumeration::_tao_unmarshal__Components_DefaultEnumeration (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::DefaultEnumeration::objects (const Components::CCMObjectSeq &val)
{
  this->_pd_objects = val;
}

// readonly get method 
const Components::CCMObjectSeq &
OBV_Components::DefaultEnumeration::objects (void) const
{
  return this->_pd_objects;
}

// read/write get method 
Components::CCMObjectSeq &
OBV_Components::DefaultEnumeration::objects (void)
{
  return this->_pd_objects;
}

CORBA::Boolean 
OBV_Components::PersistentIdValue::_tao_marshal__Components_PersistentIdValue (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::PersistentIdValue::_tao_unmarshal__Components_PersistentIdValue (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::PersistentIdValue::pid (char *val)
{
  // set the value
  this->_pd_pid = val;
}
// accessor to set the member
void
OBV_Components::PersistentIdValue::pid (const char *val)
{
  // set the value
  this->_pd_pid = CORBA::string_dup (val);
}
// accessor to set the member
void
OBV_Components::PersistentIdValue::pid (const CORBA::String_var &val)
{
  ;
  // set the value
  CORBA::String_var pid_var = val;
  this->_pd_pid = pid_var._retn ();
}
const char *
OBV_Components::PersistentIdValue::pid (void) const // get method
{
  return this->_pd_pid;
}

CORBA::Boolean 
OBV_Components::SegmentDescr::_tao_marshal__Components_SegmentDescr (TAO_OutputCDR &strm){
  return _tao_marshal_state (strm);
  
}
CORBA::Boolean OBV_Components::SegmentDescr::_tao_unmarshal__Components_SegmentDescr (TAO_InputCDR &strm){
  return _tao_unmarshal_state (strm);
  
}
// accessor to set the member
void
OBV_Components::SegmentDescr::sid (Components::StateIdValue* val)// set
{
  CORBA::add_ref (val);
  this->_pd_sid = val;
}
// retrieve the member
Components::StateIdValue* 
OBV_Components::SegmentDescr::sid () const
{
  return this->_pd_sid.ptr ();
}

// accessor to set the member
void
OBV_Components::SegmentDescr::seg (Components::SegmentId val) // set
{
  // set the value
  this->_pd_seg = val;
}
// retrieve the member
Components::SegmentId
OBV_Components::SegmentDescr::seg (void) const
{
  return this->_pd_seg;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::NameList &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NameList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::NameList *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NameList,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::NameList::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::NameList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::NameList*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::NameList *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_NameList
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::NameList*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::NameList *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::NameList,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_NameList,
                1,
                ACE_static_cast (void *, tmp),
                Components::NameList::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

 void
operator<<= (CORBA::Any &any, Components::Cookie *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_Cookie, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::Cookie **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_Cookie, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::Cookie::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::Cookie *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_Cookie ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::Cookie *const_holder = ACE_static_cast (
          const Components::Cookie*,
          any.value ());
      value = ACE_const_cast (
          Components::Cookie*,
          const_holder);
      return 1;
    }
    else
    {
      Components::Cookie *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_Cookie,
            1,
            ACE_static_cast (void *, tmp),
            Components::Cookie::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::Cookie, Components::Cookie_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::Cookie, Components::Cookie_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::PortDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_PortDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::PortDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_PortDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::PortDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::PortDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_PortDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::PortDescription *const_holder = ACE_static_cast (
          const Components::PortDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::PortDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::PortDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_PortDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::PortDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::PortDescription, Components::PortDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::PortDescription, Components::PortDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::FacetDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_FacetDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::FacetDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_FacetDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::FacetDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::FacetDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_FacetDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::FacetDescription *const_holder = ACE_static_cast (
          const Components::FacetDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::FacetDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::FacetDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_FacetDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::FacetDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::FacetDescription, Components::FacetDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::FacetDescription, Components::FacetDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::FacetDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FacetDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::FacetDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FacetDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::FacetDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::FacetDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::FacetDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::FacetDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_FacetDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::FacetDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::FacetDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::FacetDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_FacetDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::FacetDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidName &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidName,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidName *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidName,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidName::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidName *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidName*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidName *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidName
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidName *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidName *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidName,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidName:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidName,
                1,
                tmp,
                Components::InvalidName::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidConnection &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidConnection *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidConnection::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidConnection *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidConnection*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidConnection *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidConnection
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidConnection *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidConnection *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidConnection,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidConnection:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidConnection,
                1,
                tmp,
                Components::InvalidConnection::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ExceededConnectionLimit &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ExceededConnectionLimit,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ExceededConnectionLimit *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ExceededConnectionLimit,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ExceededConnectionLimit::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::ExceededConnectionLimit *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ExceededConnectionLimit*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ExceededConnectionLimit *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ExceededConnectionLimit
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::ExceededConnectionLimit *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::ExceededConnectionLimit *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ExceededConnectionLimit,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/ExceededConnectionLimit:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ExceededConnectionLimit,
                1,
                tmp,
                Components::ExceededConnectionLimit::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::AlreadyConnected &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_AlreadyConnected,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::AlreadyConnected *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_AlreadyConnected,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::AlreadyConnected::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::AlreadyConnected *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::AlreadyConnected*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::AlreadyConnected *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_AlreadyConnected
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::AlreadyConnected *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::AlreadyConnected *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::AlreadyConnected,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/AlreadyConnected:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_AlreadyConnected,
                1,
                tmp,
                Components::AlreadyConnected::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::NoConnection &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::NoConnection *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoConnection,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::NoConnection::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::NoConnection *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::NoConnection*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::NoConnection *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_NoConnection
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::NoConnection *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::NoConnection *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::NoConnection,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/NoConnection:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_NoConnection,
                1,
                tmp,
                Components::NoConnection::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CookieRequired &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CookieRequired,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CookieRequired *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CookieRequired,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CookieRequired::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::CookieRequired *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CookieRequired*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CookieRequired *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CookieRequired
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::CookieRequired *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::CookieRequired *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CookieRequired,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/CookieRequired:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CookieRequired,
                1,
                tmp,
                Components::CookieRequired::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CreateFailure &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CreateFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CreateFailure *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CreateFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CreateFailure::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::CreateFailure *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CreateFailure*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CreateFailure *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CreateFailure
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::CreateFailure *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::CreateFailure *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CreateFailure,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/CreateFailure:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CreateFailure,
                1,
                tmp,
                Components::CreateFailure::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::FinderFailure &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FinderFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::FinderFailure *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_FinderFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::FinderFailure::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::FinderFailure *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::FinderFailure*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::FinderFailure *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_FinderFailure
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::FinderFailure *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::FinderFailure *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::FinderFailure,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/FinderFailure:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_FinderFailure,
                1,
                tmp,
                Components::FinderFailure::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::RemoveFailure &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_RemoveFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::RemoveFailure *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_RemoveFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::RemoveFailure::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::RemoveFailure *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::RemoveFailure*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::RemoveFailure *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_RemoveFailure
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::RemoveFailure *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::RemoveFailure *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::RemoveFailure,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/RemoveFailure:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_RemoveFailure,
                1,
                tmp,
                Components::RemoveFailure::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::DuplicateKeyValue &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_DuplicateKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::DuplicateKeyValue *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_DuplicateKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::DuplicateKeyValue::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::DuplicateKeyValue *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::DuplicateKeyValue*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::DuplicateKeyValue *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_DuplicateKeyValue
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::DuplicateKeyValue *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::DuplicateKeyValue *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::DuplicateKeyValue,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/DuplicateKeyValue:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_DuplicateKeyValue,
                1,
                tmp,
                Components::DuplicateKeyValue::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidKey &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidKey,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidKey *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidKey,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidKey::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidKey *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidKey*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidKey *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidKey
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidKey *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidKey *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidKey,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidKey:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidKey,
                1,
                tmp,
                Components::InvalidKey::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::UnknownKeyValue &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_UnknownKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::UnknownKeyValue *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_UnknownKeyValue,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::UnknownKeyValue::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::UnknownKeyValue *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::UnknownKeyValue*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::UnknownKeyValue *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_UnknownKeyValue
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::UnknownKeyValue *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::UnknownKeyValue *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::UnknownKeyValue,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/UnknownKeyValue:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_UnknownKeyValue,
                1,
                tmp,
                Components::UnknownKeyValue::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::NoKeyAvailable &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoKeyAvailable,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::NoKeyAvailable *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_NoKeyAvailable,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::NoKeyAvailable::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::NoKeyAvailable *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::NoKeyAvailable*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::NoKeyAvailable *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_NoKeyAvailable
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::NoKeyAvailable *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::NoKeyAvailable *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::NoKeyAvailable,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/NoKeyAvailable:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_NoKeyAvailable,
                1,
                tmp,
                Components::NoKeyAvailable::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::BadEventType &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_BadEventType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::BadEventType *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_BadEventType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::BadEventType::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::BadEventType *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::BadEventType*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::BadEventType *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_BadEventType
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::BadEventType *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::BadEventType *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::BadEventType,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/BadEventType:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_BadEventType,
                1,
                tmp,
                Components::BadEventType::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::HomeNotFound &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeNotFound,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeNotFound *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeNotFound,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::HomeNotFound::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::HomeNotFound *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::HomeNotFound*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::HomeNotFound *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeNotFound
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::HomeNotFound *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::HomeNotFound *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::HomeNotFound,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/HomeNotFound:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_HomeNotFound,
                1,
                tmp,
                Components::HomeNotFound::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::WrongComponentType &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_WrongComponentType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::WrongComponentType *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_WrongComponentType,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::WrongComponentType::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::WrongComponentType *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::WrongComponentType*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::WrongComponentType *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_WrongComponentType
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::WrongComponentType *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::WrongComponentType *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::WrongComponentType,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/WrongComponentType:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_WrongComponentType,
                1,
                tmp,
                Components::WrongComponentType::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidConfiguration &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConfiguration,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidConfiguration *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidConfiguration,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidConfiguration::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidConfiguration *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidConfiguration*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidConfiguration *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidConfiguration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidConfiguration *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidConfiguration *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidConfiguration,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidConfiguration:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidConfiguration,
                1,
                tmp,
                Components::InvalidConfiguration::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::IllegalState &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_IllegalState,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::IllegalState *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_IllegalState,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::IllegalState::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::IllegalState *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::IllegalState*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::IllegalState *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_IllegalState
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::IllegalState *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::IllegalState *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::IllegalState,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/IllegalState:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_IllegalState,
                1,
                tmp,
                Components::IllegalState::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Navigation_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Navigation, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Navigation::_duplicate (_tao_elem),
          Components::Navigation::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Navigation_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Navigation, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Navigation::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Navigation_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Navigation::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Navigation
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Navigation,
            1,
            _tao_elem,
            Components::Navigation::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Navigation::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Navigation,Components::Navigation_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Navigation,Components::Navigation_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::ConnectionDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_ConnectionDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::ConnectionDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_ConnectionDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::ConnectionDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::ConnectionDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_ConnectionDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::ConnectionDescription *const_holder = ACE_static_cast (
          const Components::ConnectionDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::ConnectionDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::ConnectionDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_ConnectionDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::ConnectionDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ConnectionDescription, Components::ConnectionDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ConnectionDescription, Components::ConnectionDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ConnectionDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConnectionDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ConnectionDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConnectionDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ConnectionDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ConnectionDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ConnectionDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ConnectionDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConnectionDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ConnectionDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ConnectionDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ConnectionDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ConnectionDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConnectionDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

 void
operator<<= (CORBA::Any &any, Components::ReceptacleDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_ReceptacleDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::ReceptacleDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_ReceptacleDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::ReceptacleDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::ReceptacleDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_ReceptacleDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::ReceptacleDescription *const_holder = ACE_static_cast (
          const Components::ReceptacleDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::ReceptacleDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::ReceptacleDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_ReceptacleDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::ReceptacleDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ReceptacleDescription, Components::ReceptacleDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ReceptacleDescription, Components::ReceptacleDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ReceptacleDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ReceptacleDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ReceptacleDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ReceptacleDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ReceptacleDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ReceptacleDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ReceptacleDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ReceptacleDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ReceptacleDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ReceptacleDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ReceptacleDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ReceptacleDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ReceptacleDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::ReceptacleDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Receptacles_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Receptacles, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Receptacles::_duplicate (_tao_elem),
          Components::Receptacles::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Receptacles_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Receptacles, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Receptacles::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Receptacles_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Receptacles::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Receptacles
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Receptacles,
            1,
            _tao_elem,
            Components::Receptacles::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Receptacles::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Receptacles,Components::Receptacles_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Receptacles,Components::Receptacles_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::EventBase *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_EventBase, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::EventBase **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_EventBase, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::EventBase::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::EventBase *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_EventBase ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::EventBase *const_holder = ACE_static_cast (
          const Components::EventBase*,
          any.value ());
      value = ACE_const_cast (
          Components::EventBase*,
          const_holder);
      return 1;
    }
    else
    {
      Components::EventBase *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_EventBase,
            1,
            ACE_static_cast (void *, tmp),
            Components::EventBase::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::EventBase, Components::EventBase_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::EventBase, Components::EventBase_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EventConsumerBase_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_EventConsumerBase, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::EventConsumerBase::_duplicate (_tao_elem),
          Components::EventConsumerBase::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EventConsumerBase_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_EventConsumerBase, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::EventConsumerBase::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::EventConsumerBase_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::EventConsumerBase::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EventConsumerBase
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_EventConsumerBase,
            1,
            _tao_elem,
            Components::EventConsumerBase::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::EventConsumerBase::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::EventConsumerBase,Components::EventConsumerBase_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::EventConsumerBase,Components::EventConsumerBase_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::ConsumerDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_ConsumerDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::ConsumerDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_ConsumerDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::ConsumerDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::ConsumerDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_ConsumerDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::ConsumerDescription *const_holder = ACE_static_cast (
          const Components::ConsumerDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::ConsumerDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::ConsumerDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_ConsumerDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::ConsumerDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ConsumerDescription, Components::ConsumerDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ConsumerDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConsumerDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ConsumerDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConsumerDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ConsumerDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ConsumerDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ConsumerDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ConsumerDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConsumerDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ConsumerDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ConsumerDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ConsumerDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ConsumerDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConsumerDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

 void
operator<<= (CORBA::Any &any, Components::EmitterDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_EmitterDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::EmitterDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_EmitterDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::EmitterDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::EmitterDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_EmitterDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::EmitterDescription *const_holder = ACE_static_cast (
          const Components::EmitterDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::EmitterDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::EmitterDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_EmitterDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::EmitterDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::EmitterDescription, Components::EmitterDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::EmitterDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_EmitterDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::EmitterDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_EmitterDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::EmitterDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::EmitterDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::EmitterDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::EmitterDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EmitterDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::EmitterDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::EmitterDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::EmitterDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_EmitterDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::EmitterDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

 void
operator<<= (CORBA::Any &any, Components::SubscriberDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_SubscriberDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::SubscriberDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_SubscriberDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::SubscriberDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::SubscriberDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_SubscriberDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::SubscriberDescription *const_holder = ACE_static_cast (
          const Components::SubscriberDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::SubscriberDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::SubscriberDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_SubscriberDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::SubscriberDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::SubscriberDescription, Components::SubscriberDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::SubscriberDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_SubscriberDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::SubscriberDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_SubscriberDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::SubscriberDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::SubscriberDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::SubscriberDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::SubscriberDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_SubscriberDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::SubscriberDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::SubscriberDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::SubscriberDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_SubscriberDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::SubscriberDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

 void
operator<<= (CORBA::Any &any, Components::PublisherDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_PublisherDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::PublisherDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_PublisherDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::PublisherDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::PublisherDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_PublisherDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::PublisherDescription *const_holder = ACE_static_cast (
          const Components::PublisherDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::PublisherDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::PublisherDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_PublisherDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::PublisherDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::PublisherDescription, Components::PublisherDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::PublisherDescriptions &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PublisherDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::PublisherDescriptions *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PublisherDescriptions,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::PublisherDescriptions::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::PublisherDescriptions *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::PublisherDescriptions*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::PublisherDescriptions *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_PublisherDescriptions
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::PublisherDescriptions*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::PublisherDescriptions *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::PublisherDescriptions,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_PublisherDescriptions,
                1,
                ACE_static_cast (void *, tmp),
                Components::PublisherDescriptions::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Events_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Events, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Events::_duplicate (_tao_elem),
          Components::Events::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Events_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Events, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Events::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Events_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Events::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Events
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Events,
            1,
            _tao_elem,
            Components::Events::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Events::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Events,Components::Events_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Events,Components::Events_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::PrimaryKeyBase *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_PrimaryKeyBase, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::PrimaryKeyBase **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_PrimaryKeyBase, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::PrimaryKeyBase::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::PrimaryKeyBase *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_PrimaryKeyBase ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::PrimaryKeyBase *const_holder = ACE_static_cast (
          const Components::PrimaryKeyBase*,
          any.value ());
      value = ACE_const_cast (
          Components::PrimaryKeyBase*,
          const_holder);
      return 1;
    }
    else
    {
      Components::PrimaryKeyBase *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_PrimaryKeyBase,
            1,
            ACE_static_cast (void *, tmp),
            Components::PrimaryKeyBase::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::PrimaryKeyBase, Components::PrimaryKeyBase_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::PrimaryKeyBase, Components::PrimaryKeyBase_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMHome_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMHome, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::CCMHome::_duplicate (_tao_elem),
          Components::CCMHome::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMHome_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMHome, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::CCMHome::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMHome_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::CCMHome::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMHome
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_CCMHome,
            1,
            _tao_elem,
            Components::CCMHome::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::CCMHome::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::CCMHome,Components::CCMHome_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::CCMHome,Components::CCMHome_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CCMHomes &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMHomes,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMHomes *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMHomes,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CCMHomes::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMHomes *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CCMHomes*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CCMHomes *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMHomes
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::CCMHomes*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::CCMHomes *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CCMHomes,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CCMHomes,
                1,
                ACE_static_cast (void *, tmp),
                Components::CCMHomes::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::KeylessCCMHome_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_KeylessCCMHome, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::KeylessCCMHome::_duplicate (_tao_elem),
          Components::KeylessCCMHome::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::KeylessCCMHome_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_KeylessCCMHome, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::KeylessCCMHome::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::KeylessCCMHome_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::KeylessCCMHome::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_KeylessCCMHome
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_KeylessCCMHome,
            1,
            _tao_elem,
            Components::KeylessCCMHome::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::KeylessCCMHome::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::KeylessCCMHome,Components::KeylessCCMHome_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::KeylessCCMHome,Components::KeylessCCMHome_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeFinder_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeFinder, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::HomeFinder::_duplicate (_tao_elem),
          Components::HomeFinder::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeFinder_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeFinder, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::HomeFinder::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::HomeFinder_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::HomeFinder::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeFinder
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_HomeFinder,
            1,
            _tao_elem,
            Components::HomeFinder::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::HomeFinder::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::HomeFinder,Components::HomeFinder_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::HomeFinder,Components::HomeFinder_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Configurator_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Configurator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Configurator::_duplicate (_tao_elem),
          Components::Configurator::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Configurator_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_Configurator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Configurator::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Configurator_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Configurator::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Configurator
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_Configurator,
            1,
            _tao_elem,
            Components::Configurator::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Configurator::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Configurator,Components::Configurator_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Configurator,Components::Configurator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::ConfigValue *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_ConfigValue, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::ConfigValue **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_ConfigValue, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::ConfigValue::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::ConfigValue *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_ConfigValue ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::ConfigValue *const_holder = ACE_static_cast (
          const Components::ConfigValue*,
          any.value ());
      value = ACE_const_cast (
          Components::ConfigValue*,
          const_holder);
      return 1;
    }
    else
    {
      Components::ConfigValue *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_ConfigValue,
            1,
            ACE_static_cast (void *, tmp),
            Components::ConfigValue::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ConfigValue, Components::ConfigValue_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ConfigValue, Components::ConfigValue_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ConfigValues &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConfigValues,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ConfigValues *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ConfigValues,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ConfigValues::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ConfigValues *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ConfigValues*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ConfigValues *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ConfigValues
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::ConfigValues*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::ConfigValues *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ConfigValues,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ConfigValues,
                1,
                ACE_static_cast (void *, tmp),
                Components::ConfigValues::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::StandardConfigurator_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_StandardConfigurator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::StandardConfigurator::_duplicate (_tao_elem),
          Components::StandardConfigurator::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::StandardConfigurator_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_StandardConfigurator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::StandardConfigurator::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::StandardConfigurator_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::StandardConfigurator::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_StandardConfigurator
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_StandardConfigurator,
            1,
            _tao_elem,
            Components::StandardConfigurator::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::StandardConfigurator::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::StandardConfigurator,Components::StandardConfigurator_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::StandardConfigurator,Components::StandardConfigurator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeConfiguration_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeConfiguration, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::HomeConfiguration::_duplicate (_tao_elem),
          Components::HomeConfiguration::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeConfiguration_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_HomeConfiguration, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::HomeConfiguration::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::HomeConfiguration_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::HomeConfiguration::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeConfiguration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_HomeConfiguration,
            1,
            _tao_elem,
            Components::HomeConfiguration::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::HomeConfiguration::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::HomeConfiguration,Components::HomeConfiguration_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::HomeConfiguration,Components::HomeConfiguration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::ComponentPortDescription *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_ComponentPortDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::ComponentPortDescription **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_ComponentPortDescription, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::ComponentPortDescription::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::ComponentPortDescription *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_ComponentPortDescription ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::ComponentPortDescription *const_holder = ACE_static_cast (
          const Components::ComponentPortDescription*,
          any.value ());
      value = ACE_const_cast (
          Components::ComponentPortDescription*,
          const_holder);
      return 1;
    }
    else
    {
      Components::ComponentPortDescription *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_ComponentPortDescription,
            1,
            ACE_static_cast (void *, tmp),
            Components::ComponentPortDescription::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::ComponentPortDescription, Components::ComponentPortDescription_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::ComponentPortDescription, Components::ComponentPortDescription_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMObject_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMObject, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::CCMObject::_duplicate (_tao_elem),
          Components::CCMObject::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMObject_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMObject, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::CCMObject::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMObject_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::CCMObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMObject
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::_tc_CCMObject,
            1,
            _tao_elem,
            Components::CCMObject::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::CCMObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::CCMObject,Components::CCMObject_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::CCMObject,Components::CCMObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::Enumeration *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_Enumeration, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::Enumeration **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_Enumeration, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::Enumeration::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::Enumeration *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_Enumeration ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::Enumeration *const_holder = ACE_static_cast (
          const Components::Enumeration*,
          any.value ());
      value = ACE_const_cast (
          Components::Enumeration*,
          const_holder);
      return 1;
    }
    else
    {
      Components::Enumeration *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_Enumeration,
            1,
            ACE_static_cast (void *, tmp),
            Components::Enumeration::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::Enumeration, Components::Enumeration_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::Enumeration, Components::Enumeration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CCMObjectSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMObjectSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMObjectSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMObjectSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CCMObjectSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMObjectSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CCMObjectSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CCMObjectSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMObjectSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::CCMObjectSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::CCMObjectSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CCMObjectSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CCMObjectSeq,
                1,
                ACE_static_cast (void *, tmp),
                Components::CCMObjectSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

 void
operator<<= (CORBA::Any &any, Components::DefaultEnumeration *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_DefaultEnumeration, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::DefaultEnumeration **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_DefaultEnumeration, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::DefaultEnumeration::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::DefaultEnumeration *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_DefaultEnumeration ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::DefaultEnumeration *const_holder = ACE_static_cast (
          const Components::DefaultEnumeration*,
          any.value ());
      value = ACE_const_cast (
          Components::DefaultEnumeration*,
          const_holder);
      return 1;
    }
    else
    {
      Components::DefaultEnumeration *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_DefaultEnumeration,
            1,
            ACE_static_cast (void *, tmp),
            Components::DefaultEnumeration::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::DefaultEnumeration, Components::DefaultEnumeration_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::DefaultEnumeration, Components::DefaultEnumeration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::TranToken &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_TranToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::TranToken *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_TranToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::TranToken::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Transaction::TranToken *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::TranToken*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::TranToken *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_TranToken
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::Transaction::TranToken*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::Transaction::TranToken *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::TranToken,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_TranToken,
                1,
                ACE_static_cast (void *, tmp),
                Components::Transaction::TranToken::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::NoTransaction &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NoTransaction,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::NoTransaction *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NoTransaction,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::NoTransaction::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::NoTransaction *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::NoTransaction*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::NoTransaction *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_NoTransaction
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::NoTransaction *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::NoTransaction *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::NoTransaction,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/NoTransaction:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_NoTransaction,
                1,
                tmp,
                Components::Transaction::NoTransaction::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::NotSupported &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NotSupported,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::NotSupported *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NotSupported,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::NotSupported::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::NotSupported *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::NotSupported*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::NotSupported *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_NotSupported
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::NotSupported *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::NotSupported *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::NotSupported,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/NotSupported:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_NotSupported,
                1,
                tmp,
                Components::Transaction::NotSupported::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::SystemError &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_SystemError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::SystemError *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_SystemError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::SystemError::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::SystemError *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::SystemError*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::SystemError *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_SystemError
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::SystemError *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::SystemError *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::SystemError,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/SystemError:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_SystemError,
                1,
                tmp,
                Components::Transaction::SystemError::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::RollbackError &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_RollbackError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::RollbackError *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_RollbackError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::RollbackError::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::RollbackError *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::RollbackError*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::RollbackError *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_RollbackError
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::RollbackError *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::RollbackError *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::RollbackError,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/RollbackError:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_RollbackError,
                1,
                tmp,
                Components::Transaction::RollbackError::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicMixed &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicMixed,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::HeuristicMixed *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicMixed,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::HeuristicMixed::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::HeuristicMixed *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::HeuristicMixed*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicMixed *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_HeuristicMixed
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::HeuristicMixed *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::HeuristicMixed *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::HeuristicMixed,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/HeuristicMixed:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_HeuristicMixed,
                1,
                tmp,
                Components::Transaction::HeuristicMixed::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicRollback &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicRollback,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::HeuristicRollback *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicRollback,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::HeuristicRollback::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::HeuristicRollback *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::HeuristicRollback*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicRollback *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_HeuristicRollback
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::HeuristicRollback *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::HeuristicRollback *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::HeuristicRollback,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/HeuristicRollback:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_HeuristicRollback,
                1,
                tmp,
                Components::Transaction::HeuristicRollback::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::Security &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_Security,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::Security *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_Security,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::Security::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::Security *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::Security*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::Security *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_Security
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::Security *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::Security *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::Security,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/Security:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_Security,
                1,
                tmp,
                Components::Transaction::Security::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::InvalidToken &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_InvalidToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::InvalidToken *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_InvalidToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::InvalidToken::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::InvalidToken *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::InvalidToken*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::InvalidToken *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_InvalidToken
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::InvalidToken *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::InvalidToken *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::InvalidToken,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Transaction/InvalidToken:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_InvalidToken,
                1,
                tmp,
                Components::Transaction::InvalidToken::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Components::Transaction::Status _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Components::Transaction::_tc_Status,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Components::Transaction::Status &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::Transaction::_tc_Status ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::UserTransaction_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::Transaction::_tc_UserTransaction, 
      1,
      Components::Transaction::UserTransaction::_duplicate (_tao_elem),
      Components::Transaction::UserTransaction::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::UserTransaction_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::Transaction::_tc_UserTransaction, 
      1,
      *_tao_elem,
      Components::Transaction::UserTransaction::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Transaction::UserTransaction_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Transaction::UserTransaction::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_UserTransaction
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::Transaction::UserTransaction_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Transaction::UserTransaction::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Transaction::UserTransaction,Components::Transaction::UserTransaction_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Transaction::UserTransaction,Components::Transaction::UserTransaction_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMContext_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_CCMContext, 
      1,
      Components::CCMContext::_duplicate (_tao_elem),
      Components::CCMContext::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMContext_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_CCMContext, 
      1,
      *_tao_elem,
      Components::CCMContext::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCMContext_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::CCMContext::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMContext
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::CCMContext_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::CCMContext::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::CCMContext,Components::CCMContext_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::CCMContext,Components::CCMContext_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, Components::CCMExceptionReason _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Components::_tc_CCMExceptionReason,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Components::CCMExceptionReason &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_CCMExceptionReason ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::CCMException &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMException,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCMException *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_CCMException,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::CCMException::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::CCMException *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::CCMException*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::CCMException *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCMException
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::CCMException *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::CCMException *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::CCMException,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/CCMException:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_CCMException,
                1,
                tmp,
                Components::CCMException::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EnterpriseComponent_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_EnterpriseComponent, 
      1,
      Components::EnterpriseComponent::_duplicate (_tao_elem),
      Components::EnterpriseComponent::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EnterpriseComponent_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_EnterpriseComponent, 
      1,
      *_tao_elem,
      Components::EnterpriseComponent::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::EnterpriseComponent_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::EnterpriseComponent::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EnterpriseComponent
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::EnterpriseComponent_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::EnterpriseComponent::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::EnterpriseComponent,Components::EnterpriseComponent_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::EnterpriseComponent,Components::EnterpriseComponent_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::SessionContext_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_SessionContext, 
      1,
      Components::SessionContext::_duplicate (_tao_elem),
      Components::SessionContext::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::SessionContext_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_SessionContext, 
      1,
      *_tao_elem,
      Components::SessionContext::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::SessionContext_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::SessionContext::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_SessionContext
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::SessionContext_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::SessionContext::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::SessionContext,Components::SessionContext_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::SessionContext,Components::SessionContext_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::SessionComponent_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_SessionComponent, 
      1,
      Components::SessionComponent::_duplicate (_tao_elem),
      Components::SessionComponent::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::SessionComponent_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_SessionComponent, 
      1,
      *_tao_elem,
      Components::SessionComponent::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::SessionComponent_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::SessionComponent::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_SessionComponent
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::SessionComponent_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::SessionComponent::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::SessionComponent,Components::SessionComponent_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::SessionComponent,Components::SessionComponent_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::SessionSynchronization_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_SessionSynchronization, 
      1,
      Components::SessionSynchronization::_duplicate (_tao_elem),
      Components::SessionSynchronization::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::SessionSynchronization_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_SessionSynchronization, 
      1,
      *_tao_elem,
      Components::SessionSynchronization::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::SessionSynchronization_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::SessionSynchronization::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_SessionSynchronization
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::SessionSynchronization_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::SessionSynchronization::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::SessionSynchronization,Components::SessionSynchronization_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::SessionSynchronization,Components::SessionSynchronization_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EntityContext_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_EntityContext, 
      1,
      Components::EntityContext::_duplicate (_tao_elem),
      Components::EntityContext::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EntityContext_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_EntityContext, 
      1,
      *_tao_elem,
      Components::EntityContext::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::EntityContext_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::EntityContext::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EntityContext
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::EntityContext_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::EntityContext::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::EntityContext,Components::EntityContext_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::EntityContext,Components::EntityContext_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EntityComponent_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_EntityComponent, 
      1,
      Components::EntityComponent::_duplicate (_tao_elem),
      Components::EntityComponent::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::EntityComponent_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_EntityComponent, 
      1,
      *_tao_elem,
      Components::EntityComponent::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::EntityComponent_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::EntityComponent::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_EntityComponent
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::EntityComponent_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::EntityComponent::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::EntityComponent,Components::EntityComponent_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::EntityComponent,Components::EntityComponent_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, Components::BadComponentReferenceReason _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Components::_tc_BadComponentReferenceReason,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Components::BadComponentReferenceReason &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_BadComponentReferenceReason ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::IdData &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_IdData,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::IdData *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_IdData,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::IdData::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::IdData *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::IdData*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::IdData *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_IdData
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::IdData*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::IdData *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::IdData,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_IdData,
                1,
                ACE_static_cast (void *, tmp),
                Components::IdData::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::BadComponentReference &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_BadComponentReference,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::BadComponentReference *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_BadComponentReference,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::BadComponentReference::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::BadComponentReference *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::BadComponentReference*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::BadComponentReference *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_BadComponentReference
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::BadComponentReference *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::BadComponentReference *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::BadComponentReference,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/BadComponentReference:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_BadComponentReference,
                1,
                tmp,
                Components::BadComponentReference::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::PolicyMismatch &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PolicyMismatch,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::PolicyMismatch *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PolicyMismatch,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::PolicyMismatch::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::PolicyMismatch *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::PolicyMismatch*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::PolicyMismatch *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_PolicyMismatch
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::PolicyMismatch *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::PolicyMismatch *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::PolicyMismatch,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/PolicyMismatch:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_PolicyMismatch,
                1,
                tmp,
                Components::PolicyMismatch::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::PersistenceNotAvailable &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PersistenceNotAvailable,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::PersistenceNotAvailable *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_PersistenceNotAvailable,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::PersistenceNotAvailable::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::PersistenceNotAvailable *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::PersistenceNotAvailable*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::PersistenceNotAvailable *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_PersistenceNotAvailable
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::PersistenceNotAvailable *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::PersistenceNotAvailable *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::PersistenceNotAvailable,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/PersistenceNotAvailable:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_PersistenceNotAvailable,
                1,
                tmp,
                Components::PersistenceNotAvailable::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::UnknownActualHome &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_UnknownActualHome,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::UnknownActualHome *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_UnknownActualHome,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::UnknownActualHome::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::UnknownActualHome *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::UnknownActualHome*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::UnknownActualHome *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_UnknownActualHome
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::UnknownActualHome *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::UnknownActualHome *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::UnknownActualHome,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/UnknownActualHome:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_UnknownActualHome,
                1,
                tmp,
                Components::UnknownActualHome::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::ProxyHomeNotSupported &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ProxyHomeNotSupported,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::ProxyHomeNotSupported *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_ProxyHomeNotSupported,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::ProxyHomeNotSupported::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::ProxyHomeNotSupported *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::ProxyHomeNotSupported*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::ProxyHomeNotSupported *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ProxyHomeNotSupported
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::ProxyHomeNotSupported *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::ProxyHomeNotSupported *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::ProxyHomeNotSupported,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/ProxyHomeNotSupported:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_ProxyHomeNotSupported,
                1,
                tmp,
                Components::ProxyHomeNotSupported::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::InvalidStateIdData &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidStateIdData,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::InvalidStateIdData *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_InvalidStateIdData,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::InvalidStateIdData::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::InvalidStateIdData *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::InvalidStateIdData*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::InvalidStateIdData *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_InvalidStateIdData
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::InvalidStateIdData *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::InvalidStateIdData *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::InvalidStateIdData,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/InvalidStateIdData:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_InvalidStateIdData,
                1,
                tmp,
                Components::InvalidStateIdData::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeRegistration_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_HomeRegistration, 
      1,
      Components::HomeRegistration::_duplicate (_tao_elem),
      Components::HomeRegistration::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeRegistration_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_HomeRegistration, 
      1,
      *_tao_elem,
      Components::HomeRegistration::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::HomeRegistration_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::HomeRegistration::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeRegistration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::HomeRegistration_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::HomeRegistration::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::HomeRegistration,Components::HomeRegistration_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::HomeRegistration,Components::HomeRegistration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCM2Context_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_CCM2Context, 
      1,
      Components::CCM2Context::_duplicate (_tao_elem),
      Components::CCM2Context::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::CCM2Context_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_CCM2Context, 
      1,
      *_tao_elem,
      Components::CCM2Context::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::CCM2Context_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::CCM2Context::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_CCM2Context
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::CCM2Context_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::CCM2Context::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::CCM2Context,Components::CCM2Context_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::CCM2Context,Components::CCM2Context_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::ProxyHomeRegistration_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_ProxyHomeRegistration, 
      1,
      Components::ProxyHomeRegistration::_duplicate (_tao_elem),
      Components::ProxyHomeRegistration::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::ProxyHomeRegistration_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_ProxyHomeRegistration, 
      1,
      *_tao_elem,
      Components::ProxyHomeRegistration::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ProxyHomeRegistration_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::ProxyHomeRegistration::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ProxyHomeRegistration
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::ProxyHomeRegistration_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::ProxyHomeRegistration::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::ProxyHomeRegistration,Components::ProxyHomeRegistration_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::ProxyHomeRegistration,Components::ProxyHomeRegistration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Session2Context_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_Session2Context, 
      1,
      Components::Session2Context::_duplicate (_tao_elem),
      Components::Session2Context::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Session2Context_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_Session2Context, 
      1,
      *_tao_elem,
      Components::Session2Context::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Session2Context_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Session2Context::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Session2Context
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::Session2Context_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Session2Context::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Session2Context,Components::Session2Context_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Session2Context,Components::Session2Context_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::StateIdValue *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_StateIdValue, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::StateIdValue **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_StateIdValue, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::StateIdValue::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::StateIdValue *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_StateIdValue ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::StateIdValue *const_holder = ACE_static_cast (
          const Components::StateIdValue*,
          any.value ());
      value = ACE_const_cast (
          Components::StateIdValue*,
          const_holder);
      return 1;
    }
    else
    {
      Components::StateIdValue *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_StateIdValue,
            1,
            ACE_static_cast (void *, tmp),
            Components::StateIdValue::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::StateIdValue, Components::StateIdValue_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::StateIdValue, Components::StateIdValue_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::StateIdFactory_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_StateIdFactory, 
      1,
      Components::StateIdFactory::_duplicate (_tao_elem),
      Components::StateIdFactory::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::StateIdFactory_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_StateIdFactory, 
      1,
      *_tao_elem,
      Components::StateIdFactory::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::StateIdFactory_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::StateIdFactory::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_StateIdFactory
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::StateIdFactory_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::StateIdFactory::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::StateIdFactory,Components::StateIdFactory_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::StateIdFactory,Components::StateIdFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::PersistentIdValue *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_PersistentIdValue, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::PersistentIdValue **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_PersistentIdValue, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::PersistentIdValue::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::PersistentIdValue *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_PersistentIdValue ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::PersistentIdValue *const_holder = ACE_static_cast (
          const Components::PersistentIdValue*,
          any.value ());
      value = ACE_const_cast (
          Components::PersistentIdValue*,
          const_holder);
      return 1;
    }
    else
    {
      Components::PersistentIdValue *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_PersistentIdValue,
            1,
            ACE_static_cast (void *, tmp),
            Components::PersistentIdValue::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::PersistentIdValue, Components::PersistentIdValue_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::PersistentIdValue, Components::PersistentIdValue_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

 void
operator<<= (CORBA::Any &any, Components::SegmentDescr *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        Components::_tc_SegmentDescr, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

 void
operator<<= (CORBA::Any &any, Components::SegmentDescr **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        Components::_tc_SegmentDescr, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        Components::SegmentDescr::_tao_any_destructor);
  }
}

 CORBA::Boolean
operator>>= (const CORBA::Any &any, Components::SegmentDescr *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::_tc_SegmentDescr ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const Components::SegmentDescr *const_holder = ACE_static_cast (
          const Components::SegmentDescr*,
          any.value ());
      value = ACE_const_cast (
          Components::SegmentDescr*,
          const_holder);
      return 1;
    }
    else
    {
      Components::SegmentDescr *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            Components::_tc_SegmentDescr,
            1,
            ACE_static_cast (void *, tmp),
            Components::SegmentDescr::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<Components::SegmentDescr, Components::SegmentDescr_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<Components::SegmentDescr, Components::SegmentDescr_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::SegmentDescrSeq &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_SegmentDescrSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::SegmentDescrSeq *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::_tc_SegmentDescrSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::SegmentDescrSeq::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::SegmentDescrSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::SegmentDescrSeq*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::SegmentDescrSeq *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_SegmentDescrSeq
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::SegmentDescrSeq*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::SegmentDescrSeq *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::SegmentDescrSeq,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::_tc_SegmentDescrSeq,
                1,
                ACE_static_cast (void *, tmp),
                Components::SegmentDescrSeq::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::ComponentId_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_ComponentId, 
      1,
      Components::ComponentId::_duplicate (_tao_elem),
      Components::ComponentId::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::ComponentId_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_ComponentId, 
      1,
      *_tao_elem,
      Components::ComponentId::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::ComponentId_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::ComponentId::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_ComponentId
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::ComponentId_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::ComponentId::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::ComponentId,Components::ComponentId_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::ComponentId,Components::ComponentId_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Entity2Context_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_Entity2Context, 
      1,
      Components::Entity2Context::_duplicate (_tao_elem),
      Components::Entity2Context::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Entity2Context_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_Entity2Context, 
      1,
      *_tao_elem,
      Components::Entity2Context::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Entity2Context_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Entity2Context::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_Entity2Context
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::Entity2Context_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Entity2Context::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Entity2Context,Components::Entity2Context_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Entity2Context,Components::Entity2Context_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeExecutorBase_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_HomeExecutorBase, 
      1,
      Components::HomeExecutorBase::_duplicate (_tao_elem),
      Components::HomeExecutorBase::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::HomeExecutorBase_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::_tc_HomeExecutorBase, 
      1,
      *_tao_elem,
      Components::HomeExecutorBase::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::HomeExecutorBase_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::HomeExecutorBase::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::_tc_HomeExecutorBase
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::HomeExecutorBase_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
    
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::HomeExecutorBase::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::HomeExecutorBase,Components::HomeExecutorBase_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::HomeExecutorBase,Components::HomeExecutorBase_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, Components::Deployment::AssemblyState _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Components::Deployment::_tc_AssemblyState,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Components::Deployment::AssemblyState &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::Deployment::_tc_AssemblyState ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Deployment::UnknownImplId &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_UnknownImplId,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::UnknownImplId *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_UnknownImplId,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Deployment::UnknownImplId::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Deployment::UnknownImplId *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Deployment::UnknownImplId*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Deployment::UnknownImplId *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_UnknownImplId
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Deployment::UnknownImplId *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Deployment::UnknownImplId *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Deployment::UnknownImplId,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Deployment/UnknownImplId:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Deployment::_tc_UnknownImplId,
                1,
                tmp,
                Components::Deployment::UnknownImplId::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Deployment::InvalidLocation &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_InvalidLocation,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::InvalidLocation *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_InvalidLocation,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Deployment::InvalidLocation::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Deployment::InvalidLocation *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Deployment::InvalidLocation*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Deployment::InvalidLocation *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_InvalidLocation
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Deployment::InvalidLocation *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Deployment::InvalidLocation *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Deployment::InvalidLocation,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Deployment/InvalidLocation:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Deployment::_tc_InvalidLocation,
                1,
                tmp,
                Components::Deployment::InvalidLocation::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Deployment::InstallationFailure &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_InstallationFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::InstallationFailure *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_InstallationFailure,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Deployment::InstallationFailure::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Deployment::InstallationFailure *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Deployment::InstallationFailure*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Deployment::InstallationFailure *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_InstallationFailure
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Deployment::InstallationFailure *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Deployment::InstallationFailure *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Deployment::InstallationFailure,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Deployment/InstallationFailure:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Deployment::_tc_InstallationFailure,
                1,
                tmp,
                Components::Deployment::InstallationFailure::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Deployment::InvalidAssembly &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_InvalidAssembly,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::InvalidAssembly *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_InvalidAssembly,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Deployment::InvalidAssembly::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Deployment::InvalidAssembly *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Deployment::InvalidAssembly*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Deployment::InvalidAssembly *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_InvalidAssembly
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Deployment::InvalidAssembly *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Deployment::InvalidAssembly *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Deployment::InvalidAssembly,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Deployment/InvalidAssembly:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Deployment::_tc_InvalidAssembly,
                1,
                tmp,
                Components::Deployment::InvalidAssembly::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ComponentInstallation_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ComponentInstallation, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Deployment::ComponentInstallation::_duplicate (_tao_elem),
          Components::Deployment::ComponentInstallation::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ComponentInstallation_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ComponentInstallation, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Deployment::ComponentInstallation::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::ComponentInstallation_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Deployment::ComponentInstallation::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_ComponentInstallation
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::Deployment::_tc_ComponentInstallation,
            1,
            _tao_elem,
            Components::Deployment::ComponentInstallation::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Deployment::ComponentInstallation::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Deployment::ComponentInstallation,Components::Deployment::ComponentInstallation_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Deployment::ComponentInstallation,Components::Deployment::ComponentInstallation_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::Assembly_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_Assembly, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Deployment::Assembly::_duplicate (_tao_elem),
          Components::Deployment::Assembly::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::Assembly_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_Assembly, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Deployment::Assembly::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::Assembly_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Deployment::Assembly::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_Assembly
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::Deployment::_tc_Assembly,
            1,
            _tao_elem,
            Components::Deployment::Assembly::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Deployment::Assembly::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Deployment::Assembly,Components::Deployment::Assembly_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Deployment::Assembly,Components::Deployment::Assembly_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::AssemblyFactory_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_AssemblyFactory, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Deployment::AssemblyFactory::_duplicate (_tao_elem),
          Components::Deployment::AssemblyFactory::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::AssemblyFactory_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_AssemblyFactory, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Deployment::AssemblyFactory::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::AssemblyFactory_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Deployment::AssemblyFactory::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_AssemblyFactory
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::Deployment::_tc_AssemblyFactory,
            1,
            _tao_elem,
            Components::Deployment::AssemblyFactory::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Deployment::AssemblyFactory::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Deployment::AssemblyFactory,Components::Deployment::AssemblyFactory_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Deployment::AssemblyFactory,Components::Deployment::AssemblyFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Deployment::ComponentServers &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ComponentServers,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ComponentServers *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ComponentServers,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Deployment::ComponentServers::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::ComponentServers *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Deployment::ComponentServers*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Deployment::ComponentServers *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_ComponentServers
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::Deployment::ComponentServers*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::Deployment::ComponentServers *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Deployment::ComponentServers,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Deployment::_tc_ComponentServers,
                1,
                ACE_static_cast (void *, tmp),
                Components::Deployment::ComponentServers::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ServerActivator_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ServerActivator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Deployment::ServerActivator::_duplicate (_tao_elem),
          Components::Deployment::ServerActivator::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ServerActivator_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ServerActivator, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Deployment::ServerActivator::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::ServerActivator_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Deployment::ServerActivator::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_ServerActivator
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::Deployment::_tc_ServerActivator,
            1,
            _tao_elem,
            Components::Deployment::ServerActivator::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Deployment::ServerActivator::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Deployment::ServerActivator,Components::Deployment::ServerActivator_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Deployment::ServerActivator,Components::Deployment::ServerActivator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:61

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Deployment::Containers &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_Containers,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::Containers *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_Containers,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Deployment::Containers::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::Containers *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Deployment::Containers*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Deployment::Containers *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_Containers
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::Deployment::Containers*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::Deployment::Containers *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Deployment::Containers,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Deployment::_tc_Containers,
                1,
                ACE_static_cast (void *, tmp),
                Components::Deployment::Containers::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ComponentServer_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ComponentServer, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Deployment::ComponentServer::_duplicate (_tao_elem),
          Components::Deployment::ComponentServer::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ComponentServer_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ComponentServer, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Deployment::ComponentServer::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::ComponentServer_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Deployment::ComponentServer::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_ComponentServer
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::Deployment::_tc_ComponentServer,
            1,
            _tao_elem,
            Components::Deployment::ComponentServer::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Deployment::ComponentServer::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Deployment::ComponentServer,Components::Deployment::ComponentServer_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Deployment::ComponentServer,Components::Deployment::ComponentServer_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:60

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Deployment::ImplEntryPointNotFound &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ImplEntryPointNotFound,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::ImplEntryPointNotFound *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_ImplEntryPointNotFound,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Deployment::ImplEntryPointNotFound::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Deployment::ImplEntryPointNotFound *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Deployment::ImplEntryPointNotFound*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Deployment::ImplEntryPointNotFound *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_ImplEntryPointNotFound
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Deployment::ImplEntryPointNotFound *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Deployment::ImplEntryPointNotFound *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Deployment::ImplEntryPointNotFound,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:omg.org/Components/Deployment/ImplEntryPointNotFound:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Deployment::_tc_ImplEntryPointNotFound,
                1,
                tmp,
                Components::Deployment::ImplEntryPointNotFound::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}


// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:60

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::Container_ptr _tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_Container, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Components::Deployment::Container::_duplicate (_tao_elem),
          Components::Deployment::Container::_tao_any_destructor
        );
    }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Components::Deployment::Container_ptr *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Deployment::_tc_Container, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          *_tao_elem,
          Components::Deployment::Container::_tao_any_destructor
        );
    }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Deployment::Container_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Deployment::Container::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Deployment::_tc_Container
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    
    if (stream >> _tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Components::Deployment::_tc_Container,
            1,
            _tao_elem,
            Components::Deployment::Container::_tao_any_destructor
          );
        
        return 1;
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Deployment::Container::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Deployment::Container,Components::Deployment::Container_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<Components::Deployment::Container,Components::Deployment::Container_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::NameList &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::NameList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::Cookie * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::Cookie * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::Cookie *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::Cookie*, _tao_valuetype),
    (ptr_arith_t) &Components::Cookie::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::Cookie *&_tao_valuetype)
{
  return Components::Cookie::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::Cookie::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_cookieValue)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::Cookie::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_cookieValue)
  )
    return 1;
  else
    return 0;
  
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::PortDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::PortDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::PortDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::PortDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::PortDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::PortDescription *&_tao_valuetype)
{
  return Components::PortDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::PortDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_Name.in ()) &&
    (strm << _pd_type_id.in ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::PortDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_Name.out ()) &&
    (strm >> _pd_type_id.out ())
  )
    return 1;
  else
    return 0;
  
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::FacetDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::FacetDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::FacetDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::FacetDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::FacetDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::FacetDescription *&_tao_valuetype)
{
  return Components::FacetDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::FacetDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (!this->_tao_marshal__Components_PortDescription (strm)) return 0;
  if (
    (strm << _pd_facet_ref.in ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::FacetDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (!this->_tao_unmarshal__Components_PortDescription (strm)) return 0;
  if (
    (strm >> _pd_facet_ref.out ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::FacetDescriptions &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::FacetDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Navigation_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Navigation_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Navigation::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::ConnectionDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::ConnectionDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::ConnectionDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::ConnectionDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::ConnectionDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::ConnectionDescription *&_tao_valuetype)
{
  return Components::ConnectionDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::ConnectionDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_ck.in ()) &&
    (strm << _pd_objref.in ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::ConnectionDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_ck.out ()) &&
    (strm >> _pd_objref.out ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ConnectionDescriptions &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ConnectionDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::ReceptacleDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::ReceptacleDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::ReceptacleDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::ReceptacleDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::ReceptacleDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::ReceptacleDescription *&_tao_valuetype)
{
  return Components::ReceptacleDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::ReceptacleDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (!this->_tao_marshal__Components_PortDescription (strm)) return 0;
  if (
    (strm << CORBA::Any::from_boolean (_pd_is_multiple)) &&
    (strm << _pd_connections)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::ReceptacleDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (!this->_tao_unmarshal__Components_PortDescription (strm)) return 0;
  if (
    (strm >> CORBA::Any::to_boolean (_pd_is_multiple)) &&
    (strm >> _pd_connections)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ReceptacleDescriptions &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ReceptacleDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Receptacles_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Receptacles_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Receptacles::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::EventBase * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::EventBase * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::EventBase *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::EventBase*, _tao_valuetype),
    (ptr_arith_t) &Components::EventBase::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::EventBase *&_tao_valuetype)
{
  return Components::EventBase::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::EventConsumerBase_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::EventConsumerBase_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::EventConsumerBase::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::ConsumerDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::ConsumerDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::ConsumerDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::ConsumerDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::ConsumerDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::ConsumerDescription *&_tao_valuetype)
{
  return Components::ConsumerDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::ConsumerDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (!this->_tao_marshal__Components_PortDescription (strm)) return 0;
  if (
    (strm << _pd_consumer.in ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::ConsumerDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (!this->_tao_unmarshal__Components_PortDescription (strm)) return 0;
  if (
    (strm >> _pd_consumer.out ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ConsumerDescriptions &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ConsumerDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::EmitterDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::EmitterDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::EmitterDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::EmitterDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::EmitterDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::EmitterDescription *&_tao_valuetype)
{
  return Components::EmitterDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::EmitterDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (!this->_tao_marshal__Components_PortDescription (strm)) return 0;
  if (
    (strm << _pd_consumer.in ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::EmitterDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (!this->_tao_unmarshal__Components_PortDescription (strm)) return 0;
  if (
    (strm >> _pd_consumer.out ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::EmitterDescriptions &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::EmitterDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::SubscriberDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::SubscriberDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::SubscriberDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::SubscriberDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::SubscriberDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::SubscriberDescription *&_tao_valuetype)
{
  return Components::SubscriberDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::SubscriberDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (!this->_tao_marshal__Components_PortDescription (strm)) return 0;
  if (
    (strm << _pd_ck.in ()) &&
    (strm << _pd_consumer.in ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::SubscriberDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (!this->_tao_unmarshal__Components_PortDescription (strm)) return 0;
  if (
    (strm >> _pd_ck.out ()) &&
    (strm >> _pd_consumer.out ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::SubscriberDescriptions &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::SubscriberDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::PublisherDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::PublisherDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::PublisherDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::PublisherDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::PublisherDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::PublisherDescription *&_tao_valuetype)
{
  return Components::PublisherDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::PublisherDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (!this->_tao_marshal__Components_PortDescription (strm)) return 0;
  if (
    (strm << _pd_consumer)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::PublisherDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (!this->_tao_unmarshal__Components_PortDescription (strm)) return 0;
  if (
    (strm >> _pd_consumer)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::PublisherDescriptions &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::PublisherDescriptions &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Events_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Events_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Events::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::PrimaryKeyBase * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::PrimaryKeyBase * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::PrimaryKeyBase *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::PrimaryKeyBase*, _tao_valuetype),
    (ptr_arith_t) &Components::PrimaryKeyBase::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::PrimaryKeyBase *&_tao_valuetype)
{
  return Components::PrimaryKeyBase::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMHome_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMHome_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::CCMHome::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMHomes &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMHomes &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::KeylessCCMHome_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::KeylessCCMHome_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::KeylessCCMHome::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::HomeFinder_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::HomeFinder_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::HomeFinder::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Configurator_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Configurator_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Configurator::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::ConfigValue * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::ConfigValue * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::ConfigValue *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::ConfigValue*, _tao_valuetype),
    (ptr_arith_t) &Components::ConfigValue::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::ConfigValue *&_tao_valuetype)
{
  return Components::ConfigValue::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::ConfigValue::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_name.in ()) &&
    (strm << _pd_value)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::ConfigValue::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_name.out ()) &&
    (strm >> _pd_value)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::ConfigValues &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::ConfigValues &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::StandardConfigurator_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::StandardConfigurator_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::StandardConfigurator::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::HomeConfiguration_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::HomeConfiguration_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::HomeConfiguration::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::ComponentPortDescription * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::ComponentPortDescription * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::ComponentPortDescription *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::ComponentPortDescription*, _tao_valuetype),
    (ptr_arith_t) &Components::ComponentPortDescription::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::ComponentPortDescription *&_tao_valuetype)
{
  return Components::ComponentPortDescription::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::ComponentPortDescription::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_facets) &&
    (strm << _pd_receptacles) &&
    (strm << _pd_consumers) &&
    (strm << _pd_emitters) &&
    (strm << _pd_publishers)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::ComponentPortDescription::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_facets) &&
    (strm >> _pd_receptacles) &&
    (strm >> _pd_consumers) &&
    (strm >> _pd_emitters) &&
    (strm >> _pd_publishers)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMObject_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMObject_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::CCMObject::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::Enumeration * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::Enumeration * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::Enumeration *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::Enumeration*, _tao_valuetype),
    (ptr_arith_t) &Components::Enumeration::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::Enumeration *&_tao_valuetype)
{
  return Components::Enumeration::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::CCMObjectSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::CCMObjectSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::DefaultEnumeration * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::DefaultEnumeration * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::DefaultEnumeration *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::DefaultEnumeration*, _tao_valuetype),
    (ptr_arith_t) &Components::DefaultEnumeration::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::DefaultEnumeration *&_tao_valuetype)
{
  return Components::DefaultEnumeration::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::DefaultEnumeration::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_objects)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::DefaultEnumeration::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_objects)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::TranToken &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (Components::Transaction::TranToken *)&_tao_sequence);
      if (oseq->mb ())
        return strm.write_octet_array_mb (oseq->mb ());
      else
        return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Transaction::TranToken &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    if (ACE_BIT_DISABLED (strm.start ()->flags (),
    ACE_Message_Block::DONT_DELETE))
    {
      TAO_ORB_Core* orb_core = strm.orb_core ();
      if (orb_core != 0 &&
      strm.orb_core ()->resource_factory ()->
      input_cdr_allocator_type_locked () == 1)
      {
        TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
          ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
        oseq->replace (_tao_seq_len, strm.start ());
        oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
        strm.skip_bytes (_tao_seq_len);
        return 1;
      }
    }
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::IdData &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (Components::IdData *)&_tao_sequence);
      if (oseq->mb ())
        return strm.write_octet_array_mb (oseq->mb ());
      else
        return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::IdData &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    if (ACE_BIT_DISABLED (strm.start ()->flags (),
    ACE_Message_Block::DONT_DELETE))
    {
      TAO_ORB_Core* orb_core = strm.orb_core ();
      if (orb_core != 0 &&
      strm.orb_core ()->resource_factory ()->
      input_cdr_allocator_type_locked () == 1)
      {
        TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
          ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
        oseq->replace (_tao_seq_len, strm.start ());
        oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
        strm.skip_bytes (_tao_seq_len);
        return 1;
      }
    }
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::StateIdValue * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::StateIdValue * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::StateIdValue *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::StateIdValue*, _tao_valuetype),
    (ptr_arith_t) &Components::StateIdValue::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::StateIdValue *&_tao_valuetype)
{
  return Components::StateIdValue::_tao_unmarshal (strm, _tao_valuetype);
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::PersistentIdValue * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::PersistentIdValue * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::PersistentIdValue *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::PersistentIdValue*, _tao_valuetype),
    (ptr_arith_t) &Components::PersistentIdValue::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::PersistentIdValue *&_tao_valuetype)
{
  return Components::PersistentIdValue::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::PersistentIdValue::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_pid.in ())
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::PersistentIdValue::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_pid.out ())
  )
    return 1;
  else
    return 0;
  
}

//@@ Boris: begin experimental
void
CORBA::add_ref (Components::SegmentDescr * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (Components::SegmentDescr * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const Components::SegmentDescr *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (Components::SegmentDescr*, _tao_valuetype),
    (ptr_arith_t) &Components::SegmentDescr::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, Components::SegmentDescr *&_tao_valuetype)
{
  return Components::SegmentDescr::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean
OBV_Components::SegmentDescr::_tao_marshal_state (TAO_OutputCDR &strm)
{
  if (
    (strm << _pd_sid.in ()) &&
    (strm << _pd_seg)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean
OBV_Components::SegmentDescr::_tao_unmarshal_state (TAO_InputCDR &strm)
{
  if (
    (strm >> _pd_sid.out ()) &&
    (strm >> _pd_seg)
  )
    return 1;
  else
    return 0;
  
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::SegmentDescrSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::SegmentDescrSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::ComponentInstallation_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::ComponentInstallation_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Deployment::ComponentInstallation::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::Assembly_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::Assembly_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Deployment::Assembly::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::AssemblyFactory_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::AssemblyFactory_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Deployment::AssemblyFactory::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::ComponentServers &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::ComponentServers &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::ServerActivator_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::ServerActivator_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Deployment::ServerActivator::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::Containers &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::Containers &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 1159.)
    if (_tao_seq_len > strm.length())
      return 0;
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::ComponentServer_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::ComponentServer_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Deployment::ComponentServer::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Deployment::Container_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Deployment::Container_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      Components::Deployment::Container::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}
