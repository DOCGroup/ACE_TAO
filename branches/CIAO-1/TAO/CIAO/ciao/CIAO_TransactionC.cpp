// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:320

#include "CIAO_TransactionC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "CIAO_TransactionC.i"
#endif /* !defined INLINE */

#if !defined (_COMPONENTS_TRANSACTION_TRANTOKEN_CS_)
#define _COMPONENTS_TRANSACTION_TRANTOKEN_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// Components::Transaction::TranToken
// *************************************************************

Components::Transaction::TranToken::TranToken (void)
{}

Components::Transaction::TranToken::TranToken (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

Components::Transaction::TranToken::TranToken (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Octet *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

Components::Transaction::TranToken::TranToken (const TranToken &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

Components::Transaction::TranToken::~TranToken (void) // dtor
{}

void Components::Transaction::TranToken::_tao_any_destructor (void *_tao_void_pointer)
{
  TranToken *tmp = ACE_static_cast (TranToken*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_TranToken[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f54), 
  ACE_NTOHL (0x72616e54), 
  ACE_NTOHL (0x6f6b656e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/Transaction/TranToken:1.0
  10,
  ACE_NTOHL (0x5472616e), 
  ACE_NTOHL (0x546f6b65), 
  ACE_NTOHL (0x6e000000),  // name = TranToken
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_TranToken (
    CORBA::tk_alias,
    sizeof (_oc_Components_Transaction_TranToken),
    (char *) &_oc_Components_Transaction_TranToken,
    0,
    sizeof (Components::Transaction::TranToken)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_TranToken,
    &_tc_TAO_tc_Components_Transaction_TranToken
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::NoTransaction::NoTransaction (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/NoTransaction:1.0",
        "NoTransaction"
      )
{
}

Components::Transaction::NoTransaction::~NoTransaction (void)
{
}

Components::Transaction::NoTransaction::NoTransaction (const ::Components::Transaction::NoTransaction &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::NoTransaction&
Components::Transaction::NoTransaction::operator= (const ::Components::Transaction::NoTransaction &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::NoTransaction::_tao_any_destructor (void *_tao_void_pointer)
{
  NoTransaction *tmp = ACE_static_cast (NoTransaction*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::NoTransaction *
Components::Transaction::NoTransaction::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/NoTransaction:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NoTransaction *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::NoTransaction::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::NoTransaction, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::NoTransaction::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::NoTransaction (*this),
      0
    );
  return result;
}

void Components::Transaction::NoTransaction::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::NoTransaction::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::NoTransaction::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::NoTransaction::_type (void) const
{
  return ::Components::Transaction::_tc_NoTransaction;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_NoTransaction[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f4e), 
  ACE_NTOHL (0x6f547261), 
  ACE_NTOHL (0x6e736163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/Transaction/NoTransaction:1.0
  14,
  ACE_NTOHL (0x4e6f5472), 
  ACE_NTOHL (0x616e7361), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e000000),  // name = NoTransaction
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_NoTransaction (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_NoTransaction),
    (char *) &_oc_Components_Transaction_NoTransaction,
    0,
    sizeof (Components::Transaction::NoTransaction)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_NoTransaction,
    &_tc_TAO_tc_Components_Transaction_NoTransaction
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::NotSupported::NotSupported (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/NotSupported:1.0",
        "NotSupported"
      )
{
}

Components::Transaction::NotSupported::~NotSupported (void)
{
}

Components::Transaction::NotSupported::NotSupported (const ::Components::Transaction::NotSupported &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::NotSupported&
Components::Transaction::NotSupported::operator= (const ::Components::Transaction::NotSupported &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::NotSupported::_tao_any_destructor (void *_tao_void_pointer)
{
  NotSupported *tmp = ACE_static_cast (NotSupported*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::NotSupported *
Components::Transaction::NotSupported::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/NotSupported:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (NotSupported *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::NotSupported::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::NotSupported, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::NotSupported::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::NotSupported (*this),
      0
    );
  return result;
}

void Components::Transaction::NotSupported::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::NotSupported::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::NotSupported::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::NotSupported::_type (void) const
{
  return ::Components::Transaction::_tc_NotSupported;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_NotSupported[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f4e), 
  ACE_NTOHL (0x6f745375), 
  ACE_NTOHL (0x70706f72), 
  ACE_NTOHL (0x7465643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/Transaction/NotSupported:1.0
  13,
  ACE_NTOHL (0x4e6f7453), 
  ACE_NTOHL (0x7570706f), 
  ACE_NTOHL (0x72746564), 
  ACE_NTOHL (0x0),  // name = NotSupported
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_NotSupported (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_NotSupported),
    (char *) &_oc_Components_Transaction_NotSupported,
    0,
    sizeof (Components::Transaction::NotSupported)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_NotSupported,
    &_tc_TAO_tc_Components_Transaction_NotSupported
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::SystemError::SystemError (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/SystemError:1.0",
        "SystemError"
      )
{
}

Components::Transaction::SystemError::~SystemError (void)
{
}

Components::Transaction::SystemError::SystemError (const ::Components::Transaction::SystemError &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::SystemError&
Components::Transaction::SystemError::operator= (const ::Components::Transaction::SystemError &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::SystemError::_tao_any_destructor (void *_tao_void_pointer)
{
  SystemError *tmp = ACE_static_cast (SystemError*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::SystemError *
Components::Transaction::SystemError::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/SystemError:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (SystemError *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::SystemError::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::SystemError, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::SystemError::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::SystemError (*this),
      0
    );
  return result;
}

void Components::Transaction::SystemError::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::SystemError::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::SystemError::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::SystemError::_type (void) const
{
  return ::Components::Transaction::_tc_SystemError;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_SystemError[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f53), 
  ACE_NTOHL (0x79737465), 
  ACE_NTOHL (0x6d457272), 
  ACE_NTOHL (0x6f723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/Transaction/SystemError:1.0
  12,
  ACE_NTOHL (0x53797374), 
  ACE_NTOHL (0x656d4572), 
  ACE_NTOHL (0x726f7200),  // name = SystemError
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_SystemError (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_SystemError),
    (char *) &_oc_Components_Transaction_SystemError,
    0,
    sizeof (Components::Transaction::SystemError)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_SystemError,
    &_tc_TAO_tc_Components_Transaction_SystemError
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::RollbackError::RollbackError (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/RollbackError:1.0",
        "RollbackError"
      )
{
}

Components::Transaction::RollbackError::~RollbackError (void)
{
}

Components::Transaction::RollbackError::RollbackError (const ::Components::Transaction::RollbackError &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::RollbackError&
Components::Transaction::RollbackError::operator= (const ::Components::Transaction::RollbackError &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::RollbackError::_tao_any_destructor (void *_tao_void_pointer)
{
  RollbackError *tmp = ACE_static_cast (RollbackError*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::RollbackError *
Components::Transaction::RollbackError::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/RollbackError:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (RollbackError *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::RollbackError::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::RollbackError, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::RollbackError::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::RollbackError (*this),
      0
    );
  return result;
}

void Components::Transaction::RollbackError::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::RollbackError::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::RollbackError::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::RollbackError::_type (void) const
{
  return ::Components::Transaction::_tc_RollbackError;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_RollbackError[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f52), 
  ACE_NTOHL (0x6f6c6c62), 
  ACE_NTOHL (0x61636b45), 
  ACE_NTOHL (0x72726f72), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/Transaction/RollbackError:1.0
  14,
  ACE_NTOHL (0x526f6c6c), 
  ACE_NTOHL (0x6261636b), 
  ACE_NTOHL (0x4572726f), 
  ACE_NTOHL (0x72000000),  // name = RollbackError
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_RollbackError (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_RollbackError),
    (char *) &_oc_Components_Transaction_RollbackError,
    0,
    sizeof (Components::Transaction::RollbackError)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_RollbackError,
    &_tc_TAO_tc_Components_Transaction_RollbackError
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::HeuristicMixed::HeuristicMixed (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/HeuristicMixed:1.0",
        "HeuristicMixed"
      )
{
}

Components::Transaction::HeuristicMixed::~HeuristicMixed (void)
{
}

Components::Transaction::HeuristicMixed::HeuristicMixed (const ::Components::Transaction::HeuristicMixed &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::HeuristicMixed&
Components::Transaction::HeuristicMixed::operator= (const ::Components::Transaction::HeuristicMixed &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::HeuristicMixed::_tao_any_destructor (void *_tao_void_pointer)
{
  HeuristicMixed *tmp = ACE_static_cast (HeuristicMixed*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::HeuristicMixed *
Components::Transaction::HeuristicMixed::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/HeuristicMixed:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (HeuristicMixed *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::HeuristicMixed::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::HeuristicMixed, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::HeuristicMixed::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::HeuristicMixed (*this),
      0
    );
  return result;
}

void Components::Transaction::HeuristicMixed::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::HeuristicMixed::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::HeuristicMixed::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::HeuristicMixed::_type (void) const
{
  return ::Components::Transaction::_tc_HeuristicMixed;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_HeuristicMixed[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f48), 
  ACE_NTOHL (0x65757269), 
  ACE_NTOHL (0x73746963), 
  ACE_NTOHL (0x4d697865), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/Transaction/HeuristicMixed:1.0
  15,
  ACE_NTOHL (0x48657572), 
  ACE_NTOHL (0x69737469), 
  ACE_NTOHL (0x634d6978), 
  ACE_NTOHL (0x65640000),  // name = HeuristicMixed
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_HeuristicMixed (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_HeuristicMixed),
    (char *) &_oc_Components_Transaction_HeuristicMixed,
    0,
    sizeof (Components::Transaction::HeuristicMixed)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_HeuristicMixed,
    &_tc_TAO_tc_Components_Transaction_HeuristicMixed
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::HeuristicRollback::HeuristicRollback (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/HeuristicRollback:1.0",
        "HeuristicRollback"
      )
{
}

Components::Transaction::HeuristicRollback::~HeuristicRollback (void)
{
}

Components::Transaction::HeuristicRollback::HeuristicRollback (const ::Components::Transaction::HeuristicRollback &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::HeuristicRollback&
Components::Transaction::HeuristicRollback::operator= (const ::Components::Transaction::HeuristicRollback &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::HeuristicRollback::_tao_any_destructor (void *_tao_void_pointer)
{
  HeuristicRollback *tmp = ACE_static_cast (HeuristicRollback*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::HeuristicRollback *
Components::Transaction::HeuristicRollback::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/HeuristicRollback:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (HeuristicRollback *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::HeuristicRollback::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::HeuristicRollback, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::HeuristicRollback::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::HeuristicRollback (*this),
      0
    );
  return result;
}

void Components::Transaction::HeuristicRollback::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::HeuristicRollback::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::HeuristicRollback::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::HeuristicRollback::_type (void) const
{
  return ::Components::Transaction::_tc_HeuristicRollback;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_HeuristicRollback[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f48), 
  ACE_NTOHL (0x65757269), 
  ACE_NTOHL (0x73746963), 
  ACE_NTOHL (0x526f6c6c), 
  ACE_NTOHL (0x6261636b), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:Components/Transaction/HeuristicRollback:1.0
  18,
  ACE_NTOHL (0x48657572), 
  ACE_NTOHL (0x69737469), 
  ACE_NTOHL (0x63526f6c), 
  ACE_NTOHL (0x6c626163), 
  ACE_NTOHL (0x6b000000),  // name = HeuristicRollback
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_HeuristicRollback (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_HeuristicRollback),
    (char *) &_oc_Components_Transaction_HeuristicRollback,
    0,
    sizeof (Components::Transaction::HeuristicRollback)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_HeuristicRollback,
    &_tc_TAO_tc_Components_Transaction_HeuristicRollback
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::Security::Security (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/Security:1.0",
        "Security"
      )
{
}

Components::Transaction::Security::~Security (void)
{
}

Components::Transaction::Security::Security (const ::Components::Transaction::Security &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::Security&
Components::Transaction::Security::operator= (const ::Components::Transaction::Security &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::Security::_tao_any_destructor (void *_tao_void_pointer)
{
  Security *tmp = ACE_static_cast (Security*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::Security *
Components::Transaction::Security::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/Security:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (Security *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::Security::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::Security, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::Security::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::Security (*this),
      0
    );
  return result;
}

void Components::Transaction::Security::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::Security::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::Security::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::Security::_type (void) const
{
  return ::Components::Transaction::_tc_Security;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_Security[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f53), 
  ACE_NTOHL (0x65637572), 
  ACE_NTOHL (0x6974793a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/Transaction/Security:1.0
  9,
  ACE_NTOHL (0x53656375), 
  ACE_NTOHL (0x72697479), 
  ACE_NTOHL (0x0),  // name = Security
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_Security (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_Security),
    (char *) &_oc_Components_Transaction_Security,
    0,
    sizeof (Components::Transaction::Security)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Security,
    &_tc_TAO_tc_Components_Transaction_Security
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

Components::Transaction::InvalidToken::InvalidToken (void)
  : CORBA_UserException (
        "IDL:Components/Transaction/InvalidToken:1.0",
        "InvalidToken"
      )
{
}

Components::Transaction::InvalidToken::~InvalidToken (void)
{
}

Components::Transaction::InvalidToken::InvalidToken (const ::Components::Transaction::InvalidToken &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Components::Transaction::InvalidToken&
Components::Transaction::InvalidToken::operator= (const ::Components::Transaction::InvalidToken &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void Components::Transaction::InvalidToken::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidToken *tmp = ACE_static_cast (InvalidToken*, _tao_void_pointer);
  delete tmp;
}

Components::Transaction::InvalidToken *
Components::Transaction::InvalidToken::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:Components/Transaction/InvalidToken:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidToken *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *Components::Transaction::InvalidToken::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Components::Transaction::InvalidToken, 0);
  return retval;
}

CORBA::Exception *
Components::Transaction::InvalidToken::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::Components::Transaction::InvalidToken (*this),
      0
    );
  return result;
}

void Components::Transaction::InvalidToken::_raise (void)
{
  TAO_RAISE (*this);
}

void Components::Transaction::InvalidToken::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void Components::Transaction::InvalidToken::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr Components::Transaction::InvalidToken::_type (void) const
{
  return ::Components::Transaction::_tc_InvalidToken;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_InvalidToken[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f49), 
  ACE_NTOHL (0x6e76616c), 
  ACE_NTOHL (0x6964546f), 
  ACE_NTOHL (0x6b656e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:Components/Transaction/InvalidToken:1.0
  13,
  ACE_NTOHL (0x496e7661), 
  ACE_NTOHL (0x6c696454), 
  ACE_NTOHL (0x6f6b656e), 
  ACE_NTOHL (0x0),  // name = InvalidToken
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_InvalidToken (
    CORBA::tk_except,
    sizeof (_oc_Components_Transaction_InvalidToken),
    (char *) &_oc_Components_Transaction_InvalidToken,
    0,
    sizeof (Components::Transaction::InvalidToken)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_InvalidToken,
    &_tc_TAO_tc_Components_Transaction_InvalidToken
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_Status[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f53), 
  ACE_NTOHL (0x74617475), 
  ACE_NTOHL (0x733a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:Components/Transaction/Status:1.0
  7,
  ACE_NTOHL (0x53746174), 
  ACE_NTOHL (0x75730000),  // name = Status
  9, // member count
  7,
  ACE_NTOHL (0x41435449), 
  ACE_NTOHL (0x56450000),  // name = ACTIVE
  16,
  ACE_NTOHL (0x4d41524b), 
  ACE_NTOHL (0x45445f52), 
  ACE_NTOHL (0x4f4c4c42), 
  ACE_NTOHL (0x41434b00),  // name = MARKED_ROLLBACK
  9,
  ACE_NTOHL (0x50524550), 
  ACE_NTOHL (0x41524544), 
  ACE_NTOHL (0x0),  // name = PREPARED
  10,
  ACE_NTOHL (0x434f4d4d), 
  ACE_NTOHL (0x49545445), 
  ACE_NTOHL (0x44000000),  // name = COMMITTED
  12,
  ACE_NTOHL (0x524f4c4c), 
  ACE_NTOHL (0x45445f42), 
  ACE_NTOHL (0x41434b00),  // name = ROLLED_BACK
  15,
  ACE_NTOHL (0x4e4f5f54), 
  ACE_NTOHL (0x52414e53), 
  ACE_NTOHL (0x41435449), 
  ACE_NTOHL (0x4f4e0000),  // name = NO_TRANSACTION
  10,
  ACE_NTOHL (0x50524550), 
  ACE_NTOHL (0x4152494e), 
  ACE_NTOHL (0x47000000),  // name = PREPARING
  11,
  ACE_NTOHL (0x434f4d4d), 
  ACE_NTOHL (0x49545449), 
  ACE_NTOHL (0x4e470000),  // name = COMMITTING
  13,
  ACE_NTOHL (0x524f4c4c), 
  ACE_NTOHL (0x494e475f), 
  ACE_NTOHL (0x4241434b), 
  ACE_NTOHL (0x0),  // name = ROLLING_BACK
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_Status (
    CORBA::tk_enum,
    sizeof (_oc_Components_Transaction_Status),
    (char *) &_oc_Components_Transaction_Status,
    0,
    sizeof (Components::Transaction::Status)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Status,
    &_tc_TAO_tc_Components_Transaction_Status
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int Components::Transaction::UserTransaction::_tao_class_id = 0;

Components::Transaction::UserTransaction_ptr
tao_Components_Transaction_UserTransaction_duplicate (
    Components::Transaction::UserTransaction_ptr p
  )
{
  return Components::Transaction::UserTransaction::_duplicate (p);
}

void
tao_Components_Transaction_UserTransaction_release (
    Components::Transaction::UserTransaction_ptr p
  )
{
  CORBA::release (p);
}

Components::Transaction::UserTransaction_ptr
tao_Components_Transaction_UserTransaction_nil (
    void
  )
{
  return Components::Transaction::UserTransaction::_nil ();
}

Components::Transaction::UserTransaction_ptr
tao_Components_Transaction_UserTransaction_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return Components::Transaction::UserTransaction::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_Components_Transaction_UserTransaction_upcast (
    void *src
  )
{
  Components::Transaction::UserTransaction **tmp =
    ACE_static_cast (Components::Transaction::UserTransaction **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// Components::Transaction::UserTransaction_var
// *************************************************************

Components::Transaction::UserTransaction_var::UserTransaction_var (void)
  : ptr_ (UserTransaction::_nil ())
{}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::ptr (void) const
{
  return this->ptr_;
}

Components::Transaction::UserTransaction_var::UserTransaction_var (const ::Components::Transaction::UserTransaction_var &p)
  : TAO_Base_var (),
    ptr_ (UserTransaction::_duplicate (p.ptr ()))
{}

Components::Transaction::UserTransaction_var::~UserTransaction_var (void)
{
  CORBA::release (this->ptr_);
}

Components::Transaction::UserTransaction_var &
Components::Transaction::UserTransaction_var::operator= (UserTransaction_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

Components::Transaction::UserTransaction_var &
Components::Transaction::UserTransaction_var::operator= (const ::Components::Transaction::UserTransaction_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::Components::Transaction::UserTransaction::_duplicate (p.ptr ());
  }
  return *this;
}

Components::Transaction::UserTransaction_var::operator const ::Components::Transaction::UserTransaction_ptr &() const // cast
{
  return this->ptr_;
}

Components::Transaction::UserTransaction_var::operator ::Components::Transaction::UserTransaction_ptr &() // cast 
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::operator-> (void) const
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::in (void) const
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr &
Components::Transaction::UserTransaction_var::inout (void)
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr &
Components::Transaction::UserTransaction_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::Components::Transaction::UserTransaction_ptr val = this->ptr_;
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
  return val;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::tao_duplicate (UserTransaction_ptr p)
{
  return ::Components::Transaction::UserTransaction::_duplicate (p);
}

void
Components::Transaction::UserTransaction_var::tao_release (UserTransaction_ptr p)
{
  CORBA::release (p);
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::tao_nil (void)
{
  return ::Components::Transaction::UserTransaction::_nil ();
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::Components::Transaction::UserTransaction::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
Components::Transaction::UserTransaction_var::tao_upcast (void *src)
{
  UserTransaction **tmp =
    ACE_static_cast (UserTransaction **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// Components::Transaction::UserTransaction_out
// *************************************************************

Components::Transaction::UserTransaction_out::UserTransaction_out (UserTransaction_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
}

Components::Transaction::UserTransaction_out::UserTransaction_out (UserTransaction_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::Components::Transaction::UserTransaction::_nil ();
}

Components::Transaction::UserTransaction_out::UserTransaction_out (const ::Components::Transaction::UserTransaction_out &p)
  : ptr_ (ACE_const_cast (UserTransaction_out &, p).ptr_)
{}

::Components::Transaction::UserTransaction_out &
Components::Transaction::UserTransaction_out::operator= (const ::Components::Transaction::UserTransaction_out &p)
{
  this->ptr_ = ACE_const_cast (UserTransaction_out&, p).ptr_;
  return *this;
}

Components::Transaction::UserTransaction_out &
Components::Transaction::UserTransaction_out::operator= (const ::Components::Transaction::UserTransaction_var &p)
{
  this->ptr_ = ::Components::Transaction::UserTransaction::_duplicate (p.ptr ());
  return *this;
}

Components::Transaction::UserTransaction_out &
Components::Transaction::UserTransaction_out::operator= (UserTransaction_ptr p)
{
  this->ptr_ = p;
  return *this;
}

Components::Transaction::UserTransaction_out::operator ::Components::Transaction::UserTransaction_ptr &() // cast
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr &
Components::Transaction::UserTransaction_out::ptr (void)
{
  return this->ptr_;
}

::Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

Components::Transaction::UserTransaction::UserTransaction (void)
{}

Components::Transaction::UserTransaction::~UserTransaction (void)
{}

void 
Components::Transaction::UserTransaction::_tao_any_destructor (void *_tao_void_pointer)
{
  UserTransaction *tmp = ACE_static_cast (UserTransaction *, _tao_void_pointer);
  CORBA::release (tmp);
}

Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return UserTransaction::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

Components::Transaction::UserTransaction_ptr 
Components::Transaction::UserTransaction::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return UserTransaction::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          UserTransaction_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &UserTransaction::_tao_class_id
                )
            )
        );
}

Components::Transaction::UserTransaction_ptr
Components::Transaction::UserTransaction::_duplicate (UserTransaction_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *Components::Transaction::UserTransaction::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::Components::Transaction, UserTransaction)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* Components::Transaction::UserTransaction::_interface_repository_id (void) const
{
  return "IDL:Components/Transaction/UserTransaction:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_Components_Transaction_UserTransaction[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74732f54), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e2f55), 
  ACE_NTOHL (0x73657254), 
  ACE_NTOHL (0x72616e73), 
  ACE_NTOHL (0x61637469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:Components/Transaction/UserTransaction:1.0
  16,
  ACE_NTOHL (0x55736572), 
  ACE_NTOHL (0x5472616e), 
  ACE_NTOHL (0x73616374), 
  ACE_NTOHL (0x696f6e00),  // name = UserTransaction
};

static CORBA::TypeCode _tc_TAO_tc_Components_Transaction_UserTransaction (
    CORBA::tk_objref,
    sizeof (_oc_Components_Transaction_UserTransaction),
    (char *) &_oc_Components_Transaction_UserTransaction,
    0,
    sizeof (Components::Transaction::UserTransaction)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Components)
TAO_NAMESPACE_BEGIN (Transaction)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UserTransaction,
    &_tc_TAO_tc_Components_Transaction_UserTransaction
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::TranToken &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_TranToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::TranToken *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_TranToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::TranToken::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Components::Transaction::TranToken *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::TranToken*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::TranToken *&_tao_elem
  )
{
  _tao_elem = 0;
  
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_TranToken
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = ACE_static_cast(
            const Components::Transaction::TranToken*,
            _tao_any.value ()
          );
        
        return 1;
      }
    else
      {
        Components::Transaction::TranToken *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::TranToken,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_TranToken,
                1,
                ACE_static_cast (void *, tmp),
                Components::Transaction::TranToken::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::NoTransaction &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NoTransaction,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::NoTransaction *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NoTransaction,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::NoTransaction::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::NoTransaction *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::NoTransaction*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::NoTransaction *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_NoTransaction
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::NoTransaction *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::NoTransaction *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::NoTransaction,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/NoTransaction:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_NoTransaction,
                1,
                tmp,
                Components::Transaction::NoTransaction::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::NotSupported &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NotSupported,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::NotSupported *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_NotSupported,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::NotSupported::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::NotSupported *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::NotSupported*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::NotSupported *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_NotSupported
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::NotSupported *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::NotSupported *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::NotSupported,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/NotSupported:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_NotSupported,
                1,
                tmp,
                Components::Transaction::NotSupported::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::SystemError &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_SystemError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::SystemError *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_SystemError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::SystemError::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::SystemError *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::SystemError*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::SystemError *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_SystemError
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::SystemError *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::SystemError *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::SystemError,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/SystemError:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_SystemError,
                1,
                tmp,
                Components::Transaction::SystemError::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::RollbackError &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_RollbackError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::RollbackError *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_RollbackError,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::RollbackError::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::RollbackError *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::RollbackError*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::RollbackError *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_RollbackError
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::RollbackError *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::RollbackError *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::RollbackError,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/RollbackError:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_RollbackError,
                1,
                tmp,
                Components::Transaction::RollbackError::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicMixed &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicMixed,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::HeuristicMixed *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicMixed,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::HeuristicMixed::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::HeuristicMixed *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::HeuristicMixed*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicMixed *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_HeuristicMixed
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::HeuristicMixed *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::HeuristicMixed *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::HeuristicMixed,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/HeuristicMixed:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_HeuristicMixed,
                1,
                tmp,
                Components::Transaction::HeuristicMixed::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicRollback &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicRollback,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::HeuristicRollback *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_HeuristicRollback,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::HeuristicRollback::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::HeuristicRollback *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::HeuristicRollback*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::HeuristicRollback *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_HeuristicRollback
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::HeuristicRollback *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::HeuristicRollback *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::HeuristicRollback,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/HeuristicRollback:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_HeuristicRollback,
                1,
                tmp,
                Components::Transaction::HeuristicRollback::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::Security &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_Security,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::Security *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_Security,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::Security::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::Security *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::Security*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::Security *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_Security
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::Security *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::Security *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::Security,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/Security:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_Security,
                1,
                tmp,
                Components::Transaction::Security::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const Components::Transaction::InvalidToken &_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_InvalidToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin ()
        );
    }
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::InvalidToken *_tao_elem
  )
{
  TAO_OutputCDR stream;
  
  if (stream << *_tao_elem)
    {
      _tao_any._tao_replace (
          Components::Transaction::_tc_InvalidToken,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_elem,
          Components::Transaction::InvalidToken::_tao_any_destructor
        );
    }
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,Components::Transaction::InvalidToken *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Components::Transaction::InvalidToken*&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Components::Transaction::InvalidToken *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_InvalidToken
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (result == 0)
      {
        return 0; // not equivalent
      }
    
    if (_tao_any.any_owns_data ())
      {
        _tao_elem = (Components::Transaction::InvalidToken *)_tao_any.value ();
        return 1;
      }
    else
      {
        Components::Transaction::InvalidToken *tmp = 0;
        ACE_NEW_RETURN (
            tmp,
            Components::Transaction::InvalidToken,
            0
          );
        
        TAO_InputCDR stream (
            _tao_any._tao_get_cdr (),
            _tao_any._tao_byte_order ()
          );
        
        CORBA::String_var interface_repository_id;
        
        if (!(stream >> interface_repository_id.out ()))
          {
            return 0;
          }
        
        if (ACE_OS::strcmp (
                interface_repository_id.in (),
                "IDL:Components/Transaction/InvalidToken:1.0")
              )
          {
            return 0;
          }
        
        if (stream >> *tmp)
          {
            ((CORBA::Any *)&_tao_any)->_tao_replace (
                Components::Transaction::_tc_InvalidToken,
                1,
                tmp,
                Components::Transaction::InvalidToken::_tao_any_destructor
              );
            
            _tao_elem = tmp;
            return 1;
          }
        else
          {
            delete tmp;
          }
      }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (CORBA::Any &_tao_any, Components::Transaction::Status _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Components::Transaction::_tc_Status,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Components::Transaction::Status &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (Components::Transaction::_tc_Status ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::UserTransaction_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      Components::Transaction::_tc_UserTransaction,
      1,
      Components::Transaction::UserTransaction::_duplicate (_tao_elem),
      Components::Transaction::UserTransaction::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    Components::Transaction::UserTransaction_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      Components::Transaction::_tc_UserTransaction,
      1,
      *_tao_elem,
      Components::Transaction::UserTransaction::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    Components::Transaction::UserTransaction_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Components::Transaction::UserTransaction::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          Components::Transaction::_tc_UserTransaction
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          Components::Transaction::UserTransaction_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
      
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = Components::Transaction::UserTransaction::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<Components::Transaction::UserTransaction,Components::Transaction::UserTransaction_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<Components::Transaction::UserTransaction,Components::Transaction::UserTransaction_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:103

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Components::Transaction::TranToken &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      {
        TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
          ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (Components::Transaction::TranToken *)&_tao_sequence);
        if (oseq->mb ())
          return strm.write_octet_array_mb (oseq->mb ());
        else
          return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
      }
      
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Components::Transaction::TranToken &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      if (ACE_BIT_DISABLED (strm.start ()->flags (),
      ACE_Message_Block::DONT_DELETE))
      {
        TAO_ORB_Core* orb_core = strm.orb_core ();
        if (orb_core != 0 &&
        strm.orb_core ()->resource_factory ()->
        input_cdr_allocator_type_locked () == 1)
        {
          TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
            ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
          oseq->replace (_tao_seq_len, strm.start ());
          oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
          strm.skip_bytes (_tao_seq_len);
          return 1;
        }
      }
      return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
      return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    }
  
  return 0;
}

