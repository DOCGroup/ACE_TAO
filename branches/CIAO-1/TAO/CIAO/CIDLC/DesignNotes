
Intention of this file is to capture and document CIDL complier design 
ideas/decisions.

Conceptual parts of CIDL compiler design
----------------------------------------

Option Parser                       Consists of option parser and option
                                    database. 

C Preprocessor Interfacing          Represents mechanism of preprocessing
                                    cidl files.

IDL Compiler Interfacing            Represents mechanism of invoking IDL
                                    compiler.

Scanner                             Scanner for preprocessed cidl file.

Parser                              CIDL grammar parser. Consists of grammar
                                    and semantic rules.

Syntax Tree                         Intermediate representation of cidl file.

Executor Mapping Generator          Generator for local executor mapping.

Executor Implementation Generator   Generator for partial implementation
                                    of local executor mapping.

Skeleton Thunk Generator            Generator for skeleton thunks i.e.
                                    code that implements skeleton and
                                    thunks user-defined functions to
                                    executor mapping.

Compiler driver                     Establishes order of execution of
                                    different components as part of 
                                    compilation process.


How everything works together
-----------------------------

(1) Compiler Driver executes Option Parser to populate Option Database

(2) Compiler Driver executes C Preprocessor on a supplied cidl file

(3) Compiler Driver executes Parser which uses Scanner to scan preprocessed
    cidl file and generates Syntax Tree by means of semantic rules.

(4) At this point we have Syntax Tree corresponding to the original cidl
    file. Compiler Driver executes Executor Mapping Generator, 
    Executor Implementation Generator and Skeleton Thunk Generator on 
    Syntax Tree.



General Design Ideas/Decision
-------------

[IDEA]: There is an effort to use autoconf/automake in ACE/TAO. Maybe it's 
        a good idea to start using it with CIDLC? There is one side advantage
        of this approach: if we decide to embed GCC CPP then we will have to
        use configure (or otherwise ACE-ify the code which doesn't sound like
        a right solution).

[IDEA]: CIDLC is a prototype for a new IDLC, PSDLC and IfR model. Here are
        basic concepts:

          - use common IDL grammar, semantic rules and syntax tree nodes 
            for IDLC, CIDLC, PSDLC and IfR.

          - use the same internal representation (syntax tree) in all 
            compilers and IfR. This way at some stage if we will need
            to make one of the compilers IfR-integrated (import keyword?)
            then it will be a much easier task than it's now. This internal
            representation may also be usable in typecodes.

          - there are a number of mechanisms in IDLC, mostly in the front
            end, that would benefit from redesign. Hopefully some or all
            of these can be addressed incrementally in CIDLC, and later
            integrated back into IDLC.

            symbol lookup: currently lookup is accomplished by AST navigation,
                           and is probably the biggest single bottleneck in
                           performance. Perhaps a separate symbol table would
                           be preferable. Also, lookups could be specialized,
                           e.g., for declaration, for references, and
                           perhaps a third type for argument-related lookups.

            expression evaluation: currently the result (not the expression)
                                   is generated, which may not always be
                                   necessary. However, for purposes of type
                                   coercion and other checking (such as for
                                   positive integer values in string, array
                                   and sequence bounds) evaluation must be
                                   done internally. Code could be generated
                                   for expression evaluation, or perhaps 
                                   the expression parsing code already
                                   generated could be reused with different
                                   actions.

            type coercion: currrently accomplished with an n-squared switch
                           statement and a reallocation of the entire
                           expression container class. Tight coupling with the
                           rest of the front end makes it difficult to
                           eliminate the extra copies. We should just 
                           start over.

            included files: currently unwieldy due to legacy code and the
                            interoperation with several preprocessors. This
                            issue depends on the choice of a preprocessor
                            mentioned elsewhere in the document. We also need
                            to support generation of #include statements
                            where they occur, rather than always at the top
                            of the generated file.

            inheritance/supports graphs: these graphs need to be traversed at
                                         several points in the back end. 
                                         Currently they are rebuilt for each 
                                         use, using an n-squared algorithm. We
                                         could at least build them only once
                                         for each interface/valuetype,
                                         perhaps even with a better algorithm.
                                         It could be integrated into 
                                         inheritance/supports error checking 
                                         at node creation time, which also be 
                                         streamlined.

            AMI/AMH implied IDL: more can be done in the BE preprocessing
                                 pass, hopefully eliminating a big chunk of
                                 the huge volume of AMI/AMH visitor code.
                                 The implied IDL generated for CCM types,
                                 for example, leaves almost nothing extra
                                 for the visitors to do.

            global/static stuff: there are way too many variables and 
                                 functions of this type.

            containers: the IDLC front end has proprietary classes for this. 
                        Use of these legacy classes should be replaced by 
                        either ACE containers or C++ runtime containers.

            fwd decl redefinition: forward declaration nodes all initially
                                   contain a heap-allocated dummy full- 
                                   definition member, later replaced by a copy 
                                   of the full definition. This needs to be 
                                   streamlined.

            memory leaks: inconsistent copying/passing policies make it almost
                          impossible to eliminate the huge number of leaks. The
                          front end will be more and more reused, and it may be
                          desirable to make it executable as a function call,
                          in which case it will important to eliminate the
                          leaks. Perhaps copying of AST nodes can be eliminated
                          with reference counting or just with careful 
                          management, similarly for string identifiers and 
                          literals. Destroy() methods have been put in all
                          the node classes, and are called recursively from
                          the AST root at destruction time, but they are far
                          from doing a complete job,

            visitor instantiation: the huge visitor factory has already been 
                                   much reduced, and the huge enum of context 
                                   state values is being reduced. However 
                                   there will still be an abundance of switch 
                                   statements at nearly every instance of 
                                   visitor creation at scope nesting. We 
                                   could make better use of polymorphism 
                                   to get rid of them.

            node narrowing: instead of the impenetrable macros we use now, we
                            could either generate valuetype-like downcast
                            methods for the (C)IDL types, or we could just use
                            dynamic_cast.

            error reporting: making error messages more informative, and error
                             recovery could both be a lot better, as they are 
                             in most other IDL compilers. If a recursive 
                             descent parser is used (such as Spirit), there 
                             is a simple generic algorithm for error recovery.

            streams: we can get reuse of code generation streams through 
                     inheritance. One idea is to have a basic stream code
                     generation class in ACE, where it can be built upon for
                     many kinds of code generation (XML, config files, etc.).
                     A stream class for basic IDL can be inherited by a
                     stream class for a superset of the language, and so on.
                     Granted, overloaded operators can't be virtual, but
                     delegation of each overload is a one-liner, as we do 
                     with TAO_*putCDR.

            FE/BE node classes: if BE node classes are implemented at all,
                                there should be a complete separation of
                                concerns - BE node classes should contain
                                only info related to code generation, and
                                FE node classes should contain only info
                                related to the AST representation. As the
                                front end becomes more modular and reusable,
                                this will become more and more necessary.

            undefined fwd decls: now that we have dropped support for
                                 platforms without namespaces, the code
                                 generated for fwd declarations not defined
                                 in the same translation unit can be much
                                 improved, most likely by the elimination
                                 of generated flat-name global methods, and
                                 perhaps other improvements as well.

            strategized code generation: many places now have either lots of
                                         duplication, or an explosion of
                                         branching in a single visitor.
                                         Adding code generation for use cases
                                         incrementally may give us an
                                         opportunity to refactor and 
                                         strategize it better.

            node generator: this class does nothing more than call 'new' and
                            pass unchanged the arguments it gets to the 
                            appropriate constructor - it can be eliminated.

            virtual methods: there are many member functions in the IDL 
                             compiler that are needlessly virtual.

            misc. leveraging: redesign of mechanisms listed above can have
                              an effect on other mechanisms, such as the
                              handling of pragma prefix, typeprefix, and
                              reopened modules.


Option Parser
-------------

[IDEA]: Use Spirit parser framework to generate option parser.

[IDEA]: Option Database is probably a singleton.

[IDEA]: It seems we will have to execute at least two external programs
        as part of CIDLC execution: CPP and IDLC. Why wouldn't we follow
        GCC specs model (gcc -dumpspecs). Here are candidates to be put into
        specs:        

          - default CPP name and options
          - default  IDLC name and options
          - default file extensions and formats for different mappings
          - other ideas? 

[IDEA]: Provide short and long option names (e.g. -o and --output-dir)
        for every option (maybe except -I, -D, etc).


C Preprocessor Interfacing
--------------------------

[IDEA]: Embed/require GCC CPP

[IDEA]: We need a new model of handling includes in CIDLC (as well as IDLC).
        Right now I'm mentally testing a new model (thanks to Carlos for the
        comments). Soon I will put the description here.

[IDEA]: We cannot move cidl file being preprocessed to for example /tmp
        as it's currently the case with IDLC.

[IDEA]: Can we use pipes (ACE Pipes) portably to avoid temporary files?
        (Kitty, you had some ideas about that?)



IDL Compiler Interfacing
------------------------

[IDEA]: Same as for CPP: Can we use pipes?

[IDEA]: Will need a mechanism to pass options to IDLC from CIDLC command
        line (would be nice to have this ability for CPP as well).
        Something like -x in xterm? Better ideas?



Scanner
------

[IDEA]: Use Spirit framework to construct scanner. The resulting sequence
        can be sequence of objects? BTW, Spirit parser expects a "forward
        iterator"-based scanner. So this basically mean that we may have to
        keep the whole sequence in memory. BTW, this is another good reason
        to have scanner: if we manage to make scanner a predictable parser
        (i.e. no backtracking) then we don't have to keep the whole 
        preprocessed cidl file in memory.



Parser
------

[IDEA]: Use Spirit framework to construct parser.

[IDEA]: Define IDL grammar as a number of grammar capsules. This way it's
        much easier to reuse/inherit even dynamically. Need to elaborate
        this idea.

[IDEA]: Use functors as semantic actions. This way we can specify (via 
        functor's data member) on which Syntax Tree they are working.
        Bad side: semantic rules are defined during grammar construction.
        However we can use a modification of the factory method pattern.
        Better ideas?



Syntax Tree
-----------

[IDEA]: Use interface repository model as a base for Syntax Tree hierarchy.


Common Syntax Tree traversal Design Ideas/Decision
--------------------------------------------------

[IDEA] If we specify Syntax Tree traversal facility then we will be able
       to specify (or even plug dynamically) Syntax Tree traversal agents
       that may not only generate something but also annotate or modify 
       Syntax Tree. We are already using this technique for a number of
       features (e.g. AMI, IDL3 extension, what else?) but all these agents
       are hardwired inside TAO IDLC. If we have this facility then we will
       be able to produce modular and highly extensible design. Notes:

       - Some traversal agents can change Syntax Tree so that it will be
         unusable by some later traversal agents. So maybe the more 
         generic approach would be to produce new Syntax Tree?

[IDEA] Need a generic name for "Syntax Tree Traversal Agents". What about
       "Syntax Tree Traverser"?


Executor Mapping Generator
--------------------------




Executor Implementation Generator
--------------------------------

[IDEA]: Translate CIDL composition to C++ namespace.



Skeleton Thunk Generator
------------------------




Compiler driver
---------------
