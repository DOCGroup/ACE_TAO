Thu Jul  1 12:52:12 UTC 2004  Johnny Willemsen  <jwillemsen@remedy.nl>

        * tao/Transport_Connector.{h,cpp}:
          Removed the block argument from the make_connection and connect
          method again, if we should get a connected transport or not can be
          retrieved from the ProfileTransportResolver

        * tao/Transport_Connector.cpp:
          In case we get a transport from the cache that is not connected,
          call wait with zero time. We have to add more functionality here
          to handle the closing of that transport, and check the
          implementation what we do when we can't register the wait strategy
          with the reactor

        * tao/IIOP_Connector.{h,cpp}:
          Added better handling of blocking or non-blocking connects.

Thu Jul  1 10:02:12 UTC 2004  Johnny Willemsen  <jwillemsen@remedy.nl>

        * tao/Transport.{h,inl}:
          Added connection_handler accessor function and made
          connetion_handler_i protected again

        * tao/Transport_Connector.cpp:
          Use Transport::connection_handler instead of the _i version.

Wed Jun 30 14:26:12 UTC 2004  Johnny Willemsen  <jwillemsen@remedy.nl>

        * tao/Profile_Transport_Resolver.{h,cpp,i}:
          Instead of passed with each operation whether the connect should
          block or not, we now pass a boolean with the constructor if this
          tranport must deliver a connected transport or whether it is also
          allowed to deliver a not connected transport. Added an accessor for
          this member.

        * tao/Invocation_Adapter.cpp:
        * tao/Invocation_Endpoint_Selectors.{h,cpp}:
        * tao/LocateRequest_Invocation_Adapter.cpp:
          Instead of passing the block boolean with each operation, pass it
          with the constructor or the Profile_Transport_Resolver.

Wed Jun 30 10:19:12 UTC 2004  Johnny Willemsen  <jwillemsen@remedy.nl>

        * tao/Synch_Invocation (remote_oneway):
          At the top of the method we check for sync with server or sync with
          target. In case of this we do a twoway. I don't see any reason why
          lower in the method we check another time for sync with server, so
          removed that check. Changed the calling of
          Synch_Twoway_Invocation::remote_twoway(), so that we check for
          exceptions in case of emulated exception macros. Add transport local
          variable, so that we don't need to get it several times in one
          method call.

        * tao/Transport.cpp (send_message_shared_i):
          Removed queueing, it should be here, added some comments that the
          code checking for twoways or replies should go out of here. This
          class also got the new methods queue_message and queue_message_i
          when it was created as branch.

Tue Jun 20 10:10:10 UTC 2004  Johnny Willemsen  <jwillemsen@remedy.nl>

        * tao/Transport.{h,cpp}:
          Added queue_message and queue_message_i to be able to queue a
          message from the outside, use this method also internally.
          Added connected_ member and accessors to indicate whether this
          transport is connected or not


Initial comments

In onderstaande method kan worden gebufferd.

int
TAO_Transport::send_message_shared_i (TAO_Stub *stub,
                                      int message_semantics,
                                      const ACE_Message_Block *message_block,
                                      ACE_Time_Value *max_wait_time)


Hier wordt de connectie gemaakt
TAO_Transport *
TAO_IIOP_Connector::make_connection (TAO::Profile_Transport_Resolver *,
                                     TAO_Transport_Descriptor_Interface &desc,
                                     ACE_Time_Value *max_wait_time)
{

In deze call wordt de reactor event loop gedaan:

      // Wait for connection completion.  No need to specify timeout
      // to wait() since the correct timeout was passed to the
      // Connector. The Connector will close the handler in the case
      // of timeouts, so the event will complete (either success or
      // failure) within timeout.
      result =
        this->active_connect_strategy_->wait (svc_handler,
                                              0);

In deze method worden de endpoints geprobeerd om een connectie te maken. Hier
ook wat doen?
 void TAO_Default_Endpoint_Selector::select_endpoint (
    TAO::Profile_Transport_Resolver *r,
    ACE_Time_Value *max_wait_time
    ACE_ENV_ARG_DECL)
{

Hier wordt de oneway uitgevoerd
  Invocation_Status
  Synch_Oneway_Invocation::remote_oneway (ACE_Time_Value *max_wait_time
                                          ACE_ENV_ARG_DECL)


In de volgende method zit de code om een message te queuen. Dit kan
makkelijker in een helper method
 int TAO_Transport::send_message_shared_i (TAO_Stub *stub,
                                      int message_semantics,
                                      const ACE_Message_Block *message_block,
                                      ACE_Time_Value *max_wait_time)




