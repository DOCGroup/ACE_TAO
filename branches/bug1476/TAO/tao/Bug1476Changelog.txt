In onderstaande method kan worden gebufferd.

int
TAO_Transport::send_message_shared_i (TAO_Stub *stub,
                                      int message_semantics,
                                      const ACE_Message_Block *message_block,
                                      ACE_Time_Value *max_wait_time)


Hier wordt de connectie gemaakt
TAO_Transport *
TAO_IIOP_Connector::make_connection (TAO::Profile_Transport_Resolver *,
                                     TAO_Transport_Descriptor_Interface &desc,
                                     ACE_Time_Value *max_wait_time)
{

In deze call wordt de reactor event loop gedaan:

      // Wait for connection completion.  No need to specify timeout
      // to wait() since the correct timeout was passed to the
      // Connector. The Connector will close the handler in the case
      // of timeouts, so the event will complete (either success or
      // failure) within timeout.
      result =
        this->active_connect_strategy_->wait (svc_handler,
                                              0);

In deze method worden de endpoints geprobeerd om een connectie te maken. Hier
ook wat doen?
 void TAO_Default_Endpoint_Selector::select_endpoint (
    TAO::Profile_Transport_Resolver *r,
    ACE_Time_Value *max_wait_time
    ACE_ENV_ARG_DECL)
{

Hier wordt de oneway uitgevoerd
  Invocation_Status
  Synch_Oneway_Invocation::remote_oneway (ACE_Time_Value *max_wait_time
                                          ACE_ENV_ARG_DECL)


In de volgende method zit de code om een message te queuen. Dit kan
makkelijker in een helper method
 int TAO_Transport::send_message_shared_i (TAO_Stub *stub,
                                      int message_semantics,
                                      const ACE_Message_Block *message_block,
                                      ACE_Time_Value *max_wait_time)

