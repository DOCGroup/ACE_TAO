$Id$
#ifndef UUID_h
#define UUID_h 1

#include <memory>
#include "ace/Refcounted_Auto_Ptr.h"

//#include <string>
#include "ace/SString.h"
// Process_Mutex
#include "ace/Process_Mutex.h"
#include "ace/Malloc_T.h"
#include "ace/PI_Malloc.h"

template < class TYPE, class ACE_LOCK > class ACE_Singleton;
class ACE_UUID_Generator;

typedef ACE_UINT16 Unsigned16;

typedef unsigned char Unsigned8;

typedef unsigned char Octet;

typedef ACE_UINT32 Unsigned32;

typedef ACE_UINT64 Unsigned64;

class ACE_Export ACE_UUID_Impl 
{
  // Class: ACE_UUID_Impl
  //	Private implementation data and methods for UUID.
  
public:
  

  struct UUID_node_t 
  {
    // Class: UUID_node_t%3C67E3320167
    //	Type to hold a MAC address
    
    typedef enum { nodeIDSize = 6 } NodeIDSize;

    typedef Octet  NodeID[nodeIDSize];

    bool operator == (const UUID_node_t& right) const;

    bool operator != (const UUID_node_t& right) const;

    bool operator < (const UUID_node_t& right) const;

    // Data Members for Class Attributes

    NodeID nodeID;
  
  };

  
  struct UUID_t 
  {
    // Data Members for Class Attributes

    Unsigned32 timeLow;

    Unsigned16 timeMid;
    
    Unsigned16 timeHiAndVersion;
    
    Unsigned8 clockSeqHiAndReserved;
    
    Unsigned8 clockSeqLow;
    
    UUID_node_t node;
    
  };

  ACE_UUID_Impl();

  ACE_UUID_Impl (UUID_t&);//const UUID::NewUUID& );

  ACE_UUID_Impl (const ACE_SString& asString);

  ~ACE_UUID_Impl();

  bool operator == (const ACE_UUID_Impl& right) const;

  bool operator < (const ACE_UUID_Impl& right) const;

  // Operation: toString
  //	Returns a string representation of the UUID. Internally,
  //	the string representation, which is contained in as
  //	String, is only computed if this operation is called.
  //	Once the representation is computed it can never change.
  ACE_SString toString () const;

  //  Attribute: nilACE_UUID_Impl
  //  Instance of a ACE_UUID_Impl containing a nil UUID. Used by
  //  the UUID default constructor so that all nil UUIDs use
  //  the same ACE_UUID_Impl.
  
  static ACE_Refcounted_Auto_Ptr<ACE_UUID_Impl,ACE_Thread_Mutex> nilACE_UUID_Impl;

private:
  // Attribute: asString
  // The string representation of the UUID. This is created
  // and updated only on demand.
  //mutable ACE_SString asString;
  mutable ACE_SString asString;
  
  
  // This ACE_UUID_Impl's representation of the UUID
  UUID_t uuid;

  //friend class ACE_UUID_Generator;
};

class ACE_Export ACE_UUID 
{
  //	ADT representing a Universally Unique IDentifier (UUID)
  //	as described in (the expired) INTERNET-DRAFT
  //	specification entitled UUIDs and GUIDs. All instances of
  //	UUID are of the time-based variety. That is, the version
  //	number part of the timeHiAndVersion field is 1.
  //
  //	Non-nil UUIDs generated by this class are unique across
  //	both space and time with respect to all other UUIDs
  //	generated by the class (see note below).
  //
  //	The default constructor creates a nil UUID.
  //
  //	All operations on UUID are strongly exception safe.
  //
  //	UUIDs have value semantics. In addition, they may be
  //	compared for ordering and equality.
  //
  //	Note: the statement of UUID uniqueness is less stringent
  //	than the requirement for UUID in general. There is no
  //	guarantee that a UUID generated by by this class is
  //	universally unique with respect to another arbitrary
  //	UUID. However, the guarantee is sufficient of purposes
  //	of JCAF.


 public:
/*    struct NewUUID  */
/*    { */
/*      public: */
/*  protected: */
/*  private: */
/*  private: //## implementation */
/*    }; */

  ACE_UUID();

  ACE_UUID(const ACE_UUID &right);

  //	Construct a new, non-nil UUID.
  ACE_UUID (ACE_UUID_Impl::UUID_t& newUUID);

  //	Constructs a UUID from a string representation.
  //
  //	Throws IllegalArgument if the string representation is
  //	not valid.
  ACE_UUID (const ACE_SString& uuid);

  ~ACE_UUID();

  // Assignment Operation (generated)
  ACE_UUID & operator=(const ACE_UUID &right);

  // Equality Operations (generated)
  bool operator==(const ACE_UUID &right) const;

  bool operator!=(const ACE_UUID &right) const;

  // Relational Operations (generated)
  bool operator<(const ACE_UUID &right) const;

  bool operator>(const ACE_UUID &right) const;

  bool operator<=(const ACE_UUID &right) const;

  bool operator>=(const ACE_UUID &right) const;
  
  //	Returns a string representation of the ACE_UUID.
  ACE_SString toString () const;

  // Data Members for Associations
//  static NewUUID newUUID;

 private:
  ACE_Refcounted_Auto_Ptr<class ACE_UUID_Impl, ACE_Thread_Mutex> pimpl;
};



// Singleton class that generates UUIDs.
class ACE_UUID_Generator
{
 public:
  static ACE_UUID_Generator* instance();
    
  // Format timestamp, clockseq, and nodeID into a VI UUID.
  void formatV1( ACE_UUID_Impl::UUID_t&);
    
 private:
  ACE_UUID_Generator();
  ~ACE_UUID_Generator();
  friend class ACE_Singleton< ACE_UUID_Generator, ACE_Null_Mutex >;

  // Type to represent UTC as a count of 100 nanosecond intervals since
  // 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the
  // Christian calendar.
  typedef Unsigned64 UUID_time_t;

  // The maximum number of uuids that can be generated per tick of the
  // system clock. This number should be the number of 100ns ticks of the
  // actual resolution of the system's clock.
  enum {

    uuidsPerTick = 1000

  };

  // The number of uuids generated in this process since the last clock
  // tick. Value never exceeds uuidsPerTick - 1.
  Unsigned32 uuidsThisTick;

  // The system time when that last uuid was generated.
  UUID_time_t timeLast;

  // Type to map to contain the UUID generator persistent state. This
  // will be kept in memory mapped shared memory
  struct UUID_state
  {
    UUID_time_t timestamp;
	ACE_UUID_Impl::UUID_node_t node;
    Unsigned16 clockSequence;
  };

  // The UUID generator persistent state.
  UUID_state* uuidState;

  // Obtain a UUID timestamp. Compensate for the fact that the time
  // obtained from getSystem time has a resolution less than 100ns.
  void getTimestamp( UUID_time_t& timestamp);

  // Obtain the system time in UTC as a count of 100 nanosecond intervals
  // since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to
  // the Christian calendar).
  void getSystemTime( UUID_time_t& timeNow);

  // Obtain the IEEE node ID.
  void getIEEENodeIdentifier( ACE_UUID_Impl::UUID_node_t& node);

  // Shared memory allocator for persistent shared in process and
  // cross process UUID_state
  // ACE_Null_Mutex OK since this is only called when a lock is held on a
  // ACE_Process_Mutex (lock below).
  typedef ACE_Malloc_T<ACE_MMAP_MEMORY_POOL,ACE_Null_Mutex, ACE_PI_Control_Block> ShmemAllocator;
  //::auto_ptr< ShmemAllocator > shmemAllocator;
  ShmemAllocator* shmemAllocator;

  // Process mutex used to serialize access to data shared
  // between multiple processes.
  ACE_Process_Mutex lock;

  // No value semantics
  ACE_UUID_Generator( const ACE_UUID_Generator&);
  ACE_UUID_Generator& operator=( const ACE_UUID_Generator&);
};



class ACE_UUID_Admin_Impl 
{
public:
  ACE_UUID_Admin_Impl();

  // Operation: setPersistenceFilename%3C6442DF02FD
  // Sets the filename used to maintain persistent data
  // between invocations, and that is shared between
  // instances of UUID both within process and across
  // processes.
  void setPersistenceFilename (const ACE_SString& filename);

  const ACE_SString& getPersistenceFilename () const;

  static const ACE_SString& getDefaultPersistenceFilename ();

private:
  ACE_UUID_Admin_Impl(const ACE_UUID_Admin_Impl &right);

  ACE_UUID_Admin_Impl & operator=(const ACE_UUID_Admin_Impl &right);

private: 
  ACE_SString persistenceFilename;
  static const ACE_SString defaultPersistenceFilename;
};


class ACE_Export ACE_UUID_Admin 
{
  //	Class to provide an administrative interface for UUID.
  //	There is a singleton instance of the class that is made
  //	available via it's static method instance().

 public:
  //	Returns a pointer to the singleton instanace of
  //	UUID::Admin.
  static ACE_UUID_Admin* instance ();
  
  //	Sets the filename used to maintain persistent data
  //	between invocations, and that is shared between
  //	instances of UUID both within process and across
  //	processes.
  void setPersistenceFilename (const ACE_SString& filename);
  
  // Operation: getPersistenceFilename
  const ACE_SString& getPersistenceFilename () const;

  // Operation: getDefaultPersistenceFilename
  const ACE_SString& getDefaultPersistenceFilename ();

 private:
  // Constructors (generated)
  ACE_UUID_Admin();

  ACE_UUID_Admin(const ACE_UUID_Admin &right);

  //Assignment Operation (generated)
  ACE_UUID_Admin & operator=(const ACE_UUID_Admin &right);

 private: 
  friend class ACE_Singleton< ACE_UUID_Admin, ACE_Null_Mutex>;
  std::auto_ptr< class ACE_UUID_Admin_Impl > pimpl;
};



#endif



