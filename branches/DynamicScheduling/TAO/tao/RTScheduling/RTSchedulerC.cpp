// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:318


#include "RTSchedulerC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "RTSchedulerC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int RTScheduling::ThreadAction::_tao_class_id = 0;

RTScheduling::ThreadAction_ptr
tao_RTScheduling_ThreadAction_duplicate (
    RTScheduling::ThreadAction_ptr p
  )
{
  return RTScheduling::ThreadAction::_duplicate (p);
}

void
tao_RTScheduling_ThreadAction_release (
    RTScheduling::ThreadAction_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::ThreadAction_ptr
tao_RTScheduling_ThreadAction_nil (
    void
  )
{
  return RTScheduling::ThreadAction::_nil ();
}

RTScheduling::ThreadAction_ptr
tao_RTScheduling_ThreadAction_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return RTScheduling::ThreadAction::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_RTScheduling_ThreadAction_upcast (
    void *src
  )
{
  RTScheduling::ThreadAction **tmp =
    ACE_static_cast (RTScheduling::ThreadAction **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// RTScheduling::ThreadAction_var
// *************************************************************

RTScheduling::ThreadAction_var::ThreadAction_var (void)
  : ptr_ (ThreadAction::_nil ())
{}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_var::ptr (void) const
{
  return this->ptr_;
}

RTScheduling::ThreadAction_var::ThreadAction_var (const ::RTScheduling::ThreadAction_var &p)
  : TAO_Base_var (),
    ptr_ (ThreadAction::_duplicate (p.ptr ()))
{}

RTScheduling::ThreadAction_var::~ThreadAction_var (void)
{
  CORBA::release (this->ptr_);
}

RTScheduling::ThreadAction_var &
RTScheduling::ThreadAction_var::operator= (ThreadAction_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

RTScheduling::ThreadAction_var &
RTScheduling::ThreadAction_var::operator= (const ::RTScheduling::ThreadAction_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::RTScheduling::ThreadAction::_duplicate (p.ptr ());
  }
  return *this;
}

RTScheduling::ThreadAction_var::operator const ::RTScheduling::ThreadAction_ptr &() const // cast
{
  return this->ptr_;
}

RTScheduling::ThreadAction_var::operator ::RTScheduling::ThreadAction_ptr &() // cast 
{
  return this->ptr_;
}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_var::operator-> (void) const
{
  return this->ptr_;
}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_var::in (void) const
{
  return this->ptr_;
}

::RTScheduling::ThreadAction_ptr &
RTScheduling::ThreadAction_var::inout (void)
{
  return this->ptr_;
}

::RTScheduling::ThreadAction_ptr &
RTScheduling::ThreadAction_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::ThreadAction::_nil ();
  return this->ptr_;
}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::RTScheduling::ThreadAction_ptr val = this->ptr_;
  this->ptr_ = ::RTScheduling::ThreadAction::_nil ();
  return val;
}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_var::tao_duplicate (ThreadAction_ptr p)
{
  return ::RTScheduling::ThreadAction::_duplicate (p);
}

void
RTScheduling::ThreadAction_var::tao_release (ThreadAction_ptr p)
{
  CORBA::release (p);
}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_var::tao_nil (void)
{
  return ::RTScheduling::ThreadAction::_nil ();
}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::RTScheduling::ThreadAction::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::ThreadAction_var::tao_upcast (void *src)
{
  ThreadAction **tmp =
    ACE_static_cast (ThreadAction **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// RTScheduling::ThreadAction_out
// *************************************************************

RTScheduling::ThreadAction_out::ThreadAction_out (ThreadAction_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::RTScheduling::ThreadAction::_nil ();
}

RTScheduling::ThreadAction_out::ThreadAction_out (ThreadAction_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::ThreadAction::_nil ();
}

RTScheduling::ThreadAction_out::ThreadAction_out (const ::RTScheduling::ThreadAction_out &p)
  : ptr_ (ACE_const_cast (ThreadAction_out &, p).ptr_)
{}

::RTScheduling::ThreadAction_out &
RTScheduling::ThreadAction_out::operator= (const ::RTScheduling::ThreadAction_out &p)
{
  this->ptr_ = ACE_const_cast (ThreadAction_out&, p).ptr_;
  return *this;
}

RTScheduling::ThreadAction_out &
RTScheduling::ThreadAction_out::operator= (const ::RTScheduling::ThreadAction_var &p)
{
  this->ptr_ = ::RTScheduling::ThreadAction::_duplicate (p.ptr ());
  return *this;
}

RTScheduling::ThreadAction_out &
RTScheduling::ThreadAction_out::operator= (ThreadAction_ptr p)
{
  this->ptr_ = p;
  return *this;
}

RTScheduling::ThreadAction_out::operator ::RTScheduling::ThreadAction_ptr &() // cast
{
  return this->ptr_;
}

::RTScheduling::ThreadAction_ptr &
RTScheduling::ThreadAction_out::ptr (void)
{
  return this->ptr_;
}

::RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

RTScheduling::ThreadAction::ThreadAction (void)
{}

RTScheduling::ThreadAction::~ThreadAction (void)
{}

void 
RTScheduling::ThreadAction::_tao_any_destructor (void *_tao_void_pointer)
{
  ThreadAction *tmp = ACE_static_cast (ThreadAction *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ThreadAction::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::ThreadAction_ptr 
RTScheduling::ThreadAction::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ThreadAction::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          ThreadAction_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ThreadAction::_tao_class_id
                )
            )
        );
}

RTScheduling::ThreadAction_ptr
RTScheduling::ThreadAction::_duplicate (ThreadAction_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::ThreadAction::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::RTScheduling, ThreadAction)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::ThreadAction::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/ThreadAction:1.0";
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_ThreadAction[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f546872), 
  ACE_NTOHL (0x65616441), 
  ACE_NTOHL (0x6374696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:RTScheduling/ThreadAction:1.0
  13,
  ACE_NTOHL (0x54687265), 
  ACE_NTOHL (0x61644163), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ThreadAction
};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_ThreadAction (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_ThreadAction),
    (char *) &_oc_RTScheduling_ThreadAction,
    0,
    sizeof (RTScheduling::ThreadAction)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ThreadAction,
    &_tc_TAO_tc_RTScheduling_ThreadAction
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int RTScheduling::DistributableThread::_tao_class_id = 0;

RTScheduling::DistributableThread_ptr
tao_RTScheduling_DistributableThread_duplicate (
    RTScheduling::DistributableThread_ptr p
  )
{
  return RTScheduling::DistributableThread::_duplicate (p);
}

void
tao_RTScheduling_DistributableThread_release (
    RTScheduling::DistributableThread_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::DistributableThread_ptr
tao_RTScheduling_DistributableThread_nil (
    void
  )
{
  return RTScheduling::DistributableThread::_nil ();
}

RTScheduling::DistributableThread_ptr
tao_RTScheduling_DistributableThread_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return RTScheduling::DistributableThread::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_RTScheduling_DistributableThread_upcast (
    void *src
  )
{
  RTScheduling::DistributableThread **tmp =
    ACE_static_cast (RTScheduling::DistributableThread **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// RTScheduling::DistributableThread_var
// *************************************************************

RTScheduling::DistributableThread_var::DistributableThread_var (void)
  : ptr_ (DistributableThread::_nil ())
{}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_var::ptr (void) const
{
  return this->ptr_;
}

RTScheduling::DistributableThread_var::DistributableThread_var (const ::RTScheduling::DistributableThread_var &p)
  : TAO_Base_var (),
    ptr_ (DistributableThread::_duplicate (p.ptr ()))
{}

RTScheduling::DistributableThread_var::~DistributableThread_var (void)
{
  CORBA::release (this->ptr_);
}

RTScheduling::DistributableThread_var &
RTScheduling::DistributableThread_var::operator= (DistributableThread_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

RTScheduling::DistributableThread_var &
RTScheduling::DistributableThread_var::operator= (const ::RTScheduling::DistributableThread_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::RTScheduling::DistributableThread::_duplicate (p.ptr ());
  }
  return *this;
}

RTScheduling::DistributableThread_var::operator const ::RTScheduling::DistributableThread_ptr &() const // cast
{
  return this->ptr_;
}

RTScheduling::DistributableThread_var::operator ::RTScheduling::DistributableThread_ptr &() // cast 
{
  return this->ptr_;
}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_var::operator-> (void) const
{
  return this->ptr_;
}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_var::in (void) const
{
  return this->ptr_;
}

::RTScheduling::DistributableThread_ptr &
RTScheduling::DistributableThread_var::inout (void)
{
  return this->ptr_;
}

::RTScheduling::DistributableThread_ptr &
RTScheduling::DistributableThread_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::DistributableThread::_nil ();
  return this->ptr_;
}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::RTScheduling::DistributableThread_ptr val = this->ptr_;
  this->ptr_ = ::RTScheduling::DistributableThread::_nil ();
  return val;
}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_var::tao_duplicate (DistributableThread_ptr p)
{
  return ::RTScheduling::DistributableThread::_duplicate (p);
}

void
RTScheduling::DistributableThread_var::tao_release (DistributableThread_ptr p)
{
  CORBA::release (p);
}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_var::tao_nil (void)
{
  return ::RTScheduling::DistributableThread::_nil ();
}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::RTScheduling::DistributableThread::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::DistributableThread_var::tao_upcast (void *src)
{
  DistributableThread **tmp =
    ACE_static_cast (DistributableThread **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// RTScheduling::DistributableThread_out
// *************************************************************

RTScheduling::DistributableThread_out::DistributableThread_out (DistributableThread_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::RTScheduling::DistributableThread::_nil ();
}

RTScheduling::DistributableThread_out::DistributableThread_out (DistributableThread_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::DistributableThread::_nil ();
}

RTScheduling::DistributableThread_out::DistributableThread_out (const ::RTScheduling::DistributableThread_out &p)
  : ptr_ (ACE_const_cast (DistributableThread_out &, p).ptr_)
{}

::RTScheduling::DistributableThread_out &
RTScheduling::DistributableThread_out::operator= (const ::RTScheduling::DistributableThread_out &p)
{
  this->ptr_ = ACE_const_cast (DistributableThread_out&, p).ptr_;
  return *this;
}

RTScheduling::DistributableThread_out &
RTScheduling::DistributableThread_out::operator= (const ::RTScheduling::DistributableThread_var &p)
{
  this->ptr_ = ::RTScheduling::DistributableThread::_duplicate (p.ptr ());
  return *this;
}

RTScheduling::DistributableThread_out &
RTScheduling::DistributableThread_out::operator= (DistributableThread_ptr p)
{
  this->ptr_ = p;
  return *this;
}

RTScheduling::DistributableThread_out::operator ::RTScheduling::DistributableThread_ptr &() // cast
{
  return this->ptr_;
}

::RTScheduling::DistributableThread_ptr &
RTScheduling::DistributableThread_out::ptr (void)
{
  return this->ptr_;
}

::RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

RTScheduling::DistributableThread::DistributableThread (void)
{}

RTScheduling::DistributableThread::~DistributableThread (void)
{}

void 
RTScheduling::DistributableThread::_tao_any_destructor (void *_tao_void_pointer)
{
  DistributableThread *tmp = ACE_static_cast (DistributableThread *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return DistributableThread::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::DistributableThread_ptr 
RTScheduling::DistributableThread::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return DistributableThread::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          DistributableThread_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &DistributableThread::_tao_class_id
                )
            )
        );
}

RTScheduling::DistributableThread_ptr
RTScheduling::DistributableThread::_duplicate (DistributableThread_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::DistributableThread::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::RTScheduling, DistributableThread)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::DistributableThread::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/DistributableThread:1.0";
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_DistributableThread[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f446973), 
  ACE_NTOHL (0x74726962), 
  ACE_NTOHL (0x75746162), 
  ACE_NTOHL (0x6c655468), 
  ACE_NTOHL (0x72656164), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:RTScheduling/DistributableThread:1.0
  20,
  ACE_NTOHL (0x44697374), 
  ACE_NTOHL (0x72696275), 
  ACE_NTOHL (0x7461626c), 
  ACE_NTOHL (0x65546872), 
  ACE_NTOHL (0x65616400),  // name = DistributableThread
};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_DistributableThread (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_DistributableThread),
    (char *) &_oc_RTScheduling_DistributableThread,
    0,
    sizeof (RTScheduling::DistributableThread)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_DistributableThread,
    &_tc_TAO_tc_RTScheduling_DistributableThread
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int RTScheduling::Current::_tao_class_id = 0;

RTScheduling::Current_ptr
tao_RTScheduling_Current_duplicate (
    RTScheduling::Current_ptr p
  )
{
  return RTScheduling::Current::_duplicate (p);
}

void
tao_RTScheduling_Current_release (
    RTScheduling::Current_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::Current_ptr
tao_RTScheduling_Current_nil (
    void
  )
{
  return RTScheduling::Current::_nil ();
}

RTScheduling::Current_ptr
tao_RTScheduling_Current_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return RTScheduling::Current::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_RTScheduling_Current_upcast (
    void *src
  )
{
  RTScheduling::Current **tmp =
    ACE_static_cast (RTScheduling::Current **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// RTScheduling::Current_var
// *************************************************************

RTScheduling::Current_var::Current_var (void)
  : ptr_ (Current::_nil ())
{}

::RTScheduling::Current_ptr
RTScheduling::Current_var::ptr (void) const
{
  return this->ptr_;
}

RTScheduling::Current_var::Current_var (const ::RTScheduling::Current_var &p)
  : TAO_Base_var (),
    ptr_ (Current::_duplicate (p.ptr ()))
{}

RTScheduling::Current_var::~Current_var (void)
{
  CORBA::release (this->ptr_);
}

RTScheduling::Current_var &
RTScheduling::Current_var::operator= (Current_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

RTScheduling::Current_var &
RTScheduling::Current_var::operator= (const ::RTScheduling::Current_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::RTScheduling::Current::_duplicate (p.ptr ());
  }
  return *this;
}

RTScheduling::Current_var::operator const ::RTScheduling::Current_ptr &() const // cast
{
  return this->ptr_;
}

RTScheduling::Current_var::operator ::RTScheduling::Current_ptr &() // cast 
{
  return this->ptr_;
}

::RTScheduling::Current_ptr
RTScheduling::Current_var::operator-> (void) const
{
  return this->ptr_;
}

::RTScheduling::Current_ptr
RTScheduling::Current_var::in (void) const
{
  return this->ptr_;
}

::RTScheduling::Current_ptr &
RTScheduling::Current_var::inout (void)
{
  return this->ptr_;
}

::RTScheduling::Current_ptr &
RTScheduling::Current_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::Current::_nil ();
  return this->ptr_;
}

::RTScheduling::Current_ptr
RTScheduling::Current_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::RTScheduling::Current_ptr val = this->ptr_;
  this->ptr_ = ::RTScheduling::Current::_nil ();
  return val;
}

::RTScheduling::Current_ptr
RTScheduling::Current_var::tao_duplicate (Current_ptr p)
{
  return ::RTScheduling::Current::_duplicate (p);
}

void
RTScheduling::Current_var::tao_release (Current_ptr p)
{
  CORBA::release (p);
}

::RTScheduling::Current_ptr
RTScheduling::Current_var::tao_nil (void)
{
  return ::RTScheduling::Current::_nil ();
}

::RTScheduling::Current_ptr
RTScheduling::Current_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::RTScheduling::Current::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::Current_var::tao_upcast (void *src)
{
  Current **tmp =
    ACE_static_cast (Current **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// RTScheduling::Current_out
// *************************************************************

RTScheduling::Current_out::Current_out (Current_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::RTScheduling::Current::_nil ();
}

RTScheduling::Current_out::Current_out (Current_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::Current::_nil ();
}

RTScheduling::Current_out::Current_out (const ::RTScheduling::Current_out &p)
  : ptr_ (ACE_const_cast (Current_out &, p).ptr_)
{}

::RTScheduling::Current_out &
RTScheduling::Current_out::operator= (const ::RTScheduling::Current_out &p)
{
  this->ptr_ = ACE_const_cast (Current_out&, p).ptr_;
  return *this;
}

RTScheduling::Current_out &
RTScheduling::Current_out::operator= (const ::RTScheduling::Current_var &p)
{
  this->ptr_ = ::RTScheduling::Current::_duplicate (p.ptr ());
  return *this;
}

RTScheduling::Current_out &
RTScheduling::Current_out::operator= (Current_ptr p)
{
  this->ptr_ = p;
  return *this;
}

RTScheduling::Current_out::operator ::RTScheduling::Current_ptr &() // cast
{
  return this->ptr_;
}

::RTScheduling::Current_ptr &
RTScheduling::Current_out::ptr (void)
{
  return this->ptr_;
}

::RTScheduling::Current_ptr
RTScheduling::Current_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

RTScheduling::Current::Current (void)
{}

RTScheduling::Current::~Current (void)
{}

void 
RTScheduling::Current::_tao_any_destructor (void *_tao_void_pointer)
{
  Current *tmp = ACE_static_cast (Current *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::Current_ptr
RTScheduling::Current::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return Current::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::Current_ptr 
RTScheduling::Current::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Current::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          Current_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Current::_tao_class_id
                )
            )
        );
}

RTScheduling::Current_ptr
RTScheduling::Current::_duplicate (Current_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::Current::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::RTScheduling, Current)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::RTCORBA::Current::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                RTCORBA::Current_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Current::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Current_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::Current::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/Current:1.0";
}

// TAO_IDL - Generated from 
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::UNSUPPORTED_SCHEDULING_DISCIPLINE (void)
  : CORBA_UserException (
        "IDL:RTScheduling/Current/UNSUPPORTED_SCHEDULING_DISCIPLINE:1.0",
        "UNSUPPORTED_SCHEDULING_DISCIPLINE"
      )
{
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::~UNSUPPORTED_SCHEDULING_DISCIPLINE (void)
{
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::UNSUPPORTED_SCHEDULING_DISCIPLINE (const ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE&
RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::operator= (const ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_any_destructor (void *_tao_void_pointer)
{
  UNSUPPORTED_SCHEDULING_DISCIPLINE *tmp = ACE_static_cast (UNSUPPORTED_SCHEDULING_DISCIPLINE*, _tao_void_pointer);
  delete tmp;
}

RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE *
RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:RTScheduling/Current/UNSUPPORTED_SCHEDULING_DISCIPLINE:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (UNSUPPORTED_SCHEDULING_DISCIPLINE *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE, 0);
  return retval;
}

CORBA::Exception *
RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE (*this),
      0
    );
  return result;
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_raise (void)
{
  TAO_RAISE (*this);
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE::_type (void) const
{
  return ::RTScheduling::Current::_tc_UNSUPPORTED_SCHEDULING_DISCIPLINE;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  63,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x2f554e53), 
  ACE_NTOHL (0x5550504f), 
  ACE_NTOHL (0x52544544), 
  ACE_NTOHL (0x5f534348), 
  ACE_NTOHL (0x4544554c), 
  ACE_NTOHL (0x494e475f), 
  ACE_NTOHL (0x44495343), 
  ACE_NTOHL (0x49504c49), 
  ACE_NTOHL (0x4e453a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:RTScheduling/Current/UNSUPPORTED_SCHEDULING_DISCIPLINE:1.0
  34,
  ACE_NTOHL (0x554e5355), 
  ACE_NTOHL (0x50504f52), 
  ACE_NTOHL (0x5445445f), 
  ACE_NTOHL (0x53434845), 
  ACE_NTOHL (0x44554c49), 
  ACE_NTOHL (0x4e475f44), 
  ACE_NTOHL (0x49534349), 
  ACE_NTOHL (0x504c494e), 
  ACE_NTOHL (0x45000000),  // name = UNSUPPORTED_SCHEDULING_DISCIPLINE
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE (
    CORBA::tk_except,
    sizeof (_oc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE),
    (char *) &_oc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE,
    0,
    sizeof (RTScheduling::Current::UNSUPPORTED_SCHEDULING_DISCIPLINE)
  );

::CORBA::TypeCode_ptr RTScheduling::Current::_tc_UNSUPPORTED_SCHEDULING_DISCIPLINE =
  &_tc_TAO_tc_RTScheduling_Current_UNSUPPORTED_SCHEDULING_DISCIPLINE;

#if !defined (_RTSCHEDULING_CURRENT_IDTYPE_CS_)
#define _RTSCHEDULING_CURRENT_IDTYPE_CS_

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// RTScheduling::Current::IdType
// *************************************************************

RTScheduling::Current::IdType::IdType (void)
{}

RTScheduling::Current::IdType::IdType (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

RTScheduling::Current::IdType::IdType (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Octet *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

RTScheduling::Current::IdType::IdType (const IdType &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

RTScheduling::Current::IdType::~IdType (void) // dtor
{}

void RTScheduling::Current::IdType::_tao_any_destructor (void *_tao_void_pointer)
{
  IdType *tmp = ACE_static_cast (IdType*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current_IdType[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  36,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x2f496454), 
  ACE_NTOHL (0x7970653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:RTScheduling/Current/IdType:1.0
  7,
  ACE_NTOHL (0x49645479), 
  ACE_NTOHL (0x70650000),  // name = IdType
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current_IdType (
    CORBA::tk_alias,
    sizeof (_oc_RTScheduling_Current_IdType),
    (char *) &_oc_RTScheduling_Current_IdType,
    0,
    sizeof (RTScheduling::Current::IdType)
  );

::CORBA::TypeCode_ptr RTScheduling::Current::_tc_IdType =
  &_tc_TAO_tc_RTScheduling_Current_IdType;

#if !defined (_RTSCHEDULING_CURRENT_NAMELIST_CS_)
#define _RTSCHEDULING_CURRENT_NAMELIST_CS_

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:250

// *************************************************************
// RTScheduling::Current::NameList
// *************************************************************

RTScheduling::Current::NameList::NameList (void)
{}

RTScheduling::Current::NameList::NameList (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

RTScheduling::Current::NameList::NameList (
    CORBA::ULong max,
    CORBA::ULong length,
    char * *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

RTScheduling::Current::NameList::NameList (const NameList &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_String_Sequence

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

RTScheduling::Current::NameList::~NameList (void) // dtor
{}

void RTScheduling::Current::NameList::_tao_any_destructor (void *_tao_void_pointer)
{
  NameList *tmp = ACE_static_cast (NameList*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current_NameList[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  38,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x2f4e616d), 
  ACE_NTOHL (0x654c6973), 
  ACE_NTOHL (0x743a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:RTScheduling/Current/NameList:1.0
  9,
  ACE_NTOHL (0x4e616d65), 
  ACE_NTOHL (0x4c697374), 
  ACE_NTOHL (0x0),  // name = NameList
  CORBA::tk_sequence, // typecode kind
  16, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_string, 
    0U, // string length
    0U,

};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current_NameList (
    CORBA::tk_alias,
    sizeof (_oc_RTScheduling_Current_NameList),
    (char *) &_oc_RTScheduling_Current_NameList,
    0,
    sizeof (RTScheduling::Current::NameList)
  );

::CORBA::TypeCode_ptr RTScheduling::Current::_tc_NameList =
  &_tc_TAO_tc_RTScheduling_Current_NameList;

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Current[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  29,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f437572), 
  ACE_NTOHL (0x72656e74), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:RTScheduling/Current:1.0
  8,
  ACE_NTOHL (0x43757272), 
  ACE_NTOHL (0x656e7400),  // name = Current
};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Current (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_Current),
    (char *) &_oc_RTScheduling_Current,
    0,
    sizeof (RTScheduling::Current)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Current,
    &_tc_TAO_tc_RTScheduling_Current
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int RTScheduling::ResourceManager::_tao_class_id = 0;

RTScheduling::ResourceManager_ptr
tao_RTScheduling_ResourceManager_duplicate (
    RTScheduling::ResourceManager_ptr p
  )
{
  return RTScheduling::ResourceManager::_duplicate (p);
}

void
tao_RTScheduling_ResourceManager_release (
    RTScheduling::ResourceManager_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::ResourceManager_ptr
tao_RTScheduling_ResourceManager_nil (
    void
  )
{
  return RTScheduling::ResourceManager::_nil ();
}

RTScheduling::ResourceManager_ptr
tao_RTScheduling_ResourceManager_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return RTScheduling::ResourceManager::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_RTScheduling_ResourceManager_upcast (
    void *src
  )
{
  RTScheduling::ResourceManager **tmp =
    ACE_static_cast (RTScheduling::ResourceManager **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// RTScheduling::ResourceManager_var
// *************************************************************

RTScheduling::ResourceManager_var::ResourceManager_var (void)
  : ptr_ (ResourceManager::_nil ())
{}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_var::ptr (void) const
{
  return this->ptr_;
}

RTScheduling::ResourceManager_var::ResourceManager_var (const ::RTScheduling::ResourceManager_var &p)
  : TAO_Base_var (),
    ptr_ (ResourceManager::_duplicate (p.ptr ()))
{}

RTScheduling::ResourceManager_var::~ResourceManager_var (void)
{
  CORBA::release (this->ptr_);
}

RTScheduling::ResourceManager_var &
RTScheduling::ResourceManager_var::operator= (ResourceManager_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

RTScheduling::ResourceManager_var &
RTScheduling::ResourceManager_var::operator= (const ::RTScheduling::ResourceManager_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::RTScheduling::ResourceManager::_duplicate (p.ptr ());
  }
  return *this;
}

RTScheduling::ResourceManager_var::operator const ::RTScheduling::ResourceManager_ptr &() const // cast
{
  return this->ptr_;
}

RTScheduling::ResourceManager_var::operator ::RTScheduling::ResourceManager_ptr &() // cast 
{
  return this->ptr_;
}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_var::operator-> (void) const
{
  return this->ptr_;
}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_var::in (void) const
{
  return this->ptr_;
}

::RTScheduling::ResourceManager_ptr &
RTScheduling::ResourceManager_var::inout (void)
{
  return this->ptr_;
}

::RTScheduling::ResourceManager_ptr &
RTScheduling::ResourceManager_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::ResourceManager::_nil ();
  return this->ptr_;
}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::RTScheduling::ResourceManager_ptr val = this->ptr_;
  this->ptr_ = ::RTScheduling::ResourceManager::_nil ();
  return val;
}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_var::tao_duplicate (ResourceManager_ptr p)
{
  return ::RTScheduling::ResourceManager::_duplicate (p);
}

void
RTScheduling::ResourceManager_var::tao_release (ResourceManager_ptr p)
{
  CORBA::release (p);
}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_var::tao_nil (void)
{
  return ::RTScheduling::ResourceManager::_nil ();
}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::RTScheduling::ResourceManager::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::ResourceManager_var::tao_upcast (void *src)
{
  ResourceManager **tmp =
    ACE_static_cast (ResourceManager **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// RTScheduling::ResourceManager_out
// *************************************************************

RTScheduling::ResourceManager_out::ResourceManager_out (ResourceManager_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::RTScheduling::ResourceManager::_nil ();
}

RTScheduling::ResourceManager_out::ResourceManager_out (ResourceManager_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::ResourceManager::_nil ();
}

RTScheduling::ResourceManager_out::ResourceManager_out (const ::RTScheduling::ResourceManager_out &p)
  : ptr_ (ACE_const_cast (ResourceManager_out &, p).ptr_)
{}

::RTScheduling::ResourceManager_out &
RTScheduling::ResourceManager_out::operator= (const ::RTScheduling::ResourceManager_out &p)
{
  this->ptr_ = ACE_const_cast (ResourceManager_out&, p).ptr_;
  return *this;
}

RTScheduling::ResourceManager_out &
RTScheduling::ResourceManager_out::operator= (const ::RTScheduling::ResourceManager_var &p)
{
  this->ptr_ = ::RTScheduling::ResourceManager::_duplicate (p.ptr ());
  return *this;
}

RTScheduling::ResourceManager_out &
RTScheduling::ResourceManager_out::operator= (ResourceManager_ptr p)
{
  this->ptr_ = p;
  return *this;
}

RTScheduling::ResourceManager_out::operator ::RTScheduling::ResourceManager_ptr &() // cast
{
  return this->ptr_;
}

::RTScheduling::ResourceManager_ptr &
RTScheduling::ResourceManager_out::ptr (void)
{
  return this->ptr_;
}

::RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

RTScheduling::ResourceManager::ResourceManager (void)
{}

RTScheduling::ResourceManager::~ResourceManager (void)
{}

void 
RTScheduling::ResourceManager::_tao_any_destructor (void *_tao_void_pointer)
{
  ResourceManager *tmp = ACE_static_cast (ResourceManager *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ResourceManager::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::ResourceManager_ptr 
RTScheduling::ResourceManager::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ResourceManager::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          ResourceManager_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ResourceManager::_tao_class_id
                )
            )
        );
}

RTScheduling::ResourceManager_ptr
RTScheduling::ResourceManager::_duplicate (ResourceManager_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::ResourceManager::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::RTScheduling, ResourceManager)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::RTCORBA::Mutex::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                RTCORBA::Mutex_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::ResourceManager::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/ResourceManager:1.0";
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_ResourceManager[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f526573), 
  ACE_NTOHL (0x6f757263), 
  ACE_NTOHL (0x654d616e), 
  ACE_NTOHL (0x61676572), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:RTScheduling/ResourceManager:1.0
  16,
  ACE_NTOHL (0x5265736f), 
  ACE_NTOHL (0x75726365), 
  ACE_NTOHL (0x4d616e61), 
  ACE_NTOHL (0x67657200),  // name = ResourceManager
};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_ResourceManager (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_ResourceManager),
    (char *) &_oc_RTScheduling_ResourceManager,
    0,
    sizeof (RTScheduling::ResourceManager)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ResourceManager,
    &_tc_TAO_tc_RTScheduling_ResourceManager
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int RTScheduling::Scheduler::_tao_class_id = 0;

RTScheduling::Scheduler_ptr
tao_RTScheduling_Scheduler_duplicate (
    RTScheduling::Scheduler_ptr p
  )
{
  return RTScheduling::Scheduler::_duplicate (p);
}

void
tao_RTScheduling_Scheduler_release (
    RTScheduling::Scheduler_ptr p
  )
{
  CORBA::release (p);
}

RTScheduling::Scheduler_ptr
tao_RTScheduling_Scheduler_nil (
    void
  )
{
  return RTScheduling::Scheduler::_nil ();
}

RTScheduling::Scheduler_ptr
tao_RTScheduling_Scheduler_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return RTScheduling::Scheduler::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_RTScheduling_Scheduler_upcast (
    void *src
  )
{
  RTScheduling::Scheduler **tmp =
    ACE_static_cast (RTScheduling::Scheduler **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// RTScheduling::Scheduler_var
// *************************************************************

RTScheduling::Scheduler_var::Scheduler_var (void)
  : ptr_ (Scheduler::_nil ())
{}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_var::ptr (void) const
{
  return this->ptr_;
}

RTScheduling::Scheduler_var::Scheduler_var (const ::RTScheduling::Scheduler_var &p)
  : TAO_Base_var (),
    ptr_ (Scheduler::_duplicate (p.ptr ()))
{}

RTScheduling::Scheduler_var::~Scheduler_var (void)
{
  CORBA::release (this->ptr_);
}

RTScheduling::Scheduler_var &
RTScheduling::Scheduler_var::operator= (Scheduler_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

RTScheduling::Scheduler_var &
RTScheduling::Scheduler_var::operator= (const ::RTScheduling::Scheduler_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::RTScheduling::Scheduler::_duplicate (p.ptr ());
  }
  return *this;
}

RTScheduling::Scheduler_var::operator const ::RTScheduling::Scheduler_ptr &() const // cast
{
  return this->ptr_;
}

RTScheduling::Scheduler_var::operator ::RTScheduling::Scheduler_ptr &() // cast 
{
  return this->ptr_;
}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_var::operator-> (void) const
{
  return this->ptr_;
}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_var::in (void) const
{
  return this->ptr_;
}

::RTScheduling::Scheduler_ptr &
RTScheduling::Scheduler_var::inout (void)
{
  return this->ptr_;
}

::RTScheduling::Scheduler_ptr &
RTScheduling::Scheduler_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::Scheduler::_nil ();
  return this->ptr_;
}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::RTScheduling::Scheduler_ptr val = this->ptr_;
  this->ptr_ = ::RTScheduling::Scheduler::_nil ();
  return val;
}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_var::tao_duplicate (Scheduler_ptr p)
{
  return ::RTScheduling::Scheduler::_duplicate (p);
}

void
RTScheduling::Scheduler_var::tao_release (Scheduler_ptr p)
{
  CORBA::release (p);
}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_var::tao_nil (void)
{
  return ::RTScheduling::Scheduler::_nil ();
}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::RTScheduling::Scheduler::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
RTScheduling::Scheduler_var::tao_upcast (void *src)
{
  Scheduler **tmp =
    ACE_static_cast (Scheduler **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// RTScheduling::Scheduler_out
// *************************************************************

RTScheduling::Scheduler_out::Scheduler_out (Scheduler_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::RTScheduling::Scheduler::_nil ();
}

RTScheduling::Scheduler_out::Scheduler_out (Scheduler_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::RTScheduling::Scheduler::_nil ();
}

RTScheduling::Scheduler_out::Scheduler_out (const ::RTScheduling::Scheduler_out &p)
  : ptr_ (ACE_const_cast (Scheduler_out &, p).ptr_)
{}

::RTScheduling::Scheduler_out &
RTScheduling::Scheduler_out::operator= (const ::RTScheduling::Scheduler_out &p)
{
  this->ptr_ = ACE_const_cast (Scheduler_out&, p).ptr_;
  return *this;
}

RTScheduling::Scheduler_out &
RTScheduling::Scheduler_out::operator= (const ::RTScheduling::Scheduler_var &p)
{
  this->ptr_ = ::RTScheduling::Scheduler::_duplicate (p.ptr ());
  return *this;
}

RTScheduling::Scheduler_out &
RTScheduling::Scheduler_out::operator= (Scheduler_ptr p)
{
  this->ptr_ = p;
  return *this;
}

RTScheduling::Scheduler_out::operator ::RTScheduling::Scheduler_ptr &() // cast
{
  return this->ptr_;
}

::RTScheduling::Scheduler_ptr &
RTScheduling::Scheduler_out::ptr (void)
{
  return this->ptr_;
}

::RTScheduling::Scheduler_ptr
RTScheduling::Scheduler_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:225

RTScheduling::Scheduler::Scheduler (void)
{}

RTScheduling::Scheduler::~Scheduler (void)
{}

void 
RTScheduling::Scheduler::_tao_any_destructor (void *_tao_void_pointer)
{
  Scheduler *tmp = ACE_static_cast (Scheduler *, _tao_void_pointer);
  CORBA::release (tmp);
}

RTScheduling::Scheduler_ptr
RTScheduling::Scheduler::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return Scheduler::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

RTScheduling::Scheduler_ptr 
RTScheduling::Scheduler::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Scheduler::_nil ();
    }
  
  return
      ACE_reinterpret_cast (
          Scheduler_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Scheduler::_tao_class_id
                )
            )
        );
}

RTScheduling::Scheduler_ptr
RTScheduling::Scheduler::_duplicate (Scheduler_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void *RTScheduling::Scheduler::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::RTScheduling, Scheduler)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* RTScheduling::Scheduler::_interface_repository_id (void) const
{
  return "IDL:RTScheduling/Scheduler:1.0";
}

// TAO_IDL - Generated from 
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::INCOMPATIBLE_SCHEDULING_DISCIPLINES (void)
  : CORBA_UserException (
        "IDL:RTScheduling/Scheduler/INCOMPATIBLE_SCHEDULING_DISCIPLINES:1.0",
        "INCOMPATIBLE_SCHEDULING_DISCIPLINES"
      )
{
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::~INCOMPATIBLE_SCHEDULING_DISCIPLINES (void)
{
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::INCOMPATIBLE_SCHEDULING_DISCIPLINES (const ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES &_tao_excp)
  : CORBA_UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES&
RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::operator= (const ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_any_destructor (void *_tao_void_pointer)
{
  INCOMPATIBLE_SCHEDULING_DISCIPLINES *tmp = ACE_static_cast (INCOMPATIBLE_SCHEDULING_DISCIPLINES*, _tao_void_pointer);
  delete tmp;
}

RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES *
RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:RTScheduling/Scheduler/INCOMPATIBLE_SCHEDULING_DISCIPLINES:1.0", exc->_rep_id ()))
    {
      return ACE_dynamic_cast (INCOMPATIBLE_SCHEDULING_DISCIPLINES *, exc);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES, 0);
  return retval;
}

CORBA::Exception *
RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES (*this),
      0
    );
  return result;
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_raise (void)
{
  TAO_RAISE (*this);
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES::_type (void) const
{
  return ::RTScheduling::Scheduler::_tc_INCOMPATIBLE_SCHEDULING_DISCIPLINES;
}

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  67,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f536368), 
  ACE_NTOHL (0x6564756c), 
  ACE_NTOHL (0x65722f49), 
  ACE_NTOHL (0x4e434f4d), 
  ACE_NTOHL (0x50415449), 
  ACE_NTOHL (0x424c455f), 
  ACE_NTOHL (0x53434845), 
  ACE_NTOHL (0x44554c49), 
  ACE_NTOHL (0x4e475f44), 
  ACE_NTOHL (0x49534349), 
  ACE_NTOHL (0x504c494e), 
  ACE_NTOHL (0x45533a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:RTScheduling/Scheduler/INCOMPATIBLE_SCHEDULING_DISCIPLINES:1.0
  36,
  ACE_NTOHL (0x494e434f), 
  ACE_NTOHL (0x4d504154), 
  ACE_NTOHL (0x49424c45), 
  ACE_NTOHL (0x5f534348), 
  ACE_NTOHL (0x4544554c), 
  ACE_NTOHL (0x494e475f), 
  ACE_NTOHL (0x44495343), 
  ACE_NTOHL (0x49504c49), 
  ACE_NTOHL (0x4e455300),  // name = INCOMPATIBLE_SCHEDULING_DISCIPLINES
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES (
    CORBA::tk_except,
    sizeof (_oc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES),
    (char *) &_oc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES,
    0,
    sizeof (RTScheduling::Scheduler::INCOMPATIBLE_SCHEDULING_DISCIPLINES)
  );

::CORBA::TypeCode_ptr RTScheduling::Scheduler::_tc_INCOMPATIBLE_SCHEDULING_DISCIPLINES =
  &_tc_TAO_tc_RTScheduling_Scheduler_INCOMPATIBLE_SCHEDULING_DISCIPLINES;

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_RTScheduling_Scheduler[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x52545363), 
  ACE_NTOHL (0x68656475), 
  ACE_NTOHL (0x6c696e67), 
  ACE_NTOHL (0x2f536368), 
  ACE_NTOHL (0x6564756c), 
  ACE_NTOHL (0x65723a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:RTScheduling/Scheduler:1.0
  10,
  ACE_NTOHL (0x53636865), 
  ACE_NTOHL (0x64756c65), 
  ACE_NTOHL (0x72000000),  // name = Scheduler
};

static CORBA::TypeCode _tc_TAO_tc_RTScheduling_Scheduler (
    CORBA::tk_objref,
    sizeof (_oc_RTScheduling_Scheduler),
    (char *) &_oc_RTScheduling_Scheduler,
    0,
    sizeof (RTScheduling::Scheduler)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (RTScheduling)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Scheduler,
    &_tc_TAO_tc_RTScheduling_Scheduler
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ThreadAction_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_ThreadAction,
      1,
      RTScheduling::ThreadAction::_duplicate (_tao_elem),
      RTScheduling::ThreadAction::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ThreadAction_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_ThreadAction,
      1,
      *_tao_elem,
      RTScheduling::ThreadAction::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::ThreadAction_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = RTScheduling::ThreadAction::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          RTScheduling::_tc_ThreadAction
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          RTScheduling::ThreadAction_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
      
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = RTScheduling::ThreadAction::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<RTScheduling::ThreadAction,RTScheduling::ThreadAction_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<RTScheduling::ThreadAction,RTScheduling::ThreadAction_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::DistributableThread_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_DistributableThread,
      1,
      RTScheduling::DistributableThread::_duplicate (_tao_elem),
      RTScheduling::DistributableThread::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::DistributableThread_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_DistributableThread,
      1,
      *_tao_elem,
      RTScheduling::DistributableThread::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::DistributableThread_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = RTScheduling::DistributableThread::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          RTScheduling::_tc_DistributableThread
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          RTScheduling::DistributableThread_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
      
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = RTScheduling::DistributableThread::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<RTScheduling::DistributableThread,RTScheduling::DistributableThread_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<RTScheduling::DistributableThread,RTScheduling::DistributableThread_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Current_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_Current,
      1,
      RTScheduling::Current::_duplicate (_tao_elem),
      RTScheduling::Current::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Current_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_Current,
      1,
      *_tao_elem,
      RTScheduling::Current::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::Current_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = RTScheduling::Current::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          RTScheduling::_tc_Current
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          RTScheduling::Current_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
      
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = RTScheduling::Current::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<RTScheduling::Current,RTScheduling::Current_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<RTScheduling::Current,RTScheduling::Current_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ResourceManager_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_ResourceManager,
      1,
      RTScheduling::ResourceManager::_duplicate (_tao_elem),
      RTScheduling::ResourceManager::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::ResourceManager_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_ResourceManager,
      1,
      *_tao_elem,
      RTScheduling::ResourceManager::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::ResourceManager_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = RTScheduling::ResourceManager::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          RTScheduling::_tc_ResourceManager
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          RTScheduling::ResourceManager_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
      
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = RTScheduling::ResourceManager::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<RTScheduling::ResourceManager,RTScheduling::ResourceManager_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<RTScheduling::ResourceManager,RTScheduling::ResourceManager_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// C:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Scheduler_ptr _tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_Scheduler,
      1,
      RTScheduling::Scheduler::_duplicate (_tao_elem),
      RTScheduling::Scheduler::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

// Non-copying version.
void
operator<<= (
    CORBA::Any &_tao_any,
    RTScheduling::Scheduler_ptr *_tao_elem
  )
{
  _tao_any._tao_replace (
      RTScheduling::_tc_Scheduler,
      1,
      *_tao_elem,
      RTScheduling::Scheduler::_tao_any_destructor
    );
  
  _tao_any.contains_local (1);
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    RTScheduling::Scheduler_ptr &_tao_elem
  )
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = RTScheduling::Scheduler::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result =
      type->equivalent (
          RTScheduling::_tc_Scheduler
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    
    if (!result)
      {
        return 0; // not equivalent
      }
    
    _tao_elem =
      ACE_reinterpret_cast (
          RTScheduling::Scheduler_ptr,
          ACE_const_cast (void *, _tao_any.value ())
        );
      
    return 1;
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  
  _tao_elem = RTScheduling::Scheduler::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<RTScheduling::Scheduler,RTScheduling::Scheduler_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<RTScheduling::Scheduler,RTScheduling::Scheduler_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

