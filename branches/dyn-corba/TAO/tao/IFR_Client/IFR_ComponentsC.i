// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_EVENTDEF___CI_)
#define _CORBA_COMPONENTIR_EVENTDEF___CI_

ACE_INLINE
CORBA::ComponentIR::EventDef::EventDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_EventDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::EventDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_CONTAINER___CI_)
#define _CORBA_COMPONENTIR_CONTAINER___CI_

ACE_INLINE
CORBA::ComponentIR::Container::Container (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_Container_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::Container::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_MODULEDEF___CI_)
#define _CORBA_COMPONENTIR_MODULEDEF___CI_

ACE_INLINE
CORBA::ComponentIR::ModuleDef::ModuleDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_ModuleDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::ModuleDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_REPOSITORY___CI_)
#define _CORBA_COMPONENTIR_REPOSITORY___CI_

ACE_INLINE
CORBA::ComponentIR::Repository::Repository (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_Repository_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::Repository::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_PROVIDESDEF___CI_)
#define _CORBA_COMPONENTIR_PROVIDESDEF___CI_

ACE_INLINE
CORBA::ComponentIR::ProvidesDef::ProvidesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_ProvidesDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::ProvidesDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:194

// *************************************************************
// Inline operations for class CORBA::ComponentIR::ProvidesDescription_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::ProvidesDescription_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::ProvidesDescription_var (ProvidesDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::ProvidesDescription_var (const ::CORBA::ComponentIR::ProvidesDescription_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::ProvidesDescription (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::~ProvidesDescription_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var &
CORBA::ComponentIR::ProvidesDescription_var::operator= (ProvidesDescription *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescription_var &
CORBA::ComponentIR::ProvidesDescription_var::operator= (const ::CORBA::ComponentIR::ProvidesDescription_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ProvidesDescription *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              ProvidesDescription (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              ProvidesDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::ProvidesDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::ProvidesDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::operator const ::CORBA::ComponentIR::ProvidesDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::operator ::CORBA::ComponentIR::ProvidesDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::operator ::CORBA::ComponentIR::ProvidesDescription &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_var::operator ::CORBA::ComponentIR::ProvidesDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::CORBA::ComponentIR::ProvidesDescription &
CORBA::ComponentIR::ProvidesDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ProvidesDescription &
CORBA::ComponentIR::ProvidesDescription_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::CORBA::ComponentIR::ProvidesDescription *&
CORBA::ComponentIR::ProvidesDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::ProvidesDescription_var::_retn (void)
{
  ::CORBA::ComponentIR::ProvidesDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::ProvidesDescription_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:523

// *************************************************************
// Inline operations for class CORBA::ComponentIR::ProvidesDescription_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_out::ProvidesDescription_out (::CORBA::ComponentIR::ProvidesDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_out::ProvidesDescription_out (ProvidesDescription_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_out::ProvidesDescription_out (const ::CORBA::ComponentIR::ProvidesDescription_out &p)
  : ptr_ (ACE_const_cast (ProvidesDescription_out&, p).ptr_)
{}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_out &
CORBA::ComponentIR::ProvidesDescription_out::operator= (const ::CORBA::ComponentIR::ProvidesDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription_out &
CORBA::ComponentIR::ProvidesDescription_out::operator= (ProvidesDescription *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
CORBA::ComponentIR::ProvidesDescription_out::operator ::CORBA::ComponentIR::ProvidesDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ProvidesDescription *&
CORBA::ComponentIR::ProvidesDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::ProvidesDescription_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_USESDEF___CI_)
#define _CORBA_COMPONENTIR_USESDEF___CI_

ACE_INLINE
CORBA::ComponentIR::UsesDef::UsesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_UsesDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::UsesDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:194

// *************************************************************
// Inline operations for class CORBA::ComponentIR::UsesDescription_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::UsesDescription_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::UsesDescription_var (UsesDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::UsesDescription_var (const ::CORBA::ComponentIR::UsesDescription_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::UsesDescription (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::~UsesDescription_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var &
CORBA::ComponentIR::UsesDescription_var::operator= (UsesDescription *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescription_var &
CORBA::ComponentIR::UsesDescription_var::operator= (const ::CORBA::ComponentIR::UsesDescription_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UsesDescription *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              UsesDescription (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              UsesDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::UsesDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::UsesDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::operator const ::CORBA::ComponentIR::UsesDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::operator ::CORBA::ComponentIR::UsesDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::operator ::CORBA::ComponentIR::UsesDescription &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::UsesDescription_var::operator ::CORBA::ComponentIR::UsesDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::CORBA::ComponentIR::UsesDescription &
CORBA::ComponentIR::UsesDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::UsesDescription &
CORBA::ComponentIR::UsesDescription_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::CORBA::ComponentIR::UsesDescription *&
CORBA::ComponentIR::UsesDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::UsesDescription_var::_retn (void)
{
  ::CORBA::ComponentIR::UsesDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::UsesDescription_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:523

// *************************************************************
// Inline operations for class CORBA::ComponentIR::UsesDescription_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::UsesDescription_out::UsesDescription_out (::CORBA::ComponentIR::UsesDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_out::UsesDescription_out (UsesDescription_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_out::UsesDescription_out (const ::CORBA::ComponentIR::UsesDescription_out &p)
  : ptr_ (ACE_const_cast (UsesDescription_out&, p).ptr_)
{}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_out &
CORBA::ComponentIR::UsesDescription_out::operator= (const ::CORBA::ComponentIR::UsesDescription_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription_out &
CORBA::ComponentIR::UsesDescription_out::operator= (UsesDescription *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
CORBA::ComponentIR::UsesDescription_out::operator ::CORBA::ComponentIR::UsesDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::UsesDescription *&
CORBA::ComponentIR::UsesDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::UsesDescription_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_EVENTPORTDEF___CI_)
#define _CORBA_COMPONENTIR_EVENTPORTDEF___CI_

ACE_INLINE
CORBA::ComponentIR::EventPortDef::EventPortDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_EventPortDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::EventPortDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:194

// *************************************************************
// Inline operations for class CORBA::ComponentIR::EventPortDescription_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::EventPortDescription_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::EventPortDescription_var (EventPortDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::EventPortDescription_var (const ::CORBA::ComponentIR::EventPortDescription_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::EventPortDescription (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::~EventPortDescription_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var &
CORBA::ComponentIR::EventPortDescription_var::operator= (EventPortDescription *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescription_var &
CORBA::ComponentIR::EventPortDescription_var::operator= (const ::CORBA::ComponentIR::EventPortDescription_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          EventPortDescription *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              EventPortDescription (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              EventPortDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::EventPortDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::EventPortDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::operator const ::CORBA::ComponentIR::EventPortDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::operator ::CORBA::ComponentIR::EventPortDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::operator ::CORBA::ComponentIR::EventPortDescription &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::EventPortDescription_var::operator ::CORBA::ComponentIR::EventPortDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::CORBA::ComponentIR::EventPortDescription &
CORBA::ComponentIR::EventPortDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::EventPortDescription &
CORBA::ComponentIR::EventPortDescription_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::CORBA::ComponentIR::EventPortDescription *&
CORBA::ComponentIR::EventPortDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::EventPortDescription_var::_retn (void)
{
  ::CORBA::ComponentIR::EventPortDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::EventPortDescription_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:523

// *************************************************************
// Inline operations for class CORBA::ComponentIR::EventPortDescription_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_out::EventPortDescription_out (::CORBA::ComponentIR::EventPortDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_out::EventPortDescription_out (EventPortDescription_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_out::EventPortDescription_out (const ::CORBA::ComponentIR::EventPortDescription_out &p)
  : ptr_ (ACE_const_cast (EventPortDescription_out&, p).ptr_)
{}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_out &
CORBA::ComponentIR::EventPortDescription_out::operator= (const ::CORBA::ComponentIR::EventPortDescription_out &p)
{
  this->ptr_ = ACE_const_cast (EventPortDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription_out &
CORBA::ComponentIR::EventPortDescription_out::operator= (EventPortDescription *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
CORBA::ComponentIR::EventPortDescription_out::operator ::CORBA::ComponentIR::EventPortDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::EventPortDescription *&
CORBA::ComponentIR::EventPortDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::EventPortDescription_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_EMITSDEF___CI_)
#define _CORBA_COMPONENTIR_EMITSDEF___CI_

ACE_INLINE
CORBA::ComponentIR::EmitsDef::EmitsDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_EmitsDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::EmitsDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_PUBLISHESDEF___CI_)
#define _CORBA_COMPONENTIR_PUBLISHESDEF___CI_

ACE_INLINE
CORBA::ComponentIR::PublishesDef::PublishesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_PublishesDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::PublishesDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_CONSUMESDEF___CI_)
#define _CORBA_COMPONENTIR_CONSUMESDEF___CI_

ACE_INLINE
CORBA::ComponentIR::ConsumesDef::ConsumesDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_ConsumesDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::ConsumesDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_COMPONENTDEF___CI_)
#define _CORBA_COMPONENTIR_COMPONENTDEF___CI_

ACE_INLINE
CORBA::ComponentIR::ComponentDef::ComponentDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_ComponentDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::ComponentDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:98

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CI_

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::allocbuf (CORBA::ULong size)
{
  CORBA::ComponentIR::ProvidesDescription *retval = 0;
  ACE_NEW_RETURN (retval, CORBA::ComponentIR::ProvidesDescription[size], 0);
  return retval;
}

ACE_INLINE
void CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::freebuf (CORBA::ComponentIR::ProvidesDescription *buffer)
{
  delete [] buffer;
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq (void)
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::allocbuf (maximum))
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq (
    CORBA::ULong maximum,
    CORBA::ULong length,
    CORBA::ComponentIR::ProvidesDescription *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq (
    const _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      CORBA::ComponentIR::ProvidesDescription *tmp1 =
        _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::allocbuf (this->maximum_);
      CORBA::ComponentIR::ProvidesDescription * const tmp2 =
        ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::operator= (
    const _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          CORBA::ComponentIR::ProvidesDescription *tmp =
            ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription *, this->buffer_);
          
          _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  CORBA::ComponentIR::ProvidesDescription *tmp1 =
    ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription *, this->buffer_);
  CORBA::ComponentIR::ProvidesDescription * const tmp2 =
    ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
CORBA::ComponentIR::ProvidesDescription &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  CORBA::ComponentIR::ProvidesDescription* tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const CORBA::ComponentIR::ProvidesDescription &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  CORBA::ComponentIR::ProvidesDescription * const tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::get_buffer (CORBA::Boolean orphan)
{
  CORBA::ComponentIR::ProvidesDescription *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(CORBA::ComponentIR::ProvidesDescription*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const CORBA::ComponentIR::ProvidesDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast (const CORBA::ComponentIR::ProvidesDescription * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ComponentIR::ProvidesDescription *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      CORBA::ComponentIR::ProvidesDescription *tmp =
        ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription*, this->buffer_);
      _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CI_)
#define _CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CI_

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class CORBA::ComponentIR::ProvidesDescriptionSeq_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::ProvidesDescriptionSeq_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::ProvidesDescriptionSeq_var (ProvidesDescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::ProvidesDescriptionSeq_var (const ::CORBA::ComponentIR::ProvidesDescriptionSeq_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::ProvidesDescriptionSeq (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::~ProvidesDescriptionSeq_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var &
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator= (ProvidesDescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq_var &
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator= (const ::CORBA::ComponentIR::ProvidesDescriptionSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ProvidesDescriptionSeq *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              ProvidesDescriptionSeq (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              ProvidesDescriptionSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::CORBA::ComponentIR::ProvidesDescriptionSeq *
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq *
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator const ::CORBA::ComponentIR::ProvidesDescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator ::CORBA::ComponentIR::ProvidesDescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator ::CORBA::ComponentIR::ProvidesDescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator ::CORBA::ComponentIR::ProvidesDescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription &
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const CORBA::ComponentIR::ProvidesDescription &
CORBA::ComponentIR::ProvidesDescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const CORBA::ComponentIR::ProvidesDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::CORBA::ComponentIR::ProvidesDescriptionSeq &
CORBA::ComponentIR::ProvidesDescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq &
CORBA::ComponentIR::ProvidesDescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq *&
CORBA::ComponentIR::ProvidesDescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq *
CORBA::ComponentIR::ProvidesDescriptionSeq_var::_retn (void)
{
  ::CORBA::ComponentIR::ProvidesDescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq *
CORBA::ComponentIR::ProvidesDescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:566

// *************************************************************
// Inline operations for class CORBA::ComponentIR::ProvidesDescriptionSeq_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_out::ProvidesDescriptionSeq_out (ProvidesDescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_out::ProvidesDescriptionSeq_out (ProvidesDescriptionSeq_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_out::ProvidesDescriptionSeq_out (const ::CORBA::ComponentIR::ProvidesDescriptionSeq_out &p)
  : ptr_ (ACE_const_cast (ProvidesDescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq_out &
CORBA::ComponentIR::ProvidesDescriptionSeq_out::operator= (const ::CORBA::ComponentIR::ProvidesDescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq_out &
CORBA::ComponentIR::ProvidesDescriptionSeq_out::operator= (ProvidesDescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescriptionSeq_out::operator ::CORBA::ComponentIR::ProvidesDescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq *&
CORBA::ComponentIR::ProvidesDescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::ProvidesDescriptionSeq *
CORBA::ComponentIR::ProvidesDescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ProvidesDescription &
CORBA::ComponentIR::ProvidesDescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:98

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CI_

ACE_INLINE
CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::allocbuf (CORBA::ULong size)
{
  CORBA::ComponentIR::UsesDescription *retval = 0;
  ACE_NEW_RETURN (retval, CORBA::ComponentIR::UsesDescription[size], 0);
  return retval;
}

ACE_INLINE
void CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::freebuf (CORBA::ComponentIR::UsesDescription *buffer)
{
  delete [] buffer;
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq (void)
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::allocbuf (maximum))
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq (
    CORBA::ULong maximum,
    CORBA::ULong length,
    CORBA::ComponentIR::UsesDescription *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq (
    const _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      CORBA::ComponentIR::UsesDescription *tmp1 =
        _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::allocbuf (this->maximum_);
      CORBA::ComponentIR::UsesDescription * const tmp2 =
        ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::operator= (
    const _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          CORBA::ComponentIR::UsesDescription *tmp =
            ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription *, this->buffer_);
          
          _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  CORBA::ComponentIR::UsesDescription *tmp1 =
    ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription *, this->buffer_);
  CORBA::ComponentIR::UsesDescription * const tmp2 =
    ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
CORBA::ComponentIR::UsesDescription &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  CORBA::ComponentIR::UsesDescription* tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const CORBA::ComponentIR::UsesDescription &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  CORBA::ComponentIR::UsesDescription * const tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::get_buffer (CORBA::Boolean orphan)
{
  CORBA::ComponentIR::UsesDescription *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(CORBA::ComponentIR::UsesDescription*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const CORBA::ComponentIR::UsesDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast (const CORBA::ComponentIR::UsesDescription * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ComponentIR::UsesDescription *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      CORBA::ComponentIR::UsesDescription *tmp =
        ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription*, this->buffer_);
      _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CI_)
#define _CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CI_

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class CORBA::ComponentIR::UsesDescriptionSeq_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::UsesDescriptionSeq_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::UsesDescriptionSeq_var (UsesDescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::UsesDescriptionSeq_var (const ::CORBA::ComponentIR::UsesDescriptionSeq_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::UsesDescriptionSeq (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::~UsesDescriptionSeq_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var &
CORBA::ComponentIR::UsesDescriptionSeq_var::operator= (UsesDescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq_var &
CORBA::ComponentIR::UsesDescriptionSeq_var::operator= (const ::CORBA::ComponentIR::UsesDescriptionSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          UsesDescriptionSeq *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              UsesDescriptionSeq (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              UsesDescriptionSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::CORBA::ComponentIR::UsesDescriptionSeq *
CORBA::ComponentIR::UsesDescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq *
CORBA::ComponentIR::UsesDescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::operator const ::CORBA::ComponentIR::UsesDescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::operator ::CORBA::ComponentIR::UsesDescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::operator ::CORBA::ComponentIR::UsesDescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_var::operator ::CORBA::ComponentIR::UsesDescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription &
CORBA::ComponentIR::UsesDescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const CORBA::ComponentIR::UsesDescription &
CORBA::ComponentIR::UsesDescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const CORBA::ComponentIR::UsesDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::CORBA::ComponentIR::UsesDescriptionSeq &
CORBA::ComponentIR::UsesDescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq &
CORBA::ComponentIR::UsesDescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq *&
CORBA::ComponentIR::UsesDescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq *
CORBA::ComponentIR::UsesDescriptionSeq_var::_retn (void)
{
  ::CORBA::ComponentIR::UsesDescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq *
CORBA::ComponentIR::UsesDescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:566

// *************************************************************
// Inline operations for class CORBA::ComponentIR::UsesDescriptionSeq_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_out::UsesDescriptionSeq_out (UsesDescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_out::UsesDescriptionSeq_out (UsesDescriptionSeq_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_out::UsesDescriptionSeq_out (const ::CORBA::ComponentIR::UsesDescriptionSeq_out &p)
  : ptr_ (ACE_const_cast (UsesDescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq_out &
CORBA::ComponentIR::UsesDescriptionSeq_out::operator= (const ::CORBA::ComponentIR::UsesDescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq_out &
CORBA::ComponentIR::UsesDescriptionSeq_out::operator= (UsesDescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescriptionSeq_out::operator ::CORBA::ComponentIR::UsesDescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq *&
CORBA::ComponentIR::UsesDescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::UsesDescriptionSeq *
CORBA::ComponentIR::UsesDescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::UsesDescription &
CORBA::ComponentIR::UsesDescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_sequence_ci.cpp:98

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CI_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CI_

ACE_INLINE
CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::allocbuf (CORBA::ULong size)
{
  CORBA::ComponentIR::EventPortDescription *retval = 0;
  ACE_NEW_RETURN (retval, CORBA::ComponentIR::EventPortDescription[size], 0);
  return retval;
}

ACE_INLINE
void CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::freebuf (CORBA::ComponentIR::EventPortDescription *buffer)
{
  delete [] buffer;
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq (void)
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq (CORBA::ULong maximum) 
  : TAO_Unbounded_Base_Sequence (maximum, _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::allocbuf (maximum))
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq (
    CORBA::ULong maximum,
    CORBA::ULong length,
    CORBA::ComponentIR::EventPortDescription *data,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
{
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq (
    const _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq &rhs
  )
  : TAO_Unbounded_Base_Sequence (rhs)
{
  if (rhs.buffer_ != 0)
    {
      CORBA::ComponentIR::EventPortDescription *tmp1 =
        _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::allocbuf (this->maximum_);
      CORBA::ComponentIR::EventPortDescription * const tmp2 =
        ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription * ACE_CAST_CONST, rhs.buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp1[i] = tmp2[i];
        }
      
      this->buffer_ = tmp1;
    }
  else
    {
      this->buffer_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::operator= (
    const _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq &rhs
  )
{
  if (this == &rhs)
    {
      return *this;
    }
  
  if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
        {
          // Free the old buffer.
          CORBA::ComponentIR::EventPortDescription *tmp =
            ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription *, this->buffer_);
          
          _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::freebuf (tmp);
          
          this->buffer_ =
            _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::allocbuf (rhs.maximum_);
        }
    }
  else
    {
      this->buffer_ =
        _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::allocbuf (rhs.maximum_);
    }
  
  TAO_Unbounded_Base_Sequence::operator= (rhs);
  
  CORBA::ComponentIR::EventPortDescription *tmp1 =
    ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription *, this->buffer_);
  CORBA::ComponentIR::EventPortDescription * const tmp2 =
    ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription * ACE_CAST_CONST, rhs.buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      tmp1[i] = tmp2[i];
    }
  
  return *this;
}

// = Accessors.
ACE_INLINE
CORBA::ComponentIR::EventPortDescription &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::operator[] (CORBA::ULong i)
{
  ACE_ASSERT (i < this->maximum_);
  CORBA::ComponentIR::EventPortDescription* tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription*, this->buffer_);
  return tmp[i];
}

ACE_INLINE
const CORBA::ComponentIR::EventPortDescription &
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::operator[] (CORBA::ULong i) const
{
  ACE_ASSERT (i < this->maximum_);
  CORBA::ComponentIR::EventPortDescription * const tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription* ACE_CAST_CONST, this->buffer_);
  return tmp[i];
}

// Implement the TAO_Base_Sequence methods (see Sequence.h)

ACE_INLINE
CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::get_buffer (CORBA::Boolean orphan)
{
  CORBA::ComponentIR::EventPortDescription *result = 0;
  
  if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
        {
          result =
            _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::allocbuf (this->length_);
          this->buffer_ = result;
          this->release_ = 1;
        }
      else
        {
          result =
            ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription*, this->buffer_);
        }
    }
  else // if (orphan == 1)
    {
      if (this->release_ != 0)
        {
          // We set the state back to default and relinquish ownership.
          result =
            ACE_reinterpret_cast(CORBA::ComponentIR::EventPortDescription*,this->buffer_);
          this->maximum_ = 0;
          this->length_ = 0;
          this->buffer_ = 0;
          this->release_ = 0;
        }
    }
  
  return result;
}

ACE_INLINE
const CORBA::ComponentIR::EventPortDescription *
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::get_buffer (void) const
{
  return ACE_reinterpret_cast (const CORBA::ComponentIR::EventPortDescription * ACE_CAST_CONST, this->buffer_);
}

ACE_INLINE
void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::replace (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ComponentIR::EventPortDescription *data,
    CORBA::Boolean release
  )
{
  this->maximum_ = max;
  this->length_ = length;
  
  if (this->buffer_ && this->release_ == 1)
    {
      CORBA::ComponentIR::EventPortDescription *tmp =
        ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription*, this->buffer_);
      _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::freebuf (tmp);
    }
  
  this->buffer_ = data;
  this->release_ = release;
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CI_)
#define _CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CI_

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:226

// *************************************************************
// Inline operations for class CORBA::ComponentIR::EventPortDescriptionSeq_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::EventPortDescriptionSeq_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::EventPortDescriptionSeq_var (EventPortDescriptionSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::EventPortDescriptionSeq_var (const ::CORBA::ComponentIR::EventPortDescriptionSeq_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::EventPortDescriptionSeq (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::~EventPortDescriptionSeq_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var &
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator= (EventPortDescriptionSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq_var &
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator= (const ::CORBA::ComponentIR::EventPortDescriptionSeq_var &p)
{
  if (this != &p)
    {
      if (p.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          EventPortDescriptionSeq *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              EventPortDescriptionSeq (*p.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              EventPortDescriptionSeq *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE
const ::CORBA::ComponentIR::EventPortDescriptionSeq *
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq *
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator const ::CORBA::ComponentIR::EventPortDescriptionSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator ::CORBA::ComponentIR::EventPortDescriptionSeq &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator ::CORBA::ComponentIR::EventPortDescriptionSeq &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator ::CORBA::ComponentIR::EventPortDescriptionSeq *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription &
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE
const CORBA::ComponentIR::EventPortDescription &
CORBA::ComponentIR::EventPortDescriptionSeq_var::operator[] (CORBA::ULong index) const
{
  return ACE_const_cast (const CORBA::ComponentIR::EventPortDescription &, this->ptr_->operator[] (index));
}

ACE_INLINE
const ::CORBA::ComponentIR::EventPortDescriptionSeq &
CORBA::ComponentIR::EventPortDescriptionSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq &
CORBA::ComponentIR::EventPortDescriptionSeq_var::inout (void)
{
  return *this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq *&
CORBA::ComponentIR::EventPortDescriptionSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq *
CORBA::ComponentIR::EventPortDescriptionSeq_var::_retn (void)
{
  ::CORBA::ComponentIR::EventPortDescriptionSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq *
CORBA::ComponentIR::EventPortDescriptionSeq_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_ci.cpp:566

// *************************************************************
// Inline operations for class CORBA::ComponentIR::EventPortDescriptionSeq_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_out::EventPortDescriptionSeq_out (EventPortDescriptionSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_out::EventPortDescriptionSeq_out (EventPortDescriptionSeq_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_out::EventPortDescriptionSeq_out (const ::CORBA::ComponentIR::EventPortDescriptionSeq_out &p)
  : ptr_ (ACE_const_cast (EventPortDescriptionSeq_out&, p).ptr_)
{}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq_out &
CORBA::ComponentIR::EventPortDescriptionSeq_out::operator= (const ::CORBA::ComponentIR::EventPortDescriptionSeq_out &p)
{
  this->ptr_ = ACE_const_cast (EventPortDescriptionSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq_out &
CORBA::ComponentIR::EventPortDescriptionSeq_out::operator= (EventPortDescriptionSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescriptionSeq_out::operator ::CORBA::ComponentIR::EventPortDescriptionSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq *&
CORBA::ComponentIR::EventPortDescriptionSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE
::CORBA::ComponentIR::EventPortDescriptionSeq *
CORBA::ComponentIR::EventPortDescriptionSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::EventPortDescription &
CORBA::ComponentIR::EventPortDescriptionSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:194

// *************************************************************
// Inline operations for class CORBA::ComponentIR::ComponentDescription_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::ComponentDescription_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::ComponentDescription_var (ComponentDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::ComponentDescription_var (const ::CORBA::ComponentIR::ComponentDescription_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::ComponentDescription (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::~ComponentDescription_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var &
CORBA::ComponentIR::ComponentDescription_var::operator= (ComponentDescription *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::ComponentDescription_var &
CORBA::ComponentIR::ComponentDescription_var::operator= (const ::CORBA::ComponentIR::ComponentDescription_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          ComponentDescription *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              ComponentDescription (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              ComponentDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::CORBA::ComponentIR::ComponentDescription *
CORBA::ComponentIR::ComponentDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ComponentDescription *
CORBA::ComponentIR::ComponentDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::operator const ::CORBA::ComponentIR::ComponentDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::operator ::CORBA::ComponentIR::ComponentDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::operator ::CORBA::ComponentIR::ComponentDescription &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::ComponentDescription_var::operator ::CORBA::ComponentIR::ComponentDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::CORBA::ComponentIR::ComponentDescription &
CORBA::ComponentIR::ComponentDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ComponentDescription &
CORBA::ComponentIR::ComponentDescription_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::CORBA::ComponentIR::ComponentDescription *&
CORBA::ComponentIR::ComponentDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ComponentDescription *
CORBA::ComponentIR::ComponentDescription_var::_retn (void)
{
  ::CORBA::ComponentIR::ComponentDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::CORBA::ComponentIR::ComponentDescription *
CORBA::ComponentIR::ComponentDescription_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:523

// *************************************************************
// Inline operations for class CORBA::ComponentIR::ComponentDescription_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_out::ComponentDescription_out (::CORBA::ComponentIR::ComponentDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_out::ComponentDescription_out (ComponentDescription_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_out::ComponentDescription_out (const ::CORBA::ComponentIR::ComponentDescription_out &p)
  : ptr_ (ACE_const_cast (ComponentDescription_out&, p).ptr_)
{}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_out &
CORBA::ComponentIR::ComponentDescription_out::operator= (const ::CORBA::ComponentIR::ComponentDescription_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::ComponentDescription_out &
CORBA::ComponentIR::ComponentDescription_out::operator= (ComponentDescription *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
CORBA::ComponentIR::ComponentDescription_out::operator ::CORBA::ComponentIR::ComponentDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ComponentDescription *&
CORBA::ComponentIR::ComponentDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::ComponentDescription *
CORBA::ComponentIR::ComponentDescription_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_FACTORYDEF___CI_)
#define _CORBA_COMPONENTIR_FACTORYDEF___CI_

ACE_INLINE
CORBA::ComponentIR::FactoryDef::FactoryDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_FactoryDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::FactoryDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_FINDERDEF___CI_)
#define _CORBA_COMPONENTIR_FINDERDEF___CI_

ACE_INLINE
CORBA::ComponentIR::FinderDef::FinderDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_FinderDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::FinderDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_ci.cpp:68

#if !defined (_CORBA_COMPONENTIR_HOMEDEF___CI_)
#define _CORBA_COMPONENTIR_HOMEDEF___CI_

ACE_INLINE
CORBA::ComponentIR::HomeDef::HomeDef (
    TAO_Stub *objref,
    CORBA::Boolean _tao_collocated,
    TAO_Abstract_ServantBase *servant
  )
  : CORBA_Object (objref, _tao_collocated, servant)
{
  this->CORBA_ComponentIR_HomeDef_setup_collocation (_tao_collocated);
}

ACE_INLINE
CORBA::Boolean
CORBA::ComponentIR::HomeDef::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:194

// *************************************************************
// Inline operations for class CORBA::ComponentIR::HomeDescription_var
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::HomeDescription_var (void)
  : ptr_ (0)
{}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::HomeDescription_var (HomeDescription *p)
  : ptr_ (p)
{}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::HomeDescription_var (const ::CORBA::ComponentIR::HomeDescription_var &p)
{
  if (p.ptr_)
    {
      ACE_NEW (this->ptr_, ::CORBA::ComponentIR::HomeDescription (*p.ptr_));
    }
  else
    {
      this->ptr_ = 0;
    }
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::~HomeDescription_var (void)
{
  delete this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var &
CORBA::ComponentIR::HomeDescription_var::operator= (HomeDescription *_tao_struct_var)
{
  delete this->ptr_;
  this->ptr_ = _tao_struct_var;
  return *this;
}

ACE_INLINE
::CORBA::ComponentIR::HomeDescription_var &
CORBA::ComponentIR::HomeDescription_var::operator= (const ::CORBA::ComponentIR::HomeDescription_var &_tao_struct_var)
{
  if (this != &_tao_struct_var)
    {
      if (_tao_struct_var.ptr_ == 0)
        {
          delete this->ptr_;
          this->ptr_ = 0;
        }
      else
        {
          HomeDescription *deep_copy = 0;
          ACE_NEW_RETURN (
              deep_copy,
              HomeDescription (*_tao_struct_var.ptr_),
              *this
            );
          
          if (deep_copy != 0)
            {
              HomeDescription *tmp = deep_copy;
              deep_copy = this->ptr_;
              this->ptr_ = tmp;
              delete deep_copy;
            }
        }
    }
  
  return *this;
}

ACE_INLINE const ::CORBA::ComponentIR::HomeDescription *
CORBA::ComponentIR::HomeDescription_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::HomeDescription *
CORBA::ComponentIR::HomeDescription_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::operator const ::CORBA::ComponentIR::HomeDescription &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::operator ::CORBA::ComponentIR::HomeDescription &() // cast 
{
  return *this->ptr_;
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::operator ::CORBA::ComponentIR::HomeDescription &() const // cast 
{
  return *this->ptr_;
}

// Variable-size types only.
ACE_INLINE
CORBA::ComponentIR::HomeDescription_var::operator ::CORBA::ComponentIR::HomeDescription *&() // cast 
{
  return this->ptr_;
}

ACE_INLINE const ::CORBA::ComponentIR::HomeDescription &
CORBA::ComponentIR::HomeDescription_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::HomeDescription &
CORBA::ComponentIR::HomeDescription_var::inout (void)
{
  return *this->ptr_;
}

// Mapping for variable size.
ACE_INLINE ::CORBA::ComponentIR::HomeDescription *&
CORBA::ComponentIR::HomeDescription_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::HomeDescription *
CORBA::ComponentIR::HomeDescription_var::_retn (void)
{
  ::CORBA::ComponentIR::HomeDescription *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::CORBA::ComponentIR::HomeDescription *
CORBA::ComponentIR::HomeDescription_var::ptr (void) const
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_structure.cpp:523

// *************************************************************
// Inline operations for class CORBA::ComponentIR::HomeDescription_out
// *************************************************************

ACE_INLINE
CORBA::ComponentIR::HomeDescription_out::HomeDescription_out (::CORBA::ComponentIR::HomeDescription *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_out::HomeDescription_out (HomeDescription_var &p)
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_out::HomeDescription_out (const ::CORBA::ComponentIR::HomeDescription_out &p)
  : ptr_ (ACE_const_cast (HomeDescription_out&, p).ptr_)
{}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_out &
CORBA::ComponentIR::HomeDescription_out::operator= (const ::CORBA::ComponentIR::HomeDescription_out &p)
{
  this->ptr_ = ACE_const_cast (HomeDescription_out&, p).ptr_;
  return *this;
}

ACE_INLINE
CORBA::ComponentIR::HomeDescription_out &
CORBA::ComponentIR::HomeDescription_out::operator= (HomeDescription *_tao_struct_out)
{
  this->ptr_ = _tao_struct_out;
  return *this;
}

ACE_INLINE 
CORBA::ComponentIR::HomeDescription_out::operator ::CORBA::ComponentIR::HomeDescription *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::HomeDescription *&
CORBA::ComponentIR::HomeDescription_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::CORBA::ComponentIR::HomeDescription *
CORBA::ComponentIR::HomeDescription_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface_fwd/cdr_op_ci.cpp:59

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::ComponentDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::ComponentDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface_fwd/cdr_op_ci.cpp:59

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::HomeDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::HomeDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::EventDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::EventDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::Container_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::Container_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::ModuleDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::ModuleDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::Repository_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::Repository_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::ProvidesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::ProvidesDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/cdr_op_ci.cpp:103

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::ProvidesDescription &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.interface_type.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::ProvidesDescription &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.interface_type.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::UsesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::UsesDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/cdr_op_ci.cpp:103

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::UsesDescription &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.interface_type.in ()) &&
    (strm << CORBA::Any::from_boolean (_tao_aggregate.is_multiple))
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::UsesDescription &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.interface_type.out ()) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.is_multiple))
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::EventPortDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::EventPortDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/cdr_op_ci.cpp:103

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::EventPortDescription &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.event.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::EventPortDescription &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.event.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::EmitsDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::EmitsDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::PublishesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::PublishesDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::ConsumesDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::ConsumesDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_CORBA_ComponentIR_ProvidesDescriptionSeq_I_
#define _TAO_CDR_OP_CORBA_ComponentIR_ProvidesDescriptionSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::ProvidesDescriptionSeq &
  );

CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::ProvidesDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ComponentIR_ProvidesDescriptionSeq_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_CORBA_ComponentIR_UsesDescriptionSeq_I_
#define _TAO_CDR_OP_CORBA_ComponentIR_UsesDescriptionSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::UsesDescriptionSeq &
  );

CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::UsesDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ComponentIR_UsesDescriptionSeq_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_ci.cpp:84

#if !defined _TAO_CDR_OP_CORBA_ComponentIR_EventPortDescriptionSeq_I_
#define _TAO_CDR_OP_CORBA_ComponentIR_EventPortDescriptionSeq_I_

CORBA::Boolean TAO_IFR_Client_Export operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::EventPortDescriptionSeq &
  );

CORBA::Boolean TAO_IFR_Client_Export operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::EventPortDescriptionSeq &
  );

#endif /* _TAO_CDR_OP_CORBA_ComponentIR_EventPortDescriptionSeq_I_ */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/cdr_op_ci.cpp:103

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::ComponentDescription &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.base_component.in ()) &&
    (strm << _tao_aggregate.supported_interfaces) &&
    (strm << _tao_aggregate.provided_interfaces) &&
    (strm << _tao_aggregate.used_interfaces) &&
    (strm << _tao_aggregate.emits_events) &&
    (strm << _tao_aggregate.publishes_events) &&
    (strm << _tao_aggregate.consumes_events) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << _tao_aggregate.type.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::ComponentDescription &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.base_component.out ()) &&
    (strm >> _tao_aggregate.supported_interfaces) &&
    (strm >> _tao_aggregate.provided_interfaces) &&
    (strm >> _tao_aggregate.used_interfaces) &&
    (strm >> _tao_aggregate.emits_events) &&
    (strm >> _tao_aggregate.publishes_events) &&
    (strm >> _tao_aggregate.consumes_events) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> _tao_aggregate.type.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::FactoryDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::FactoryDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_ci.cpp:72

TAO_IFR_Client_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const CORBA::ComponentIR::FinderDef_ptr
  );

TAO_IFR_Client_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    CORBA::ComponentIR::FinderDef_ptr &
  );

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/cdr_op_ci.cpp:103

ACE_INLINE
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::HomeDescription &_tao_aggregate
  )
{
  if (
    (strm << _tao_aggregate.name.in ()) &&
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.defined_in.in ()) &&
    (strm << _tao_aggregate.version.in ()) &&
    (strm << _tao_aggregate.base_home.in ()) &&
    (strm << _tao_aggregate.managed_component.in ()) &&
    (strm << _tao_aggregate.primary_key) &&
    (strm << _tao_aggregate.factories) &&
    (strm << _tao_aggregate.finders) &&
    (strm << _tao_aggregate.operations) &&
    (strm << _tao_aggregate.attributes) &&
    (strm << _tao_aggregate.type.in ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

ACE_INLINE
CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::HomeDescription &_tao_aggregate
  )
{
  if (
    (strm >> _tao_aggregate.name.out ()) &&
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.defined_in.out ()) &&
    (strm >> _tao_aggregate.version.out ()) &&
    (strm >> _tao_aggregate.base_home.out ()) &&
    (strm >> _tao_aggregate.managed_component.out ()) &&
    (strm >> _tao_aggregate.primary_key) &&
    (strm >> _tao_aggregate.factories) &&
    (strm >> _tao_aggregate.finders) &&
    (strm >> _tao_aggregate.operations) &&
    (strm >> _tao_aggregate.attributes) &&
    (strm >> _tao_aggregate.type.out ())
   )
    {
      return 1;
    }
  else
    {
      return 0;
    }
}

