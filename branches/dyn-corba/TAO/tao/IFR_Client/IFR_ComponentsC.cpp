// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:314


#include "IFR_ComponentsC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */



#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_ComponentsC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::EventDef::_tao_class_id = 0;

CORBA::ComponentIR::EventDef_ptr
tao_CORBA_ComponentIR_EventDef_duplicate (
    CORBA::ComponentIR::EventDef_ptr p
  )
{
  return CORBA::ComponentIR::EventDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_EventDef_release (
    CORBA::ComponentIR::EventDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::EventDef_ptr
tao_CORBA_ComponentIR_EventDef_nil (
    void
  )
{
  return CORBA::ComponentIR::EventDef::_nil ();
}

CORBA::ComponentIR::EventDef_ptr
tao_CORBA_ComponentIR_EventDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::EventDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_EventDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::EventDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::EventDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_EventDef_marshal (
    CORBA::ComponentIR::EventDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::EventDef_var
// *************************************************************

CORBA::ComponentIR::EventDef_var::EventDef_var (void)
  : ptr_ (EventDef::_nil ())
{}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::EventDef_var::EventDef_var (const ::CORBA::ComponentIR::EventDef_var &p)
  : TAO_Base_var (),
    ptr_ (EventDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::EventDef_var::~EventDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::EventDef_var &
CORBA::ComponentIR::EventDef_var::operator= (EventDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::EventDef_var &
CORBA::ComponentIR::EventDef_var::operator= (const ::CORBA::ComponentIR::EventDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::EventDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::EventDef_var::operator const ::CORBA::ComponentIR::EventDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::EventDef_var::operator ::CORBA::ComponentIR::EventDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventDef_ptr &
CORBA::ComponentIR::EventDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventDef_ptr &
CORBA::ComponentIR::EventDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::EventDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::EventDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::EventDef::_nil ();
  return val;
}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_var::tao_duplicate (EventDef_ptr p)
{
  return ::CORBA::ComponentIR::EventDef::_duplicate (p);
}

void
CORBA::ComponentIR::EventDef_var::tao_release (EventDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::EventDef::_nil ();
}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::EventDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::EventDef_var::tao_upcast (void *src)
{
  EventDef **tmp =
    ACE_static_cast (EventDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::EventDef_out
// *************************************************************

CORBA::ComponentIR::EventDef_out::EventDef_out (EventDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::EventDef::_nil ();
}

CORBA::ComponentIR::EventDef_out::EventDef_out (EventDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::EventDef::_nil ();
}

CORBA::ComponentIR::EventDef_out::EventDef_out (const ::CORBA::ComponentIR::EventDef_out &p)
  : ptr_ (ACE_const_cast (EventDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::EventDef_out &
CORBA::ComponentIR::EventDef_out::operator= (const ::CORBA::ComponentIR::EventDef_out &p)
{
  this->ptr_ = ACE_const_cast (EventDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::EventDef_out &
CORBA::ComponentIR::EventDef_out::operator= (const ::CORBA::ComponentIR::EventDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::EventDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::EventDef_out &
CORBA::ComponentIR::EventDef_out::operator= (EventDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::EventDef_out::operator ::CORBA::ComponentIR::EventDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventDef_ptr &
CORBA::ComponentIR::EventDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_EventDef_Proxy_Impl::_TAO_EventDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Impl::_TAO_EventDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_EventDef_Proxy_Broker::_TAO_EventDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventDef_Proxy_Broker::~_TAO_EventDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Broker::_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Broker::~_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::EventDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::EventDef::EventDef (int collocated)
{
  this->CORBA_ComponentIR_EventDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::EventDef::CORBA_ComponentIR_EventDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EventDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EventDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker ();
  
  this->CORBA_ExtValueDef_setup_collocation (collocated);
}

CORBA::ComponentIR::EventDef::~EventDef (void)
{}

void 
CORBA::ComponentIR::EventDef::_tao_any_destructor (void *_tao_void_pointer)
{
  EventDef *tmp = ACE_static_cast (EventDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return EventDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/EventDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (EventDef::_nil ());
      
      if (is_a == 0)
        {
          return EventDef::_nil ();
        }
    }
  
  return EventDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::EventDef_ptr 
CORBA::ComponentIR::EventDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return EventDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      EventDef_ptr default_proxy = EventDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::EventDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              EventDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::EventDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              EventDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          EventDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &EventDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::EventDef_ptr
CORBA::ComponentIR::EventDef::_duplicate (EventDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::EventDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/EventDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtValueDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ValueDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::EventDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, EventDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::ExtValueDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ExtValueDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::ValueDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ValueDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/EventDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_EventDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f4576), 
  ACE_NTOHL (0x656e7444), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EventDef:1.0
    9,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x0),  // name = EventDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_EventDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_EventDef),
    (char *) &_oc_CORBA_ComponentIR_EventDef,
    0,
    sizeof (CORBA::ComponentIR::EventDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EventDef,
    &_tc_TAO_tc_CORBA_ComponentIR_EventDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::Container::_tao_class_id = 0;

CORBA::ComponentIR::Container_ptr
tao_CORBA_ComponentIR_Container_duplicate (
    CORBA::ComponentIR::Container_ptr p
  )
{
  return CORBA::ComponentIR::Container::_duplicate (p);
}

void
tao_CORBA_ComponentIR_Container_release (
    CORBA::ComponentIR::Container_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::Container_ptr
tao_CORBA_ComponentIR_Container_nil (
    void
  )
{
  return CORBA::ComponentIR::Container::_nil ();
}

CORBA::ComponentIR::Container_ptr
tao_CORBA_ComponentIR_Container_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::Container::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_Container_upcast (
    void *src
  )
{
  CORBA::ComponentIR::Container **tmp =
    ACE_static_cast (CORBA::ComponentIR::Container **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_Container_marshal (
    CORBA::ComponentIR::Container_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::Container_var
// *************************************************************

CORBA::ComponentIR::Container_var::Container_var (void)
  : ptr_ (Container::_nil ())
{}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::Container_var::Container_var (const ::CORBA::ComponentIR::Container_var &p)
  : TAO_Base_var (),
    ptr_ (Container::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::Container_var::~Container_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::Container_var &
CORBA::ComponentIR::Container_var::operator= (Container_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::Container_var &
CORBA::ComponentIR::Container_var::operator= (const ::CORBA::ComponentIR::Container_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::Container::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::Container_var::operator const ::CORBA::ComponentIR::Container_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::Container_var::operator ::CORBA::ComponentIR::Container_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::Container_ptr &
CORBA::ComponentIR::Container_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::Container_ptr &
CORBA::ComponentIR::Container_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::Container::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::Container_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::Container::_nil ();
  return val;
}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_var::tao_duplicate (Container_ptr p)
{
  return ::CORBA::ComponentIR::Container::_duplicate (p);
}

void
CORBA::ComponentIR::Container_var::tao_release (Container_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::Container::_nil ();
}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::Container::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::Container_var::tao_upcast (void *src)
{
  Container **tmp =
    ACE_static_cast (Container **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::Container_out
// *************************************************************

CORBA::ComponentIR::Container_out::Container_out (Container_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::Container::_nil ();
}

CORBA::ComponentIR::Container_out::Container_out (Container_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::Container::_nil ();
}

CORBA::ComponentIR::Container_out::Container_out (const ::CORBA::ComponentIR::Container_out &p)
  : ptr_ (ACE_const_cast (Container_out &, p).ptr_)
{}

::CORBA::ComponentIR::Container_out &
CORBA::ComponentIR::Container_out::operator= (const ::CORBA::ComponentIR::Container_out &p)
{
  this->ptr_ = ACE_const_cast (Container_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::Container_out &
CORBA::ComponentIR::Container_out::operator= (const ::CORBA::ComponentIR::Container_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::Container::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::Container_out &
CORBA::ComponentIR::Container_out::operator= (Container_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::Container_out::operator ::CORBA::ComponentIR::Container_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::Container_ptr &
CORBA::ComponentIR::Container_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::ComponentDef_ptr base_component,
      const CORBA::InterfaceDefSeq & supports_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::ComponentDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component (const TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::ComponentIR::ComponentDef_ptr base_component_;
    const CORBA::InterfaceDefSeq & supports_interfaces_;
    
    ::CORBA::ComponentIR::ComponentDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component::TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::ComponentDef_ptr base_component,
      const CORBA::InterfaceDefSeq & supports_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      base_component_ (base_component),
      supports_interfaces_ (supports_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->base_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->supports_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component::result (::CORBA::ComponentIR::ComponentDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::HomeDef_ptr base_home,
      CORBA::ComponentIR::ComponentDef_ptr managed_component,
      const CORBA::InterfaceDefSeq & supports_interfaces,
      CORBA::ValueDef_ptr primary_key
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::HomeDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home (const TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::ComponentIR::HomeDef_ptr base_home_;
    CORBA::ComponentIR::ComponentDef_ptr managed_component_;
    const CORBA::InterfaceDefSeq & supports_interfaces_;
    CORBA::ValueDef_ptr primary_key_;
    
    ::CORBA::ComponentIR::HomeDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home::TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::HomeDef_ptr base_home,
      CORBA::ComponentIR::ComponentDef_ptr managed_component,
      const CORBA::InterfaceDefSeq & supports_interfaces,
      CORBA::ValueDef_ptr primary_key
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      base_home_ (base_home),
      managed_component_ (managed_component),
      supports_interfaces_ (supports_interfaces),
      primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (7);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->base_home_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->managed_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->supports_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->primary_key_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home::result (::CORBA::ComponentIR::HomeDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::Boolean & is_custom,
      const CORBA::Boolean & is_abstract,
      CORBA::ValueDef_ptr base_value,
      const CORBA::Boolean & is_truncatable,
      const CORBA::ValueDefSeq & abstract_base_values,
      const CORBA::InterfaceDefSeq & supported_interfaces,
      const CORBA::ExtInitializerSeq & initializers
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::EventDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event (const TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::Boolean & is_custom_;
    const CORBA::Boolean & is_abstract_;
    CORBA::ValueDef_ptr base_value_;
    const CORBA::Boolean & is_truncatable_;
    const CORBA::ValueDefSeq & abstract_base_values_;
    const CORBA::InterfaceDefSeq & supported_interfaces_;
    const CORBA::ExtInitializerSeq & initializers_;
    
    ::CORBA::ComponentIR::EventDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event::TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::Boolean & is_custom,
      const CORBA::Boolean & is_abstract,
      CORBA::ValueDef_ptr base_value,
      const CORBA::Boolean & is_truncatable,
      const CORBA::ValueDefSeq & abstract_base_values,
      const CORBA::InterfaceDefSeq & supported_interfaces,
      const CORBA::ExtInitializerSeq & initializers
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      is_custom_ (is_custom),
      is_abstract_ (is_abstract),
      base_value_ (base_value),
      is_truncatable_ (is_truncatable),
      abstract_base_values_ (abstract_base_values),
      supported_interfaces_ (supported_interfaces),
      initializers_ (initializers)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (10);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->base_value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->abstract_base_values_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->initializers_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event::result (::CORBA::ComponentIR::EventDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_Container_Proxy_Impl::_TAO_Container_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Impl::_TAO_Container_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::ComponentDef_ptr CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::ComponentDef_ptr base_component,
    const CORBA::InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::ComponentDef_var _tao_retval (CORBA::ComponentIR::ComponentDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component",
      16,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_component _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          base_component,
          supports_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_component) &&
              (_tao_out << supports_interfaces)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::ComponentDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::HomeDef_ptr CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::HomeDef_ptr base_home,
    CORBA::ComponentIR::ComponentDef_ptr managed_component,
    const CORBA::InterfaceDefSeq & supports_interfaces,
    CORBA::ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::HomeDef_var _tao_retval (CORBA::ComponentIR::HomeDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_home",
      11,
      7,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_home _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          base_home,
          managed_component,
          supports_interfaces,
          primary_key
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_home) &&
              (_tao_out << managed_component) &&
              (_tao_out << supports_interfaces) &&
              (_tao_out << primary_key)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::HomeDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::EventDef_ptr CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Impl::create_event (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::ExtInitializerSeq & initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::EventDef_var _tao_retval (CORBA::ComponentIR::EventDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_event",
      12,
      10,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_Container_create_event _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          is_custom,
          is_abstract,
          base_value,
          is_truncatable,
          abstract_base_values,
          supported_interfaces,
          initializers
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << CORBA::Any::from_boolean (is_custom)) &&
              (_tao_out << CORBA::Any::from_boolean (is_abstract)) &&
              (_tao_out << base_value) &&
              (_tao_out << CORBA::Any::from_boolean (is_truncatable)) &&
              (_tao_out << abstract_base_values) &&
              (_tao_out << supported_interfaces) &&
              (_tao_out << initializers)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::EventDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_Container_Proxy_Broker::_TAO_Container_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Container_Proxy_Broker::~_TAO_Container_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Container_Proxy_Broker * (*CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Broker::_TAO_Container_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Broker::~_TAO_Container_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Container_Proxy_Impl&
CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::Container *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::Container::Container (int collocated)
{
  this->CORBA_ComponentIR_Container_setup_collocation (collocated);
}

void
CORBA::ComponentIR::Container::CORBA_ComponentIR_Container_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Container_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Container_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker ();
}

CORBA::ComponentIR::Container::~Container (void)
{}

void 
CORBA::ComponentIR::Container::_tao_any_destructor (void *_tao_void_pointer)
{
  Container *tmp = ACE_static_cast (Container *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Container::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/Container:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Container::_nil ());
      
      if (is_a == 0)
        {
          return Container::_nil ();
        }
    }
  
  return Container::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::Container_ptr 
CORBA::ComponentIR::Container::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Container::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Container_ptr default_proxy = Container::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::Container (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Container::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::Container (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Container::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Container_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Container::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::Container_ptr
CORBA::ComponentIR::Container::_duplicate (Container_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::Container::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::Container::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, Container)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/Container:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::ComponentDef_ptr CORBA::ComponentIR::Container::create_component (
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::ComponentDef_ptr base_component,
    const CORBA::InterfaceDefSeq & supports_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_component (
      this,
      id,
      name,
      version,
      base_component,
      supports_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::HomeDef_ptr CORBA::ComponentIR::Container::create_home (
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::HomeDef_ptr base_home,
    CORBA::ComponentIR::ComponentDef_ptr managed_component,
    const CORBA::InterfaceDefSeq & supports_interfaces,
    CORBA::ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_home (
      this,
      id,
      name,
      version,
      base_home,
      managed_component,
      supports_interfaces,
      primary_key
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::EventDef_ptr CORBA::ComponentIR::Container::create_event (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::ExtInitializerSeq & initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_Container_Proxy_Impl &proxy = 
    this->the_TAO_Container_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_event (
      this,
      id,
      name,
      version,
      is_custom,
      is_abstract,
      base_value,
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_Container[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f436f), 
  ACE_NTOHL (0x6e746169), 
  ACE_NTOHL (0x6e65723a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/Container:1.0
    10,
  ACE_NTOHL (0x436f6e74), 
  ACE_NTOHL (0x61696e65), 
  ACE_NTOHL (0x72000000),  // name = Container
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_Container (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_Container),
    (char *) &_oc_CORBA_ComponentIR_Container,
    0,
    sizeof (CORBA::ComponentIR::Container)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Container,
    &_tc_TAO_tc_CORBA_ComponentIR_Container
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::ModuleDef::_tao_class_id = 0;

CORBA::ComponentIR::ModuleDef_ptr
tao_CORBA_ComponentIR_ModuleDef_duplicate (
    CORBA::ComponentIR::ModuleDef_ptr p
  )
{
  return CORBA::ComponentIR::ModuleDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_ModuleDef_release (
    CORBA::ComponentIR::ModuleDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::ModuleDef_ptr
tao_CORBA_ComponentIR_ModuleDef_nil (
    void
  )
{
  return CORBA::ComponentIR::ModuleDef::_nil ();
}

CORBA::ComponentIR::ModuleDef_ptr
tao_CORBA_ComponentIR_ModuleDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::ModuleDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_ModuleDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::ModuleDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::ModuleDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_ModuleDef_marshal (
    CORBA::ComponentIR::ModuleDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::ModuleDef_var
// *************************************************************

CORBA::ComponentIR::ModuleDef_var::ModuleDef_var (void)
  : ptr_ (ModuleDef::_nil ())
{}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::ModuleDef_var::ModuleDef_var (const ::CORBA::ComponentIR::ModuleDef_var &p)
  : TAO_Base_var (),
    ptr_ (ModuleDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::ModuleDef_var::~ModuleDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::ModuleDef_var &
CORBA::ComponentIR::ModuleDef_var::operator= (ModuleDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ModuleDef_var &
CORBA::ComponentIR::ModuleDef_var::operator= (const ::CORBA::ComponentIR::ModuleDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::ModuleDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::ModuleDef_var::operator const ::CORBA::ComponentIR::ModuleDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::ModuleDef_var::operator ::CORBA::ComponentIR::ModuleDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ModuleDef_ptr &
CORBA::ComponentIR::ModuleDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ModuleDef_ptr &
CORBA::ComponentIR::ModuleDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ModuleDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::ModuleDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::ModuleDef::_nil ();
  return val;
}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_var::tao_duplicate (ModuleDef_ptr p)
{
  return ::CORBA::ComponentIR::ModuleDef::_duplicate (p);
}

void
CORBA::ComponentIR::ModuleDef_var::tao_release (ModuleDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::ModuleDef::_nil ();
}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::ModuleDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::ModuleDef_var::tao_upcast (void *src)
{
  ModuleDef **tmp =
    ACE_static_cast (ModuleDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::ModuleDef_out
// *************************************************************

CORBA::ComponentIR::ModuleDef_out::ModuleDef_out (ModuleDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::ModuleDef::_nil ();
}

CORBA::ComponentIR::ModuleDef_out::ModuleDef_out (ModuleDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ModuleDef::_nil ();
}

CORBA::ComponentIR::ModuleDef_out::ModuleDef_out (const ::CORBA::ComponentIR::ModuleDef_out &p)
  : ptr_ (ACE_const_cast (ModuleDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::ModuleDef_out &
CORBA::ComponentIR::ModuleDef_out::operator= (const ::CORBA::ComponentIR::ModuleDef_out &p)
{
  this->ptr_ = ACE_const_cast (ModuleDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::ModuleDef_out &
CORBA::ComponentIR::ModuleDef_out::operator= (const ::CORBA::ComponentIR::ModuleDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::ModuleDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::ModuleDef_out &
CORBA::ComponentIR::ModuleDef_out::operator= (ModuleDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ModuleDef_out::operator ::CORBA::ComponentIR::ModuleDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::ModuleDef_ptr &
CORBA::ComponentIR::ModuleDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_ModuleDef_Proxy_Impl::_TAO_ModuleDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Impl::_TAO_ModuleDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_ModuleDef_Proxy_Broker::_TAO_ModuleDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ModuleDef_Proxy_Broker::~_TAO_ModuleDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ModuleDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Broker::_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Broker::~_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ModuleDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::ModuleDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::ModuleDef::ModuleDef (int collocated)
{
  this->CORBA_ComponentIR_ModuleDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::ModuleDef::CORBA_ComponentIR_ModuleDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ModuleDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ModuleDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker ();
  
  this->CORBA_ModuleDef_setup_collocation (collocated);
  this->CORBA_ComponentIR_Container_setup_collocation (collocated);
}

CORBA::ComponentIR::ModuleDef::~ModuleDef (void)
{}

void 
CORBA::ComponentIR::ModuleDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ModuleDef *tmp = ACE_static_cast (ModuleDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ModuleDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/ModuleDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ModuleDef::_nil ());
      
      if (is_a == 0)
        {
          return ModuleDef::_nil ();
        }
    }
  
  return ModuleDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::ModuleDef_ptr 
CORBA::ComponentIR::ModuleDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ModuleDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ModuleDef_ptr default_proxy = ModuleDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ModuleDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ModuleDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ModuleDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ModuleDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ModuleDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ModuleDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::ModuleDef_ptr
CORBA::ComponentIR::ModuleDef::_duplicate (ModuleDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::ModuleDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/ModuleDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::ModuleDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, ModuleDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::ModuleDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ModuleDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, Container)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ComponentIR::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ModuleDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_ModuleDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f4d6f), 
  ACE_NTOHL (0x64756c65), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ModuleDef:1.0
    10,
  ACE_NTOHL (0x4d6f6475), 
  ACE_NTOHL (0x6c654465), 
  ACE_NTOHL (0x66000000),  // name = ModuleDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_ModuleDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_ModuleDef),
    (char *) &_oc_CORBA_ComponentIR_ModuleDef,
    0,
    sizeof (CORBA::ComponentIR::ModuleDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ModuleDef,
    &_tc_TAO_tc_CORBA_ComponentIR_ModuleDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::Repository::_tao_class_id = 0;

CORBA::ComponentIR::Repository_ptr
tao_CORBA_ComponentIR_Repository_duplicate (
    CORBA::ComponentIR::Repository_ptr p
  )
{
  return CORBA::ComponentIR::Repository::_duplicate (p);
}

void
tao_CORBA_ComponentIR_Repository_release (
    CORBA::ComponentIR::Repository_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::Repository_ptr
tao_CORBA_ComponentIR_Repository_nil (
    void
  )
{
  return CORBA::ComponentIR::Repository::_nil ();
}

CORBA::ComponentIR::Repository_ptr
tao_CORBA_ComponentIR_Repository_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::Repository::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_Repository_upcast (
    void *src
  )
{
  CORBA::ComponentIR::Repository **tmp =
    ACE_static_cast (CORBA::ComponentIR::Repository **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_Repository_marshal (
    CORBA::ComponentIR::Repository_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::Repository_var
// *************************************************************

CORBA::ComponentIR::Repository_var::Repository_var (void)
  : ptr_ (Repository::_nil ())
{}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::Repository_var::Repository_var (const ::CORBA::ComponentIR::Repository_var &p)
  : TAO_Base_var (),
    ptr_ (Repository::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::Repository_var::~Repository_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::Repository_var &
CORBA::ComponentIR::Repository_var::operator= (Repository_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::Repository_var &
CORBA::ComponentIR::Repository_var::operator= (const ::CORBA::ComponentIR::Repository_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::Repository::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::Repository_var::operator const ::CORBA::ComponentIR::Repository_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::Repository_var::operator ::CORBA::ComponentIR::Repository_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::Repository_ptr &
CORBA::ComponentIR::Repository_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::Repository_ptr &
CORBA::ComponentIR::Repository_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::Repository::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::Repository_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::Repository::_nil ();
  return val;
}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_var::tao_duplicate (Repository_ptr p)
{
  return ::CORBA::ComponentIR::Repository::_duplicate (p);
}

void
CORBA::ComponentIR::Repository_var::tao_release (Repository_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::Repository::_nil ();
}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::Repository::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::Repository_var::tao_upcast (void *src)
{
  Repository **tmp =
    ACE_static_cast (Repository **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::Repository_out
// *************************************************************

CORBA::ComponentIR::Repository_out::Repository_out (Repository_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::Repository::_nil ();
}

CORBA::ComponentIR::Repository_out::Repository_out (Repository_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::Repository::_nil ();
}

CORBA::ComponentIR::Repository_out::Repository_out (const ::CORBA::ComponentIR::Repository_out &p)
  : ptr_ (ACE_const_cast (Repository_out &, p).ptr_)
{}

::CORBA::ComponentIR::Repository_out &
CORBA::ComponentIR::Repository_out::operator= (const ::CORBA::ComponentIR::Repository_out &p)
{
  this->ptr_ = ACE_const_cast (Repository_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::Repository_out &
CORBA::ComponentIR::Repository_out::operator= (const ::CORBA::ComponentIR::Repository_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::Repository::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::Repository_out &
CORBA::ComponentIR::Repository_out::operator= (Repository_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::Repository_out::operator ::CORBA::ComponentIR::Repository_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::Repository_ptr &
CORBA::ComponentIR::Repository_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_Repository_Proxy_Impl::_TAO_Repository_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Impl::_TAO_Repository_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_Repository_Proxy_Broker::_TAO_Repository_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Repository_Proxy_Broker::~_TAO_Repository_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Repository_Proxy_Broker * (*CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Broker::_TAO_Repository_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Broker::~_TAO_Repository_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_Repository_Proxy_Impl&
CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::Repository *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::Repository::Repository (int collocated)
{
  this->CORBA_ComponentIR_Repository_setup_collocation (collocated);
}

void
CORBA::ComponentIR::Repository::CORBA_ComponentIR_Repository_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Repository_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Repository_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker ();
  
  this->CORBA_Repository_setup_collocation (collocated);
  this->CORBA_ComponentIR_Container_setup_collocation (collocated);
}

CORBA::ComponentIR::Repository::~Repository (void)
{}

void 
CORBA::ComponentIR::Repository::_tao_any_destructor (void *_tao_void_pointer)
{
  Repository *tmp = ACE_static_cast (Repository *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return Repository::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/Repository:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (Repository::_nil ());
      
      if (is_a == 0)
        {
          return Repository::_nil ();
        }
    }
  
  return Repository::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::Repository_ptr 
CORBA::ComponentIR::Repository::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Repository::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      Repository_ptr default_proxy = Repository::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::Repository (
                  stub,
                  1,
                  obj->_servant ()
                ),
              Repository::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::Repository (
                  stub,
                  0,
                  obj->_servant ()
                ),
              Repository::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          Repository_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Repository::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::Repository_ptr
CORBA::ComponentIR::Repository::_duplicate (Repository_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::Repository::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/Repository:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Repository:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::Repository::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, Repository)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Repository::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Repository_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, Container)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ComponentIR::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/Repository:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_Repository[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5265), 
  ACE_NTOHL (0x706f7369), 
  ACE_NTOHL (0x746f7279), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ComponentIR/Repository:1.0
    11,
  ACE_NTOHL (0x5265706f), 
  ACE_NTOHL (0x7369746f), 
  ACE_NTOHL (0x72790000),  // name = Repository
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_Repository (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_Repository),
    (char *) &_oc_CORBA_ComponentIR_Repository,
    0,
    sizeof (CORBA::ComponentIR::Repository)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Repository,
    &_tc_TAO_tc_CORBA_ComponentIR_Repository
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::ProvidesDef::_tao_class_id = 0;

CORBA::ComponentIR::ProvidesDef_ptr
tao_CORBA_ComponentIR_ProvidesDef_duplicate (
    CORBA::ComponentIR::ProvidesDef_ptr p
  )
{
  return CORBA::ComponentIR::ProvidesDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_ProvidesDef_release (
    CORBA::ComponentIR::ProvidesDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::ProvidesDef_ptr
tao_CORBA_ComponentIR_ProvidesDef_nil (
    void
  )
{
  return CORBA::ComponentIR::ProvidesDef::_nil ();
}

CORBA::ComponentIR::ProvidesDef_ptr
tao_CORBA_ComponentIR_ProvidesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::ProvidesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_ProvidesDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::ProvidesDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::ProvidesDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_ProvidesDef_marshal (
    CORBA::ComponentIR::ProvidesDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::ProvidesDef_var
// *************************************************************

CORBA::ComponentIR::ProvidesDef_var::ProvidesDef_var (void)
  : ptr_ (ProvidesDef::_nil ())
{}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::ProvidesDef_var::ProvidesDef_var (const ::CORBA::ComponentIR::ProvidesDef_var &p)
  : TAO_Base_var (),
    ptr_ (ProvidesDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::ProvidesDef_var::~ProvidesDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::ProvidesDef_var &
CORBA::ComponentIR::ProvidesDef_var::operator= (ProvidesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ProvidesDef_var &
CORBA::ComponentIR::ProvidesDef_var::operator= (const ::CORBA::ComponentIR::ProvidesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::ProvidesDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::ProvidesDef_var::operator const ::CORBA::ComponentIR::ProvidesDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::ProvidesDef_var::operator ::CORBA::ComponentIR::ProvidesDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ProvidesDef_ptr &
CORBA::ComponentIR::ProvidesDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ProvidesDef_ptr &
CORBA::ComponentIR::ProvidesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ProvidesDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::ProvidesDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::ProvidesDef::_nil ();
  return val;
}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_var::tao_duplicate (ProvidesDef_ptr p)
{
  return ::CORBA::ComponentIR::ProvidesDef::_duplicate (p);
}

void
CORBA::ComponentIR::ProvidesDef_var::tao_release (ProvidesDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::ProvidesDef::_nil ();
}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::ProvidesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::ProvidesDef_var::tao_upcast (void *src)
{
  ProvidesDef **tmp =
    ACE_static_cast (ProvidesDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::ProvidesDef_out
// *************************************************************

CORBA::ComponentIR::ProvidesDef_out::ProvidesDef_out (ProvidesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::ProvidesDef::_nil ();
}

CORBA::ComponentIR::ProvidesDef_out::ProvidesDef_out (ProvidesDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ProvidesDef::_nil ();
}

CORBA::ComponentIR::ProvidesDef_out::ProvidesDef_out (const ::CORBA::ComponentIR::ProvidesDef_out &p)
  : ptr_ (ACE_const_cast (ProvidesDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::ProvidesDef_out &
CORBA::ComponentIR::ProvidesDef_out::operator= (const ::CORBA::ComponentIR::ProvidesDef_out &p)
{
  this->ptr_ = ACE_const_cast (ProvidesDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::ProvidesDef_out &
CORBA::ComponentIR::ProvidesDef_out::operator= (const ::CORBA::ComponentIR::ProvidesDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::ProvidesDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::ProvidesDef_out &
CORBA::ComponentIR::ProvidesDef_out::operator= (ProvidesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ProvidesDef_out::operator ::CORBA::ComponentIR::ProvidesDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::ProvidesDef_ptr &
CORBA::ComponentIR::ProvidesDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get &);
    
    ::CORBA::InterfaceDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get::TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get::result (::CORBA::InterfaceDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::InterfaceDef_ptr interface_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set &);
    CORBA::InterfaceDef_ptr interface_type_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set::TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::InterfaceDef_ptr interface_type
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      interface_type_ (interface_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_ProvidesDef_Proxy_Impl::_TAO_ProvidesDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Impl::_TAO_ProvidesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDef_ptr CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDef_var _tao_retval (CORBA::InterfaceDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::InterfaceDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_interface_type",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ProvidesDef_interface_type_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          interface_type
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << interface_type)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_ProvidesDef_Proxy_Broker::_TAO_ProvidesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ProvidesDef_Proxy_Broker::~_TAO_ProvidesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ProvidesDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Broker::_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Broker::~_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ProvidesDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::ProvidesDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::ProvidesDef::ProvidesDef (int collocated)
{
  this->CORBA_ComponentIR_ProvidesDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::ProvidesDef::CORBA_ComponentIR_ProvidesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::ComponentIR::ProvidesDef::~ProvidesDef (void)
{}

void 
CORBA::ComponentIR::ProvidesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ProvidesDef *tmp = ACE_static_cast (ProvidesDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ProvidesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/ProvidesDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ProvidesDef::_nil ());
      
      if (is_a == 0)
        {
          return ProvidesDef::_nil ();
        }
    }
  
  return ProvidesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::ProvidesDef_ptr 
CORBA::ComponentIR::ProvidesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ProvidesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ProvidesDef_ptr default_proxy = ProvidesDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ProvidesDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ProvidesDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ProvidesDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ProvidesDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ProvidesDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ProvidesDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::ProvidesDef_ptr
CORBA::ComponentIR::ProvidesDef::_duplicate (ProvidesDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::ProvidesDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/ProvidesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::ProvidesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, ProvidesDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ProvidesDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDef_ptr CORBA::ComponentIR::ProvidesDef::interface_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ProvidesDef_Proxy_Impl &proxy = 
    this->the_TAO_ProvidesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.interface_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::ProvidesDef::interface_type (
    CORBA::InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ProvidesDef_Proxy_Impl &proxy = 
    this->the_TAO_ProvidesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.interface_type (
      this,
      interface_type
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_ProvidesDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5072), 
  ACE_NTOHL (0x6f766964), 
  ACE_NTOHL (0x65734465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ProvidesDef:1.0
    12,
  ACE_NTOHL (0x50726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x44656600),  // name = ProvidesDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_ProvidesDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_ProvidesDef),
    (char *) &_oc_CORBA_ComponentIR_ProvidesDef,
    0,
    sizeof (CORBA::ComponentIR::ProvidesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ProvidesDef,
    &_tc_TAO_tc_CORBA_ComponentIR_ProvidesDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_ProvidesDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5072), 
  ACE_NTOHL (0x6f766964), 
  ACE_NTOHL (0x65734465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ProvidesDescription:1.0
    20,
  ACE_NTOHL (0x50726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
  5, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  15,
  ACE_NTOHL (0x696e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x655f7479), 
  ACE_NTOHL (0x70650000),  // name = interface_type
    0xffffffff, // indirection
  0xffffff28, // negative offset (-216)
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_ProvidesDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ComponentIR_ProvidesDescription),
    (char *) &_oc_CORBA_ComponentIR_ProvidesDescription,
    0,
    sizeof (CORBA::ComponentIR::ProvidesDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ProvidesDescription,
    &_tc_TAO_tc_CORBA_ComponentIR_ProvidesDescription
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ComponentIR::ProvidesDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ProvidesDescription *tmp = ACE_static_cast (ProvidesDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::UsesDef::_tao_class_id = 0;

CORBA::ComponentIR::UsesDef_ptr
tao_CORBA_ComponentIR_UsesDef_duplicate (
    CORBA::ComponentIR::UsesDef_ptr p
  )
{
  return CORBA::ComponentIR::UsesDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_UsesDef_release (
    CORBA::ComponentIR::UsesDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::UsesDef_ptr
tao_CORBA_ComponentIR_UsesDef_nil (
    void
  )
{
  return CORBA::ComponentIR::UsesDef::_nil ();
}

CORBA::ComponentIR::UsesDef_ptr
tao_CORBA_ComponentIR_UsesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::UsesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_UsesDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::UsesDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::UsesDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_UsesDef_marshal (
    CORBA::ComponentIR::UsesDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::UsesDef_var
// *************************************************************

CORBA::ComponentIR::UsesDef_var::UsesDef_var (void)
  : ptr_ (UsesDef::_nil ())
{}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::UsesDef_var::UsesDef_var (const ::CORBA::ComponentIR::UsesDef_var &p)
  : TAO_Base_var (),
    ptr_ (UsesDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::UsesDef_var::~UsesDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::UsesDef_var &
CORBA::ComponentIR::UsesDef_var::operator= (UsesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::UsesDef_var &
CORBA::ComponentIR::UsesDef_var::operator= (const ::CORBA::ComponentIR::UsesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::UsesDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::UsesDef_var::operator const ::CORBA::ComponentIR::UsesDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::UsesDef_var::operator ::CORBA::ComponentIR::UsesDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::UsesDef_ptr &
CORBA::ComponentIR::UsesDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::UsesDef_ptr &
CORBA::ComponentIR::UsesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::UsesDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::UsesDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::UsesDef::_nil ();
  return val;
}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_var::tao_duplicate (UsesDef_ptr p)
{
  return ::CORBA::ComponentIR::UsesDef::_duplicate (p);
}

void
CORBA::ComponentIR::UsesDef_var::tao_release (UsesDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::UsesDef::_nil ();
}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::UsesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::UsesDef_var::tao_upcast (void *src)
{
  UsesDef **tmp =
    ACE_static_cast (UsesDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::UsesDef_out
// *************************************************************

CORBA::ComponentIR::UsesDef_out::UsesDef_out (UsesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::UsesDef::_nil ();
}

CORBA::ComponentIR::UsesDef_out::UsesDef_out (UsesDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::UsesDef::_nil ();
}

CORBA::ComponentIR::UsesDef_out::UsesDef_out (const ::CORBA::ComponentIR::UsesDef_out &p)
  : ptr_ (ACE_const_cast (UsesDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::UsesDef_out &
CORBA::ComponentIR::UsesDef_out::operator= (const ::CORBA::ComponentIR::UsesDef_out &p)
{
  this->ptr_ = ACE_const_cast (UsesDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::UsesDef_out &
CORBA::ComponentIR::UsesDef_out::operator= (const ::CORBA::ComponentIR::UsesDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::UsesDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::UsesDef_out &
CORBA::ComponentIR::UsesDef_out::operator= (UsesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::UsesDef_out::operator ::CORBA::ComponentIR::UsesDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::UsesDef_ptr &
CORBA::ComponentIR::UsesDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get &);
    
    ::CORBA::InterfaceDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get::TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get::result (::CORBA::InterfaceDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::InterfaceDef_ptr interface_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set &);
    CORBA::InterfaceDef_ptr interface_type_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set::TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::InterfaceDef_ptr interface_type
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      interface_type_ (interface_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Boolean result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get &);
    
    ::CORBA::Boolean _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get::TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_multiple
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set &);
    const CORBA::Boolean & is_multiple_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set::TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_multiple
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_UsesDef_Proxy_Impl::_TAO_UsesDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Impl::_TAO_UsesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDef_ptr CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDef_var _tao_retval (CORBA::InterfaceDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::InterfaceDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_interface_type",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_interface_type_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          interface_type
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << interface_type)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_multiple",
      16,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_multiple
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_multiple",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_UsesDef_is_multiple_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          is_multiple
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << CORBA::Any::from_boolean (is_multiple))
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_UsesDef_Proxy_Broker::_TAO_UsesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_UsesDef_Proxy_Broker::~_TAO_UsesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_UsesDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Broker::_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Broker::~_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_UsesDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::UsesDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::UsesDef::UsesDef (int collocated)
{
  this->CORBA_ComponentIR_UsesDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::UsesDef::CORBA_ComponentIR_UsesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_UsesDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_UsesDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::ComponentIR::UsesDef::~UsesDef (void)
{}

void 
CORBA::ComponentIR::UsesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  UsesDef *tmp = ACE_static_cast (UsesDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return UsesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/UsesDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (UsesDef::_nil ());
      
      if (is_a == 0)
        {
          return UsesDef::_nil ();
        }
    }
  
  return UsesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::UsesDef_ptr 
CORBA::ComponentIR::UsesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return UsesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      UsesDef_ptr default_proxy = UsesDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::UsesDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              UsesDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::UsesDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              UsesDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          UsesDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &UsesDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::UsesDef_ptr
CORBA::ComponentIR::UsesDef::_duplicate (UsesDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::UsesDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/UsesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::UsesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, UsesDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/UsesDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDef_ptr CORBA::ComponentIR::UsesDef::interface_type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy = 
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.interface_type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::UsesDef::interface_type (
    CORBA::InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy = 
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.interface_type (
      this,
      interface_type
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean CORBA::ComponentIR::UsesDef::is_multiple (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy = 
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_multiple (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::UsesDef::is_multiple (
    CORBA::Boolean is_multiple
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_UsesDef_Proxy_Impl &proxy = 
    this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.is_multiple (
      this,
      is_multiple
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_UsesDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5573), 
  ACE_NTOHL (0x65734465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/UsesDef:1.0
    8,
  ACE_NTOHL (0x55736573), 
  ACE_NTOHL (0x44656600),  // name = UsesDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_UsesDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_UsesDef),
    (char *) &_oc_CORBA_ComponentIR_UsesDef,
    0,
    sizeof (CORBA::ComponentIR::UsesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UsesDef,
    &_tc_TAO_tc_CORBA_ComponentIR_UsesDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_UsesDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5573), 
  ACE_NTOHL (0x65734465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/UsesDescription:1.0
    16,
  ACE_NTOHL (0x55736573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = UsesDescription
  6, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  15,
  ACE_NTOHL (0x696e7465), 
  ACE_NTOHL (0x72666163), 
  ACE_NTOHL (0x655f7479), 
  ACE_NTOHL (0x70650000),  // name = interface_type
    0xffffffff, // indirection
  0xffffff28, // negative offset (-216)
  12,
  ACE_NTOHL (0x69735f6d), 
  ACE_NTOHL (0x756c7469), 
  ACE_NTOHL (0x706c6500),  // name = is_multiple
    CORBA::tk_boolean,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_UsesDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ComponentIR_UsesDescription),
    (char *) &_oc_CORBA_ComponentIR_UsesDescription,
    0,
    sizeof (CORBA::ComponentIR::UsesDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UsesDescription,
    &_tc_TAO_tc_CORBA_ComponentIR_UsesDescription
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ComponentIR::UsesDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  UsesDescription *tmp = ACE_static_cast (UsesDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::EventPortDef::_tao_class_id = 0;

CORBA::ComponentIR::EventPortDef_ptr
tao_CORBA_ComponentIR_EventPortDef_duplicate (
    CORBA::ComponentIR::EventPortDef_ptr p
  )
{
  return CORBA::ComponentIR::EventPortDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_EventPortDef_release (
    CORBA::ComponentIR::EventPortDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::EventPortDef_ptr
tao_CORBA_ComponentIR_EventPortDef_nil (
    void
  )
{
  return CORBA::ComponentIR::EventPortDef::_nil ();
}

CORBA::ComponentIR::EventPortDef_ptr
tao_CORBA_ComponentIR_EventPortDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::EventPortDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_EventPortDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::EventPortDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::EventPortDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_EventPortDef_marshal (
    CORBA::ComponentIR::EventPortDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::EventPortDef_var
// *************************************************************

CORBA::ComponentIR::EventPortDef_var::EventPortDef_var (void)
  : ptr_ (EventPortDef::_nil ())
{}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::EventPortDef_var::EventPortDef_var (const ::CORBA::ComponentIR::EventPortDef_var &p)
  : TAO_Base_var (),
    ptr_ (EventPortDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::EventPortDef_var::~EventPortDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::EventPortDef_var &
CORBA::ComponentIR::EventPortDef_var::operator= (EventPortDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::EventPortDef_var &
CORBA::ComponentIR::EventPortDef_var::operator= (const ::CORBA::ComponentIR::EventPortDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::EventPortDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::EventPortDef_var::operator const ::CORBA::ComponentIR::EventPortDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::EventPortDef_var::operator ::CORBA::ComponentIR::EventPortDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventPortDef_ptr &
CORBA::ComponentIR::EventPortDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventPortDef_ptr &
CORBA::ComponentIR::EventPortDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::EventPortDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::EventPortDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::EventPortDef::_nil ();
  return val;
}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_var::tao_duplicate (EventPortDef_ptr p)
{
  return ::CORBA::ComponentIR::EventPortDef::_duplicate (p);
}

void
CORBA::ComponentIR::EventPortDef_var::tao_release (EventPortDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::EventPortDef::_nil ();
}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::EventPortDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::EventPortDef_var::tao_upcast (void *src)
{
  EventPortDef **tmp =
    ACE_static_cast (EventPortDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::EventPortDef_out
// *************************************************************

CORBA::ComponentIR::EventPortDef_out::EventPortDef_out (EventPortDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::EventPortDef::_nil ();
}

CORBA::ComponentIR::EventPortDef_out::EventPortDef_out (EventPortDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::EventPortDef::_nil ();
}

CORBA::ComponentIR::EventPortDef_out::EventPortDef_out (const ::CORBA::ComponentIR::EventPortDef_out &p)
  : ptr_ (ACE_const_cast (EventPortDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::EventPortDef_out &
CORBA::ComponentIR::EventPortDef_out::operator= (const ::CORBA::ComponentIR::EventPortDef_out &p)
{
  this->ptr_ = ACE_const_cast (EventPortDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::EventPortDef_out &
CORBA::ComponentIR::EventPortDef_out::operator= (const ::CORBA::ComponentIR::EventPortDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::EventPortDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::EventPortDef_out &
CORBA::ComponentIR::EventPortDef_out::operator= (EventPortDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::EventPortDef_out::operator ::CORBA::ComponentIR::EventPortDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventPortDef_ptr &
CORBA::ComponentIR::EventPortDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::EventDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get &);
    
    ::CORBA::ComponentIR::EventDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get::TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get::result (::CORBA::ComponentIR::EventDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set &);
    CORBA::ComponentIR::EventDef_ptr event_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set::TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      event_ (event)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->event_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * event_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Boolean result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a (const TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a &);
    const char * event_id_;
    
    ::CORBA::Boolean _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a::TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * event_id
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      event_id_ (event_id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= event_id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_EventPortDef_Proxy_Impl::_TAO_EventPortDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Impl::_TAO_EventPortDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::EventDef_ptr CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::EventDef_var _tao_retval (CORBA::ComponentIR::EventDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_event",
      10,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::EventDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_event",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_event_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          event
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << event)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_EventPortDef_is_a _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          event_id
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << event_id)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  _tao_retval
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_EventPortDef_Proxy_Broker::_TAO_EventPortDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventPortDef_Proxy_Broker::~_TAO_EventPortDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventPortDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Broker::the_TAO_EventPortDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Broker::_TAO_EventPortDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Broker::~_TAO_EventPortDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EventPortDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::EventPortDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::EventPortDef::EventPortDef (int collocated)
{
  this->CORBA_ComponentIR_EventPortDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::EventPortDef::CORBA_ComponentIR_EventPortDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EventPortDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EventPortDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_EventPortDef_Remote_Proxy_Broker::the_TAO_EventPortDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::ComponentIR::EventPortDef::~EventPortDef (void)
{}

void 
CORBA::ComponentIR::EventPortDef::_tao_any_destructor (void *_tao_void_pointer)
{
  EventPortDef *tmp = ACE_static_cast (EventPortDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return EventPortDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (EventPortDef::_nil ());
      
      if (is_a == 0)
        {
          return EventPortDef::_nil ();
        }
    }
  
  return EventPortDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::EventPortDef_ptr 
CORBA::ComponentIR::EventPortDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return EventPortDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      EventPortDef_ptr default_proxy = EventPortDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::EventPortDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              EventPortDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::EventPortDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              EventPortDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          EventPortDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &EventPortDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::EventPortDef_ptr
CORBA::ComponentIR::EventPortDef::_duplicate (EventPortDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::EventPortDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::EventPortDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, EventPortDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::EventPortDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::EventDef_ptr CORBA::ComponentIR::EventPortDef::event (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_EventPortDef_Proxy_Impl &proxy = 
    this->the_TAO_EventPortDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.event (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::EventPortDef::event (
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_EventPortDef_Proxy_Impl &proxy = 
    this->the_TAO_EventPortDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.event (
      this,
      event
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean CORBA::ComponentIR::EventPortDef::is_a (
    const char * event_id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_EventPortDef_Proxy_Impl &proxy = 
    this->the_TAO_EventPortDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_a (
      this,
      event_id
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_EventPortDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f4576), 
  ACE_NTOHL (0x656e7450), 
  ACE_NTOHL (0x6f727444), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0
    13,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74506f72), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x0),  // name = EventPortDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_EventPortDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_EventPortDef),
    (char *) &_oc_CORBA_ComponentIR_EventPortDef,
    0,
    sizeof (CORBA::ComponentIR::EventPortDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EventPortDef,
    &_tc_TAO_tc_CORBA_ComponentIR_EventPortDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_EventPortDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f4576), 
  ACE_NTOHL (0x656e7450), 
  ACE_NTOHL (0x6f727444), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EventPortDescription:1.0
    21,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74506f72), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = EventPortDescription
  5, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  6,
  ACE_NTOHL (0x6576656e), 
  ACE_NTOHL (0x74000000),  // name = event
    0xffffffff, // indirection
  0xffffff30, // negative offset (-208)
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_EventPortDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ComponentIR_EventPortDescription),
    (char *) &_oc_CORBA_ComponentIR_EventPortDescription,
    0,
    sizeof (CORBA::ComponentIR::EventPortDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EventPortDescription,
    &_tc_TAO_tc_CORBA_ComponentIR_EventPortDescription
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ComponentIR::EventPortDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  EventPortDescription *tmp = ACE_static_cast (EventPortDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::EmitsDef::_tao_class_id = 0;

CORBA::ComponentIR::EmitsDef_ptr
tao_CORBA_ComponentIR_EmitsDef_duplicate (
    CORBA::ComponentIR::EmitsDef_ptr p
  )
{
  return CORBA::ComponentIR::EmitsDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_EmitsDef_release (
    CORBA::ComponentIR::EmitsDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::EmitsDef_ptr
tao_CORBA_ComponentIR_EmitsDef_nil (
    void
  )
{
  return CORBA::ComponentIR::EmitsDef::_nil ();
}

CORBA::ComponentIR::EmitsDef_ptr
tao_CORBA_ComponentIR_EmitsDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::EmitsDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_EmitsDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::EmitsDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::EmitsDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_EmitsDef_marshal (
    CORBA::ComponentIR::EmitsDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::EmitsDef_var
// *************************************************************

CORBA::ComponentIR::EmitsDef_var::EmitsDef_var (void)
  : ptr_ (EmitsDef::_nil ())
{}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::EmitsDef_var::EmitsDef_var (const ::CORBA::ComponentIR::EmitsDef_var &p)
  : TAO_Base_var (),
    ptr_ (EmitsDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::EmitsDef_var::~EmitsDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::EmitsDef_var &
CORBA::ComponentIR::EmitsDef_var::operator= (EmitsDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::EmitsDef_var &
CORBA::ComponentIR::EmitsDef_var::operator= (const ::CORBA::ComponentIR::EmitsDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::EmitsDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::EmitsDef_var::operator const ::CORBA::ComponentIR::EmitsDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::EmitsDef_var::operator ::CORBA::ComponentIR::EmitsDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::EmitsDef_ptr &
CORBA::ComponentIR::EmitsDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::EmitsDef_ptr &
CORBA::ComponentIR::EmitsDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::EmitsDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::EmitsDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::EmitsDef::_nil ();
  return val;
}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_var::tao_duplicate (EmitsDef_ptr p)
{
  return ::CORBA::ComponentIR::EmitsDef::_duplicate (p);
}

void
CORBA::ComponentIR::EmitsDef_var::tao_release (EmitsDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::EmitsDef::_nil ();
}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::EmitsDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::EmitsDef_var::tao_upcast (void *src)
{
  EmitsDef **tmp =
    ACE_static_cast (EmitsDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::EmitsDef_out
// *************************************************************

CORBA::ComponentIR::EmitsDef_out::EmitsDef_out (EmitsDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::EmitsDef::_nil ();
}

CORBA::ComponentIR::EmitsDef_out::EmitsDef_out (EmitsDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::EmitsDef::_nil ();
}

CORBA::ComponentIR::EmitsDef_out::EmitsDef_out (const ::CORBA::ComponentIR::EmitsDef_out &p)
  : ptr_ (ACE_const_cast (EmitsDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::EmitsDef_out &
CORBA::ComponentIR::EmitsDef_out::operator= (const ::CORBA::ComponentIR::EmitsDef_out &p)
{
  this->ptr_ = ACE_const_cast (EmitsDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::EmitsDef_out &
CORBA::ComponentIR::EmitsDef_out::operator= (const ::CORBA::ComponentIR::EmitsDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::EmitsDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::EmitsDef_out &
CORBA::ComponentIR::EmitsDef_out::operator= (EmitsDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::EmitsDef_out::operator ::CORBA::ComponentIR::EmitsDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::EmitsDef_ptr &
CORBA::ComponentIR::EmitsDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_EmitsDef_Proxy_Impl::_TAO_EmitsDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Impl::_TAO_EmitsDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_EmitsDef_Proxy_Broker::_TAO_EmitsDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EmitsDef_Proxy_Broker::~_TAO_EmitsDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EmitsDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Broker::_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Broker::~_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_EmitsDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::EmitsDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::EmitsDef::EmitsDef (int collocated)
{
  this->CORBA_ComponentIR_EmitsDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::EmitsDef::CORBA_ComponentIR_EmitsDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker ();
  
  this->CORBA_ComponentIR_EventPortDef_setup_collocation (collocated);
}

CORBA::ComponentIR::EmitsDef::~EmitsDef (void)
{}

void 
CORBA::ComponentIR::EmitsDef::_tao_any_destructor (void *_tao_void_pointer)
{
  EmitsDef *tmp = ACE_static_cast (EmitsDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return EmitsDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/EmitsDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (EmitsDef::_nil ());
      
      if (is_a == 0)
        {
          return EmitsDef::_nil ();
        }
    }
  
  return EmitsDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::EmitsDef_ptr 
CORBA::ComponentIR::EmitsDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return EmitsDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      EmitsDef_ptr default_proxy = EmitsDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::EmitsDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              EmitsDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::EmitsDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              EmitsDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          EmitsDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &EmitsDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::EmitsDef_ptr
CORBA::ComponentIR::EmitsDef::_duplicate (EmitsDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::EmitsDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/EmitsDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::EmitsDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, EmitsDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, EventPortDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ComponentIR::EventPortDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/EmitsDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_EmitsDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  43,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f456d), 
  ACE_NTOHL (0x69747344), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EmitsDef:1.0
    9,
  ACE_NTOHL (0x456d6974), 
  ACE_NTOHL (0x73446566), 
  ACE_NTOHL (0x0),  // name = EmitsDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_EmitsDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_EmitsDef),
    (char *) &_oc_CORBA_ComponentIR_EmitsDef,
    0,
    sizeof (CORBA::ComponentIR::EmitsDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EmitsDef,
    &_tc_TAO_tc_CORBA_ComponentIR_EmitsDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::PublishesDef::_tao_class_id = 0;

CORBA::ComponentIR::PublishesDef_ptr
tao_CORBA_ComponentIR_PublishesDef_duplicate (
    CORBA::ComponentIR::PublishesDef_ptr p
  )
{
  return CORBA::ComponentIR::PublishesDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_PublishesDef_release (
    CORBA::ComponentIR::PublishesDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::PublishesDef_ptr
tao_CORBA_ComponentIR_PublishesDef_nil (
    void
  )
{
  return CORBA::ComponentIR::PublishesDef::_nil ();
}

CORBA::ComponentIR::PublishesDef_ptr
tao_CORBA_ComponentIR_PublishesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::PublishesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_PublishesDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::PublishesDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::PublishesDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_PublishesDef_marshal (
    CORBA::ComponentIR::PublishesDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::PublishesDef_var
// *************************************************************

CORBA::ComponentIR::PublishesDef_var::PublishesDef_var (void)
  : ptr_ (PublishesDef::_nil ())
{}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::PublishesDef_var::PublishesDef_var (const ::CORBA::ComponentIR::PublishesDef_var &p)
  : TAO_Base_var (),
    ptr_ (PublishesDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::PublishesDef_var::~PublishesDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::PublishesDef_var &
CORBA::ComponentIR::PublishesDef_var::operator= (PublishesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::PublishesDef_var &
CORBA::ComponentIR::PublishesDef_var::operator= (const ::CORBA::ComponentIR::PublishesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::PublishesDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::PublishesDef_var::operator const ::CORBA::ComponentIR::PublishesDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::PublishesDef_var::operator ::CORBA::ComponentIR::PublishesDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::PublishesDef_ptr &
CORBA::ComponentIR::PublishesDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::PublishesDef_ptr &
CORBA::ComponentIR::PublishesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::PublishesDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::PublishesDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::PublishesDef::_nil ();
  return val;
}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_var::tao_duplicate (PublishesDef_ptr p)
{
  return ::CORBA::ComponentIR::PublishesDef::_duplicate (p);
}

void
CORBA::ComponentIR::PublishesDef_var::tao_release (PublishesDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::PublishesDef::_nil ();
}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::PublishesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::PublishesDef_var::tao_upcast (void *src)
{
  PublishesDef **tmp =
    ACE_static_cast (PublishesDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::PublishesDef_out
// *************************************************************

CORBA::ComponentIR::PublishesDef_out::PublishesDef_out (PublishesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::PublishesDef::_nil ();
}

CORBA::ComponentIR::PublishesDef_out::PublishesDef_out (PublishesDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::PublishesDef::_nil ();
}

CORBA::ComponentIR::PublishesDef_out::PublishesDef_out (const ::CORBA::ComponentIR::PublishesDef_out &p)
  : ptr_ (ACE_const_cast (PublishesDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::PublishesDef_out &
CORBA::ComponentIR::PublishesDef_out::operator= (const ::CORBA::ComponentIR::PublishesDef_out &p)
{
  this->ptr_ = ACE_const_cast (PublishesDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::PublishesDef_out &
CORBA::ComponentIR::PublishesDef_out::operator= (const ::CORBA::ComponentIR::PublishesDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::PublishesDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::PublishesDef_out &
CORBA::ComponentIR::PublishesDef_out::operator= (PublishesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::PublishesDef_out::operator ::CORBA::ComponentIR::PublishesDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::PublishesDef_ptr &
CORBA::ComponentIR::PublishesDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_PublishesDef_Proxy_Impl::_TAO_PublishesDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Impl::_TAO_PublishesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_PublishesDef_Proxy_Broker::_TAO_PublishesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_PublishesDef_Proxy_Broker::~_TAO_PublishesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_PublishesDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Broker::_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Broker::~_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_PublishesDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::PublishesDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::PublishesDef::PublishesDef (int collocated)
{
  this->CORBA_ComponentIR_PublishesDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::PublishesDef::CORBA_ComponentIR_PublishesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker ();
  
  this->CORBA_ComponentIR_EventPortDef_setup_collocation (collocated);
}

CORBA::ComponentIR::PublishesDef::~PublishesDef (void)
{}

void 
CORBA::ComponentIR::PublishesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  PublishesDef *tmp = ACE_static_cast (PublishesDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return PublishesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/PublishesDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (PublishesDef::_nil ());
      
      if (is_a == 0)
        {
          return PublishesDef::_nil ();
        }
    }
  
  return PublishesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::PublishesDef_ptr 
CORBA::ComponentIR::PublishesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return PublishesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      PublishesDef_ptr default_proxy = PublishesDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::PublishesDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              PublishesDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::PublishesDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              PublishesDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          PublishesDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &PublishesDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::PublishesDef_ptr
CORBA::ComponentIR::PublishesDef::_duplicate (PublishesDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::PublishesDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/PublishesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::PublishesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, PublishesDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, EventPortDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ComponentIR::EventPortDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/PublishesDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_PublishesDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5075), 
  ACE_NTOHL (0x626c6973), 
  ACE_NTOHL (0x68657344), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/PublishesDef:1.0
    13,
  ACE_NTOHL (0x5075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x73446566), 
  ACE_NTOHL (0x0),  // name = PublishesDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_PublishesDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_PublishesDef),
    (char *) &_oc_CORBA_ComponentIR_PublishesDef,
    0,
    sizeof (CORBA::ComponentIR::PublishesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_PublishesDef,
    &_tc_TAO_tc_CORBA_ComponentIR_PublishesDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::ConsumesDef::_tao_class_id = 0;

CORBA::ComponentIR::ConsumesDef_ptr
tao_CORBA_ComponentIR_ConsumesDef_duplicate (
    CORBA::ComponentIR::ConsumesDef_ptr p
  )
{
  return CORBA::ComponentIR::ConsumesDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_ConsumesDef_release (
    CORBA::ComponentIR::ConsumesDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::ConsumesDef_ptr
tao_CORBA_ComponentIR_ConsumesDef_nil (
    void
  )
{
  return CORBA::ComponentIR::ConsumesDef::_nil ();
}

CORBA::ComponentIR::ConsumesDef_ptr
tao_CORBA_ComponentIR_ConsumesDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::ConsumesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_ConsumesDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::ConsumesDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::ConsumesDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_ConsumesDef_marshal (
    CORBA::ComponentIR::ConsumesDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::ConsumesDef_var
// *************************************************************

CORBA::ComponentIR::ConsumesDef_var::ConsumesDef_var (void)
  : ptr_ (ConsumesDef::_nil ())
{}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::ConsumesDef_var::ConsumesDef_var (const ::CORBA::ComponentIR::ConsumesDef_var &p)
  : TAO_Base_var (),
    ptr_ (ConsumesDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::ConsumesDef_var::~ConsumesDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::ConsumesDef_var &
CORBA::ComponentIR::ConsumesDef_var::operator= (ConsumesDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ConsumesDef_var &
CORBA::ComponentIR::ConsumesDef_var::operator= (const ::CORBA::ComponentIR::ConsumesDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::ConsumesDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::ConsumesDef_var::operator const ::CORBA::ComponentIR::ConsumesDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::ConsumesDef_var::operator ::CORBA::ComponentIR::ConsumesDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ConsumesDef_ptr &
CORBA::ComponentIR::ConsumesDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ConsumesDef_ptr &
CORBA::ComponentIR::ConsumesDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ConsumesDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::ConsumesDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::ConsumesDef::_nil ();
  return val;
}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_var::tao_duplicate (ConsumesDef_ptr p)
{
  return ::CORBA::ComponentIR::ConsumesDef::_duplicate (p);
}

void
CORBA::ComponentIR::ConsumesDef_var::tao_release (ConsumesDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::ConsumesDef::_nil ();
}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::ConsumesDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::ConsumesDef_var::tao_upcast (void *src)
{
  ConsumesDef **tmp =
    ACE_static_cast (ConsumesDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::ConsumesDef_out
// *************************************************************

CORBA::ComponentIR::ConsumesDef_out::ConsumesDef_out (ConsumesDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::ConsumesDef::_nil ();
}

CORBA::ComponentIR::ConsumesDef_out::ConsumesDef_out (ConsumesDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ConsumesDef::_nil ();
}

CORBA::ComponentIR::ConsumesDef_out::ConsumesDef_out (const ::CORBA::ComponentIR::ConsumesDef_out &p)
  : ptr_ (ACE_const_cast (ConsumesDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::ConsumesDef_out &
CORBA::ComponentIR::ConsumesDef_out::operator= (const ::CORBA::ComponentIR::ConsumesDef_out &p)
{
  this->ptr_ = ACE_const_cast (ConsumesDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::ConsumesDef_out &
CORBA::ComponentIR::ConsumesDef_out::operator= (const ::CORBA::ComponentIR::ConsumesDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::ConsumesDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::ConsumesDef_out &
CORBA::ComponentIR::ConsumesDef_out::operator= (ConsumesDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ConsumesDef_out::operator ::CORBA::ComponentIR::ConsumesDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::ConsumesDef_ptr &
CORBA::ComponentIR::ConsumesDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_ConsumesDef_Proxy_Impl::_TAO_ConsumesDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Impl::_TAO_ConsumesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_ConsumesDef_Proxy_Broker::_TAO_ConsumesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ConsumesDef_Proxy_Broker::~_TAO_ConsumesDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ConsumesDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Broker::_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Broker::~_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ConsumesDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::ConsumesDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::ConsumesDef::ConsumesDef (int collocated)
{
  this->CORBA_ComponentIR_ConsumesDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::ConsumesDef::CORBA_ComponentIR_ConsumesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker ();
  
  this->CORBA_ComponentIR_EventPortDef_setup_collocation (collocated);
}

CORBA::ComponentIR::ConsumesDef::~ConsumesDef (void)
{}

void 
CORBA::ComponentIR::ConsumesDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ConsumesDef *tmp = ACE_static_cast (ConsumesDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ConsumesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/ConsumesDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ConsumesDef::_nil ());
      
      if (is_a == 0)
        {
          return ConsumesDef::_nil ();
        }
    }
  
  return ConsumesDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::ConsumesDef_ptr 
CORBA::ComponentIR::ConsumesDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ConsumesDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ConsumesDef_ptr default_proxy = ConsumesDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ConsumesDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ConsumesDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ConsumesDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ConsumesDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ConsumesDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ConsumesDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::ConsumesDef_ptr
CORBA::ComponentIR::ConsumesDef::_duplicate (ConsumesDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::ConsumesDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/ConsumesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::ConsumesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, ConsumesDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, EventPortDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ComponentIR::EventPortDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ConsumesDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_ConsumesDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f436f), 
  ACE_NTOHL (0x6e73756d), 
  ACE_NTOHL (0x65734465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ConsumesDef:1.0
    12,
  ACE_NTOHL (0x436f6e73), 
  ACE_NTOHL (0x756d6573), 
  ACE_NTOHL (0x44656600),  // name = ConsumesDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_ConsumesDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_ConsumesDef),
    (char *) &_oc_CORBA_ComponentIR_ConsumesDef,
    0,
    sizeof (CORBA::ComponentIR::ConsumesDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ConsumesDef,
    &_tc_TAO_tc_CORBA_ComponentIR_ConsumesDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::ComponentDef::_tao_class_id = 0;

CORBA::ComponentIR::ComponentDef_ptr
tao_CORBA_ComponentIR_ComponentDef_duplicate (
    CORBA::ComponentIR::ComponentDef_ptr p
  )
{
  return CORBA::ComponentIR::ComponentDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_ComponentDef_release (
    CORBA::ComponentIR::ComponentDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::ComponentDef_ptr
tao_CORBA_ComponentIR_ComponentDef_nil (
    void
  )
{
  return CORBA::ComponentIR::ComponentDef::_nil ();
}

CORBA::ComponentIR::ComponentDef_ptr
tao_CORBA_ComponentIR_ComponentDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::ComponentDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_ComponentDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::ComponentDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::ComponentDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_ComponentDef_marshal (
    CORBA::ComponentIR::ComponentDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::ComponentDef_var
// *************************************************************

CORBA::ComponentIR::ComponentDef_var::ComponentDef_var (void)
  : ptr_ (ComponentDef::_nil ())
{}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::ComponentDef_var::ComponentDef_var (const ::CORBA::ComponentIR::ComponentDef_var &p)
  : TAO_Base_var (),
    ptr_ (ComponentDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::ComponentDef_var::~ComponentDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::ComponentDef_var &
CORBA::ComponentIR::ComponentDef_var::operator= (ComponentDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ComponentDef_var &
CORBA::ComponentIR::ComponentDef_var::operator= (const ::CORBA::ComponentIR::ComponentDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::ComponentDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::ComponentDef_var::operator const ::CORBA::ComponentIR::ComponentDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::ComponentDef_var::operator ::CORBA::ComponentIR::ComponentDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::ComponentDef_ptr &
CORBA::ComponentIR::ComponentDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ComponentDef_ptr &
CORBA::ComponentIR::ComponentDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ComponentDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::ComponentDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::ComponentDef::_nil ();
  return val;
}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_var::tao_duplicate (ComponentDef_ptr p)
{
  return ::CORBA::ComponentIR::ComponentDef::_duplicate (p);
}

void
CORBA::ComponentIR::ComponentDef_var::tao_release (ComponentDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::ComponentDef::_nil ();
}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::ComponentDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::ComponentDef_var::tao_upcast (void *src)
{
  ComponentDef **tmp =
    ACE_static_cast (ComponentDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::ComponentDef_out
// *************************************************************

CORBA::ComponentIR::ComponentDef_out::ComponentDef_out (ComponentDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::ComponentDef::_nil ();
}

CORBA::ComponentIR::ComponentDef_out::ComponentDef_out (ComponentDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::ComponentDef::_nil ();
}

CORBA::ComponentIR::ComponentDef_out::ComponentDef_out (const ::CORBA::ComponentIR::ComponentDef_out &p)
  : ptr_ (ACE_const_cast (ComponentDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::ComponentDef_out &
CORBA::ComponentIR::ComponentDef_out::operator= (const ::CORBA::ComponentIR::ComponentDef_out &p)
{
  this->ptr_ = ACE_const_cast (ComponentDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::ComponentDef_out &
CORBA::ComponentIR::ComponentDef_out::operator= (const ::CORBA::ComponentIR::ComponentDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::ComponentDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::ComponentDef_out &
CORBA::ComponentIR::ComponentDef_out::operator= (ComponentDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::ComponentDef_out::operator ::CORBA::ComponentIR::ComponentDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::ComponentDef_ptr &
CORBA::ComponentIR::ComponentDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::ComponentDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get &);
    
    ::CORBA::ComponentIR::ComponentDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get::result (::CORBA::ComponentIR::ComponentDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::ComponentDef_ptr base_component
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set &);
    CORBA::ComponentIR::ComponentDef_ptr base_component_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::ComponentDef_ptr base_component
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      base_component_ (base_component)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->base_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDefSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get &);
    
    ::CORBA::InterfaceDefSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get::result (::CORBA::InterfaceDefSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & supported_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set &);
    const CORBA::InterfaceDefSeq & supported_interfaces_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & supported_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::InterfaceDef_ptr interface_type
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::ProvidesDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::InterfaceDef_ptr interface_type_;
    
    ::CORBA::ComponentIR::ProvidesDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::InterfaceDef_ptr interface_type
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      interface_type_ (interface_type)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides::result (::CORBA::ComponentIR::ProvidesDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::InterfaceDef_ptr interface_type,
      const CORBA::Boolean & is_multiple
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::UsesDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::InterfaceDef_ptr interface_type_;
    const CORBA::Boolean & is_multiple_;
    
    ::CORBA::ComponentIR::UsesDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::InterfaceDef_ptr interface_type,
      const CORBA::Boolean & is_multiple
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      interface_type_ (interface_type),
      is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->interface_type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses::result (::CORBA::ComponentIR::UsesDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::EmitsDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::ComponentIR::EventDef_ptr event_;
    
    ::CORBA::ComponentIR::EmitsDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      event_ (event)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->event_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits::result (::CORBA::ComponentIR::EmitsDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::PublishesDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::ComponentIR::EventDef_ptr event_;
    
    ::CORBA::ComponentIR::PublishesDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      event_ (event)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->event_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes::result (::CORBA::ComponentIR::PublishesDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::ConsumesDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::ComponentIR::EventDef_ptr event_;
    
    ::CORBA::ComponentIR::ConsumesDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes::TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::ComponentIR::EventDef_ptr event
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      event_ (event)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (4);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->event_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes::result (::CORBA::ComponentIR::ConsumesDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_ComponentDef_Proxy_Impl::_TAO_ComponentDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::_TAO_ComponentDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::ComponentDef_ptr CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::ComponentDef_var _tao_retval (CORBA::ComponentIR::ComponentDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_component",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::ComponentDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ComponentIR::ComponentDef_ptr base_component
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_component",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_base_component_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          base_component
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << base_component)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDefSeq * CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDefSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::InterfaceDefSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::InterfaceDefSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::InterfaceDefSeq * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_supported_interfaces_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          supported_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << supported_interfaces)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::ProvidesDef_ptr CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::ProvidesDef_var _tao_retval (CORBA::ComponentIR::ProvidesDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_provides",
      15,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_provides _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          interface_type
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::ProvidesDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::UsesDef_ptr CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::UsesDef_var _tao_retval (CORBA::ComponentIR::UsesDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_uses",
      11,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_uses _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          interface_type,
          is_multiple
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type) &&
              (_tao_out << CORBA::Any::from_boolean (is_multiple))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::UsesDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::EmitsDef_ptr CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::EmitsDef_var _tao_retval (CORBA::ComponentIR::EmitsDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_emits",
      12,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_emits _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          event
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << event)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::EmitsDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::PublishesDef_ptr CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::PublishesDef_var _tao_retval (CORBA::ComponentIR::PublishesDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_publishes",
      16,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_publishes _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          event
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << event)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::PublishesDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::ConsumesDef_ptr CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::ConsumesDef_var _tao_retval (CORBA::ComponentIR::ConsumesDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_consumes",
      15,
      4,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_ComponentDef_create_consumes _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          event
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << event)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::ConsumesDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_ComponentDef_Proxy_Broker::_TAO_ComponentDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ComponentDef_Proxy_Broker::~_TAO_ComponentDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ComponentDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Broker::_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Broker::~_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_ComponentDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::ComponentDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::ComponentDef::ComponentDef (int collocated)
{
  this->CORBA_ComponentIR_ComponentDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::ComponentDef::CORBA_ComponentIR_ComponentDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker ();
  
  this->CORBA_ExtInterfaceDef_setup_collocation (collocated);
}

CORBA::ComponentIR::ComponentDef::~ComponentDef (void)
{}

void 
CORBA::ComponentIR::ComponentDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentDef *tmp = ACE_static_cast (ComponentDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ComponentDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/ComponentDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ComponentDef::_nil ());
      
      if (is_a == 0)
        {
          return ComponentDef::_nil ();
        }
    }
  
  return ComponentDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::ComponentDef_ptr 
CORBA::ComponentIR::ComponentDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ComponentDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ComponentDef_ptr default_proxy = ComponentDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ComponentDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ComponentDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::ComponentDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ComponentDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ComponentDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ComponentDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::ComponentDef_ptr
CORBA::ComponentIR::ComponentDef::_duplicate (ComponentDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::ComponentDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/ComponentDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::ComponentDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, ComponentDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::ExtInterfaceDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ExtInterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::InterfaceDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::InterfaceAttrExtension::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceAttrExtension_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ComponentDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::ComponentDef_ptr CORBA::ComponentIR::ComponentDef::base_component (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.base_component (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::ComponentDef::base_component (
    CORBA::ComponentIR::ComponentDef_ptr base_component
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.base_component (
      this,
      base_component
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDefSeq * CORBA::ComponentIR::ComponentDef::supported_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.supported_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::ComponentDef::supported_interfaces (
    const CORBA::InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.supported_interfaces (
      this,
      supported_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::ProvidesDef_ptr CORBA::ComponentIR::ComponentDef::create_provides (
    const char * id,
    const char * name,
    const char * version,
    CORBA::InterfaceDef_ptr interface_type
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_provides (
      this,
      id,
      name,
      version,
      interface_type
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::UsesDef_ptr CORBA::ComponentIR::ComponentDef::create_uses (
    const char * id,
    const char * name,
    const char * version,
    CORBA::InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_uses (
      this,
      id,
      name,
      version,
      interface_type,
      is_multiple
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::EmitsDef_ptr CORBA::ComponentIR::ComponentDef::create_emits (
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_emits (
      this,
      id,
      name,
      version,
      event
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::PublishesDef_ptr CORBA::ComponentIR::ComponentDef::create_publishes (
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_publishes (
      this,
      id,
      name,
      version,
      event
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::ConsumesDef_ptr CORBA::ComponentIR::ComponentDef::create_consumes (
    const char * id,
    const char * name,
    const char * version,
    CORBA::ComponentIR::EventDef_ptr event
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ComponentDef_Proxy_Impl &proxy = 
    this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_consumes (
      this,
      id,
      name,
      version,
      event
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_ComponentDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7444), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ComponentDef:1.0
    13,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74446566), 
  ACE_NTOHL (0x0),  // name = ComponentDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_ComponentDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_ComponentDef),
    (char *) &_oc_CORBA_ComponentIR_ComponentDef,
    0,
    sizeof (CORBA::ComponentIR::ComponentDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ComponentDef,
    &_tc_TAO_tc_CORBA_ComponentIR_ComponentDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:100

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CS_

void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::ComponentIR::ProvidesDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::ComponentIR::ProvidesDescription *old =
        ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::ComponentIR::ProvidesDescription *tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::ProvidesDescription *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CS_)
#define _CORBA_COMPONENTIR_PROVIDESDESCRIPTIONSEQ_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:249

// *************************************************************
// CORBA::ComponentIR::ProvidesDescriptionSeq
// *************************************************************

CORBA::ComponentIR::ProvidesDescriptionSeq::ProvidesDescriptionSeq (void)
{}

CORBA::ComponentIR::ProvidesDescriptionSeq::ProvidesDescriptionSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::ProvidesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::ComponentIR::ProvidesDescriptionSeq::ProvidesDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ComponentIR::ProvidesDescription *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::ProvidesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::ComponentIR::ProvidesDescriptionSeq::ProvidesDescriptionSeq (const ProvidesDescriptionSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_ProvidesDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::ProvidesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::ComponentIR::ProvidesDescriptionSeq::~ProvidesDescriptionSeq (void) // dtor
{}

void CORBA::ComponentIR::ProvidesDescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ProvidesDescriptionSeq *tmp = ACE_static_cast (ProvidesDescriptionSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_ProvidesDescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  57,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5072), 
  ACE_NTOHL (0x6f766964), 
  ACE_NTOHL (0x65734465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ProvidesDescriptionSeq:1.0
    23,
  ACE_NTOHL (0x50726f76), 
  ACE_NTOHL (0x69646573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65710000),  // name = ProvidesDescriptionSeq
    CORBA::tk_sequence, // typecode kind
  424, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    408, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      54,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f436f), 
      ACE_NTOHL (0x6d706f6e), 
      ACE_NTOHL (0x656e7449), 
      ACE_NTOHL (0x522f5072), 
      ACE_NTOHL (0x6f766964), 
      ACE_NTOHL (0x65734465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e3a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ProvidesDescription:1.0
            20,
      ACE_NTOHL (0x50726f76), 
      ACE_NTOHL (0x69646573), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
      5, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5265), 
        ACE_NTOHL (0x706f7369), 
        ACE_NTOHL (0x746f7279), 
        ACE_NTOHL (0x49643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
            0xffffffff, // indirection
      0xffffff9c, // negative offset (-100)
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5665), 
        ACE_NTOHL (0x7273696f), 
        ACE_NTOHL (0x6e537065), 
        ACE_NTOHL (0x633a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
        0U, // string length

      15,
      ACE_NTOHL (0x696e7465), 
      ACE_NTOHL (0x72666163), 
      ACE_NTOHL (0x655f7479), 
      ACE_NTOHL (0x70650000),  // name = interface_type
            0xffffffff, // indirection
      0xffffff28, // negative offset (-216)

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_ProvidesDescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ComponentIR_ProvidesDescriptionSeq),
    (char *) &_oc_CORBA_ComponentIR_ProvidesDescriptionSeq,
    0,
    sizeof (CORBA::ComponentIR::ProvidesDescriptionSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ProvidesDescriptionSeq,
    &_tc_TAO_tc_CORBA_ComponentIR_ProvidesDescriptionSeq
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:100

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CS_

void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::ComponentIR::UsesDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::ComponentIR::UsesDescription *old =
        ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::ComponentIR::UsesDescription *tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::UsesDescription *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CS_)
#define _CORBA_COMPONENTIR_USESDESCRIPTIONSEQ_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:249

// *************************************************************
// CORBA::ComponentIR::UsesDescriptionSeq
// *************************************************************

CORBA::ComponentIR::UsesDescriptionSeq::UsesDescriptionSeq (void)
{}

CORBA::ComponentIR::UsesDescriptionSeq::UsesDescriptionSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::UsesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::ComponentIR::UsesDescriptionSeq::UsesDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ComponentIR::UsesDescription *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::UsesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::ComponentIR::UsesDescriptionSeq::UsesDescriptionSeq (const UsesDescriptionSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_UsesDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::UsesDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::ComponentIR::UsesDescriptionSeq::~UsesDescriptionSeq (void) // dtor
{}

void CORBA::ComponentIR::UsesDescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  UsesDescriptionSeq *tmp = ACE_static_cast (UsesDescriptionSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_UsesDescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  53,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f5573), 
  ACE_NTOHL (0x65734465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ComponentIR/UsesDescriptionSeq:1.0
    19,
  ACE_NTOHL (0x55736573), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e53), 
  ACE_NTOHL (0x65710000),  // name = UsesDescriptionSeq
    CORBA::tk_sequence, // typecode kind
  436, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    420, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      50,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f436f), 
      ACE_NTOHL (0x6d706f6e), 
      ACE_NTOHL (0x656e7449), 
      ACE_NTOHL (0x522f5573), 
      ACE_NTOHL (0x65734465), 
      ACE_NTOHL (0x73637269), 
      ACE_NTOHL (0x7074696f), 
      ACE_NTOHL (0x6e3a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/UsesDescription:1.0
            16,
      ACE_NTOHL (0x55736573), 
      ACE_NTOHL (0x44657363), 
      ACE_NTOHL (0x72697074), 
      ACE_NTOHL (0x696f6e00),  // name = UsesDescription
      6, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5265), 
        ACE_NTOHL (0x706f7369), 
        ACE_NTOHL (0x746f7279), 
        ACE_NTOHL (0x49643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
            0xffffffff, // indirection
      0xffffff9c, // negative offset (-100)
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5665), 
        ACE_NTOHL (0x7273696f), 
        ACE_NTOHL (0x6e537065), 
        ACE_NTOHL (0x633a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
        0U, // string length

      15,
      ACE_NTOHL (0x696e7465), 
      ACE_NTOHL (0x72666163), 
      ACE_NTOHL (0x655f7479), 
      ACE_NTOHL (0x70650000),  // name = interface_type
            0xffffffff, // indirection
      0xffffff28, // negative offset (-216)
      12,
      ACE_NTOHL (0x69735f6d), 
      ACE_NTOHL (0x756c7469), 
      ACE_NTOHL (0x706c6500),  // name = is_multiple
            CORBA::tk_boolean,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_UsesDescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ComponentIR_UsesDescriptionSeq),
    (char *) &_oc_CORBA_ComponentIR_UsesDescriptionSeq,
    0,
    sizeof (CORBA::ComponentIR::UsesDescriptionSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_UsesDescriptionSeq,
    &_tc_TAO_tc_CORBA_ComponentIR_UsesDescriptionSeq
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:100

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CS_

void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::ComponentIR::EventPortDescription* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::ComponentIR::EventPortDescription *old =
        ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::ComponentIR::EventPortDescription *tmp =
    ACE_reinterpret_cast (CORBA::ComponentIR::EventPortDescription *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::ComponentIR::_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CS_)
#define _CORBA_COMPONENTIR_EVENTPORTDESCRIPTIONSEQ_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:249

// *************************************************************
// CORBA::ComponentIR::EventPortDescriptionSeq
// *************************************************************

CORBA::ComponentIR::EventPortDescriptionSeq::EventPortDescriptionSeq (void)
{}

CORBA::ComponentIR::EventPortDescriptionSeq::EventPortDescriptionSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::EventPortDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::ComponentIR::EventPortDescriptionSeq::EventPortDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ComponentIR::EventPortDescription *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::EventPortDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::ComponentIR::EventPortDescriptionSeq::EventPortDescriptionSeq (const EventPortDescriptionSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ComponentIR_EventPortDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ComponentIR::EventPortDescription>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::ComponentIR::EventPortDescriptionSeq::~EventPortDescriptionSeq (void) // dtor
{}

void CORBA::ComponentIR::EventPortDescriptionSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  EventPortDescriptionSeq *tmp = ACE_static_cast (EventPortDescriptionSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_EventPortDescriptionSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  58,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f4576), 
  ACE_NTOHL (0x656e7450), 
  ACE_NTOHL (0x6f727444), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e5365), 
  ACE_NTOHL (0x713a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EventPortDescriptionSeq:1.0
    24,
  ACE_NTOHL (0x4576656e), 
  ACE_NTOHL (0x74506f72), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x53657100),  // name = EventPortDescriptionSeq
    CORBA::tk_sequence, // typecode kind
  420, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    404, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      55,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f436f), 
      ACE_NTOHL (0x6d706f6e), 
      ACE_NTOHL (0x656e7449), 
      ACE_NTOHL (0x522f4576), 
      ACE_NTOHL (0x656e7450), 
      ACE_NTOHL (0x6f727444), 
      ACE_NTOHL (0x65736372), 
      ACE_NTOHL (0x69707469), 
      ACE_NTOHL (0x6f6e3a31), 
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EventPortDescription:1.0
            21,
      ACE_NTOHL (0x4576656e), 
      ACE_NTOHL (0x74506f72), 
      ACE_NTOHL (0x74446573), 
      ACE_NTOHL (0x63726970), 
      ACE_NTOHL (0x74696f6e), 
      ACE_NTOHL (0x0),  // name = EventPortDescription
      5, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5265), 
        ACE_NTOHL (0x706f7369), 
        ACE_NTOHL (0x746f7279), 
        ACE_NTOHL (0x49643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
            0xffffffff, // indirection
      0xffffff9c, // negative offset (-100)
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5665), 
        ACE_NTOHL (0x7273696f), 
        ACE_NTOHL (0x6e537065), 
        ACE_NTOHL (0x633a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
        0U, // string length

      6,
      ACE_NTOHL (0x6576656e), 
      ACE_NTOHL (0x74000000),  // name = event
            0xffffffff, // indirection
      0xffffff30, // negative offset (-208)

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_EventPortDescriptionSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ComponentIR_EventPortDescriptionSeq),
    (char *) &_oc_CORBA_ComponentIR_EventPortDescriptionSeq,
    0,
    sizeof (CORBA::ComponentIR::EventPortDescriptionSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_EventPortDescriptionSeq,
    &_tc_TAO_tc_CORBA_ComponentIR_EventPortDescriptionSeq
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_ComponentDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7444), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ComponentDescription:1.0
    21,
  ACE_NTOHL (0x436f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ComponentDescription
  13, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  15,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f636f6d), 
  ACE_NTOHL (0x706f6e65), 
  ACE_NTOHL (0x6e740000),  // name = base_component
    0xffffffff, // indirection
  0xffffff28, // negative offset (-216)
  21,
  ACE_NTOHL (0x73757070), 
  ACE_NTOHL (0x6f727465), 
  ACE_NTOHL (0x645f696e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636573), 
  ACE_NTOHL (0x0),  // name = supported_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49645365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
        16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
        CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xfffffeac, // negative offset (-340)
      0U,


  20,
  ACE_NTOHL (0x70726f76), 
  ACE_NTOHL (0x69646564), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = provided_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  320, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    57,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f436f), 
    ACE_NTOHL (0x6d706f6e), 
    ACE_NTOHL (0x656e7449), 
    ACE_NTOHL (0x522f5072), 
    ACE_NTOHL (0x6f766964), 
    ACE_NTOHL (0x65734465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ProvidesDescriptionSeq:1.0
        23,
    ACE_NTOHL (0x50726f76), 
    ACE_NTOHL (0x69646573), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65710000),  // name = ProvidesDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    216, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      200, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        54,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f436f), 
        ACE_NTOHL (0x6d706f6e), 
        ACE_NTOHL (0x656e7449), 
        ACE_NTOHL (0x522f5072), 
        ACE_NTOHL (0x6f766964), 
        ACE_NTOHL (0x65734465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/ProvidesDescription:1.0
                20,
        ACE_NTOHL (0x50726f76), 
        ACE_NTOHL (0x69646573), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
        5, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffd50, // negative offset (-688)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffd94, // negative offset (-620)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffd7c, // negative offset (-644)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffddc, // negative offset (-548)
        15,
        ACE_NTOHL (0x696e7465), 
        ACE_NTOHL (0x72666163), 
        ACE_NTOHL (0x655f7479), 
        ACE_NTOHL (0x70650000),  // name = interface_type
                0xffffffff, // indirection
        0xfffffd4c, // negative offset (-692)

      0U,


  16,
  ACE_NTOHL (0x75736564), 
  ACE_NTOHL (0x5f696e74), 
  ACE_NTOHL (0x65726661), 
  ACE_NTOHL (0x63657300),  // name = used_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  324, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    53,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f436f), 
    ACE_NTOHL (0x6d706f6e), 
    ACE_NTOHL (0x656e7449), 
    ACE_NTOHL (0x522f5573), 
    ACE_NTOHL (0x65734465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ComponentIR/UsesDescriptionSeq:1.0
        19,
    ACE_NTOHL (0x55736573), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65710000),  // name = UsesDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    228, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      212, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        50,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f436f), 
        ACE_NTOHL (0x6d706f6e), 
        ACE_NTOHL (0x656e7449), 
        ACE_NTOHL (0x522f5573), 
        ACE_NTOHL (0x65734465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/UsesDescription:1.0
                16,
        ACE_NTOHL (0x55736573), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = UsesDescription
        6, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffc04, // negative offset (-1020)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffc48, // negative offset (-952)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffc30, // negative offset (-976)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffc90, // negative offset (-880)
        15,
        ACE_NTOHL (0x696e7465), 
        ACE_NTOHL (0x72666163), 
        ACE_NTOHL (0x655f7479), 
        ACE_NTOHL (0x70650000),  // name = interface_type
                0xffffffff, // indirection
        0xfffffc00, // negative offset (-1024)
        12,
        ACE_NTOHL (0x69735f6d), 
        ACE_NTOHL (0x756c7469), 
        ACE_NTOHL (0x706c6500),  // name = is_multiple
                CORBA::tk_boolean,


      0U,


  13,
  ACE_NTOHL (0x656d6974), 
  ACE_NTOHL (0x735f6576), 
  ACE_NTOHL (0x656e7473), 
  ACE_NTOHL (0x0),  // name = emits_events
    CORBA::tk_alias, // typecode kind for typedefs
  316, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    58,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f436f), 
    ACE_NTOHL (0x6d706f6e), 
    ACE_NTOHL (0x656e7449), 
    ACE_NTOHL (0x522f4576), 
    ACE_NTOHL (0x656e7450), 
    ACE_NTOHL (0x6f727444), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EventPortDescriptionSeq:1.0
        24,
    ACE_NTOHL (0x4576656e), 
    ACE_NTOHL (0x74506f72), 
    ACE_NTOHL (0x74446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x53657100),  // name = EventPortDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    212, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      196, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        55,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f436f), 
        ACE_NTOHL (0x6d706f6e), 
        ACE_NTOHL (0x656e7449), 
        ACE_NTOHL (0x522f4576), 
        ACE_NTOHL (0x656e7450), 
        ACE_NTOHL (0x6f727444), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/EventPortDescription:1.0
                21,
        ACE_NTOHL (0x4576656e), 
        ACE_NTOHL (0x74506f72), 
        ACE_NTOHL (0x74446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = EventPortDescription
        5, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffa90, // negative offset (-1392)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffad4, // negative offset (-1324)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffabc, // negative offset (-1348)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffb1c, // negative offset (-1252)
        6,
        ACE_NTOHL (0x6576656e), 
        ACE_NTOHL (0x74000000),  // name = event
                0xffffffff, // indirection
        0xfffffa94, // negative offset (-1388)

      0U,


  17,
  ACE_NTOHL (0x7075626c), 
  ACE_NTOHL (0x69736865), 
  ACE_NTOHL (0x735f6576), 
  ACE_NTOHL (0x656e7473), 
  ACE_NTOHL (0x0),  // name = publishes_events
    0xffffffff, // indirection
  0xfffffea0, // negative offset (-352)
  16,
  ACE_NTOHL (0x636f6e73), 
  ACE_NTOHL (0x756d6573), 
  ACE_NTOHL (0x5f657665), 
  ACE_NTOHL (0x6e747300),  // name = consumes_events
    0xffffffff, // indirection
  0xfffffe84, // negative offset (-380)
  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
    CORBA::tk_alias, // typecode kind for typedefs
  744, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    44,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x74417474), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExtAttrDescriptionSeq:1.0
        22,
    ACE_NTOHL (0x45787441), 
    ACE_NTOHL (0x74747244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x71000000),  // name = ExtAttrDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    656, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      640, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        46,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x74417474), 
        ACE_NTOHL (0x72696275), 
        ACE_NTOHL (0x74654465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAttributeDescription:1.0
                24,
        ACE_NTOHL (0x45787441), 
        ACE_NTOHL (0x74747269), 
        ACE_NTOHL (0x62757465), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = ExtAttributeDescription
        8, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff918, // negative offset (-1768)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff95c, // negative offset (-1700)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff944, // negative offset (-1724)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff9a4, // negative offset (-1628)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472), 
          ACE_NTOHL (0x69627574), 
          ACE_NTOHL (0x654d6f64), 
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
          
        15,
        ACE_NTOHL (0x6765745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = get_exceptions
                CORBA::tk_alias, // typecode kind for typedefs
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x45786344), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          196, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            180, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                            21,
              ACE_NTOHL (0x45786365), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff770, // negative offset (-2192)
              3,
              ACE_NTOHL (0x69640000),  // name = id
                            0xffffffff, // indirection
              0xfffff7b4, // negative offset (-2124)
              11,
              ACE_NTOHL (0x64656669), 
              ACE_NTOHL (0x6e65645f), 
              ACE_NTOHL (0x696e0000),  // name = defined_in
                            0xffffffff, // indirection
              0xfffff79c, // negative offset (-2148)
              8,
              ACE_NTOHL (0x76657273), 
              ACE_NTOHL (0x696f6e00),  // name = version
                            0xffffffff, // indirection
              0xfffff7fc, // negative offset (-2052)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,


            0U,


        15,
        ACE_NTOHL (0x7075745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = put_exceptions
                0xffffffff, // indirection
        0xfffffecc, // negative offset (-308)

      0U,


  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_ComponentDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ComponentIR_ComponentDescription),
    (char *) &_oc_CORBA_ComponentIR_ComponentDescription,
    0,
    sizeof (CORBA::ComponentIR::ComponentDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ComponentDescription,
    &_tc_TAO_tc_CORBA_ComponentIR_ComponentDescription
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ComponentIR::ComponentDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ComponentDescription *tmp = ACE_static_cast (ComponentDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::FactoryDef::_tao_class_id = 0;

CORBA::ComponentIR::FactoryDef_ptr
tao_CORBA_ComponentIR_FactoryDef_duplicate (
    CORBA::ComponentIR::FactoryDef_ptr p
  )
{
  return CORBA::ComponentIR::FactoryDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_FactoryDef_release (
    CORBA::ComponentIR::FactoryDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::FactoryDef_ptr
tao_CORBA_ComponentIR_FactoryDef_nil (
    void
  )
{
  return CORBA::ComponentIR::FactoryDef::_nil ();
}

CORBA::ComponentIR::FactoryDef_ptr
tao_CORBA_ComponentIR_FactoryDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::FactoryDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_FactoryDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::FactoryDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::FactoryDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_FactoryDef_marshal (
    CORBA::ComponentIR::FactoryDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::FactoryDef_var
// *************************************************************

CORBA::ComponentIR::FactoryDef_var::FactoryDef_var (void)
  : ptr_ (FactoryDef::_nil ())
{}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::FactoryDef_var::FactoryDef_var (const ::CORBA::ComponentIR::FactoryDef_var &p)
  : TAO_Base_var (),
    ptr_ (FactoryDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::FactoryDef_var::~FactoryDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::FactoryDef_var &
CORBA::ComponentIR::FactoryDef_var::operator= (FactoryDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::FactoryDef_var &
CORBA::ComponentIR::FactoryDef_var::operator= (const ::CORBA::ComponentIR::FactoryDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::FactoryDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::FactoryDef_var::operator const ::CORBA::ComponentIR::FactoryDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::FactoryDef_var::operator ::CORBA::ComponentIR::FactoryDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::FactoryDef_ptr &
CORBA::ComponentIR::FactoryDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::FactoryDef_ptr &
CORBA::ComponentIR::FactoryDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::FactoryDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::FactoryDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::FactoryDef::_nil ();
  return val;
}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_var::tao_duplicate (FactoryDef_ptr p)
{
  return ::CORBA::ComponentIR::FactoryDef::_duplicate (p);
}

void
CORBA::ComponentIR::FactoryDef_var::tao_release (FactoryDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::FactoryDef::_nil ();
}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::FactoryDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::FactoryDef_var::tao_upcast (void *src)
{
  FactoryDef **tmp =
    ACE_static_cast (FactoryDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::FactoryDef_out
// *************************************************************

CORBA::ComponentIR::FactoryDef_out::FactoryDef_out (FactoryDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::FactoryDef::_nil ();
}

CORBA::ComponentIR::FactoryDef_out::FactoryDef_out (FactoryDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::FactoryDef::_nil ();
}

CORBA::ComponentIR::FactoryDef_out::FactoryDef_out (const ::CORBA::ComponentIR::FactoryDef_out &p)
  : ptr_ (ACE_const_cast (FactoryDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::FactoryDef_out &
CORBA::ComponentIR::FactoryDef_out::operator= (const ::CORBA::ComponentIR::FactoryDef_out &p)
{
  this->ptr_ = ACE_const_cast (FactoryDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::FactoryDef_out &
CORBA::ComponentIR::FactoryDef_out::operator= (const ::CORBA::ComponentIR::FactoryDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::FactoryDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::FactoryDef_out &
CORBA::ComponentIR::FactoryDef_out::operator= (FactoryDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::FactoryDef_out::operator ::CORBA::ComponentIR::FactoryDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::FactoryDef_ptr &
CORBA::ComponentIR::FactoryDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_FactoryDef_Proxy_Impl::_TAO_FactoryDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Impl::_TAO_FactoryDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_FactoryDef_Proxy_Broker::_TAO_FactoryDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FactoryDef_Proxy_Broker::~_TAO_FactoryDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FactoryDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Broker::_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Broker::~_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FactoryDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::FactoryDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::FactoryDef::FactoryDef (int collocated)
{
  this->CORBA_ComponentIR_FactoryDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::FactoryDef::CORBA_ComponentIR_FactoryDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker ();
  
  this->CORBA_OperationDef_setup_collocation (collocated);
}

CORBA::ComponentIR::FactoryDef::~FactoryDef (void)
{}

void 
CORBA::ComponentIR::FactoryDef::_tao_any_destructor (void *_tao_void_pointer)
{
  FactoryDef *tmp = ACE_static_cast (FactoryDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return FactoryDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/FactoryDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (FactoryDef::_nil ());
      
      if (is_a == 0)
        {
          return FactoryDef::_nil ();
        }
    }
  
  return FactoryDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::FactoryDef_ptr 
CORBA::ComponentIR::FactoryDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return FactoryDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      FactoryDef_ptr default_proxy = FactoryDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::FactoryDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              FactoryDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::FactoryDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              FactoryDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          FactoryDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &FactoryDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::FactoryDef_ptr
CORBA::ComponentIR::FactoryDef::_duplicate (FactoryDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::FactoryDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/FactoryDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::FactoryDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, FactoryDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::OperationDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::OperationDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/FactoryDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_FactoryDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f4661), 
  ACE_NTOHL (0x63746f72), 
  ACE_NTOHL (0x79446566), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ComponentIR/FactoryDef:1.0
    11,
  ACE_NTOHL (0x46616374), 
  ACE_NTOHL (0x6f727944), 
  ACE_NTOHL (0x65660000),  // name = FactoryDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_FactoryDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_FactoryDef),
    (char *) &_oc_CORBA_ComponentIR_FactoryDef,
    0,
    sizeof (CORBA::ComponentIR::FactoryDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FactoryDef,
    &_tc_TAO_tc_CORBA_ComponentIR_FactoryDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::FinderDef::_tao_class_id = 0;

CORBA::ComponentIR::FinderDef_ptr
tao_CORBA_ComponentIR_FinderDef_duplicate (
    CORBA::ComponentIR::FinderDef_ptr p
  )
{
  return CORBA::ComponentIR::FinderDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_FinderDef_release (
    CORBA::ComponentIR::FinderDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::FinderDef_ptr
tao_CORBA_ComponentIR_FinderDef_nil (
    void
  )
{
  return CORBA::ComponentIR::FinderDef::_nil ();
}

CORBA::ComponentIR::FinderDef_ptr
tao_CORBA_ComponentIR_FinderDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::FinderDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_FinderDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::FinderDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::FinderDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_FinderDef_marshal (
    CORBA::ComponentIR::FinderDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::FinderDef_var
// *************************************************************

CORBA::ComponentIR::FinderDef_var::FinderDef_var (void)
  : ptr_ (FinderDef::_nil ())
{}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::FinderDef_var::FinderDef_var (const ::CORBA::ComponentIR::FinderDef_var &p)
  : TAO_Base_var (),
    ptr_ (FinderDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::FinderDef_var::~FinderDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::FinderDef_var &
CORBA::ComponentIR::FinderDef_var::operator= (FinderDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::FinderDef_var &
CORBA::ComponentIR::FinderDef_var::operator= (const ::CORBA::ComponentIR::FinderDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::FinderDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::FinderDef_var::operator const ::CORBA::ComponentIR::FinderDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::FinderDef_var::operator ::CORBA::ComponentIR::FinderDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::FinderDef_ptr &
CORBA::ComponentIR::FinderDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::FinderDef_ptr &
CORBA::ComponentIR::FinderDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::FinderDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::FinderDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::FinderDef::_nil ();
  return val;
}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_var::tao_duplicate (FinderDef_ptr p)
{
  return ::CORBA::ComponentIR::FinderDef::_duplicate (p);
}

void
CORBA::ComponentIR::FinderDef_var::tao_release (FinderDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::FinderDef::_nil ();
}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::FinderDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::FinderDef_var::tao_upcast (void *src)
{
  FinderDef **tmp =
    ACE_static_cast (FinderDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::FinderDef_out
// *************************************************************

CORBA::ComponentIR::FinderDef_out::FinderDef_out (FinderDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::FinderDef::_nil ();
}

CORBA::ComponentIR::FinderDef_out::FinderDef_out (FinderDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::FinderDef::_nil ();
}

CORBA::ComponentIR::FinderDef_out::FinderDef_out (const ::CORBA::ComponentIR::FinderDef_out &p)
  : ptr_ (ACE_const_cast (FinderDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::FinderDef_out &
CORBA::ComponentIR::FinderDef_out::operator= (const ::CORBA::ComponentIR::FinderDef_out &p)
{
  this->ptr_ = ACE_const_cast (FinderDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::FinderDef_out &
CORBA::ComponentIR::FinderDef_out::operator= (const ::CORBA::ComponentIR::FinderDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::FinderDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::FinderDef_out &
CORBA::ComponentIR::FinderDef_out::operator= (FinderDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::FinderDef_out::operator ::CORBA::ComponentIR::FinderDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::FinderDef_ptr &
CORBA::ComponentIR::FinderDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_FinderDef_Proxy_Impl::_TAO_FinderDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Impl::_TAO_FinderDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_FinderDef_Proxy_Broker::_TAO_FinderDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FinderDef_Proxy_Broker::~_TAO_FinderDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FinderDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Broker::_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Broker::~_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_FinderDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::FinderDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::FinderDef::FinderDef (int collocated)
{
  this->CORBA_ComponentIR_FinderDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::FinderDef::CORBA_ComponentIR_FinderDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FinderDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FinderDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker ();
  
  this->CORBA_OperationDef_setup_collocation (collocated);
}

CORBA::ComponentIR::FinderDef::~FinderDef (void)
{}

void 
CORBA::ComponentIR::FinderDef::_tao_any_destructor (void *_tao_void_pointer)
{
  FinderDef *tmp = ACE_static_cast (FinderDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return FinderDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/FinderDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (FinderDef::_nil ());
      
      if (is_a == 0)
        {
          return FinderDef::_nil ();
        }
    }
  
  return FinderDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::FinderDef_ptr 
CORBA::ComponentIR::FinderDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return FinderDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      FinderDef_ptr default_proxy = FinderDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::FinderDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              FinderDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::FinderDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              FinderDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          FinderDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &FinderDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::FinderDef_ptr
CORBA::ComponentIR::FinderDef::_duplicate (FinderDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::FinderDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/FinderDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::FinderDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, FinderDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::OperationDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::OperationDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/FinderDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_FinderDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f4669), 
  ACE_NTOHL (0x6e646572), 
  ACE_NTOHL (0x4465663a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/FinderDef:1.0
    10,
  ACE_NTOHL (0x46696e64), 
  ACE_NTOHL (0x65724465), 
  ACE_NTOHL (0x66000000),  // name = FinderDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_FinderDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_FinderDef),
    (char *) &_oc_CORBA_ComponentIR_FinderDef,
    0,
    sizeof (CORBA::ComponentIR::FinderDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FinderDef,
    &_tc_TAO_tc_CORBA_ComponentIR_FinderDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ComponentIR::HomeDef::_tao_class_id = 0;

CORBA::ComponentIR::HomeDef_ptr
tao_CORBA_ComponentIR_HomeDef_duplicate (
    CORBA::ComponentIR::HomeDef_ptr p
  )
{
  return CORBA::ComponentIR::HomeDef::_duplicate (p);
}

void
tao_CORBA_ComponentIR_HomeDef_release (
    CORBA::ComponentIR::HomeDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ComponentIR::HomeDef_ptr
tao_CORBA_ComponentIR_HomeDef_nil (
    void
  )
{
  return CORBA::ComponentIR::HomeDef::_nil ();
}

CORBA::ComponentIR::HomeDef_ptr
tao_CORBA_ComponentIR_HomeDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ComponentIR::HomeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ComponentIR_HomeDef_upcast (
    void *src
  )
{
  CORBA::ComponentIR::HomeDef **tmp =
    ACE_static_cast (CORBA::ComponentIR::HomeDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ComponentIR_HomeDef_marshal (
    CORBA::ComponentIR::HomeDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ComponentIR::HomeDef_var
// *************************************************************

CORBA::ComponentIR::HomeDef_var::HomeDef_var (void)
  : ptr_ (HomeDef::_nil ())
{}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ComponentIR::HomeDef_var::HomeDef_var (const ::CORBA::ComponentIR::HomeDef_var &p)
  : TAO_Base_var (),
    ptr_ (HomeDef::_duplicate (p.ptr ()))
{}

CORBA::ComponentIR::HomeDef_var::~HomeDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ComponentIR::HomeDef_var &
CORBA::ComponentIR::HomeDef_var::operator= (HomeDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::HomeDef_var &
CORBA::ComponentIR::HomeDef_var::operator= (const ::CORBA::ComponentIR::HomeDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ComponentIR::HomeDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ComponentIR::HomeDef_var::operator const ::CORBA::ComponentIR::HomeDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ComponentIR::HomeDef_var::operator ::CORBA::ComponentIR::HomeDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ComponentIR::HomeDef_ptr &
CORBA::ComponentIR::HomeDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::HomeDef_ptr &
CORBA::ComponentIR::HomeDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::HomeDef::_nil ();
  return this->ptr_;
}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ComponentIR::HomeDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ComponentIR::HomeDef::_nil ();
  return val;
}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_var::tao_duplicate (HomeDef_ptr p)
{
  return ::CORBA::ComponentIR::HomeDef::_duplicate (p);
}

void
CORBA::ComponentIR::HomeDef_var::tao_release (HomeDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_var::tao_nil (void)
{
  return ::CORBA::ComponentIR::HomeDef::_nil ();
}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ComponentIR::HomeDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ComponentIR::HomeDef_var::tao_upcast (void *src)
{
  HomeDef **tmp =
    ACE_static_cast (HomeDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ComponentIR::HomeDef_out
// *************************************************************

CORBA::ComponentIR::HomeDef_out::HomeDef_out (HomeDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ComponentIR::HomeDef::_nil ();
}

CORBA::ComponentIR::HomeDef_out::HomeDef_out (HomeDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ComponentIR::HomeDef::_nil ();
}

CORBA::ComponentIR::HomeDef_out::HomeDef_out (const ::CORBA::ComponentIR::HomeDef_out &p)
  : ptr_ (ACE_const_cast (HomeDef_out &, p).ptr_)
{}

::CORBA::ComponentIR::HomeDef_out &
CORBA::ComponentIR::HomeDef_out::operator= (const ::CORBA::ComponentIR::HomeDef_out &p)
{
  this->ptr_ = ACE_const_cast (HomeDef_out&, p).ptr_;
  return *this;
}

CORBA::ComponentIR::HomeDef_out &
CORBA::ComponentIR::HomeDef_out::operator= (const ::CORBA::ComponentIR::HomeDef_var &p)
{
  this->ptr_ = ::CORBA::ComponentIR::HomeDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ComponentIR::HomeDef_out &
CORBA::ComponentIR::HomeDef_out::operator= (HomeDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ComponentIR::HomeDef_out::operator ::CORBA::ComponentIR::HomeDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ComponentIR::HomeDef_ptr &
CORBA::ComponentIR::HomeDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::HomeDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get &);
    
    ::CORBA::ComponentIR::HomeDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get::result (::CORBA::ComponentIR::HomeDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::HomeDef_ptr base_home
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set &);
    CORBA::ComponentIR::HomeDef_ptr base_home_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::HomeDef_ptr base_home
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      base_home_ (base_home)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->base_home_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDefSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get &);
    
    ::CORBA::InterfaceDefSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get::result (::CORBA::InterfaceDefSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & supported_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set &);
    const CORBA::InterfaceDefSeq & supported_interfaces_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & supported_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::ComponentDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get &);
    
    ::CORBA::ComponentIR::ComponentDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get::result (::CORBA::ComponentIR::ComponentDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::ComponentDef_ptr managed_component
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set &);
    CORBA::ComponentIR::ComponentDef_ptr managed_component_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ComponentIR::ComponentDef_ptr managed_component
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      managed_component_ (managed_component)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->managed_component_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ValueDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get &);
    
    ::CORBA::ValueDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get::result (::CORBA::ValueDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ValueDef_ptr primary_key
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set &);
    CORBA::ValueDef_ptr primary_key_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ValueDef_ptr primary_key
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->primary_key_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::FactoryDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::ParDescriptionSeq & params_;
    const CORBA::ExceptionDefSeq & exceptions_;
    
    ::CORBA::ComponentIR::FactoryDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      params_ (params),
      exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory::result (::CORBA::ComponentIR::FactoryDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ComponentIR::FinderDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder &);
    const char * id_;
    const char * name_;
    const char * version_;
    const CORBA::ParDescriptionSeq & params_;
    const CORBA::ExceptionDefSeq & exceptions_;
    
    ::CORBA::ComponentIR::FinderDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder::TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      params_ (params),
      exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder::result (::CORBA::ComponentIR::FinderDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::ComponentIR::_TAO_HomeDef_Proxy_Impl::_TAO_HomeDef_Proxy_Impl (void)
{}

CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::_TAO_HomeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::HomeDef_ptr CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::HomeDef_var _tao_retval (CORBA::ComponentIR::HomeDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_home",
      14,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::HomeDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ComponentIR::HomeDef_ptr base_home
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_home",
      14,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_base_home_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          base_home
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << base_home)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDefSeq * CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDefSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::InterfaceDefSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::InterfaceDefSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::InterfaceDefSeq * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_supported_interfaces_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          supported_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << supported_interfaces)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::ComponentDef_ptr CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::ComponentDef_var _tao_retval (CORBA::ComponentIR::ComponentDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_managed_component",
      22,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::ComponentDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ComponentIR::ComponentDef_ptr managed_component
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_managed_component",
      22,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_managed_component_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          managed_component
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << managed_component)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ValueDef_ptr CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDef_var _tao_retval (CORBA::ValueDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ValueDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_primary_key",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_primary_key_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          primary_key
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << primary_key)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::FactoryDef_ptr CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::FactoryDef_var _tao_retval (CORBA::ComponentIR::FactoryDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_factory",
      14,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_factory _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          params,
          exceptions
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::FactoryDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ComponentIR::FinderDef_ptr CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ComponentIR::FinderDef_var _tao_retval (CORBA::ComponentIR::FinderDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_finder",
      13,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ComponentIR_HomeDef_create_finder _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          params,
          exceptions
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ComponentIR::FinderDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::ComponentIR::_TAO_HomeDef_Proxy_Broker::_TAO_HomeDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_HomeDef_Proxy_Broker::~_TAO_HomeDef_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_HomeDef_Proxy_Broker * (*CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Broker *
CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Broker::_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Broker::~_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

CORBA::ComponentIR::_TAO_HomeDef_Proxy_Impl&
CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ComponentIR::HomeDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ComponentIR::HomeDef::HomeDef (int collocated)
{
  this->CORBA_ComponentIR_HomeDef_setup_collocation (collocated);
}

void
CORBA::ComponentIR::HomeDef::CORBA_ComponentIR_HomeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeDef_Proxy_Broker_ =
      ::CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeDef_Proxy_Broker_ =
      ::CORBA::ComponentIR::_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker ();
  
  this->CORBA_ExtInterfaceDef_setup_collocation (collocated);
}

CORBA::ComponentIR::HomeDef::~HomeDef (void)
{}

void 
CORBA::ComponentIR::HomeDef::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeDef *tmp = ACE_static_cast (HomeDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return HomeDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ComponentIR/HomeDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (HomeDef::_nil ());
      
      if (is_a == 0)
        {
          return HomeDef::_nil ();
        }
    }
  
  return HomeDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ComponentIR::HomeDef_ptr 
CORBA::ComponentIR::HomeDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return HomeDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      HomeDef_ptr default_proxy = HomeDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::HomeDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              HomeDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ComponentIR::HomeDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              HomeDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          HomeDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &HomeDef::_tao_class_id
                )
            )
        );
}

CORBA::ComponentIR::HomeDef_ptr
CORBA::ComponentIR::HomeDef::_duplicate (HomeDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ComponentIR::HomeDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ComponentIR/HomeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ComponentIR::HomeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA::ComponentIR, HomeDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::ExtInterfaceDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ExtInterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::InterfaceDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::InterfaceAttrExtension::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::InterfaceAttrExtension_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ComponentIR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/HomeDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::HomeDef_ptr CORBA::ComponentIR::HomeDef::base_home (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.base_home (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::HomeDef::base_home (
    CORBA::ComponentIR::HomeDef_ptr base_home
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.base_home (
      this,
      base_home
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDefSeq * CORBA::ComponentIR::HomeDef::supported_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.supported_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::HomeDef::supported_interfaces (
    const CORBA::InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.supported_interfaces (
      this,
      supported_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::ComponentDef_ptr CORBA::ComponentIR::HomeDef::managed_component (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.managed_component (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::HomeDef::managed_component (
    CORBA::ComponentIR::ComponentDef_ptr managed_component
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.managed_component (
      this,
      managed_component
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ValueDef_ptr CORBA::ComponentIR::HomeDef::primary_key (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.primary_key (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ComponentIR::HomeDef::primary_key (
    CORBA::ValueDef_ptr primary_key
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.primary_key (
      this,
      primary_key
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::FactoryDef_ptr CORBA::ComponentIR::HomeDef::create_factory (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_factory (
      this,
      id,
      name,
      version,
      params,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ComponentIR::FinderDef_ptr CORBA::ComponentIR::HomeDef::create_finder (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_HomeDef_Proxy_Impl &proxy = 
    this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_finder (
      this,
      id,
      name,
      version,
      params,
      exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_HomeDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f486f), 
  ACE_NTOHL (0x6d654465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/HomeDef:1.0
    8,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x44656600),  // name = HomeDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_HomeDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ComponentIR_HomeDef),
    (char *) &_oc_CORBA_ComponentIR_HomeDef,
    0,
    sizeof (CORBA::ComponentIR::HomeDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_HomeDef,
    &_tc_TAO_tc_CORBA_ComponentIR_HomeDef
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ComponentIR_HomeDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f436f), 
  ACE_NTOHL (0x6d706f6e), 
  ACE_NTOHL (0x656e7449), 
  ACE_NTOHL (0x522f486f), 
  ACE_NTOHL (0x6d654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ComponentIR/HomeDescription:1.0
    16,
  ACE_NTOHL (0x486f6d65), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = HomeDescription
  12, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  10,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f686f6d), 
  ACE_NTOHL (0x65000000),  // name = base_home
    0xffffffff, // indirection
  0xffffff2c, // negative offset (-212)
  18,
  ACE_NTOHL (0x6d616e61), 
  ACE_NTOHL (0x6765645f), 
  ACE_NTOHL (0x636f6d70), 
  ACE_NTOHL (0x6f6e656e), 
  ACE_NTOHL (0x74000000),  // name = managed_component
    0xffffffff, // indirection
  0xffffff0c, // negative offset (-244)
  12,
  ACE_NTOHL (0x7072696d), 
  ACE_NTOHL (0x6172795f), 
  ACE_NTOHL (0x6b657900),  // name = primary_key
    CORBA::tk_struct, // typecode kind
  408, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5661), 
    ACE_NTOHL (0x6c756544), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e3a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDescription:1.0
        17,
    ACE_NTOHL (0x56616c75), 
    ACE_NTOHL (0x65446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x0),  // name = ValueDescription
    10, // member count
        5,
    ACE_NTOHL (0x6e616d65), 
    ACE_NTOHL (0x0),  // name = name
        0xffffffff, // indirection
    0xfffffe40, // negative offset (-448)
    3,
    ACE_NTOHL (0x69640000),  // name = id
        0xffffffff, // indirection
    0xfffffe84, // negative offset (-380)
    12,
    ACE_NTOHL (0x69735f61), 
    ACE_NTOHL (0x62737472), 
    ACE_NTOHL (0x61637400),  // name = is_abstract
        CORBA::tk_boolean,

    10,
    ACE_NTOHL (0x69735f63), 
    ACE_NTOHL (0x7573746f), 
    ACE_NTOHL (0x6d000000),  // name = is_custom
        CORBA::tk_boolean,

    11,
    ACE_NTOHL (0x64656669), 
    ACE_NTOHL (0x6e65645f), 
    ACE_NTOHL (0x696e0000),  // name = defined_in
        0xffffffff, // indirection
    0xfffffe44, // negative offset (-444)
    8,
    ACE_NTOHL (0x76657273), 
    ACE_NTOHL (0x696f6e00),  // name = version
        0xffffffff, // indirection
    0xfffffea4, // negative offset (-348)
    21,
    ACE_NTOHL (0x73757070), 
    ACE_NTOHL (0x6f727465), 
    ACE_NTOHL (0x645f696e), 
    ACE_NTOHL (0x74657266), 
    ACE_NTOHL (0x61636573), 
    ACE_NTOHL (0x0),  // name = supported_interfaces
        CORBA::tk_alias, // typecode kind for typedefs
    92, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      38,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5265), 
      ACE_NTOHL (0x706f7369), 
      ACE_NTOHL (0x746f7279), 
      ACE_NTOHL (0x49645365), 
      ACE_NTOHL (0x713a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
            16,
      ACE_NTOHL (0x5265706f), 
      ACE_NTOHL (0x7369746f), 
      ACE_NTOHL (0x72794964), 
      ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
            CORBA::tk_sequence, // typecode kind
      16, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        0xffffffff, // indirection
        0xfffffdb4, // negative offset (-588)
        0U,


    21,
    ACE_NTOHL (0x61627374), 
    ACE_NTOHL (0x72616374), 
    ACE_NTOHL (0x5f626173), 
    ACE_NTOHL (0x655f7661), 
    ACE_NTOHL (0x6c756573), 
    ACE_NTOHL (0x0),  // name = abstract_base_values
        0xffffffff, // indirection
    0xffffff7c, // negative offset (-132)
    15,
    ACE_NTOHL (0x69735f74), 
    ACE_NTOHL (0x72756e63), 
    ACE_NTOHL (0x61746162), 
    ACE_NTOHL (0x6c650000),  // name = is_truncatable
        CORBA::tk_boolean,

    11,
    ACE_NTOHL (0x62617365), 
    ACE_NTOHL (0x5f76616c), 
    ACE_NTOHL (0x75650000),  // name = base_value
        0xffffffff, // indirection
    0xfffffd5c, // negative offset (-676)

  10,
  ACE_NTOHL (0x66616374), 
  ACE_NTOHL (0x6f726965), 
  ACE_NTOHL (0x73000000),  // name = factories
    CORBA::tk_alias, // typecode kind for typedefs
  1340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f70), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
        17,
    ACE_NTOHL (0x4f704465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x0),  // name = OpDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    1260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1244, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
                21,
        ACE_NTOHL (0x4f706572), 
        ACE_NTOHL (0x6174696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffc2c, // negative offset (-980)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffc70, // negative offset (-912)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffc58, // negative offset (-936)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffcb8, // negative offset (-840)
        7,
        ACE_NTOHL (0x72657375), 
        ACE_NTOHL (0x6c740000),  // name = result
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        100, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f70), 
          ACE_NTOHL (0x65726174), 
          ACE_NTOHL (0x696f6e4d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14,
          ACE_NTOHL (0x4f706572), 
          ACE_NTOHL (0x6174696f), 
          ACE_NTOHL (0x6e4d6f64), 
          ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10,
          ACE_NTOHL (0x4f505f4e), 
          ACE_NTOHL (0x4f524d41), 
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f), 
          ACE_NTOHL (0x4e455741), 
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
          
        9,
        ACE_NTOHL (0x636f6e74), 
        ACE_NTOHL (0x65787473), 
        ACE_NTOHL (0x0),  // name = contexts
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f436f), 
          ACE_NTOHL (0x6e746578), 
          ACE_NTOHL (0x74496453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
                    13,
          ACE_NTOHL (0x436f6e74), 
          ACE_NTOHL (0x65787449), 
          ACE_NTOHL (0x64536571), 
          ACE_NTOHL (0x0),  // name = ContextIdSeq
                    CORBA::tk_sequence, // typecode kind
          96, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            80, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f436f), 
              ACE_NTOHL (0x6e746578), 
              ACE_NTOHL (0x74496465), 
              ACE_NTOHL (0x6e746966), 
              ACE_NTOHL (0x6965723a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
                            18,
              ACE_NTOHL (0x436f6e74), 
              ACE_NTOHL (0x65787449), 
              ACE_NTOHL (0x64656e74), 
              ACE_NTOHL (0x69666965), 
              ACE_NTOHL (0x72000000),  // name = ContextIdentifier
                            0xffffffff, // indirection
              0xfffffaac, // negative offset (-1364)

            0U,


        11,
        ACE_NTOHL (0x70617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x72730000),  // name = parameters
                CORBA::tk_alias, // typecode kind for typedefs
        428, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5061), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x50617244), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          348, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            332, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x74657244), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
                            21,
              ACE_NTOHL (0x50617261), 
              ACE_NTOHL (0x6d657465), 
              ACE_NTOHL (0x72446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff9cc, // negative offset (-1588)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
                            CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4944), 
                ACE_NTOHL (0x4c547970), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                                8,
                ACE_NTOHL (0x49444c54), 
                ACE_NTOHL (0x79706500),  // name = IDLType
                
              5,
              ACE_NTOHL (0x6d6f6465), 
              ACE_NTOHL (0x0),  // name = mode
                            CORBA::tk_enum, // typecode kind
              116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
                36,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f5061), 
                ACE_NTOHL (0x72616d65), 
                ACE_NTOHL (0x7465724d), 
                ACE_NTOHL (0x6f64653a), 
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14,
                ACE_NTOHL (0x50617261), 
                ACE_NTOHL (0x6d657465), 
                ACE_NTOHL (0x724d6f64), 
                ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x0),  // name = PARAM_IN
                10,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f4f55), 
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
                

            0U,


        11,
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = exceptions
                CORBA::tk_alias, // typecode kind for typedefs
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x45786344), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          196, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            180, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                            21,
              ACE_NTOHL (0x45786365), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff808, // negative offset (-2040)
              3,
              ACE_NTOHL (0x69640000),  // name = id
                            0xffffffff, // indirection
              0xfffff84c, // negative offset (-1972)
              11,
              ACE_NTOHL (0x64656669), 
              ACE_NTOHL (0x6e65645f), 
              ACE_NTOHL (0x696e0000),  // name = defined_in
                            0xffffffff, // indirection
              0xfffff834, // negative offset (-1996)
              8,
              ACE_NTOHL (0x76657273), 
              ACE_NTOHL (0x696f6e00),  // name = version
                            0xffffffff, // indirection
              0xfffff894, // negative offset (-1900)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,


            0U,



      0U,


  8,
  ACE_NTOHL (0x66696e64), 
  ACE_NTOHL (0x65727300),  // name = finders
    0xffffffff, // indirection
  0xfffffaac, // negative offset (-1364)
  11,
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e730000),  // name = operations
    0xffffffff, // indirection
  0xfffffa94, // negative offset (-1388)
  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
    CORBA::tk_alias, // typecode kind for typedefs
  468, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    44,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x74417474), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExtAttrDescriptionSeq:1.0
        22,
    ACE_NTOHL (0x45787441), 
    ACE_NTOHL (0x74747244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x71000000),  // name = ExtAttrDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    380, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      364, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        46,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x74417474), 
        ACE_NTOHL (0x72696275), 
        ACE_NTOHL (0x74654465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAttributeDescription:1.0
                24,
        ACE_NTOHL (0x45787441), 
        ACE_NTOHL (0x74747269), 
        ACE_NTOHL (0x62757465), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = ExtAttributeDescription
        8, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff6a0, // negative offset (-2400)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff6e4, // negative offset (-2332)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff6cc, // negative offset (-2356)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff72c, // negative offset (-2260)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472), 
          ACE_NTOHL (0x69627574), 
          ACE_NTOHL (0x654d6f64), 
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
          
        15,
        ACE_NTOHL (0x6765745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = get_exceptions
                0xffffffff, // indirection
        0xfffffcec, // negative offset (-788)
        15,
        ACE_NTOHL (0x7075745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = put_exceptions
                0xffffffff, // indirection
        0xfffffcd0, // negative offset (-816)

      0U,


  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ComponentIR_HomeDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ComponentIR_HomeDescription),
    (char *) &_oc_CORBA_ComponentIR_HomeDescription,
    0,
    sizeof (CORBA::ComponentIR::HomeDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_BEGIN (ComponentIR)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_HomeDescription,
    &_tc_TAO_tc_CORBA_ComponentIR_HomeDescription
  )
TAO_NAMESPACE_END
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ComponentIR::HomeDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  HomeDescription *tmp = ACE_static_cast (HomeDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::EventDef_ptr _tao_objptr =
    CORBA::ComponentIR::EventDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::EventDef>::insert (
      _tao_any,
      CORBA::ComponentIR::EventDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_EventDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::EventDef>::extract (
        _tao_any,
        CORBA::ComponentIR::EventDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_EventDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::EventDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::EventDef,CORBA::ComponentIR::EventDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::EventDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::EventDef, CORBA::ComponentIR::EventDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::EventDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::Container_ptr _tao_elem
  )
{
  CORBA::ComponentIR::Container_ptr _tao_objptr =
    CORBA::ComponentIR::Container::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::Container_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::Container>::insert (
      _tao_any,
      CORBA::ComponentIR::Container::_tao_any_destructor,
      CORBA::ComponentIR::_tc_Container,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::Container_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::Container>::extract (
        _tao_any,
        CORBA::ComponentIR::Container::_tao_any_destructor,
        CORBA::ComponentIR::_tc_Container,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::Container>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::Container,CORBA::ComponentIR::Container_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::Container>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::Container, CORBA::ComponentIR::Container_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::Container>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ModuleDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::ModuleDef_ptr _tao_objptr =
    CORBA::ComponentIR::ModuleDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ModuleDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::ModuleDef>::insert (
      _tao_any,
      CORBA::ComponentIR::ModuleDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ModuleDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::ModuleDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::ModuleDef>::extract (
        _tao_any,
        CORBA::ComponentIR::ModuleDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_ModuleDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::ModuleDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::ModuleDef,CORBA::ComponentIR::ModuleDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::ModuleDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::ModuleDef, CORBA::ComponentIR::ModuleDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::ModuleDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::Repository_ptr _tao_elem
  )
{
  CORBA::ComponentIR::Repository_ptr _tao_objptr =
    CORBA::ComponentIR::Repository::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::Repository_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::Repository>::insert (
      _tao_any,
      CORBA::ComponentIR::Repository::_tao_any_destructor,
      CORBA::ComponentIR::_tc_Repository,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::Repository_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::Repository>::extract (
        _tao_any,
        CORBA::ComponentIR::Repository::_tao_any_destructor,
        CORBA::ComponentIR::_tc_Repository,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::Repository>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::Repository,CORBA::ComponentIR::Repository_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::Repository>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::Repository, CORBA::ComponentIR::Repository_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::Repository>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ProvidesDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::ProvidesDef_ptr _tao_objptr =
    CORBA::ComponentIR::ProvidesDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ProvidesDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::ProvidesDef>::insert (
      _tao_any,
      CORBA::ComponentIR::ProvidesDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ProvidesDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::ProvidesDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::ProvidesDef>::extract (
        _tao_any,
        CORBA::ComponentIR::ProvidesDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_ProvidesDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::ProvidesDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::ProvidesDef,CORBA::ComponentIR::ProvidesDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::ProvidesDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::ProvidesDef, CORBA::ComponentIR::ProvidesDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::ProvidesDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::ProvidesDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescription>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::ProvidesDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ProvidesDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ProvidesDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescription>::insert (
      _tao_any,
      CORBA::ComponentIR::ProvidesDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ProvidesDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::ProvidesDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::ProvidesDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::ProvidesDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescription>::extract (
        _tao_any,
        CORBA::ComponentIR::ProvidesDescription::_tao_any_destructor,
        CORBA::ComponentIR::_tc_ProvidesDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::UsesDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::UsesDef_ptr _tao_objptr =
    CORBA::ComponentIR::UsesDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::UsesDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::UsesDef>::insert (
      _tao_any,
      CORBA::ComponentIR::UsesDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_UsesDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::UsesDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::UsesDef>::extract (
        _tao_any,
        CORBA::ComponentIR::UsesDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_UsesDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::UsesDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::UsesDef,CORBA::ComponentIR::UsesDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::UsesDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::UsesDef, CORBA::ComponentIR::UsesDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::UsesDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::UsesDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescription>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::UsesDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_UsesDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::UsesDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescription>::insert (
      _tao_any,
      CORBA::ComponentIR::UsesDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_UsesDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::UsesDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::UsesDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::UsesDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescription>::extract (
        _tao_any,
        CORBA::ComponentIR::UsesDescription::_tao_any_destructor,
        CORBA::ComponentIR::_tc_UsesDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventPortDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::EventPortDef_ptr _tao_objptr =
    CORBA::ComponentIR::EventPortDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventPortDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::EventPortDef>::insert (
      _tao_any,
      CORBA::ComponentIR::EventPortDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_EventPortDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventPortDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::EventPortDef>::extract (
        _tao_any,
        CORBA::ComponentIR::EventPortDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_EventPortDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::EventPortDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::EventPortDef,CORBA::ComponentIR::EventPortDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::EventPortDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::EventPortDef, CORBA::ComponentIR::EventPortDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::EventPortDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::EventPortDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescription>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::EventPortDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_EventPortDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventPortDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescription>::insert (
      _tao_any,
      CORBA::ComponentIR::EventPortDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_EventPortDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventPortDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::EventPortDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::EventPortDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescription>::extract (
        _tao_any,
        CORBA::ComponentIR::EventPortDescription::_tao_any_destructor,
        CORBA::ComponentIR::_tc_EventPortDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EmitsDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::EmitsDef_ptr _tao_objptr =
    CORBA::ComponentIR::EmitsDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EmitsDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::EmitsDef>::insert (
      _tao_any,
      CORBA::ComponentIR::EmitsDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_EmitsDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::EmitsDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::EmitsDef>::extract (
        _tao_any,
        CORBA::ComponentIR::EmitsDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_EmitsDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::EmitsDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::EmitsDef,CORBA::ComponentIR::EmitsDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::EmitsDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::EmitsDef, CORBA::ComponentIR::EmitsDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::EmitsDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::PublishesDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::PublishesDef_ptr _tao_objptr =
    CORBA::ComponentIR::PublishesDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::PublishesDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::PublishesDef>::insert (
      _tao_any,
      CORBA::ComponentIR::PublishesDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_PublishesDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::PublishesDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::PublishesDef>::extract (
        _tao_any,
        CORBA::ComponentIR::PublishesDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_PublishesDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::PublishesDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::PublishesDef,CORBA::ComponentIR::PublishesDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::PublishesDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::PublishesDef, CORBA::ComponentIR::PublishesDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::PublishesDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ConsumesDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::ConsumesDef_ptr _tao_objptr =
    CORBA::ComponentIR::ConsumesDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ConsumesDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::ConsumesDef>::insert (
      _tao_any,
      CORBA::ComponentIR::ConsumesDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ConsumesDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::ConsumesDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::ConsumesDef>::extract (
        _tao_any,
        CORBA::ComponentIR::ConsumesDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_ConsumesDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::ConsumesDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::ConsumesDef,CORBA::ComponentIR::ConsumesDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::ConsumesDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::ConsumesDef, CORBA::ComponentIR::ConsumesDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::ConsumesDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ComponentDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::ComponentDef_ptr _tao_objptr =
    CORBA::ComponentIR::ComponentDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ComponentDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::ComponentDef>::insert (
      _tao_any,
      CORBA::ComponentIR::ComponentDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ComponentDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::ComponentDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::ComponentDef>::extract (
        _tao_any,
        CORBA::ComponentIR::ComponentDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_ComponentDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::ComponentDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::ComponentDef,CORBA::ComponentIR::ComponentDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::ComponentDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::ComponentDef, CORBA::ComponentIR::ComponentDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::ComponentDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::ProvidesDescriptionSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescriptionSeq>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::ProvidesDescriptionSeq::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ProvidesDescriptionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ProvidesDescriptionSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescriptionSeq>::insert (
      _tao_any,
      CORBA::ComponentIR::ProvidesDescriptionSeq::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ProvidesDescriptionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::ProvidesDescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::ProvidesDescriptionSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::ProvidesDescriptionSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ProvidesDescriptionSeq>::extract (
        _tao_any,
        CORBA::ComponentIR::ProvidesDescriptionSeq::_tao_any_destructor,
        CORBA::ComponentIR::_tc_ProvidesDescriptionSeq,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::UsesDescriptionSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescriptionSeq>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::UsesDescriptionSeq::_tao_any_destructor,
      CORBA::ComponentIR::_tc_UsesDescriptionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::UsesDescriptionSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescriptionSeq>::insert (
      _tao_any,
      CORBA::ComponentIR::UsesDescriptionSeq::_tao_any_destructor,
      CORBA::ComponentIR::_tc_UsesDescriptionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::UsesDescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::UsesDescriptionSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::UsesDescriptionSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::UsesDescriptionSeq>::extract (
        _tao_any,
        CORBA::ComponentIR::UsesDescriptionSeq::_tao_any_destructor,
        CORBA::ComponentIR::_tc_UsesDescriptionSeq,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::EventPortDescriptionSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescriptionSeq>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::EventPortDescriptionSeq::_tao_any_destructor,
      CORBA::ComponentIR::_tc_EventPortDescriptionSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventPortDescriptionSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescriptionSeq>::insert (
      _tao_any,
      CORBA::ComponentIR::EventPortDescriptionSeq::_tao_any_destructor,
      CORBA::ComponentIR::_tc_EventPortDescriptionSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::EventPortDescriptionSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::EventPortDescriptionSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::EventPortDescriptionSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::EventPortDescriptionSeq>::extract (
        _tao_any,
        CORBA::ComponentIR::EventPortDescriptionSeq::_tao_any_destructor,
        CORBA::ComponentIR::_tc_EventPortDescriptionSeq,
        _tao_elem
      );
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::ComponentDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ComponentDescription>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::ComponentDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ComponentDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::ComponentDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ComponentDescription>::insert (
      _tao_any,
      CORBA::ComponentIR::ComponentDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_ComponentDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::ComponentDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::ComponentDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::ComponentDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ComponentDescription>::extract (
        _tao_any,
        CORBA::ComponentIR::ComponentDescription::_tao_any_destructor,
        CORBA::ComponentIR::_tc_ComponentDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ComponentDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ComponentIR::ComponentDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::FactoryDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::FactoryDef_ptr _tao_objptr =
    CORBA::ComponentIR::FactoryDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::FactoryDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::FactoryDef>::insert (
      _tao_any,
      CORBA::ComponentIR::FactoryDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_FactoryDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::FactoryDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::FactoryDef>::extract (
        _tao_any,
        CORBA::ComponentIR::FactoryDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_FactoryDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::FactoryDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::FactoryDef,CORBA::ComponentIR::FactoryDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::FactoryDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::FactoryDef, CORBA::ComponentIR::FactoryDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::FactoryDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::FinderDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::FinderDef_ptr _tao_objptr =
    CORBA::ComponentIR::FinderDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::FinderDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::FinderDef>::insert (
      _tao_any,
      CORBA::ComponentIR::FinderDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_FinderDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::FinderDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::FinderDef>::extract (
        _tao_any,
        CORBA::ComponentIR::FinderDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_FinderDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::FinderDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::FinderDef,CORBA::ComponentIR::FinderDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::FinderDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::FinderDef, CORBA::ComponentIR::FinderDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::FinderDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::HomeDef_ptr _tao_elem
  )
{
  CORBA::ComponentIR::HomeDef_ptr _tao_objptr =
    CORBA::ComponentIR::HomeDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::HomeDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ComponentIR::HomeDef>::insert (
      _tao_any,
      CORBA::ComponentIR::HomeDef::_tao_any_destructor,
      CORBA::ComponentIR::_tc_HomeDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::HomeDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ComponentIR::HomeDef>::extract (
        _tao_any,
        CORBA::ComponentIR::HomeDef::_tao_any_destructor,
        CORBA::ComponentIR::_tc_HomeDef,
        _tao_elem
      );
}

CORBA::Boolean
TAO::Any_Impl_T<CORBA::ComponentIR::HomeDef>::to_object (
    CORBA::Object_ptr &_tao_elem
  ) const
{
  _tao_elem = CORBA::Object::_duplicate (this->value_);
  return 1;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ComponentIR::HomeDef,CORBA::ComponentIR::HomeDef_var>;
  template class TAO::Any_Impl_T<CORBA::ComponentIR::HomeDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ComponentIR::HomeDef, CORBA::ComponentIR::HomeDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ComponentIR::HomeDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ComponentIR::HomeDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::HomeDescription>::insert_copy (
      _tao_any,
      CORBA::ComponentIR::HomeDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_HomeDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ComponentIR::HomeDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ComponentIR::HomeDescription>::insert (
      _tao_any,
      CORBA::ComponentIR::HomeDescription::_tao_any_destructor,
      CORBA::ComponentIR::_tc_HomeDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ComponentIR::HomeDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ComponentIR::HomeDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ComponentIR::HomeDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ComponentIR::HomeDescription>::extract (
        _tao_any,
        CORBA::ComponentIR::HomeDescription::_tao_any_destructor,
        CORBA::ComponentIR::_tc_HomeDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ComponentIR::HomeDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ComponentIR::HomeDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::EventDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::EventDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::EventDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::Container_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::Container_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::Container::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::ModuleDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::ModuleDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::ModuleDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::Repository_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::Repository_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::Repository::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::ProvidesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::ProvidesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::ProvidesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::UsesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::UsesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::UsesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::EventPortDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::EventPortDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::EventPortDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::EmitsDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::EmitsDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::EmitsDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::PublishesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::PublishesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::PublishesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::ConsumesDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::ConsumesDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::ConsumesDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::ComponentDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::ComponentDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::ComponentDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:125

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::ProvidesDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::ProvidesDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:125

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::UsesDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::UsesDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:125

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::EventPortDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::EventPortDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::FactoryDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::FactoryDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::FactoryDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::FinderDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::FinderDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::FinderDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ComponentIR::HomeDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ComponentIR::HomeDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ComponentIR::HomeDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

