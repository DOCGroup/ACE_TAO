// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:314


#include "IFR_ExtendedC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */



#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_ExtendedC.i"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::FixedDef::_tao_class_id = 0;

CORBA::FixedDef_ptr
tao_CORBA_FixedDef_duplicate (
    CORBA::FixedDef_ptr p
  )
{
  return CORBA::FixedDef::_duplicate (p);
}

void
tao_CORBA_FixedDef_release (
    CORBA::FixedDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::FixedDef_ptr
tao_CORBA_FixedDef_nil (
    void
  )
{
  return CORBA::FixedDef::_nil ();
}

CORBA::FixedDef_ptr
tao_CORBA_FixedDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::FixedDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_FixedDef_upcast (
    void *src
  )
{
  CORBA::FixedDef **tmp =
    ACE_static_cast (CORBA::FixedDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_FixedDef_marshal (
    CORBA::FixedDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::FixedDef_var
// *************************************************************

CORBA::FixedDef_var::FixedDef_var (void)
  : ptr_ (FixedDef::_nil ())
{}

::CORBA::FixedDef_ptr
CORBA::FixedDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::FixedDef_var::FixedDef_var (const ::CORBA::FixedDef_var &p)
  : TAO_Base_var (),
    ptr_ (FixedDef::_duplicate (p.ptr ()))
{}

CORBA::FixedDef_var::~FixedDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::FixedDef_var &
CORBA::FixedDef_var::operator= (FixedDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::FixedDef_var &
CORBA::FixedDef_var::operator= (const ::CORBA::FixedDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::FixedDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::FixedDef_var::operator const ::CORBA::FixedDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::FixedDef_var::operator ::CORBA::FixedDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::FixedDef_ptr
CORBA::FixedDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::FixedDef_ptr
CORBA::FixedDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::FixedDef_ptr &
CORBA::FixedDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::FixedDef_ptr &
CORBA::FixedDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::FixedDef::_nil ();
  return this->ptr_;
}

::CORBA::FixedDef_ptr
CORBA::FixedDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::FixedDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::FixedDef::_nil ();
  return val;
}

::CORBA::FixedDef_ptr
CORBA::FixedDef_var::tao_duplicate (FixedDef_ptr p)
{
  return ::CORBA::FixedDef::_duplicate (p);
}

void
CORBA::FixedDef_var::tao_release (FixedDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::FixedDef_ptr
CORBA::FixedDef_var::tao_nil (void)
{
  return ::CORBA::FixedDef::_nil ();
}

::CORBA::FixedDef_ptr
CORBA::FixedDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::FixedDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::FixedDef_var::tao_upcast (void *src)
{
  FixedDef **tmp =
    ACE_static_cast (FixedDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::FixedDef_out
// *************************************************************

CORBA::FixedDef_out::FixedDef_out (FixedDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::FixedDef::_nil ();
}

CORBA::FixedDef_out::FixedDef_out (FixedDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::FixedDef::_nil ();
}

CORBA::FixedDef_out::FixedDef_out (const ::CORBA::FixedDef_out &p)
  : ptr_ (ACE_const_cast (FixedDef_out &, p).ptr_)
{}

::CORBA::FixedDef_out &
CORBA::FixedDef_out::operator= (const ::CORBA::FixedDef_out &p)
{
  this->ptr_ = ACE_const_cast (FixedDef_out&, p).ptr_;
  return *this;
}

CORBA::FixedDef_out &
CORBA::FixedDef_out::operator= (const ::CORBA::FixedDef_var &p)
{
  this->ptr_ = ::CORBA::FixedDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::FixedDef_out &
CORBA::FixedDef_out::operator= (FixedDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::FixedDef_out::operator ::CORBA::FixedDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::FixedDef_ptr &
CORBA::FixedDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::FixedDef_ptr
CORBA::FixedDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_FixedDef_digits_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_FixedDef_digits_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::UShort result);
    
  private:
    TAO_ClientRequestInfo_CORBA_FixedDef_digits_get (const TAO_ClientRequestInfo_CORBA_FixedDef_digits_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_FixedDef_digits_get &);
    
    ::CORBA::UShort _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_FixedDef_digits_get::TAO_ClientRequestInfo_CORBA_FixedDef_digits_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_FixedDef_digits_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_FixedDef_digits_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_FixedDef_digits_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_FixedDef_digits_get::result (CORBA::UShort result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_FixedDef_digits_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_FixedDef_digits_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::UShort & digits
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_FixedDef_digits_set (const TAO_ClientRequestInfo_CORBA_FixedDef_digits_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_FixedDef_digits_set &);
    const CORBA::UShort & digits_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_FixedDef_digits_set::TAO_ClientRequestInfo_CORBA_FixedDef_digits_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::UShort & digits
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      digits_ (digits)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_FixedDef_digits_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= digits_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_FixedDef_digits_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_FixedDef_digits_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_FixedDef_scale_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_FixedDef_scale_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Short result);
    
  private:
    TAO_ClientRequestInfo_CORBA_FixedDef_scale_get (const TAO_ClientRequestInfo_CORBA_FixedDef_scale_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_FixedDef_scale_get &);
    
    ::CORBA::Short _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_FixedDef_scale_get::TAO_ClientRequestInfo_CORBA_FixedDef_scale_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_FixedDef_scale_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_FixedDef_scale_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_FixedDef_scale_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_FixedDef_scale_get::result (CORBA::Short result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_FixedDef_scale_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_FixedDef_scale_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Short & scale
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_FixedDef_scale_set (const TAO_ClientRequestInfo_CORBA_FixedDef_scale_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_FixedDef_scale_set &);
    const CORBA::Short & scale_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_FixedDef_scale_set::TAO_ClientRequestInfo_CORBA_FixedDef_scale_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Short & scale
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      scale_ (scale)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_FixedDef_scale_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= scale_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_FixedDef_scale_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_FixedDef_scale_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_FixedDef_Proxy_Impl::_TAO_FixedDef_Proxy_Impl (void)
{}

CORBA::_TAO_FixedDef_Remote_Proxy_Impl::_TAO_FixedDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::UShort CORBA::_TAO_FixedDef_Remote_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::UShort _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_digits",
      11,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_FixedDef_digits_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::UShort _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_FixedDef_Remote_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_digits",
      11,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_FixedDef_digits_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          digits
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << digits)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Short CORBA::_TAO_FixedDef_Remote_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Short _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_scale",
      10,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_FixedDef_scale_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Short _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_FixedDef_Remote_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Short scale
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_scale",
      10,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_FixedDef_scale_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          scale
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << scale)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_FixedDef_Proxy_Broker::_TAO_FixedDef_Proxy_Broker (void)
{
}

CORBA::_TAO_FixedDef_Proxy_Broker::~_TAO_FixedDef_Proxy_Broker (void)
{
}

CORBA::_TAO_FixedDef_Proxy_Broker * (*CORBA__TAO_FixedDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_FixedDef_Remote_Proxy_Broker *
CORBA::_TAO_FixedDef_Remote_Proxy_Broker::the_TAO_FixedDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_FixedDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_FixedDef_Remote_Proxy_Broker::_TAO_FixedDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_FixedDef_Remote_Proxy_Broker::~_TAO_FixedDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_FixedDef_Proxy_Impl&
CORBA::_TAO_FixedDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::FixedDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::FixedDef::FixedDef (int collocated)
{
  this->CORBA_FixedDef_setup_collocation (collocated);
}

void
CORBA::FixedDef::CORBA_FixedDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FixedDef_Proxy_Broker_ =
      ::CORBA__TAO_FixedDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FixedDef_Proxy_Broker_ =
      ::CORBA::_TAO_FixedDef_Remote_Proxy_Broker::the_TAO_FixedDef_Remote_Proxy_Broker ();
  
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::FixedDef::~FixedDef (void)
{}

void 
CORBA::FixedDef::_tao_any_destructor (void *_tao_void_pointer)
{
  FixedDef *tmp = ACE_static_cast (FixedDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::FixedDef_ptr
CORBA::FixedDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return FixedDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/FixedDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (FixedDef::_nil ());
      
      if (is_a == 0)
        {
          return FixedDef::_nil ();
        }
    }
  
  return FixedDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::FixedDef_ptr 
CORBA::FixedDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return FixedDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      FixedDef_ptr default_proxy = FixedDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_FixedDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::FixedDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              FixedDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::FixedDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              FixedDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          FixedDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &FixedDef::_tao_class_id
                )
            )
        );
}

CORBA::FixedDef_ptr
CORBA::FixedDef::_duplicate (FixedDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::FixedDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/FixedDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::FixedDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, FixedDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/FixedDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::UShort CORBA::FixedDef::digits (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_FixedDef_Proxy_Impl &proxy = 
    this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.digits (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::FixedDef::digits (
    CORBA::UShort digits
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_FixedDef_Proxy_Impl &proxy = 
    this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.digits (
      this,
      digits
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Short CORBA::FixedDef::scale (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_FixedDef_Proxy_Impl &proxy = 
    this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.scale (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::FixedDef::scale (
    CORBA::Short scale
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_FixedDef_Proxy_Impl &proxy = 
    this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.scale (
      this,
      scale
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_FixedDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4669), 
  ACE_NTOHL (0x78656444), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/FixedDef:1.0
    9,
  ACE_NTOHL (0x46697865), 
  ACE_NTOHL (0x64446566), 
  ACE_NTOHL (0x0),  // name = FixedDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_FixedDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_FixedDef),
    (char *) &_oc_CORBA_FixedDef,
    0,
    sizeof (CORBA::FixedDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_FixedDef,
    &_tc_TAO_tc_CORBA_FixedDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueMember[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c75654d), 
  ACE_NTOHL (0x656d6265), 
  ACE_NTOHL (0x723a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
    12,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x654d656d), 
  ACE_NTOHL (0x62657200),  // name = ValueMember
  7, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff9c, // negative offset (-100)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

  9,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x5f646566), 
  ACE_NTOHL (0x0),  // name = type_def
    CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4944), 
    ACE_NTOHL (0x4c547970), 
    ACE_NTOHL (0x653a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8,
    ACE_NTOHL (0x49444c54), 
    ACE_NTOHL (0x79706500),  // name = IDLType
    
  7,
  ACE_NTOHL (0x61636365), 
  ACE_NTOHL (0x73730000),  // name = access
    CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5669), 
    ACE_NTOHL (0x73696269), 
    ACE_NTOHL (0x6c697479), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
        11,
    ACE_NTOHL (0x56697369), 
    ACE_NTOHL (0x62696c69), 
    ACE_NTOHL (0x74790000),  // name = Visibility
        CORBA::tk_short,


};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMember (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ValueMember),
    (char *) &_oc_CORBA_ValueMember,
    0,
    sizeof (CORBA::ValueMember)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ValueMember,
    &_tc_TAO_tc_CORBA_ValueMember
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ValueMember::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueMember *tmp = ACE_static_cast (ValueMember*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/gen_unbounded_sequence_cs.cpp:100

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CS_

void
CORBA::_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::_allocate_buffer (CORBA::ULong length)
{
  CORBA::ValueMember* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
    {
      CORBA::ValueMember *old =
        ACE_reinterpret_cast (CORBA::ValueMember *, this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        {
          tmp[i] = old[i];
        }
      
      if (this->release_)
        {
          _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::freebuf (old);
        }
    }
  
  this->buffer_ = tmp;
}

void
CORBA::_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    {
      return;
    }
  
  CORBA::ValueMember *tmp =
    ACE_reinterpret_cast (CORBA::ValueMember *, this->buffer_);
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::freebuf (tmp);
  this->buffer_ = 0;
} 

CORBA::_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::~_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void)
{
  this->_deallocate_buffer ();
}

#endif /* end #if !defined */

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_VALUEMEMBERSEQ_CS_)
#define _CORBA_VALUEMEMBERSEQ_CS_

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:249

// *************************************************************
// CORBA::ValueMemberSeq
// *************************************************************

CORBA::ValueMemberSeq::ValueMemberSeq (void)
{}

CORBA::ValueMemberSeq::ValueMemberSeq (CORBA::ULong max)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ValueMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}

CORBA::ValueMemberSeq::ValueMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::ValueMember *buffer,
    CORBA::Boolean release
  )
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ValueMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}

CORBA::ValueMemberSeq::ValueMemberSeq (const ValueMemberSeq &seq)
  : 

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::ValueMember>

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}

CORBA::ValueMemberSeq::~ValueMemberSeq (void) // dtor
{}

void CORBA::ValueMemberSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueMemberSeq *tmp = ACE_static_cast (ValueMemberSeq*, _tao_void_pointer);
  delete tmp;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueMemberSeq[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c75654d), 
  ACE_NTOHL (0x656d6265), 
  ACE_NTOHL (0x72536571), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberSeq:1.0
    15,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x654d656d), 
  ACE_NTOHL (0x62657253), 
  ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
    CORBA::tk_sequence, // typecode kind
  544, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    528, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x434f5242), 
      ACE_NTOHL (0x412f5661), 
      ACE_NTOHL (0x6c75654d), 
      ACE_NTOHL (0x656d6265), 
      ACE_NTOHL (0x723a312e), 
      ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
            12,
      ACE_NTOHL (0x56616c75), 
      ACE_NTOHL (0x654d656d), 
      ACE_NTOHL (0x62657200),  // name = ValueMember
      7, // member count
            5,
      ACE_NTOHL (0x6e616d65), 
      ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4964), 
        ACE_NTOHL (0x656e7469), 
        ACE_NTOHL (0x66696572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11,
        ACE_NTOHL (0x4964656e), 
        ACE_NTOHL (0x74696669), 
        ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
        0U, // string length

      3,
      ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5265), 
        ACE_NTOHL (0x706f7369), 
        ACE_NTOHL (0x746f7279), 
        ACE_NTOHL (0x49643a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13,
        ACE_NTOHL (0x5265706f), 
        ACE_NTOHL (0x7369746f), 
        ACE_NTOHL (0x72794964), 
        ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
        0U, // string length

      11,
      ACE_NTOHL (0x64656669), 
      ACE_NTOHL (0x6e65645f), 
      ACE_NTOHL (0x696e0000),  // name = defined_in
            0xffffffff, // indirection
      0xffffff9c, // negative offset (-100)
      8,
      ACE_NTOHL (0x76657273), 
      ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5665), 
        ACE_NTOHL (0x7273696f), 
        ACE_NTOHL (0x6e537065), 
        ACE_NTOHL (0x633a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12,
        ACE_NTOHL (0x56657273), 
        ACE_NTOHL (0x696f6e53), 
        ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
        0U, // string length

      5,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

      9,
      ACE_NTOHL (0x74797065), 
      ACE_NTOHL (0x5f646566), 
      ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4944), 
        ACE_NTOHL (0x4c547970), 
        ACE_NTOHL (0x653a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8,
        ACE_NTOHL (0x49444c54), 
        ACE_NTOHL (0x79706500),  // name = IDLType
        
      7,
      ACE_NTOHL (0x61636365), 
      ACE_NTOHL (0x73730000),  // name = access
            CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5669), 
        ACE_NTOHL (0x73696269), 
        ACE_NTOHL (0x6c697479), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
                11,
        ACE_NTOHL (0x56697369), 
        ACE_NTOHL (0x62696c69), 
        ACE_NTOHL (0x74790000),  // name = Visibility
                CORBA::tk_short,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMemberSeq (
    CORBA::tk_alias,
    sizeof (_oc_CORBA_ValueMemberSeq),
    (char *) &_oc_CORBA_ValueMemberSeq,
    0,
    sizeof (CORBA::ValueMemberSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ValueMemberSeq,
    &_tc_TAO_tc_CORBA_ValueMemberSeq
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ValueMemberDef::_tao_class_id = 0;

CORBA::ValueMemberDef_ptr
tao_CORBA_ValueMemberDef_duplicate (
    CORBA::ValueMemberDef_ptr p
  )
{
  return CORBA::ValueMemberDef::_duplicate (p);
}

void
tao_CORBA_ValueMemberDef_release (
    CORBA::ValueMemberDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ValueMemberDef_ptr
tao_CORBA_ValueMemberDef_nil (
    void
  )
{
  return CORBA::ValueMemberDef::_nil ();
}

CORBA::ValueMemberDef_ptr
tao_CORBA_ValueMemberDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ValueMemberDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ValueMemberDef_upcast (
    void *src
  )
{
  CORBA::ValueMemberDef **tmp =
    ACE_static_cast (CORBA::ValueMemberDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ValueMemberDef_marshal (
    CORBA::ValueMemberDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ValueMemberDef_var
// *************************************************************

CORBA::ValueMemberDef_var::ValueMemberDef_var (void)
  : ptr_ (ValueMemberDef::_nil ())
{}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ValueMemberDef_var::ValueMemberDef_var (const ::CORBA::ValueMemberDef_var &p)
  : TAO_Base_var (),
    ptr_ (ValueMemberDef::_duplicate (p.ptr ()))
{}

CORBA::ValueMemberDef_var::~ValueMemberDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ValueMemberDef_var &
CORBA::ValueMemberDef_var::operator= (ValueMemberDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ValueMemberDef_var &
CORBA::ValueMemberDef_var::operator= (const ::CORBA::ValueMemberDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ValueMemberDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ValueMemberDef_var::operator const ::CORBA::ValueMemberDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ValueMemberDef_var::operator ::CORBA::ValueMemberDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ValueMemberDef_ptr &
CORBA::ValueMemberDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ValueMemberDef_ptr &
CORBA::ValueMemberDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ValueMemberDef::_nil ();
  return this->ptr_;
}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ValueMemberDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ValueMemberDef::_nil ();
  return val;
}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_var::tao_duplicate (ValueMemberDef_ptr p)
{
  return ::CORBA::ValueMemberDef::_duplicate (p);
}

void
CORBA::ValueMemberDef_var::tao_release (ValueMemberDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_var::tao_nil (void)
{
  return ::CORBA::ValueMemberDef::_nil ();
}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ValueMemberDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ValueMemberDef_var::tao_upcast (void *src)
{
  ValueMemberDef **tmp =
    ACE_static_cast (ValueMemberDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ValueMemberDef_out
// *************************************************************

CORBA::ValueMemberDef_out::ValueMemberDef_out (ValueMemberDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ValueMemberDef::_nil ();
}

CORBA::ValueMemberDef_out::ValueMemberDef_out (ValueMemberDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ValueMemberDef::_nil ();
}

CORBA::ValueMemberDef_out::ValueMemberDef_out (const ::CORBA::ValueMemberDef_out &p)
  : ptr_ (ACE_const_cast (ValueMemberDef_out &, p).ptr_)
{}

::CORBA::ValueMemberDef_out &
CORBA::ValueMemberDef_out::operator= (const ::CORBA::ValueMemberDef_out &p)
{
  this->ptr_ = ACE_const_cast (ValueMemberDef_out&, p).ptr_;
  return *this;
}

CORBA::ValueMemberDef_out &
CORBA::ValueMemberDef_out::operator= (const ::CORBA::ValueMemberDef_var &p)
{
  this->ptr_ = ::CORBA::ValueMemberDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ValueMemberDef_out &
CORBA::ValueMemberDef_out::operator= (ValueMemberDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ValueMemberDef_out::operator ::CORBA::ValueMemberDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ValueMemberDef_ptr &
CORBA::ValueMemberDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::TypeCode_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get &);
    
    ::CORBA::TypeCode_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get::TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get::TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set &);
    CORBA::IDLType_ptr type_def_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set::TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Visibility result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get &);
    
    ::CORBA::Visibility _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get::TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get::result (CORBA::Visibility result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Visibility & access
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set &);
    const CORBA::Visibility & access_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set::TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Visibility & access
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      access_ (access)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= access_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ValueMemberDef_Proxy_Impl::_TAO_ValueMemberDef_Proxy_Impl (void)
{}

CORBA::_TAO_ValueMemberDef_Remote_Proxy_Impl::_TAO_ValueMemberDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::TypeCode_ptr CORBA::_TAO_ValueMemberDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval (CORBA::TypeCode::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::TypeCode_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IDLType_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueMemberDef_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << type_def)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Visibility CORBA::_TAO_ValueMemberDef_Remote_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Visibility _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_access",
      11,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Visibility _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueMemberDef_Remote_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Visibility access
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_access",
      11,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueMemberDef_access_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          access
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << access)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ValueMemberDef_Proxy_Broker::_TAO_ValueMemberDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueMemberDef_Proxy_Broker::~_TAO_ValueMemberDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueMemberDef_Proxy_Broker * (*CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ValueMemberDef_Remote_Proxy_Broker *
CORBA::_TAO_ValueMemberDef_Remote_Proxy_Broker::the_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ValueMemberDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ValueMemberDef_Remote_Proxy_Broker::_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueMemberDef_Remote_Proxy_Broker::~_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueMemberDef_Proxy_Impl&
CORBA::_TAO_ValueMemberDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ValueMemberDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ValueMemberDef::ValueMemberDef (int collocated)
{
  this->CORBA_ValueMemberDef_setup_collocation (collocated);
}

void
CORBA::ValueMemberDef::CORBA_ValueMemberDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
      ::CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
      ::CORBA::_TAO_ValueMemberDef_Remote_Proxy_Broker::the_TAO_ValueMemberDef_Remote_Proxy_Broker ();
  
  this->CORBA_Contained_setup_collocation (collocated);
}

CORBA::ValueMemberDef::~ValueMemberDef (void)
{}

void 
CORBA::ValueMemberDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueMemberDef *tmp = ACE_static_cast (ValueMemberDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ValueMemberDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ValueMemberDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ValueMemberDef::_nil ());
      
      if (is_a == 0)
        {
          return ValueMemberDef::_nil ();
        }
    }
  
  return ValueMemberDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ValueMemberDef_ptr 
CORBA::ValueMemberDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ValueMemberDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ValueMemberDef_ptr default_proxy = ValueMemberDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ValueMemberDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ValueMemberDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ValueMemberDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ValueMemberDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ValueMemberDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ValueMemberDef::_tao_class_id
                )
            )
        );
}

CORBA::ValueMemberDef_ptr
CORBA::ValueMemberDef::_duplicate (ValueMemberDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ValueMemberDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ValueMemberDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ValueMemberDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueMemberDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::TypeCode_ptr CORBA::ValueMemberDef::type (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueMemberDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::ValueMemberDef::type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueMemberDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueMemberDef::type_def (
    CORBA::IDLType_ptr type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueMemberDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.type_def (
      this,
      type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Visibility CORBA::ValueMemberDef::access (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueMemberDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.access (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueMemberDef::access (
    CORBA::Visibility access
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueMemberDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.access (
      this,
      access
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueMemberDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c75654d), 
  ACE_NTOHL (0x656d6265), 
  ACE_NTOHL (0x72446566), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberDef:1.0
    15,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x654d656d), 
  ACE_NTOHL (0x62657244), 
  ACE_NTOHL (0x65660000),  // name = ValueMemberDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMemberDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ValueMemberDef),
    (char *) &_oc_CORBA_ValueMemberDef,
    0,
    sizeof (CORBA::ValueMemberDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ValueMemberDef,
    &_tc_TAO_tc_CORBA_ValueMemberDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ValueDef::_tao_class_id = 0;

CORBA::ValueDef_ptr
tao_CORBA_ValueDef_duplicate (
    CORBA::ValueDef_ptr p
  )
{
  return CORBA::ValueDef::_duplicate (p);
}

void
tao_CORBA_ValueDef_release (
    CORBA::ValueDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ValueDef_ptr
tao_CORBA_ValueDef_nil (
    void
  )
{
  return CORBA::ValueDef::_nil ();
}

CORBA::ValueDef_ptr
tao_CORBA_ValueDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ValueDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ValueDef_upcast (
    void *src
  )
{
  CORBA::ValueDef **tmp =
    ACE_static_cast (CORBA::ValueDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ValueDef_marshal (
    CORBA::ValueDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ValueDef_var
// *************************************************************

CORBA::ValueDef_var::ValueDef_var (void)
  : ptr_ (ValueDef::_nil ())
{}

::CORBA::ValueDef_ptr
CORBA::ValueDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ValueDef_var::ValueDef_var (const ::CORBA::ValueDef_var &p)
  : TAO_Base_var (),
    ptr_ (ValueDef::_duplicate (p.ptr ()))
{}

CORBA::ValueDef_var::~ValueDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ValueDef_var &
CORBA::ValueDef_var::operator= (ValueDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ValueDef_var &
CORBA::ValueDef_var::operator= (const ::CORBA::ValueDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ValueDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ValueDef_var::operator const ::CORBA::ValueDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ValueDef_var::operator ::CORBA::ValueDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ValueDef_ptr
CORBA::ValueDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ValueDef_ptr
CORBA::ValueDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ValueDef_ptr &
CORBA::ValueDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ValueDef_ptr &
CORBA::ValueDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ValueDef::_nil ();
  return this->ptr_;
}

::CORBA::ValueDef_ptr
CORBA::ValueDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ValueDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ValueDef::_nil ();
  return val;
}

::CORBA::ValueDef_ptr
CORBA::ValueDef_var::tao_duplicate (ValueDef_ptr p)
{
  return ::CORBA::ValueDef::_duplicate (p);
}

void
CORBA::ValueDef_var::tao_release (ValueDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ValueDef_ptr
CORBA::ValueDef_var::tao_nil (void)
{
  return ::CORBA::ValueDef::_nil ();
}

::CORBA::ValueDef_ptr
CORBA::ValueDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ValueDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ValueDef_var::tao_upcast (void *src)
{
  ValueDef **tmp =
    ACE_static_cast (ValueDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ValueDef_out
// *************************************************************

CORBA::ValueDef_out::ValueDef_out (ValueDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ValueDef::_nil ();
}

CORBA::ValueDef_out::ValueDef_out (ValueDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ValueDef::_nil ();
}

CORBA::ValueDef_out::ValueDef_out (const ::CORBA::ValueDef_out &p)
  : ptr_ (ACE_const_cast (ValueDef_out &, p).ptr_)
{}

::CORBA::ValueDef_out &
CORBA::ValueDef_out::operator= (const ::CORBA::ValueDef_out &p)
{
  this->ptr_ = ACE_const_cast (ValueDef_out&, p).ptr_;
  return *this;
}

CORBA::ValueDef_out &
CORBA::ValueDef_out::operator= (const ::CORBA::ValueDef_var &p)
{
  this->ptr_ = ::CORBA::ValueDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ValueDef_out &
CORBA::ValueDef_out::operator= (ValueDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ValueDef_out::operator ::CORBA::ValueDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ValueDef_ptr &
CORBA::ValueDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ValueDef_ptr
CORBA::ValueDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InterfaceDefSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get (const TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get &);
    
    ::CORBA::InterfaceDefSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get::TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get::result (::CORBA::InterfaceDefSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & supported_interfaces
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set (const TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set &);
    const CORBA::InterfaceDefSeq & supported_interfaces_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set::TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InterfaceDefSeq & supported_interfaces
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->supported_interfaces_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::InitializerSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get (const TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get &);
    
    ::CORBA::InitializerSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get::TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get::result (::CORBA::InitializerSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InitializerSeq & initializers
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set (const TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set &);
    const CORBA::InitializerSeq & initializers_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set::TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::InitializerSeq & initializers
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      initializers_ (initializers)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->initializers_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ValueDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get (const TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get &);
    
    ::CORBA::ValueDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get::TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get::result (::CORBA::ValueDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ValueDef_ptr base_value
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set (const TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set &);
    CORBA::ValueDef_ptr base_value_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set::TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::ValueDef_ptr base_value
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      base_value_ (base_value)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->base_value_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ValueDefSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get (const TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get &);
    
    ::CORBA::ValueDefSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get::TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get::result (::CORBA::ValueDefSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ValueDefSeq & abstract_base_values
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set (const TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set &);
    const CORBA::ValueDefSeq & abstract_base_values_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set::TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ValueDefSeq & abstract_base_values
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      abstract_base_values_ (abstract_base_values)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->abstract_base_values_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Boolean result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get (const TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get &);
    
    ::CORBA::Boolean _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get::TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_abstract
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set (const TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set &);
    const CORBA::Boolean & is_abstract_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set::TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_abstract
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      is_abstract_ (is_abstract)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Boolean result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get (const TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get &);
    
    ::CORBA::Boolean _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get::TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_custom
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set (const TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set &);
    const CORBA::Boolean & is_custom_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set::TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_custom
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      is_custom_ (is_custom)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Boolean result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get (const TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get &);
    
    ::CORBA::Boolean _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get::TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_truncatable
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set (const TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set &);
    const CORBA::Boolean & is_truncatable_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set::TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::Boolean & is_truncatable
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      is_truncatable_ (is_truncatable)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_is_a : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::Boolean result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_is_a (const TAO_ClientRequestInfo_CORBA_ValueDef_is_a &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_is_a &);
    const char * id_;
    
    ::CORBA::Boolean _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_is_a::TAO_ClientRequestInfo_CORBA_ValueDef_is_a (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_a::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_is_a::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_is_a::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_is_a::result (CORBA::Boolean result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_describe_value : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_describe_value (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ValueDef::FullValueDescription * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_describe_value (const TAO_ClientRequestInfo_CORBA_ValueDef_describe_value &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_describe_value &);
    
    ::CORBA::ValueDef::FullValueDescription * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_describe_value::TAO_ClientRequestInfo_CORBA_ValueDef_describe_value (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_describe_value::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_describe_value::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_describe_value::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_describe_value::result (::CORBA::ValueDef::FullValueDescription * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      const CORBA::Visibility & access
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ValueMemberDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member (const TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr type_;
    const CORBA::Visibility & access_;
    
    ::CORBA::ValueMemberDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member::TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      const CORBA::Visibility & access
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      type_ (type),
      access_ (access)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= access_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member::result (::CORBA::ValueMemberDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::AttributeDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute (const TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr type_;
    const CORBA::AttributeMode & mode_;
    
    ::CORBA::AttributeDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute::TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      type_ (type),
      mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (5);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute::result (::CORBA::AttributeDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueDef_create_operation : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueDef_create_operation (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr result,
      CORBA::OperationMode & mode,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions,
      const CORBA::ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::OperationDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueDef_create_operation (const TAO_ClientRequestInfo_CORBA_ValueDef_create_operation &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueDef_create_operation &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr result_;
    const CORBA::OperationMode & mode_;
    const CORBA::ParDescriptionSeq & params_;
    const CORBA::ExceptionDefSeq & exceptions_;
    const CORBA::ContextIdSeq & contexts_;
    
    ::CORBA::OperationDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueDef_create_operation::TAO_ClientRequestInfo_CORBA_ValueDef_create_operation (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr result,
      CORBA::OperationMode & mode,
      const CORBA::ParDescriptionSeq & params,
      const CORBA::ExceptionDefSeq & exceptions,
      const CORBA::ContextIdSeq & contexts
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      result_ (result),
      mode_ (mode),
      params_ (params),
      exceptions_ (exceptions),
      contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueDef_create_operation::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (8);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->result_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->params_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->contexts_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueDef_create_operation::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueDef_create_operation::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueDef_create_operation::result (::CORBA::OperationDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ValueDef_Proxy_Impl::_TAO_ValueDef_Proxy_Impl (void)
{}

CORBA::_TAO_ValueDef_Remote_Proxy_Impl::_TAO_ValueDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InterfaceDefSeq * CORBA::_TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDefSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::InterfaceDefSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::InterfaceDefSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::InterfaceDefSeq * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_supported_interfaces_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          supported_interfaces
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << supported_interfaces)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::InitializerSeq * CORBA::_TAO_ValueDef_Remote_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InitializerSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::InitializerSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::InitializerSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_initializers",
      17,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_initializers_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::InitializerSeq * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueDef_Remote_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::InitializerSeq & initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_initializers",
      17,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_initializers_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          initializers
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << initializers)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ValueDef_ptr CORBA::_TAO_ValueDef_Remote_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDef_var _tao_retval (CORBA::ValueDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_value",
      15,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_base_value_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ValueDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueDef_Remote_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ValueDef_ptr base_value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_value",
      15,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_base_value_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          base_value
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << base_value)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ValueDefSeq * CORBA::_TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDefSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ValueDefSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ValueDefSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_abstract_base_values",
      25,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ValueDefSeq * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::ValueDefSeq & abstract_base_values
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_abstract_base_values",
      25,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_abstract_base_values_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          abstract_base_values
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << abstract_base_values)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean CORBA::_TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_abstract",
      16,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_abstract",
      16,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_is_abstract_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          is_abstract
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << CORBA::Any::from_boolean (is_abstract))
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean CORBA::_TAO_ValueDef_Remote_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_custom",
      14,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueDef_Remote_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_custom
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_custom",
      14,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_is_custom_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          is_custom
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << CORBA::Any::from_boolean (is_custom))
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean CORBA::_TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_truncatable",
      19,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_truncatable
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_truncatable",
      19,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_is_truncatable_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          is_truncatable
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << CORBA::Any::from_boolean (is_truncatable))
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

CORBA::Boolean CORBA::_TAO_ValueDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval);
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_is_a _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  _tao_retval
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval);

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  _tao_retval
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          CORBA::Boolean _tao_retval_info =
            _tao_retval;
          _tao_ri.result (_tao_retval_info);
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval);
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval);
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ValueDef::FullValueDescription * CORBA::_TAO_ValueDef_Remote_Proxy_Impl::describe_value (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDef::FullValueDescription_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ValueDef::FullValueDescription *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ValueDef::FullValueDescription, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_value",
      14,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_describe_value _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ValueDef::FullValueDescription * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ValueMemberDef_ptr CORBA::_TAO_ValueDef_Remote_Proxy_Impl::create_value_member (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::Visibility access
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueMemberDef_var _tao_retval (CORBA::ValueMemberDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_member",
      19,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_create_value_member _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          type,
          access
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << access)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ValueMemberDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::AttributeDef_ptr CORBA::_TAO_ValueDef_Remote_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AttributeDef_var _tao_retval (CORBA::AttributeDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      5,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_create_attribute _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          type,
          mode
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << mode)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::AttributeDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::OperationDef_ptr CORBA::_TAO_ValueDef_Remote_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::OperationDef_var _tao_retval (CORBA::OperationDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      8,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueDef_create_operation _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          result,
          mode,
          params,
          exceptions,
          contexts
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << result) &&
              (_tao_out << mode) &&
              (_tao_out << params) &&
              (_tao_out << exceptions) &&
              (_tao_out << contexts)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::OperationDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ValueDef_Proxy_Broker::_TAO_ValueDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueDef_Proxy_Broker::~_TAO_ValueDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueDef_Proxy_Broker * (*CORBA__TAO_ValueDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ValueDef_Remote_Proxy_Broker *
CORBA::_TAO_ValueDef_Remote_Proxy_Broker::the_TAO_ValueDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ValueDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ValueDef_Remote_Proxy_Broker::_TAO_ValueDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueDef_Remote_Proxy_Broker::~_TAO_ValueDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueDef_Proxy_Impl&
CORBA::_TAO_ValueDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ValueDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ValueDef::ValueDef (int collocated)
{
  this->CORBA_ValueDef_setup_collocation (collocated);
}

void
CORBA::ValueDef::CORBA_ValueDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ValueDef_Proxy_Broker_ =
      ::CORBA__TAO_ValueDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ValueDef_Proxy_Broker_ =
      ::CORBA::_TAO_ValueDef_Remote_Proxy_Broker::the_TAO_ValueDef_Remote_Proxy_Broker ();
  
  this->CORBA_Container_setup_collocation (collocated);
  this->CORBA_Contained_setup_collocation (collocated);
  this->CORBA_IDLType_setup_collocation (collocated);
}

CORBA::ValueDef::~ValueDef (void)
{}

void 
CORBA::ValueDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueDef *tmp = ACE_static_cast (ValueDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ValueDef_ptr
CORBA::ValueDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ValueDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ValueDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ValueDef::_nil ());
      
      if (is_a == 0)
        {
          return ValueDef::_nil ();
        }
    }
  
  return ValueDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ValueDef_ptr 
CORBA::ValueDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ValueDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ValueDef_ptr default_proxy = ValueDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ValueDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ValueDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ValueDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ValueDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ValueDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ValueDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ValueDef::_tao_class_id
                )
            )
        );
}

CORBA::ValueDef_ptr
CORBA::ValueDef::_duplicate (ValueDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ValueDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ValueDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ValueDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ValueDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::InterfaceDefSeq * CORBA::ValueDef::supported_interfaces (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.supported_interfaces (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueDef::supported_interfaces (
    const CORBA::InterfaceDefSeq & supported_interfaces
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.supported_interfaces (
      this,
      supported_interfaces
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::InitializerSeq * CORBA::ValueDef::initializers (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.initializers (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueDef::initializers (
    const CORBA::InitializerSeq & initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.initializers (
      this,
      initializers
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ValueDef_ptr CORBA::ValueDef::base_value (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.base_value (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueDef::base_value (
    CORBA::ValueDef_ptr base_value
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.base_value (
      this,
      base_value
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ValueDefSeq * CORBA::ValueDef::abstract_base_values (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.abstract_base_values (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueDef::abstract_base_values (
    const CORBA::ValueDefSeq & abstract_base_values
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.abstract_base_values (
      this,
      abstract_base_values
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean CORBA::ValueDef::is_abstract (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_abstract (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueDef::is_abstract (
    CORBA::Boolean is_abstract
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.is_abstract (
      this,
      is_abstract
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean CORBA::ValueDef::is_custom (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_custom (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueDef::is_custom (
    CORBA::Boolean is_custom
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.is_custom (
      this,
      is_custom
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean CORBA::ValueDef::is_truncatable (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_truncatable (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueDef::is_truncatable (
    CORBA::Boolean is_truncatable
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.is_truncatable (
      this,
      is_truncatable
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

CORBA::Boolean CORBA::ValueDef::is_a (
    const char * id
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.is_a (
      this,
      id
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueDef_FullValueDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c756544), 
  ACE_NTOHL (0x65662f46), 
  ACE_NTOHL (0x756c6c56), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e3a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ValueDef/FullValueDescription:1.0
    21,
  ACE_NTOHL (0x46756c6c), 
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = FullValueDescription
  15, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  12,
  ACE_NTOHL (0x69735f61), 
  ACE_NTOHL (0x62737472), 
  ACE_NTOHL (0x61637400),  // name = is_abstract
    CORBA::tk_boolean,

  10,
  ACE_NTOHL (0x69735f63), 
  ACE_NTOHL (0x7573746f), 
  ACE_NTOHL (0x6d000000),  // name = is_custom
    CORBA::tk_boolean,

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff74, // negative offset (-140)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e730000),  // name = operations
    CORBA::tk_alias, // typecode kind for typedefs
  1340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f70), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
        17,
    ACE_NTOHL (0x4f704465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x0),  // name = OpDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    1260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1244, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
                21,
        ACE_NTOHL (0x4f706572), 
        ACE_NTOHL (0x6174696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffdec, // negative offset (-532)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffe30, // negative offset (-464)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffe18, // negative offset (-488)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffea0, // negative offset (-352)
        7,
        ACE_NTOHL (0x72657375), 
        ACE_NTOHL (0x6c740000),  // name = result
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        100, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f70), 
          ACE_NTOHL (0x65726174), 
          ACE_NTOHL (0x696f6e4d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14,
          ACE_NTOHL (0x4f706572), 
          ACE_NTOHL (0x6174696f), 
          ACE_NTOHL (0x6e4d6f64), 
          ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10,
          ACE_NTOHL (0x4f505f4e), 
          ACE_NTOHL (0x4f524d41), 
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f), 
          ACE_NTOHL (0x4e455741), 
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
          
        9,
        ACE_NTOHL (0x636f6e74), 
        ACE_NTOHL (0x65787473), 
        ACE_NTOHL (0x0),  // name = contexts
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f436f), 
          ACE_NTOHL (0x6e746578), 
          ACE_NTOHL (0x74496453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
                    13,
          ACE_NTOHL (0x436f6e74), 
          ACE_NTOHL (0x65787449), 
          ACE_NTOHL (0x64536571), 
          ACE_NTOHL (0x0),  // name = ContextIdSeq
                    CORBA::tk_sequence, // typecode kind
          96, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            80, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f436f), 
              ACE_NTOHL (0x6e746578), 
              ACE_NTOHL (0x74496465), 
              ACE_NTOHL (0x6e746966), 
              ACE_NTOHL (0x6965723a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
                            18,
              ACE_NTOHL (0x436f6e74), 
              ACE_NTOHL (0x65787449), 
              ACE_NTOHL (0x64656e74), 
              ACE_NTOHL (0x69666965), 
              ACE_NTOHL (0x72000000),  // name = ContextIdentifier
                            0xffffffff, // indirection
              0xfffffc6c, // negative offset (-916)

            0U,


        11,
        ACE_NTOHL (0x70617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x72730000),  // name = parameters
                CORBA::tk_alias, // typecode kind for typedefs
        428, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5061), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x50617244), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          348, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            332, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x74657244), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
                            21,
              ACE_NTOHL (0x50617261), 
              ACE_NTOHL (0x6d657465), 
              ACE_NTOHL (0x72446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffffb8c, // negative offset (-1140)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
                            CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4944), 
                ACE_NTOHL (0x4c547970), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                                8,
                ACE_NTOHL (0x49444c54), 
                ACE_NTOHL (0x79706500),  // name = IDLType
                
              5,
              ACE_NTOHL (0x6d6f6465), 
              ACE_NTOHL (0x0),  // name = mode
                            CORBA::tk_enum, // typecode kind
              116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
                36,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f5061), 
                ACE_NTOHL (0x72616d65), 
                ACE_NTOHL (0x7465724d), 
                ACE_NTOHL (0x6f64653a), 
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14,
                ACE_NTOHL (0x50617261), 
                ACE_NTOHL (0x6d657465), 
                ACE_NTOHL (0x724d6f64), 
                ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x0),  // name = PARAM_IN
                10,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f4f55), 
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
                

            0U,


        11,
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = exceptions
                CORBA::tk_alias, // typecode kind for typedefs
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x45786344), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          196, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            180, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                            21,
              ACE_NTOHL (0x45786365), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff9c8, // negative offset (-1592)
              3,
              ACE_NTOHL (0x69640000),  // name = id
                            0xffffffff, // indirection
              0xfffffa0c, // negative offset (-1524)
              11,
              ACE_NTOHL (0x64656669), 
              ACE_NTOHL (0x6e65645f), 
              ACE_NTOHL (0x696e0000),  // name = defined_in
                            0xffffffff, // indirection
              0xfffff9f4, // negative offset (-1548)
              8,
              ACE_NTOHL (0x76657273), 
              ACE_NTOHL (0x696f6e00),  // name = version
                            0xffffffff, // indirection
              0xfffffa7c, // negative offset (-1412)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,


            0U,



      0U,


  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
    CORBA::tk_alias, // typecode kind for typedefs
  404, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4174), 
    ACE_NTOHL (0x74724465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
        19,
    ACE_NTOHL (0x41747472), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    320, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      304, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4174), 
        ACE_NTOHL (0x74726962), 
        ACE_NTOHL (0x75746544), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
                21,
        ACE_NTOHL (0x41747472), 
        ACE_NTOHL (0x69627574), 
        ACE_NTOHL (0x65446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = AttributeDescription
        6, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff894, // negative offset (-1900)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff8d8, // negative offset (-1832)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff8c0, // negative offset (-1856)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff948, // negative offset (-1720)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472), 
          ACE_NTOHL (0x69627574), 
          ACE_NTOHL (0x654d6f64), 
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
          

      0U,


  8,
  ACE_NTOHL (0x6d656d62), 
  ACE_NTOHL (0x65727300),  // name = members
    CORBA::tk_alias, // typecode kind for typedefs
  360, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5661), 
    ACE_NTOHL (0x6c75654d), 
    ACE_NTOHL (0x656d6265), 
    ACE_NTOHL (0x72536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberSeq:1.0
        15,
    ACE_NTOHL (0x56616c75), 
    ACE_NTOHL (0x654d656d), 
    ACE_NTOHL (0x62657253), 
    ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
        CORBA::tk_sequence, // typecode kind
    284, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      268, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5661), 
        ACE_NTOHL (0x6c75654d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
                12,
        ACE_NTOHL (0x56616c75), 
        ACE_NTOHL (0x654d656d), 
        ACE_NTOHL (0x62657200),  // name = ValueMember
        7, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff708, // negative offset (-2296)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff74c, // negative offset (-2228)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff734, // negative offset (-2252)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff7bc, // negative offset (-2116)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        9,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f646566), 
        ACE_NTOHL (0x0),  // name = type_def
                0xffffffff, // indirection
        0xfffffb3c, // negative offset (-1220)
        7,
        ACE_NTOHL (0x61636365), 
        ACE_NTOHL (0x73730000),  // name = access
                CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5669), 
          ACE_NTOHL (0x73696269), 
          ACE_NTOHL (0x6c697479), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
                    11,
          ACE_NTOHL (0x56697369), 
          ACE_NTOHL (0x62696c69), 
          ACE_NTOHL (0x74790000),  // name = Visibility
                    CORBA::tk_short,



      0U,


  13,
  ACE_NTOHL (0x696e6974), 
  ACE_NTOHL (0x69616c69), 
  ACE_NTOHL (0x7a657273), 
  ACE_NTOHL (0x0),  // name = initializers
    CORBA::tk_alias, // typecode kind for typedefs
  416, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f496e), 
    ACE_NTOHL (0x69746961), 
    ACE_NTOHL (0x6c697a65), 
    ACE_NTOHL (0x72536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InitializerSeq:1.0
        15,
    ACE_NTOHL (0x496e6974), 
    ACE_NTOHL (0x69616c69), 
    ACE_NTOHL (0x7a657253), 
    ACE_NTOHL (0x65710000),  // name = InitializerSeq
        CORBA::tk_sequence, // typecode kind
    340, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      324, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f496e), 
        ACE_NTOHL (0x69746961), 
        ACE_NTOHL (0x6c697a65), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
                12,
        ACE_NTOHL (0x496e6974), 
        ACE_NTOHL (0x69616c69), 
        ACE_NTOHL (0x7a657200),  // name = Initializer
        2, // member count
                8,
        ACE_NTOHL (0x6d656d62), 
        ACE_NTOHL (0x65727300),  // name = members
                CORBA::tk_alias, // typecode kind for typedefs
        220, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          38,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5374), 
          ACE_NTOHL (0x72756374), 
          ACE_NTOHL (0x4d656d62), 
          ACE_NTOHL (0x65725365), 
          ACE_NTOHL (0x713a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
                    16,
          ACE_NTOHL (0x53747275), 
          ACE_NTOHL (0x63744d65), 
          ACE_NTOHL (0x6d626572), 
          ACE_NTOHL (0x53657100),  // name = StructMemberSeq
                    CORBA::tk_sequence, // typecode kind
          144, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            128, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5374), 
              ACE_NTOHL (0x72756374), 
              ACE_NTOHL (0x4d656d62), 
              ACE_NTOHL (0x65723a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
                            13,
              ACE_NTOHL (0x53747275), 
              ACE_NTOHL (0x63744d65), 
              ACE_NTOHL (0x6d626572), 
              ACE_NTOHL (0x0),  // name = StructMember
              3, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff4d4, // negative offset (-2860)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
                            0xffffffff, // indirection
              0xfffff944, // negative offset (-1724)

            0U,


        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff494, // negative offset (-2924)

      0U,


  21,
  ACE_NTOHL (0x73757070), 
  ACE_NTOHL (0x6f727465), 
  ACE_NTOHL (0x645f696e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636573), 
  ACE_NTOHL (0x0),  // name = supported_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49645365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
        16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
        CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xfffff468, // negative offset (-2968)
      0U,


  21,
  ACE_NTOHL (0x61627374), 
  ACE_NTOHL (0x72616374), 
  ACE_NTOHL (0x5f626173), 
  ACE_NTOHL (0x655f7661), 
  ACE_NTOHL (0x6c756573), 
  ACE_NTOHL (0x0),  // name = abstract_base_values
    0xffffffff, // indirection
  0xffffff7c, // negative offset (-132)
  15,
  ACE_NTOHL (0x69735f74), 
  ACE_NTOHL (0x72756e63), 
  ACE_NTOHL (0x61746162), 
  ACE_NTOHL (0x6c650000),  // name = is_truncatable
    CORBA::tk_boolean,

  11,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f76616c), 
  ACE_NTOHL (0x75650000),  // name = base_value
    0xffffffff, // indirection
  0xfffff410, // negative offset (-3056)
  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDef_FullValueDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ValueDef_FullValueDescription),
    (char *) &_oc_CORBA_ValueDef_FullValueDescription,
    0,
    sizeof (CORBA::ValueDef::FullValueDescription)
  );

::CORBA::TypeCode_ptr CORBA::ValueDef::_tc_FullValueDescription =
  &_tc_TAO_tc_CORBA_ValueDef_FullValueDescription;

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ValueDef::FullValueDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  FullValueDescription *tmp = ACE_static_cast (FullValueDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ValueDef::FullValueDescription * CORBA::ValueDef::describe_value (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe_value (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ValueMemberDef_ptr CORBA::ValueDef::create_value_member (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::Visibility access
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_value_member (
      this,
      id,
      name,
      version,
      type,
      access
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::AttributeDef_ptr CORBA::ValueDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_attribute (
      this,
      id,
      name,
      version,
      type,
      mode
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::OperationDef_ptr CORBA::ValueDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_operation (
      this,
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  31,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c756544), 
  ACE_NTOHL (0x65663a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
    9,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65446566), 
  ACE_NTOHL (0x0),  // name = ValueDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ValueDef),
    (char *) &_oc_CORBA_ValueDef,
    0,
    sizeof (CORBA::ValueDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ValueDef,
    &_tc_TAO_tc_CORBA_ValueDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c756544), 
  ACE_NTOHL (0x65736372), 
  ACE_NTOHL (0x69707469), 
  ACE_NTOHL (0x6f6e3a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDescription:1.0
    17,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65446573), 
  ACE_NTOHL (0x63726970), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x0),  // name = ValueDescription
  10, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  12,
  ACE_NTOHL (0x69735f61), 
  ACE_NTOHL (0x62737472), 
  ACE_NTOHL (0x61637400),  // name = is_abstract
    CORBA::tk_boolean,

  10,
  ACE_NTOHL (0x69735f63), 
  ACE_NTOHL (0x7573746f), 
  ACE_NTOHL (0x6d000000),  // name = is_custom
    CORBA::tk_boolean,

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff74, // negative offset (-140)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  21,
  ACE_NTOHL (0x73757070), 
  ACE_NTOHL (0x6f727465), 
  ACE_NTOHL (0x645f696e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636573), 
  ACE_NTOHL (0x0),  // name = supported_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49645365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
        16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
        CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xfffffea0, // negative offset (-352)
      0U,


  21,
  ACE_NTOHL (0x61627374), 
  ACE_NTOHL (0x72616374), 
  ACE_NTOHL (0x5f626173), 
  ACE_NTOHL (0x655f7661), 
  ACE_NTOHL (0x6c756573), 
  ACE_NTOHL (0x0),  // name = abstract_base_values
    0xffffffff, // indirection
  0xffffff7c, // negative offset (-132)
  15,
  ACE_NTOHL (0x69735f74), 
  ACE_NTOHL (0x72756e63), 
  ACE_NTOHL (0x61746162), 
  ACE_NTOHL (0x6c650000),  // name = is_truncatable
    CORBA::tk_boolean,

  11,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f76616c), 
  ACE_NTOHL (0x75650000),  // name = base_value
    0xffffffff, // indirection
  0xfffffe48, // negative offset (-440)
};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ValueDescription),
    (char *) &_oc_CORBA_ValueDescription,
    0,
    sizeof (CORBA::ValueDescription)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ValueDescription,
    &_tc_TAO_tc_CORBA_ValueDescription
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ValueDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueDescription *tmp = ACE_static_cast (ValueDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ExtValueDef::_tao_class_id = 0;

CORBA::ExtValueDef_ptr
tao_CORBA_ExtValueDef_duplicate (
    CORBA::ExtValueDef_ptr p
  )
{
  return CORBA::ExtValueDef::_duplicate (p);
}

void
tao_CORBA_ExtValueDef_release (
    CORBA::ExtValueDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ExtValueDef_ptr
tao_CORBA_ExtValueDef_nil (
    void
  )
{
  return CORBA::ExtValueDef::_nil ();
}

CORBA::ExtValueDef_ptr
tao_CORBA_ExtValueDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ExtValueDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ExtValueDef_upcast (
    void *src
  )
{
  CORBA::ExtValueDef **tmp =
    ACE_static_cast (CORBA::ExtValueDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ExtValueDef_marshal (
    CORBA::ExtValueDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ExtValueDef_var
// *************************************************************

CORBA::ExtValueDef_var::ExtValueDef_var (void)
  : ptr_ (ExtValueDef::_nil ())
{}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ExtValueDef_var::ExtValueDef_var (const ::CORBA::ExtValueDef_var &p)
  : TAO_Base_var (),
    ptr_ (ExtValueDef::_duplicate (p.ptr ()))
{}

CORBA::ExtValueDef_var::~ExtValueDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ExtValueDef_var &
CORBA::ExtValueDef_var::operator= (ExtValueDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ExtValueDef_var &
CORBA::ExtValueDef_var::operator= (const ::CORBA::ExtValueDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ExtValueDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ExtValueDef_var::operator const ::CORBA::ExtValueDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ExtValueDef_var::operator ::CORBA::ExtValueDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ExtValueDef_ptr &
CORBA::ExtValueDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ExtValueDef_ptr &
CORBA::ExtValueDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ExtValueDef::_nil ();
  return this->ptr_;
}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ExtValueDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ExtValueDef::_nil ();
  return val;
}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_var::tao_duplicate (ExtValueDef_ptr p)
{
  return ::CORBA::ExtValueDef::_duplicate (p);
}

void
CORBA::ExtValueDef_var::tao_release (ExtValueDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_var::tao_nil (void)
{
  return ::CORBA::ExtValueDef::_nil ();
}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ExtValueDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ExtValueDef_var::tao_upcast (void *src)
{
  ExtValueDef **tmp =
    ACE_static_cast (ExtValueDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ExtValueDef_out
// *************************************************************

CORBA::ExtValueDef_out::ExtValueDef_out (ExtValueDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ExtValueDef::_nil ();
}

CORBA::ExtValueDef_out::ExtValueDef_out (ExtValueDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ExtValueDef::_nil ();
}

CORBA::ExtValueDef_out::ExtValueDef_out (const ::CORBA::ExtValueDef_out &p)
  : ptr_ (ACE_const_cast (ExtValueDef_out &, p).ptr_)
{}

::CORBA::ExtValueDef_out &
CORBA::ExtValueDef_out::operator= (const ::CORBA::ExtValueDef_out &p)
{
  this->ptr_ = ACE_const_cast (ExtValueDef_out&, p).ptr_;
  return *this;
}

CORBA::ExtValueDef_out &
CORBA::ExtValueDef_out::operator= (const ::CORBA::ExtValueDef_var &p)
{
  this->ptr_ = ::CORBA::ExtValueDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ExtValueDef_out &
CORBA::ExtValueDef_out::operator= (ExtValueDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ExtValueDef_out::operator ::CORBA::ExtValueDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ExtValueDef_ptr &
CORBA::ExtValueDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ExtValueDef_ptr
CORBA::ExtValueDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExtInitializerSeq * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get (const TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get &);
    
    ::CORBA::ExtInitializerSeq * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get::TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get::result (::CORBA::ExtInitializerSeq * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExtInitializerSeq & ext_initializers
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set (const TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set &);
    const CORBA::ExtInitializerSeq & ext_initializers_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set::TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const CORBA::ExtInitializerSeq & ext_initializers
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      ext_initializers_ (ext_initializers)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->ext_initializers_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExtValueDef::ExtFullValueDescription * result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value (const TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value &);
    
    ::CORBA::ExtValueDef::ExtFullValueDescription * _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value::TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value::result (::CORBA::ExtValueDef::ExtFullValueDescription * result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode,
      const CORBA::ExceptionDefSeq & get_exceptions,
      const CORBA::ExceptionDefSeq & set_exceptions
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::ExtAttributeDef_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute (const TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute &);
    const char * id_;
    const char * name_;
    const char * version_;
    CORBA::IDLType_ptr type_;
    const CORBA::AttributeMode & mode_;
    const CORBA::ExceptionDefSeq & get_exceptions_;
    const CORBA::ExceptionDefSeq & set_exceptions_;
    
    ::CORBA::ExtAttributeDef_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute::TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      const char * id,
      const char * name,
      const char * version,
      CORBA::IDLType_ptr type,
      CORBA::AttributeMode & mode,
      const CORBA::ExceptionDefSeq & get_exceptions,
      const CORBA::ExceptionDefSeq & set_exceptions
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      id_ (id),
      name_ (name),
      version_ (version),
      type_ (type),
      mode_ (mode),
      get_exceptions_ (get_exceptions),
      set_exceptions_ (set_exceptions)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (7);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<= id_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= name_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<= version_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->type_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->mode_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->get_exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  (*parameter_list)[len].argument <<=  this->set_exceptions_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute::result (::CORBA::ExtAttributeDef_ptr result)
{
  // Update the result. 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ExtValueDef_Proxy_Impl::_TAO_ExtValueDef_Proxy_Impl (void)
{}

CORBA::_TAO_ExtValueDef_Remote_Proxy_Impl::_TAO_ExtValueDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExtInitializerSeq * CORBA::_TAO_ExtValueDef_Remote_Proxy_Impl::ext_initializers (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExtInitializerSeq_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ExtInitializerSeq *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ExtInitializerSeq, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_ext_initializers",
      21,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ExtInitializerSeq * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ExtValueDef_Remote_Proxy_Impl::ext_initializers (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::ExtInitializerSeq & ext_initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_ext_initializers",
      21,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtValueDef_ext_initializers_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          ext_initializers
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << ext_initializers)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExtValueDef::ExtFullValueDescription * CORBA::_TAO_ExtValueDef_Remote_Proxy_Impl::describe_ext_value (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExtValueDef::ExtFullValueDescription_var _tao_retval;
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
  
  {
    CORBA::ExtValueDef::ExtFullValueDescription *tmp;
    ACE_NEW_RETURN (tmp, CORBA::ExtValueDef::ExtFullValueDescription, _tao_retval._retn ());
    _tao_retval = tmp;
  }
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_ext_value",
      18,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtValueDef_describe_ext_value _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ExtValueDef::ExtFullValueDescription * _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::ExtAttributeDef_ptr CORBA::_TAO_ExtValueDef_Remote_Proxy_Impl::create_ext_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    const CORBA::ExceptionDefSeq & get_exceptions,
    const CORBA::ExceptionDefSeq & set_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExtAttributeDef_var _tao_retval (CORBA::ExtAttributeDef::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_ext_attribute",
      20,
      7,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ExtValueDef_create_ext_attribute _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          id,
          name,
          version,
          type,
          mode,
          get_exceptions,
          set_exceptions
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << mode) &&
              (_tao_out << get_exceptions) &&
              (_tao_out << set_exceptions)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      
                    ),
                  0
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::ExtAttributeDef_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ExtValueDef_Proxy_Broker::_TAO_ExtValueDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtValueDef_Proxy_Broker::~_TAO_ExtValueDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtValueDef_Proxy_Broker * (*CORBA__TAO_ExtValueDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ExtValueDef_Remote_Proxy_Broker *
CORBA::_TAO_ExtValueDef_Remote_Proxy_Broker::the_TAO_ExtValueDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ExtValueDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ExtValueDef_Remote_Proxy_Broker::_TAO_ExtValueDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtValueDef_Remote_Proxy_Broker::~_TAO_ExtValueDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ExtValueDef_Proxy_Impl&
CORBA::_TAO_ExtValueDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ExtValueDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ExtValueDef::ExtValueDef (int collocated)
{
  this->CORBA_ExtValueDef_setup_collocation (collocated);
}

void
CORBA::ExtValueDef::CORBA_ExtValueDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ExtValueDef_Proxy_Broker_ =
      ::CORBA__TAO_ExtValueDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ExtValueDef_Proxy_Broker_ =
      ::CORBA::_TAO_ExtValueDef_Remote_Proxy_Broker::the_TAO_ExtValueDef_Remote_Proxy_Broker ();
  
  this->CORBA_ValueDef_setup_collocation (collocated);
}

CORBA::ExtValueDef::~ExtValueDef (void)
{}

void 
CORBA::ExtValueDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtValueDef *tmp = ACE_static_cast (ExtValueDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ExtValueDef_ptr
CORBA::ExtValueDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtValueDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ExtValueDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ExtValueDef::_nil ());
      
      if (is_a == 0)
        {
          return ExtValueDef::_nil ();
        }
    }
  
  return ExtValueDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ExtValueDef_ptr 
CORBA::ExtValueDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ExtValueDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ExtValueDef_ptr default_proxy = ExtValueDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ExtValueDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtValueDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ExtValueDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ExtValueDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ExtValueDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ExtValueDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ExtValueDef::_tao_class_id
                )
            )
        );
}

CORBA::ExtValueDef_ptr
CORBA::ExtValueDef::_duplicate (ExtValueDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ExtValueDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ExtValueDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ValueDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ExtValueDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ExtValueDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ValueDef)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::ValueDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Container::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Container_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ExtValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtValueDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ExtInitializerSeq * CORBA::ExtValueDef::ext_initializers (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ExtValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.ext_initializers (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ExtValueDef::ext_initializers (
    const CORBA::ExtInitializerSeq & ext_initializers
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ExtValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.ext_initializers (
      this,
      ext_initializers
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtValueDef_ExtFullValueDescription[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  58,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x7456616c), 
  ACE_NTOHL (0x75654465), 
  ACE_NTOHL (0x662f4578), 
  ACE_NTOHL (0x7446756c), 
  ACE_NTOHL (0x6c56616c), 
  ACE_NTOHL (0x75654465), 
  ACE_NTOHL (0x73637269), 
  ACE_NTOHL (0x7074696f), 
  ACE_NTOHL (0x6e3a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtValueDef/ExtFullValueDescription:1.0
    24,
  ACE_NTOHL (0x45787446), 
  ACE_NTOHL (0x756c6c56), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x44657363), 
  ACE_NTOHL (0x72697074), 
  ACE_NTOHL (0x696f6e00),  // name = ExtFullValueDescription
  15, // member count
    5,
  ACE_NTOHL (0x6e616d65), 
  ACE_NTOHL (0x0),  // name = name
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4964), 
    ACE_NTOHL (0x656e7469), 
    ACE_NTOHL (0x66696572), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11,
    ACE_NTOHL (0x4964656e), 
    ACE_NTOHL (0x74696669), 
    ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
    0U, // string length

  3,
  ACE_NTOHL (0x69640000),  // name = id
    CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49643a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
    0U, // string length

  12,
  ACE_NTOHL (0x69735f61), 
  ACE_NTOHL (0x62737472), 
  ACE_NTOHL (0x61637400),  // name = is_abstract
    CORBA::tk_boolean,

  10,
  ACE_NTOHL (0x69735f63), 
  ACE_NTOHL (0x7573746f), 
  ACE_NTOHL (0x6d000000),  // name = is_custom
    CORBA::tk_boolean,

  11,
  ACE_NTOHL (0x64656669), 
  ACE_NTOHL (0x6e65645f), 
  ACE_NTOHL (0x696e0000),  // name = defined_in
    0xffffffff, // indirection
  0xffffff74, // negative offset (-140)
  8,
  ACE_NTOHL (0x76657273), 
  ACE_NTOHL (0x696f6e00),  // name = version
    CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5665), 
    ACE_NTOHL (0x7273696f), 
    ACE_NTOHL (0x6e537065), 
    ACE_NTOHL (0x633a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12,
    ACE_NTOHL (0x56657273), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
    0U, // string length

  11,
  ACE_NTOHL (0x6f706572), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e730000),  // name = operations
    CORBA::tk_alias, // typecode kind for typedefs
  1340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f70), 
    ACE_NTOHL (0x44657363), 
    ACE_NTOHL (0x72697074), 
    ACE_NTOHL (0x696f6e53), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
        17,
    ACE_NTOHL (0x4f704465), 
    ACE_NTOHL (0x73637269), 
    ACE_NTOHL (0x7074696f), 
    ACE_NTOHL (0x6e536571), 
    ACE_NTOHL (0x0),  // name = OpDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    1260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1244, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4f70), 
        ACE_NTOHL (0x65726174), 
        ACE_NTOHL (0x696f6e44), 
        ACE_NTOHL (0x65736372), 
        ACE_NTOHL (0x69707469), 
        ACE_NTOHL (0x6f6e3a31), 
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
                21,
        ACE_NTOHL (0x4f706572), 
        ACE_NTOHL (0x6174696f), 
        ACE_NTOHL (0x6e446573), 
        ACE_NTOHL (0x63726970), 
        ACE_NTOHL (0x74696f6e), 
        ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffffdec, // negative offset (-532)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffffe30, // negative offset (-464)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffffe18, // negative offset (-488)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffffea0, // negative offset (-352)
        7,
        ACE_NTOHL (0x72657375), 
        ACE_NTOHL (0x6c740000),  // name = result
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        100, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4f70), 
          ACE_NTOHL (0x65726174), 
          ACE_NTOHL (0x696f6e4d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14,
          ACE_NTOHL (0x4f706572), 
          ACE_NTOHL (0x6174696f), 
          ACE_NTOHL (0x6e4d6f64), 
          ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10,
          ACE_NTOHL (0x4f505f4e), 
          ACE_NTOHL (0x4f524d41), 
          ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10,
          ACE_NTOHL (0x4f505f4f), 
          ACE_NTOHL (0x4e455741), 
          ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
          
        9,
        ACE_NTOHL (0x636f6e74), 
        ACE_NTOHL (0x65787473), 
        ACE_NTOHL (0x0),  // name = contexts
                CORBA::tk_alias, // typecode kind for typedefs
        168, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f436f), 
          ACE_NTOHL (0x6e746578), 
          ACE_NTOHL (0x74496453), 
          ACE_NTOHL (0x65713a31), 
          ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
                    13,
          ACE_NTOHL (0x436f6e74), 
          ACE_NTOHL (0x65787449), 
          ACE_NTOHL (0x64536571), 
          ACE_NTOHL (0x0),  // name = ContextIdSeq
                    CORBA::tk_sequence, // typecode kind
          96, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            80, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f436f), 
              ACE_NTOHL (0x6e746578), 
              ACE_NTOHL (0x74496465), 
              ACE_NTOHL (0x6e746966), 
              ACE_NTOHL (0x6965723a), 
              ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
                            18,
              ACE_NTOHL (0x436f6e74), 
              ACE_NTOHL (0x65787449), 
              ACE_NTOHL (0x64656e74), 
              ACE_NTOHL (0x69666965), 
              ACE_NTOHL (0x72000000),  // name = ContextIdentifier
                            0xffffffff, // indirection
              0xfffffc6c, // negative offset (-916)

            0U,


        11,
        ACE_NTOHL (0x70617261), 
        ACE_NTOHL (0x6d657465), 
        ACE_NTOHL (0x72730000),  // name = parameters
                CORBA::tk_alias, // typecode kind for typedefs
        428, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5061), 
          ACE_NTOHL (0x72446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x50617244), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          348, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            332, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5061), 
              ACE_NTOHL (0x72616d65), 
              ACE_NTOHL (0x74657244), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
                            21,
              ACE_NTOHL (0x50617261), 
              ACE_NTOHL (0x6d657465), 
              ACE_NTOHL (0x72446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffffb8c, // negative offset (-1140)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
                            CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f4944), 
                ACE_NTOHL (0x4c547970), 
                ACE_NTOHL (0x653a312e), 
                ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                                8,
                ACE_NTOHL (0x49444c54), 
                ACE_NTOHL (0x79706500),  // name = IDLType
                
              5,
              ACE_NTOHL (0x6d6f6465), 
              ACE_NTOHL (0x0),  // name = mode
                            CORBA::tk_enum, // typecode kind
              116, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
                36,
                ACE_NTOHL (0x49444c3a), 
                ACE_NTOHL (0x6f6d672e), 
                ACE_NTOHL (0x6f72672f), 
                ACE_NTOHL (0x434f5242), 
                ACE_NTOHL (0x412f5061), 
                ACE_NTOHL (0x72616d65), 
                ACE_NTOHL (0x7465724d), 
                ACE_NTOHL (0x6f64653a), 
                ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14,
                ACE_NTOHL (0x50617261), 
                ACE_NTOHL (0x6d657465), 
                ACE_NTOHL (0x724d6f64), 
                ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x0),  // name = PARAM_IN
                10,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f4f55), 
                ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12,
                ACE_NTOHL (0x50415241), 
                ACE_NTOHL (0x4d5f494e), 
                ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
                

            0U,


        11,
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = exceptions
                CORBA::tk_alias, // typecode kind for typedefs
        276, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4578), 
          ACE_NTOHL (0x63446573), 
          ACE_NTOHL (0x63726970), 
          ACE_NTOHL (0x74696f6e), 
          ACE_NTOHL (0x5365713a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
                    18,
          ACE_NTOHL (0x45786344), 
          ACE_NTOHL (0x65736372), 
          ACE_NTOHL (0x69707469), 
          ACE_NTOHL (0x6f6e5365), 
          ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
                    CORBA::tk_sequence, // typecode kind
          196, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            180, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f4578), 
              ACE_NTOHL (0x63657074), 
              ACE_NTOHL (0x696f6e44), 
              ACE_NTOHL (0x65736372), 
              ACE_NTOHL (0x69707469), 
              ACE_NTOHL (0x6f6e3a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
                            21,
              ACE_NTOHL (0x45786365), 
              ACE_NTOHL (0x7074696f), 
              ACE_NTOHL (0x6e446573), 
              ACE_NTOHL (0x63726970), 
              ACE_NTOHL (0x74696f6e), 
              ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff9c8, // negative offset (-1592)
              3,
              ACE_NTOHL (0x69640000),  // name = id
                            0xffffffff, // indirection
              0xfffffa0c, // negative offset (-1524)
              11,
              ACE_NTOHL (0x64656669), 
              ACE_NTOHL (0x6e65645f), 
              ACE_NTOHL (0x696e0000),  // name = defined_in
                            0xffffffff, // indirection
              0xfffff9f4, // negative offset (-1548)
              8,
              ACE_NTOHL (0x76657273), 
              ACE_NTOHL (0x696f6e00),  // name = version
                            0xffffffff, // indirection
              0xfffffa7c, // negative offset (-1412)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,


            0U,



      0U,


  11,
  ACE_NTOHL (0x61747472), 
  ACE_NTOHL (0x69627574), 
  ACE_NTOHL (0x65730000),  // name = attributes
    CORBA::tk_alias, // typecode kind for typedefs
  468, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    44,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x74417474), 
    ACE_NTOHL (0x72446573), 
    ACE_NTOHL (0x63726970), 
    ACE_NTOHL (0x74696f6e), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExtAttrDescriptionSeq:1.0
        22,
    ACE_NTOHL (0x45787441), 
    ACE_NTOHL (0x74747244), 
    ACE_NTOHL (0x65736372), 
    ACE_NTOHL (0x69707469), 
    ACE_NTOHL (0x6f6e5365), 
    ACE_NTOHL (0x71000000),  // name = ExtAttrDescriptionSeq
        CORBA::tk_sequence, // typecode kind
    380, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      364, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        46,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x74417474), 
        ACE_NTOHL (0x72696275), 
        ACE_NTOHL (0x74654465), 
        ACE_NTOHL (0x73637269), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e3a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtAttributeDescription:1.0
                24,
        ACE_NTOHL (0x45787441), 
        ACE_NTOHL (0x74747269), 
        ACE_NTOHL (0x62757465), 
        ACE_NTOHL (0x44657363), 
        ACE_NTOHL (0x72697074), 
        ACE_NTOHL (0x696f6e00),  // name = ExtAttributeDescription
        8, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff88c, // negative offset (-1908)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff8d0, // negative offset (-1840)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff8b8, // negative offset (-1864)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff940, // negative offset (-1728)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        5,
        ACE_NTOHL (0x6d6f6465), 
        ACE_NTOHL (0x0),  // name = mode
                CORBA::tk_enum, // typecode kind
        104, // encapsulation length
TAO_ENCAP_BYTE_ORDER, // byte order
          36,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f4174), 
          ACE_NTOHL (0x74726962), 
          ACE_NTOHL (0x7574654d), 
          ACE_NTOHL (0x6f64653a), 
          ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14,
          ACE_NTOHL (0x41747472), 
          ACE_NTOHL (0x69627574), 
          ACE_NTOHL (0x654d6f64), 
          ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f4e4f52), 
          ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14,
          ACE_NTOHL (0x41545452), 
          ACE_NTOHL (0x5f524541), 
          ACE_NTOHL (0x444f4e4c), 
          ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
          
        15,
        ACE_NTOHL (0x6765745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = get_exceptions
                0xffffffff, // indirection
        0xfffffd18, // negative offset (-744)
        15,
        ACE_NTOHL (0x7075745f), 
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = put_exceptions
                0xffffffff, // indirection
        0xfffffcfc, // negative offset (-772)

      0U,


  8,
  ACE_NTOHL (0x6d656d62), 
  ACE_NTOHL (0x65727300),  // name = members
    CORBA::tk_alias, // typecode kind for typedefs
  360, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5661), 
    ACE_NTOHL (0x6c75654d), 
    ACE_NTOHL (0x656d6265), 
    ACE_NTOHL (0x72536571), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberSeq:1.0
        15,
    ACE_NTOHL (0x56616c75), 
    ACE_NTOHL (0x654d656d), 
    ACE_NTOHL (0x62657253), 
    ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
        CORBA::tk_sequence, // typecode kind
    284, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      268, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f5661), 
        ACE_NTOHL (0x6c75654d), 
        ACE_NTOHL (0x656d6265), 
        ACE_NTOHL (0x723a312e), 
        ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
                12,
        ACE_NTOHL (0x56616c75), 
        ACE_NTOHL (0x654d656d), 
        ACE_NTOHL (0x62657200),  // name = ValueMember
        7, // member count
                5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff6c8, // negative offset (-2360)
        3,
        ACE_NTOHL (0x69640000),  // name = id
                0xffffffff, // indirection
        0xfffff70c, // negative offset (-2292)
        11,
        ACE_NTOHL (0x64656669), 
        ACE_NTOHL (0x6e65645f), 
        ACE_NTOHL (0x696e0000),  // name = defined_in
                0xffffffff, // indirection
        0xfffff6f4, // negative offset (-2316)
        8,
        ACE_NTOHL (0x76657273), 
        ACE_NTOHL (0x696f6e00),  // name = version
                0xffffffff, // indirection
        0xfffff77c, // negative offset (-2180)
        5,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x0),  // name = type
                CORBA::tk_TypeCode,

        9,
        ACE_NTOHL (0x74797065), 
        ACE_NTOHL (0x5f646566), 
        ACE_NTOHL (0x0),  // name = type_def
                0xffffffff, // indirection
        0xfffffafc, // negative offset (-1284)
        7,
        ACE_NTOHL (0x61636365), 
        ACE_NTOHL (0x73730000),  // name = access
                CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5669), 
          ACE_NTOHL (0x73696269), 
          ACE_NTOHL (0x6c697479), 
          ACE_NTOHL (0x3a312e30), 
          ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
                    11,
          ACE_NTOHL (0x56697369), 
          ACE_NTOHL (0x62696c69), 
          ACE_NTOHL (0x74790000),  // name = Visibility
                    CORBA::tk_short,



      0U,


  13,
  ACE_NTOHL (0x696e6974), 
  ACE_NTOHL (0x69616c69), 
  ACE_NTOHL (0x7a657273), 
  ACE_NTOHL (0x0),  // name = initializers
    CORBA::tk_alias, // typecode kind for typedefs
  452, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4578), 
    ACE_NTOHL (0x74496e69), 
    ACE_NTOHL (0x7469616c), 
    ACE_NTOHL (0x697a6572), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExtInitializerSeq:1.0
        18,
    ACE_NTOHL (0x45787449), 
    ACE_NTOHL (0x6e697469), 
    ACE_NTOHL (0x616c697a), 
    ACE_NTOHL (0x65725365), 
    ACE_NTOHL (0x71000000),  // name = ExtInitializerSeq
        CORBA::tk_sequence, // typecode kind
    372, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      356, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37,
        ACE_NTOHL (0x49444c3a), 
        ACE_NTOHL (0x6f6d672e), 
        ACE_NTOHL (0x6f72672f), 
        ACE_NTOHL (0x434f5242), 
        ACE_NTOHL (0x412f4578), 
        ACE_NTOHL (0x74496e69), 
        ACE_NTOHL (0x7469616c), 
        ACE_NTOHL (0x697a6572), 
        ACE_NTOHL (0x3a312e30), 
        ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ExtInitializer:1.0
                15,
        ACE_NTOHL (0x45787449), 
        ACE_NTOHL (0x6e697469), 
        ACE_NTOHL (0x616c697a), 
        ACE_NTOHL (0x65720000),  // name = ExtInitializer
        3, // member count
                8,
        ACE_NTOHL (0x6d656d62), 
        ACE_NTOHL (0x65727300),  // name = members
                CORBA::tk_alias, // typecode kind for typedefs
        220, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          38,
          ACE_NTOHL (0x49444c3a), 
          ACE_NTOHL (0x6f6d672e), 
          ACE_NTOHL (0x6f72672f), 
          ACE_NTOHL (0x434f5242), 
          ACE_NTOHL (0x412f5374), 
          ACE_NTOHL (0x72756374), 
          ACE_NTOHL (0x4d656d62), 
          ACE_NTOHL (0x65725365), 
          ACE_NTOHL (0x713a312e), 
          ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
                    16,
          ACE_NTOHL (0x53747275), 
          ACE_NTOHL (0x63744d65), 
          ACE_NTOHL (0x6d626572), 
          ACE_NTOHL (0x53657100),  // name = StructMemberSeq
                    CORBA::tk_sequence, // typecode kind
          144, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            128, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35,
              ACE_NTOHL (0x49444c3a), 
              ACE_NTOHL (0x6f6d672e), 
              ACE_NTOHL (0x6f72672f), 
              ACE_NTOHL (0x434f5242), 
              ACE_NTOHL (0x412f5374), 
              ACE_NTOHL (0x72756374), 
              ACE_NTOHL (0x4d656d62), 
              ACE_NTOHL (0x65723a31), 
              ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
                            13,
              ACE_NTOHL (0x53747275), 
              ACE_NTOHL (0x63744d65), 
              ACE_NTOHL (0x6d626572), 
              ACE_NTOHL (0x0),  // name = StructMember
              3, // member count
                            5,
              ACE_NTOHL (0x6e616d65), 
              ACE_NTOHL (0x0),  // name = name
                            0xffffffff, // indirection
              0xfffff488, // negative offset (-2936)
              5,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x0),  // name = type
                            CORBA::tk_TypeCode,

              9,
              ACE_NTOHL (0x74797065), 
              ACE_NTOHL (0x5f646566), 
              ACE_NTOHL (0x0),  // name = type_def
                            0xffffffff, // indirection
              0xfffff8f8, // negative offset (-1800)

            0U,


        11,
        ACE_NTOHL (0x65786365), 
        ACE_NTOHL (0x7074696f), 
        ACE_NTOHL (0x6e730000),  // name = exceptions
                0xffffffff, // indirection
        0xfffff9b4, // negative offset (-1612)
        5,
        ACE_NTOHL (0x6e616d65), 
        ACE_NTOHL (0x0),  // name = name
                0xffffffff, // indirection
        0xfffff430, // negative offset (-3024)

      0U,


  21,
  ACE_NTOHL (0x73757070), 
  ACE_NTOHL (0x6f727465), 
  ACE_NTOHL (0x645f696e), 
  ACE_NTOHL (0x74657266), 
  ACE_NTOHL (0x61636573), 
  ACE_NTOHL (0x0),  // name = supported_interfaces
    CORBA::tk_alias, // typecode kind for typedefs
  92, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5265), 
    ACE_NTOHL (0x706f7369), 
    ACE_NTOHL (0x746f7279), 
    ACE_NTOHL (0x49645365), 
    ACE_NTOHL (0x713a312e), 
    ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
        16,
    ACE_NTOHL (0x5265706f), 
    ACE_NTOHL (0x7369746f), 
    ACE_NTOHL (0x72794964), 
    ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
        CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      0xffffffff, // indirection
      0xfffff404, // negative offset (-3068)
      0U,


  21,
  ACE_NTOHL (0x61627374), 
  ACE_NTOHL (0x72616374), 
  ACE_NTOHL (0x5f626173), 
  ACE_NTOHL (0x655f7661), 
  ACE_NTOHL (0x6c756573), 
  ACE_NTOHL (0x0),  // name = abstract_base_values
    0xffffffff, // indirection
  0xffffff7c, // negative offset (-132)
  15,
  ACE_NTOHL (0x69735f74), 
  ACE_NTOHL (0x72756e63), 
  ACE_NTOHL (0x61746162), 
  ACE_NTOHL (0x6c650000),  // name = is_truncatable
    CORBA::tk_boolean,

  11,
  ACE_NTOHL (0x62617365), 
  ACE_NTOHL (0x5f76616c), 
  ACE_NTOHL (0x75650000),  // name = base_value
    0xffffffff, // indirection
  0xfffff3ac, // negative offset (-3156)
  5,
  ACE_NTOHL (0x74797065), 
  ACE_NTOHL (0x0),  // name = type
    CORBA::tk_TypeCode,

};

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtValueDef_ExtFullValueDescription (
    CORBA::tk_struct,
    sizeof (_oc_CORBA_ExtValueDef_ExtFullValueDescription),
    (char *) &_oc_CORBA_ExtValueDef_ExtFullValueDescription,
    0,
    sizeof (CORBA::ExtValueDef::ExtFullValueDescription)
  );

::CORBA::TypeCode_ptr CORBA::ExtValueDef::_tc_ExtFullValueDescription =
  &_tc_TAO_tc_CORBA_ExtValueDef_ExtFullValueDescription;

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/structure_cs.cpp:66

void CORBA::ExtValueDef::ExtFullValueDescription::_tao_any_destructor (void *_tao_void_pointer)
{
  ExtFullValueDescription *tmp = ACE_static_cast (ExtFullValueDescription*, _tao_void_pointer);
  delete tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ExtValueDef::ExtFullValueDescription * CORBA::ExtValueDef::describe_ext_value (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ExtValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.describe_ext_value (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::ExtAttributeDef_ptr CORBA::ExtValueDef::create_ext_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    const CORBA::ExceptionDefSeq & get_exceptions,
    const CORBA::ExceptionDefSeq & set_exceptions
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ExtValueDef_Proxy_Impl &proxy = 
    this->the_TAO_ExtValueDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.create_ext_attribute (
      this,
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      set_exceptions
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ExtValueDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f4578), 
  ACE_NTOHL (0x7456616c), 
  ACE_NTOHL (0x75654465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExtValueDef:1.0
    12,
  ACE_NTOHL (0x45787456), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x44656600),  // name = ExtValueDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ExtValueDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ExtValueDef),
    (char *) &_oc_CORBA_ExtValueDef,
    0,
    sizeof (CORBA::ExtValueDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ExtValueDef,
    &_tc_TAO_tc_CORBA_ExtValueDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int CORBA::ValueBoxDef::_tao_class_id = 0;

CORBA::ValueBoxDef_ptr
tao_CORBA_ValueBoxDef_duplicate (
    CORBA::ValueBoxDef_ptr p
  )
{
  return CORBA::ValueBoxDef::_duplicate (p);
}

void
tao_CORBA_ValueBoxDef_release (
    CORBA::ValueBoxDef_ptr p
  )
{
  CORBA::release (p);
}

CORBA::ValueBoxDef_ptr
tao_CORBA_ValueBoxDef_nil (
    void
  )
{
  return CORBA::ValueBoxDef::_nil ();
}

CORBA::ValueBoxDef_ptr
tao_CORBA_ValueBoxDef_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return CORBA::ValueBoxDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
tao_CORBA_ValueBoxDef_upcast (
    void *src
  )
{
  CORBA::ValueBoxDef **tmp =
    ACE_static_cast (CORBA::ValueBoxDef **, src);
  return *tmp;
}

CORBA::Boolean
tao_CORBA_ValueBoxDef_marshal (
    CORBA::ValueBoxDef_ptr p,
    TAO_OutputCDR &strm
  )
{
  return p->marshal (strm);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:721

// *************************************************************
// CORBA::ValueBoxDef_var
// *************************************************************

CORBA::ValueBoxDef_var::ValueBoxDef_var (void)
  : ptr_ (ValueBoxDef::_nil ())
{}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_var::ptr (void) const
{
  return this->ptr_;
}

CORBA::ValueBoxDef_var::ValueBoxDef_var (const ::CORBA::ValueBoxDef_var &p)
  : TAO_Base_var (),
    ptr_ (ValueBoxDef::_duplicate (p.ptr ()))
{}

CORBA::ValueBoxDef_var::~ValueBoxDef_var (void)
{
  CORBA::release (this->ptr_);
}

CORBA::ValueBoxDef_var &
CORBA::ValueBoxDef_var::operator= (ValueBoxDef_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

CORBA::ValueBoxDef_var &
CORBA::ValueBoxDef_var::operator= (const ::CORBA::ValueBoxDef_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::CORBA::ValueBoxDef::_duplicate (p.ptr ());
  }
  return *this;
}

CORBA::ValueBoxDef_var::operator const ::CORBA::ValueBoxDef_ptr &() const // cast
{
  return this->ptr_;
}

CORBA::ValueBoxDef_var::operator ::CORBA::ValueBoxDef_ptr &() // cast 
{
  return this->ptr_;
}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_var::operator-> (void) const
{
  return this->ptr_;
}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_var::in (void) const
{
  return this->ptr_;
}

::CORBA::ValueBoxDef_ptr &
CORBA::ValueBoxDef_var::inout (void)
{
  return this->ptr_;
}

::CORBA::ValueBoxDef_ptr &
CORBA::ValueBoxDef_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ValueBoxDef::_nil ();
  return this->ptr_;
}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::CORBA::ValueBoxDef_ptr val = this->ptr_;
  this->ptr_ = ::CORBA::ValueBoxDef::_nil ();
  return val;
}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_var::tao_duplicate (ValueBoxDef_ptr p)
{
  return ::CORBA::ValueBoxDef::_duplicate (p);
}

void
CORBA::ValueBoxDef_var::tao_release (ValueBoxDef_ptr p)
{
  CORBA::release (p);
}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_var::tao_nil (void)
{
  return ::CORBA::ValueBoxDef::_nil ();
}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_var::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return ::CORBA::ValueBoxDef::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
CORBA::ValueBoxDef_var::tao_upcast (void *src)
{
  ValueBoxDef **tmp =
    ACE_static_cast (ValueBoxDef **, src);
  return *tmp;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_interface.cpp:1030

// *************************************************************
// CORBA::ValueBoxDef_out
// *************************************************************

CORBA::ValueBoxDef_out::ValueBoxDef_out (ValueBoxDef_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::CORBA::ValueBoxDef::_nil ();
}

CORBA::ValueBoxDef_out::ValueBoxDef_out (ValueBoxDef_var &p)
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::CORBA::ValueBoxDef::_nil ();
}

CORBA::ValueBoxDef_out::ValueBoxDef_out (const ::CORBA::ValueBoxDef_out &p)
  : ptr_ (ACE_const_cast (ValueBoxDef_out &, p).ptr_)
{}

::CORBA::ValueBoxDef_out &
CORBA::ValueBoxDef_out::operator= (const ::CORBA::ValueBoxDef_out &p)
{
  this->ptr_ = ACE_const_cast (ValueBoxDef_out&, p).ptr_;
  return *this;
}

CORBA::ValueBoxDef_out &
CORBA::ValueBoxDef_out::operator= (const ::CORBA::ValueBoxDef_var &p)
{
  this->ptr_ = ::CORBA::ValueBoxDef::_duplicate (p.ptr ());
  return *this;
}

CORBA::ValueBoxDef_out &
CORBA::ValueBoxDef_out::operator= (ValueBoxDef_ptr p)
{
  this->ptr_ = p;
  return *this;
}

CORBA::ValueBoxDef_out::operator ::CORBA::ValueBoxDef_ptr &() // cast
{
  return this->ptr_;
}

::CORBA::ValueBoxDef_ptr &
CORBA::ValueBoxDef_out::ptr (void)
{
  return this->ptr_;
}

::CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef_out::operator-> (void)
{
  return this->ptr_;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interceptors_cs.cpp:56

#if (TAO_HAS_INTERCEPTORS == 1)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

    void result (::CORBA::IDLType_ptr result);
    
  private:
    TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get (const TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get &);
    
    ::CORBA::IDLType_ptr _result;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get::TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get::result (::CORBA::IDLType_ptr result)
{
  // Update the result. 
  this->_result = result;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:76

class TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set : public TAO_ClientRequestInfo_i
{
public:
  TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr original_type_def
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);

    virtual Dynamic::ParameterList * arguments (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual Dynamic::ExceptionList * exceptions (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));
    
    virtual CORBA::Any * result (ACE_ENV_SINGLE_ARG_DECL)
      ACE_THROW_SPEC ((CORBA::SystemException));

  private:
    TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set (const TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set &);
    void operator= (const TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set &);
    CORBA::IDLType_ptr original_type_def_;
  };
  
  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/interceptors_cs.cpp:376
  
  TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set::TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set (
      TAO_GIOP_Invocation *_tao_invocation,
      CORBA::Object_ptr _tao_target,
      CORBA::IDLType_ptr original_type_def
      ACE_ENV_ARG_DECL_NOT_USED      
    )
      : TAO_ClientRequestInfo_i (_tao_invocation, _tao_target),
      original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  (*parameter_list)[len].argument <<=  this->original_type_def_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}



#endif /* TAO_HAS_INTERCEPTORS */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_impl_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

CORBA::_TAO_ValueBoxDef_Proxy_Impl::_TAO_ValueBoxDef_Proxy_Impl (void)
{}

CORBA::_TAO_ValueBoxDef_Remote_Proxy_Impl::_TAO_ValueBoxDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

::CORBA::IDLType_ptr CORBA::_TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval (CORBA::IDLType::_nil ());
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW_RETURN (CORBA::INTERNAL (),_tao_retval._retn ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_original_type_def",
      22,
      0,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_get _tao_ri (
          &_tao_call,
          _collocated_tao_target_
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK_RETURN (_tao_retval._retn ());

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          
          if (!(
              (_tao_in >> _tao_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                  CORBA::MARSHAL (
                      TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES
                    ),
                  0
                );
            }
          
#if TAO_HAS_INTERCEPTORS == 1
          ::CORBA::IDLType_ptr _tao_retval_info =
            _tao_retval._retn ();
          _tao_ri.result (_tao_retval_info);
          _tao_retval = _tao_retval_info;
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK_RETURN (_tao_retval._retn ());
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
  
  return _tao_retval._retn ();
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/remote_proxy_impl_cs.cpp:63

void CORBA::_TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  
  if (istub == 0)
    {
      ACE_THROW (CORBA::INTERNAL ());
    }
    
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_original_type_def",
      22,
      1,
      istub->orb_core ()
    );
  
  int _invoke_status;
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors (),
      &_tao_call,
      _invoke_status
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      TAO_ClientRequestInfo_CORBA_ValueBoxDef_original_type_def_set _tao_ri (
          &_tao_call,
          _collocated_tao_target_,
          original_type_def
          ACE_ENV_ARG_PARAMETER
        );
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      TAO_INTERCEPTOR (_tao_ri.response_expected (1));
      
#if TAO_HAS_INTERCEPTORS == 1
      
      ACE_TRY
        {
          _tao_vfr.send_request (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          if (_invoke_status == TAO_INVOKE_RESTART)
            {
              _tao_call.restart_flag (1);
              continue;
            }
          
#endif /* TAO_HAS_INTERCEPTORS */
          
          _tao_call.start (ACE_ENV_SINGLE_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag)
              ACE_ENV_ARG_PARAMETER
            );
          TAO_INTERCEPTOR_CHECK;

          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          
          if (!(
              (_tao_out << original_type_def)
              ))
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::MARSHAL (
                      
                    )
                );
            }
          
          _invoke_status =
            _tao_call.invoke (0, 0 ACE_ENV_ARG_PARAMETER);
          TAO_INTERCEPTOR_CHECK;

          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                  CORBA::UNKNOWN (
                      CORBA::OMGVMCID | 1, CORBA::COMPLETED_YES
                    )
                );
            }
          else if (_invoke_status == TAO_INVOKE_RESTART)
            {
              TAO_INTERCEPTOR (
                  _tao_ri.reply_status (_invoke_status);
                  _tao_vfr.receive_other (
                      &_tao_ri
                      ACE_ENV_ARG_PARAMETER
                    );
                  ACE_TRY_CHECK;
                )
              
              continue;
            }
#if TAO_HAS_INTERCEPTORS == 1
          
          _tao_ri.reply_status (_invoke_status);
          _tao_vfr.receive_reply (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          _tao_ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
              || _tao_status == PortableInterceptor::USER_EXCEPTION)
            {
              ACE_RE_THROW;
            }
        }
      
# if defined (ACE_HAS_EXCEPTIONS) \
     && defined (ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS)
      ACE_CATCHALL
        {
          CORBA::UNKNOWN ex;
          
          _tao_ri.exception (&ex);
          _tao_vfr.receive_exception (
              &_tao_ri
              ACE_ENV_ARG_PARAMETER
            );
          ACE_TRY_CHECK;
          
          PortableInterceptor::ReplyStatus _tao_status =
            _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
          ACE_TRY_CHECK;
          
          if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION)
            ACE_TRY_THROW (ex);
        }
# endif  /* ACE_HAS_EXCEPTIONS && ACE_HAS_BROKEN_UNEXPECTED_EXCEPTIONS */
      
      ACE_ENDTRY;
      ACE_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_CHECK;
      
      if (_tao_status == PortableInterceptor::LOCATION_FORWARD
          || _tao_status == PortableInterceptor::TRANSPORT_RETRY)
        {
          continue;
        }
      
#endif  /* TAO_HAS_INTERCEPTORS */
      
      break;
    }
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/remote_proxy_broker_cs.cpp:31

///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

CORBA::_TAO_ValueBoxDef_Proxy_Broker::_TAO_ValueBoxDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueBoxDef_Proxy_Broker::~_TAO_ValueBoxDef_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueBoxDef_Proxy_Broker * (*CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
CORBA::_TAO_ValueBoxDef_Remote_Proxy_Broker *
CORBA::_TAO_ValueBoxDef_Remote_Proxy_Broker::the_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
{
  static ::CORBA::_TAO_ValueBoxDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

CORBA::_TAO_ValueBoxDef_Remote_Proxy_Broker::_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueBoxDef_Remote_Proxy_Broker::~_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
{
}

CORBA::_TAO_ValueBoxDef_Proxy_Impl&
CORBA::_TAO_ValueBoxDef_Remote_Proxy_Broker::select_proxy (
    ::CORBA::ValueBoxDef *
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return this->remote_proxy_impl_;
}

//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:234

CORBA::ValueBoxDef::ValueBoxDef (int collocated)
{
  this->CORBA_ValueBoxDef_setup_collocation (collocated);
}

void
CORBA::ValueBoxDef::CORBA_ValueBoxDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
      ::CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
      ::CORBA::_TAO_ValueBoxDef_Remote_Proxy_Broker::the_TAO_ValueBoxDef_Remote_Proxy_Broker ();
  
  this->CORBA_TypedefDef_setup_collocation (collocated);
}

CORBA::ValueBoxDef::~ValueBoxDef (void)
{}

void 
CORBA::ValueBoxDef::_tao_any_destructor (void *_tao_void_pointer)
{
  ValueBoxDef *tmp = ACE_static_cast (ValueBoxDef *, _tao_void_pointer);
  CORBA::release (tmp);
}

CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  if (CORBA::is_nil (obj))
    {
      return ValueBoxDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a =
        obj->_is_a (
            "IDL:omg.org/CORBA/ValueBoxDef:1.0"
            ACE_ENV_ARG_PARAMETER
          );
      ACE_CHECK_RETURN (ValueBoxDef::_nil ());
      
      if (is_a == 0)
        {
          return ValueBoxDef::_nil ();
        }
    }
  
  return ValueBoxDef::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

CORBA::ValueBoxDef_ptr 
CORBA::ValueBoxDef::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ValueBoxDef::_nil ();
    }
  
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      
      if (stub != 0)
        {
          stub->_incr_refcnt ();
        }
      
      ValueBoxDef_ptr default_proxy = ValueBoxDef::_nil ();
      
      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&
          CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer != 0
        )
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ValueBoxDef (
                  stub,
                  1,
                  obj->_servant ()
                ),
              ValueBoxDef::_nil ()
            );
        }
      
      if (CORBA::is_nil (default_proxy))
        {
          ACE_NEW_RETURN (
              default_proxy,
              ::CORBA::ValueBoxDef (
                  stub,
                  0,
                  obj->_servant ()
                ),
              ValueBoxDef::_nil ()
            );
        }
      
      return default_proxy;
    }
  else 
    return
      ACE_reinterpret_cast (
          ValueBoxDef_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ValueBoxDef::_tao_class_id
                )
            )
        );
}

CORBA::ValueBoxDef_ptr
CORBA::ValueBoxDef::_duplicate (ValueBoxDef_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

CORBA::Boolean
CORBA::ValueBoxDef::_is_a (
    const char *value
    ACE_ENV_ARG_DECL
  )
{
  if (
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/ValueBoxDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          (char *)value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
     )
    {
      return 1; // success using local knowledge
    }
  else
    {
      return this->CORBA_Object::_is_a (
          value
          ACE_ENV_ARG_PARAMETER
        );
    }
}

void *CORBA::ValueBoxDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  
  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::CORBA, ValueBoxDef)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::TypedefDef::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::TypedefDef_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Contained::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Contained_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IDLType::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IDLType_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::IRObject::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::IRObject_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }
  
  if (retv != 0)
    {
      this->_add_ref ();
    }
  
  return retv;
}

const char* CORBA::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueBoxDef:1.0";
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

::CORBA::IDLType_ptr CORBA::ValueBoxDef::original_type_def (
    ACE_ENV_SINGLE_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueBoxDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return proxy.original_type_def (
      this
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_operation/operation_cs.cpp:80

void CORBA::ValueBoxDef::original_type_def (
    CORBA::IDLType_ptr original_type_def
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  _TAO_ValueBoxDef_Proxy_Impl &proxy = 
    this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  proxy.original_type_def (
      this,
      original_type_def
      ACE_ENV_ARG_PARAMETER
    );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_CORBA_ValueBoxDef[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x434f5242), 
  ACE_NTOHL (0x412f5661), 
  ACE_NTOHL (0x6c756542), 
  ACE_NTOHL (0x6f784465), 
  ACE_NTOHL (0x663a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueBoxDef:1.0
    12,
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65426f78), 
  ACE_NTOHL (0x44656600),  // name = ValueBoxDef
  };

static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueBoxDef (
    CORBA::tk_objref,
    sizeof (_oc_CORBA_ValueBoxDef),
    (char *) &_oc_CORBA_ValueBoxDef,
    0,
    sizeof (CORBA::ValueBoxDef)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ValueBoxDef,
    &_tc_TAO_tc_CORBA_ValueBoxDef
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::FixedDef_ptr _tao_elem
  )
{
  CORBA::FixedDef_ptr _tao_objptr =
    CORBA::FixedDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::FixedDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::FixedDef>::insert (
      _tao_any,
      CORBA::FixedDef::_tao_any_destructor,
      CORBA::_tc_FixedDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::FixedDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::FixedDef>::extract (
        _tao_any,
        CORBA::FixedDef::_tao_any_destructor,
        CORBA::_tc_FixedDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::FixedDef,CORBA::FixedDef_var>;
  template class TAO::Any_Impl_T<CORBA::FixedDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::FixedDef, CORBA::FixedDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::FixedDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueMember &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueMember>::insert_copy (
      _tao_any,
      CORBA::ValueMember::_tao_any_destructor,
      CORBA::_tc_ValueMember,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueMember *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueMember>::insert (
      _tao_any,
      CORBA::ValueMember::_tao_any_destructor,
      CORBA::_tc_ValueMember,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueMember *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ValueMember *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ValueMember *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ValueMember>::extract (
        _tao_any,
        CORBA::ValueMember::_tao_any_destructor,
        CORBA::_tc_ValueMember,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ValueMember>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ValueMember>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueMemberSeq &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueMemberSeq>::insert_copy (
      _tao_any,
      CORBA::ValueMemberSeq::_tao_any_destructor,
      CORBA::_tc_ValueMemberSeq,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueMemberSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueMemberSeq>::insert (
      _tao_any,
      CORBA::ValueMemberSeq::_tao_any_destructor,
      CORBA::_tc_ValueMemberSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueMemberSeq *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ValueMemberSeq *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ValueMemberSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ValueMemberSeq>::extract (
        _tao_any,
        CORBA::ValueMemberSeq::_tao_any_destructor,
        CORBA::_tc_ValueMemberSeq,
        _tao_elem
      );
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueMemberDef_ptr _tao_elem
  )
{
  CORBA::ValueMemberDef_ptr _tao_objptr =
    CORBA::ValueMemberDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueMemberDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ValueMemberDef>::insert (
      _tao_any,
      CORBA::ValueMemberDef::_tao_any_destructor,
      CORBA::_tc_ValueMemberDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueMemberDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ValueMemberDef>::extract (
        _tao_any,
        CORBA::ValueMemberDef::_tao_any_destructor,
        CORBA::_tc_ValueMemberDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>;
  template class TAO::Any_Impl_T<CORBA::ValueMemberDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ValueMemberDef, CORBA::ValueMemberDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ValueMemberDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueDef_ptr _tao_elem
  )
{
  CORBA::ValueDef_ptr _tao_objptr =
    CORBA::ValueDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ValueDef>::insert (
      _tao_any,
      CORBA::ValueDef::_tao_any_destructor,
      CORBA::_tc_ValueDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ValueDef>::extract (
        _tao_any,
        CORBA::ValueDef::_tao_any_destructor,
        CORBA::_tc_ValueDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ValueDef,CORBA::ValueDef_var>;
  template class TAO::Any_Impl_T<CORBA::ValueDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ValueDef, CORBA::ValueDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ValueDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueDef::FullValueDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueDef::FullValueDescription>::insert_copy (
      _tao_any,
      CORBA::ValueDef::FullValueDescription::_tao_any_destructor,
      CORBA::ValueDef::_tc_FullValueDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueDef::FullValueDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueDef::FullValueDescription>::insert (
      _tao_any,
      CORBA::ValueDef::FullValueDescription::_tao_any_destructor,
      CORBA::ValueDef::_tc_FullValueDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueDef::FullValueDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ValueDef::FullValueDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ValueDef::FullValueDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ValueDef::FullValueDescription>::extract (
        _tao_any,
        CORBA::ValueDef::FullValueDescription::_tao_any_destructor,
        CORBA::ValueDef::_tc_FullValueDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ValueDef::FullValueDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ValueDef::FullValueDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueDescription>::insert_copy (
      _tao_any,
      CORBA::ValueDescription::_tao_any_destructor,
      CORBA::_tc_ValueDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ValueDescription>::insert (
      _tao_any,
      CORBA::ValueDescription::_tao_any_destructor,
      CORBA::_tc_ValueDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ValueDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ValueDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ValueDescription>::extract (
        _tao_any,
        CORBA::ValueDescription::_tao_any_destructor,
        CORBA::_tc_ValueDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ValueDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ValueDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtValueDef_ptr _tao_elem
  )
{
  CORBA::ExtValueDef_ptr _tao_objptr =
    CORBA::ExtValueDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtValueDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ExtValueDef>::insert (
      _tao_any,
      CORBA::ExtValueDef::_tao_any_destructor,
      CORBA::_tc_ExtValueDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtValueDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ExtValueDef>::extract (
        _tao_any,
        CORBA::ExtValueDef::_tao_any_destructor,
        CORBA::_tc_ExtValueDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ExtValueDef,CORBA::ExtValueDef_var>;
  template class TAO::Any_Impl_T<CORBA::ExtValueDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ExtValueDef, CORBA::ExtValueDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ExtValueDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from 
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_structure/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExtValueDef::ExtFullValueDescription &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExtValueDef::ExtFullValueDescription>::insert_copy (
      _tao_any,
      CORBA::ExtValueDef::ExtFullValueDescription::_tao_any_destructor,
      CORBA::ExtValueDef::_tc_ExtFullValueDescription,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ExtValueDef::ExtFullValueDescription *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<CORBA::ExtValueDef::ExtFullValueDescription>::insert (
      _tao_any,
      CORBA::ExtValueDef::ExtFullValueDescription::_tao_any_destructor,
      CORBA::ExtValueDef::_tc_ExtFullValueDescription,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ExtValueDef::ExtFullValueDescription *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const CORBA::ExtValueDef::ExtFullValueDescription *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const CORBA::ExtValueDef::ExtFullValueDescription *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<CORBA::ExtValueDef::ExtFullValueDescription>::extract (
        _tao_any,
        CORBA::ExtValueDef::ExtFullValueDescription::_tao_any_destructor,
        CORBA::ExtValueDef::_tc_ExtFullValueDescription,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<CORBA::ExtValueDef::ExtFullValueDescription>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<CORBA::ExtValueDef::ExtFullValueDescription>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueBoxDef_ptr _tao_elem
  )
{
  CORBA::ValueBoxDef_ptr _tao_objptr =
    CORBA::ValueBoxDef::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    CORBA::ValueBoxDef_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<CORBA::ValueBoxDef>::insert (
      _tao_any,
      CORBA::ValueBoxDef::_tao_any_destructor,
      CORBA::_tc_ValueBoxDef,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    CORBA::ValueBoxDef_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<CORBA::ValueBoxDef>::extract (
        _tao_any,
        CORBA::ValueBoxDef::_tao_any_destructor,
        CORBA::_tc_ValueBoxDef,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>;
  template class TAO::Any_Impl_T<CORBA::ValueBoxDef>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<CORBA::ValueBoxDef, CORBA::ValueBoxDef_var>
# pragma instantiate TAO::Any_Impl_T<CORBA::ValueBoxDef>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::FixedDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::FixedDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::FixedDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:125

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ValueMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();
  
  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ValueMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  
  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }
      
      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);
      
      // If length is 0 we return true.
      if (0 >= _tao_seq_len) 
        {
          return 1;
        }
      
      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;
      
      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }
      
      return _tao_marshal_flag;
    }
  
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ValueMemberDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ValueMemberDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ValueMemberDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ValueDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ValueDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ValueDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExtValueDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExtValueDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ExtValueDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/cdr_op_cs.cpp:94

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ValueBoxDef_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ValueBoxDef_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    
    if ((strm >> obj.inout ()) == 0)
      {
        return 0;
      }
    
    // Narrow to the right type.
    _tao_objref =
      CORBA::ValueBoxDef::_unchecked_narrow (
          obj.in ()
          ACE_ENV_ARG_PARAMETER
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

