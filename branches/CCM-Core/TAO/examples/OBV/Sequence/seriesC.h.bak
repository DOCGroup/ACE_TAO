// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_SERIESC_H_
#define _TAO_IDL_SERIESC_H_

#include "tao/corba.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

// Valuetype class
class registry;
typedef registry *registry_ptr;

#if !defined (_REGISTRY___VAR_CH_)
#define _REGISTRY___VAR_CH_

class  registry_var
{
public:
  registry_var (void); // default constructor
  registry_var (registry*);
  registry_var (const registry*); // (TAO extension)
  registry_var (const registry_var &); // copy constructor
  ~registry_var (void); // destructor

  registry_var &operator= (registry*);
  registry_var &operator= (const registry_var &);
  registry* operator-> (void) const;

  operator const registry* () const;
  operator registry* ();
  // in, inout, out, _retn
  registry* in (void) const;
  registry* &inout (void);
  registry* &out (void);
  registry* _retn (void);
  registry* ptr (void) const;

private:
  registry* ptr_;
};


#endif /* end #if !defined */


#if !defined (_REGISTRY___OUT_CH_)
#define _REGISTRY___OUT_CH_

class  registry_out
{
public:
  registry_out (registry* &);
  registry_out (registry_var &);
  registry_out (const registry_out &);
  registry_out &operator= (const registry_out &);
  registry_out &operator= (const registry_var &);
  registry_out &operator= (registry*);
  operator registry* &();
  registry* &ptr (void);
  registry* operator-> (void);

private:
  registry* &ptr_;
};


#endif /* end #if !defined */


#if !defined (_REGISTRY___INIT_CH_)
#define _REGISTRY___INIT_CH_

class  registry_init : public CORBA_ValueFactoryBase
{
public:
  virtual ~registry_init ();
  virtual const char* tao_repository_id (void);

  // create () goes here

};

#endif /* end #if !defined */


#if !defined (_REGISTRY_CH_)
#define _REGISTRY_CH_

class  registry
  : public virtual CORBA_ValueBase
{
public:

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef registry* _ptr_type;
  typedef registry_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static registry* _downcast (CORBA::ValueBase* );
  // The address of static _downcast is implicit used as type id

  // (TAO extensions or internals)
  static CORBA::Boolean _tao_unmarshal (
      TAO_InputCDR &,
      registry *&
    );
  virtual const char* _tao_obv_repository_id () const;
  static const char* _tao_obv_static_repository_id ();

  virtual void value (CORBA::Long) = 0;    // set
  virtual CORBA::Long value (void) const = 0;     // get method


protected:
  registry ();
  virtual ~registry ();

  // TAO internals
  virtual void *_tao_obv_narrow (ptr_arith_t);
  virtual CORBA::Boolean _tao_marshal_v (TAO_OutputCDR &);
  virtual CORBA::Boolean _tao_unmarshal_v (TAO_InputCDR &);

private:
  registry (const registry &);
  void operator= (const registry &);

protected:
  virtual CORBA::Boolean _tao_marshal__registry (TAO_OutputCDR &) = 0;
  virtual CORBA::Boolean _tao_unmarshal__registry (TAO_InputCDR &) = 0;

};

#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_REGISTRIES_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_REGISTRIES_CH_

class TAO_EXPORT_MACRO _TAO_Unbounded_Valuetype_Sequence_registries
  : public TAO_Unbounded_Base_Sequence
{
public:
  // = Initialization and termination methods.
  _TAO_Unbounded_Valuetype_Sequence_registries (void);
  _TAO_Unbounded_Valuetype_Sequence_registries (CORBA::ULong maximum);
  _TAO_Unbounded_Valuetype_Sequence_registries (
      CORBA::ULong maximum,
      CORBA::ULong length,
      registry_ptr *value,
      CORBA::Boolean release = 0
    );
  _TAO_Unbounded_Valuetype_Sequence_registries (
      const _TAO_Unbounded_Valuetype_Sequence_registries &rhs
    );
  _TAO_Unbounded_Valuetype_Sequence_registries &operator= (
      const _TAO_Unbounded_Valuetype_Sequence_registries &rhs
    );
  virtual ~_TAO_Unbounded_Valuetype_Sequence_registries (void);

  // = Accessors.
  TAO_Valuetype_Manager<registry,registry_var> operator[] (CORBA::ULong index) const;

  // = Static operations.
  static  **allocbuf (CORBA::ULong nelems);
  static void freebuf ( **buffer);

  // Implement the TAO_Base_Sequence methods (see Sequence.h)
  virtual void _allocate_buffer (CORBA::ULong length);
  virtual void _deallocate_buffer (void);
  * *get_buffer (CORBA::Boolean orphan = 0);
  const * *get_buffer (void) const;
  virtual void _shrink_buffer (
      CORBA::ULong nl,
      CORBA::ULong ol
    );

  /*
  virtual void _downcast (
      void* target,
      CORBA_ValueBase *src,
      CORBA_Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual CORBA_ValueBase* _upcast (void *src) const;
  */
};

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_REGISTRIES_CH_)
#define _REGISTRIES_CH_

class registries;
class registries_var;

// *************************************************************
// registries
// *************************************************************

class  registries : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_registries
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<registry,registry_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  registries (void); // default ctor
  registries (CORBA::ULong max); // uses max size
  registries (
      CORBA::ULong max,
      CORBA::ULong length,
      registry_ptr *buffer,
      CORBA::Boolean release = 0
    );
  registries (const registries &); // copy ctor
  ~registries (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef registries_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


};

#endif /* end #if !defined */


#if !defined (_REGISTRIES___VAR_CH_)
#define _REGISTRIES___VAR_CH_

// *************************************************************
// class registries_var
// *************************************************************

class  registries_var
{
public:
  registries_var (void);
  registries_var (registries *);
  registries_var (const registries_var &);
  ~registries_var (void);

  registries_var &operator= (registries *);
  registries_var &operator= (const registries_var &);
  registries *operator-> (void);
  const registries *operator-> (void) const;

  operator const registries &() const;
  operator registries &();
  operator registries &() const;
  operator registries *&(); // variable-size base types only

  TAO_Valuetype_Manager<registry,registry_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const registries &in (void) const;
  registries &inout (void);
  registries *&out (void);
  registries *_retn (void);
  registries *ptr (void) const;

private:
  registries *ptr_;
};


#endif /* end #if !defined */


#if !defined (_REGISTRIES___OUT_CH_)
#define _REGISTRIES___OUT_CH_

class  registries_out
{
public:
  registries_out (registries *&);
  registries_out (registries_var &);
  registries_out (const registries_out &);
  registries_out &operator= (const registries_out &);
  registries_out &operator= (registries *);
  operator registries *&();
  registries *&ptr (void);
  registries *operator-> (void);
  TAO_Valuetype_Manager<registry,registry_var> operator[] (CORBA::ULong index);

private:
  registries *&ptr_;
  // Assignment from T_var not allowed.
  void operator= (const registries_var &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_registries;


#if !defined (_SERIES___PTR_CH_)
#define _SERIES___PTR_CH_

class series;
typedef series *series_ptr;

#endif /* end #if !defined */


#if !defined (_SERIES___VAR_CH_)
#define _SERIES___VAR_CH_

class  series_var : public TAO_Base_var
{
public:
  series_var (void); // default constructor
  series_var (series_ptr p) : ptr_ (p) {}
  series_var (const series_var &); // copy constructor
  ~series_var (void); // destructor

  series_var &operator= (series_ptr);
  series_var &operator= (const series_var &);
  series_ptr operator-> (void) const;

  operator const series_ptr &() const;
  operator series_ptr &();
  // in, inout, out, _retn
  series_ptr in (void) const;
  series_ptr &inout (void);
  series_ptr &out (void);
  series_ptr _retn (void);
  series_ptr ptr (void) const;

  // Hooks used by template sequence and object manager classes
  // for non-defined forward declared interfaces.
  static series_ptr duplicate (series_ptr);
  static void release (series_ptr);
  static series_ptr nil (void);
  static series_ptr narrow (
      CORBA::Object *,
      CORBA::Environment &
    );
  static CORBA::Object * upcast (void *);

private:
  series_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  series_var (const TAO_Base_var &rhs);
  series_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_SERIES___OUT_CH_)
#define _SERIES___OUT_CH_

class  series_out
{
public:
  series_out (series_ptr &);
  series_out (series_var &);
  series_out (const series_out &);
  series_out &operator= (const series_out &);
  series_out &operator= (const series_var &);
  series_out &operator= (series_ptr);
  operator series_ptr &();
  series_ptr &ptr (void);
  series_ptr operator-> (void);

private:
  series_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_SERIES_CH_)
#define _SERIES_CH_

// Forward Classes Declaration.
class _TAO_series_Proxy_Impl;
class _TAO_series_Remote_Proxy_Impl;
class _TAO_series_Proxy_Broker;
class _TAO_series_Remote_Proxy_Broker;

class  series
  : public virtual CORBA_Object
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef series_ptr _ptr_type;
  typedef series_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

  // The static operations.
  static series_ptr _duplicate (series_ptr obj);

  static series_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );

  static series_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );

  static series_ptr _nil (void)
    {
      return (series_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual registry * cube (
      registry * v,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual registries * sum (
      const registries & x,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void shutdown (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );

  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_series_Proxy_Broker *the_TAO_series_Proxy_Broker_;

protected:
  series (int collocated = 0);

  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void series_setup_collocation (int collocated);

  series (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_series_Remote_Proxy_Impl;
  friend class _TAO_series_ThruPOA_Proxy_Impl;
  friend class _TAO_series_Direct_Proxy_Impl;

  virtual ~series (void);

private:
  series (const series &);
  void operator= (const series &);
};

// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base Proxy Impl. Declaration
//

class  _TAO_series_Proxy_Impl
  : public virtual TAO_Object_Proxy_Impl
{
public:
  virtual ~_TAO_series_Proxy_Impl (void) { }
  virtual registry * cube (
      CORBA_Object *_collocated_tao_target_,
      registry * v,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual registries * sum (
      CORBA_Object *_collocated_tao_target_,
      const registries & x,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void shutdown (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;


protected:
  _TAO_series_Proxy_Impl (void);
};

//
//               End Base Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                Remote Proxy Impl. Declaration
//

class  _TAO_series_Remote_Proxy_Impl
  : public virtual _TAO_series_Proxy_Impl,
    public virtual TAO_Remote_Object_Proxy_Impl
{
public:
  _TAO_series_Remote_Proxy_Impl (void);

  virtual ~_TAO_series_Remote_Proxy_Impl (void) { }
  virtual registry * cube (
      CORBA_Object *_collocated_tao_target_,
      registry * v,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual registries * sum (
      CORBA_Object *_collocated_tao_target_,
      const registries & x,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void shutdown (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));


};

//
//             End Remote Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////

// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.


///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class  _TAO_series_Proxy_Broker
{
public:
  virtual ~_TAO_series_Proxy_Broker (void);
  virtual _TAO_series_Proxy_Impl &select_proxy (
      series *object,
      CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
    ) = 0;

protected:
  _TAO_series_Proxy_Broker (void);

};

//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class  _TAO_series_Remote_Proxy_Broker
  : public virtual _TAO_series_Proxy_Broker
{
public:
  _TAO_series_Remote_Proxy_Broker (void);

  virtual ~_TAO_series_Remote_Proxy_Broker (void);

  virtual _TAO_series_Proxy_Impl &select_proxy (
      series *object,
      CORBA_Environment &ACE_TRY_ENV
    );

private:
  _TAO_series_Remote_Proxy_Impl remote_proxy_impl_;

public:
  // This member function is used to get an handle to the unique instance
  // of the Remote Proxy Broker that is available for a given
  // interface.
  static _TAO_series_Remote_Proxy_Broker *the_TAO_series_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_series;

// Proxy Broker Factory function pointer declarations.

extern
_TAO_series_Proxy_Broker *
(*_TAO_series_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );


#if !defined (_REGISTRY___OBV_CH_)
#define _REGISTRY___OBV_CH_

// OBV_ class
class OBV_registry
  : public virtual registry
{
public:
  virtual void value (CORBA::Long);    // set
  virtual CORBA::Long value (void) const;     // get method


protected:
  virtual CORBA::Boolean _tao_marshal__registry (TAO_OutputCDR &);
  virtual CORBA::Boolean _tao_unmarshal__registry (TAO_InputCDR &);
  CORBA::Boolean _tao_marshal_state (TAO_OutputCDR &);
  CORBA::Boolean _tao_unmarshal_state (TAO_InputCDR &);

private:
  CORBA::Long _pd_value;

};

#endif /* end #if !defined */

 void operator<<= (CORBA::Any &, const registries &); // copying version
 void operator<<= (CORBA::Any &, registries*); // noncopying version
 CORBA::Boolean operator>>= (const CORBA::Any &, registries *&); // deprecated
 CORBA::Boolean operator>>= (const CORBA::Any &, const registries *&);
// Any operators for interface series
 void operator<<= (CORBA::Any &, series_ptr);
 CORBA::Boolean operator>>= (const CORBA::Any &, series *&);

#ifndef __ACE_INLINE__

 CORBA::Boolean operator<< (TAO_OutputCDR &, const registry *); //
 CORBA::Boolean operator>> (TAO_InputCDR &, registry *&);

#if !defined _TAO_CDR_OP_registries_H_
#define _TAO_CDR_OP_registries_H_

 CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const registries &
  );
 CORBA::Boolean operator>> (
    TAO_InputCDR &,
    registries &
  );

#endif /* _TAO_CDR_OP_registries_H_ */

 CORBA::Boolean operator<< (TAO_OutputCDR &, const series_ptr );
 CORBA::Boolean operator>> (TAO_InputCDR &, series_ptr &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "seriesC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#endif /* ifndef */
