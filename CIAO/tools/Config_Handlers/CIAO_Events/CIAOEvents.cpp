/* $Id$
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please contact the current XSC maintainer:
 *             Will Otte <wotte@dre.vanderbilt.edu>
 */

// Fix for Borland compilers, which seem to have a broken
// <string> include.
#ifdef __BORLANDC__
# include <string.h>
#endif

#include "CIAOEvents.hpp"

namespace CIAO
{
  namespace Config_Handlers
  {
    // EventServiceType
    // 

    EventServiceType::Value EventServiceType::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::CIAO::Config_Handlers::EventServiceType const& a, ::CIAO::Config_Handlers::EventServiceType const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::CIAO::Config_Handlers::EventServiceType const& a, ::CIAO::Config_Handlers::EventServiceType const& b)
    {
      return a.v_ != b.v_;
    }

    EventServiceType::
    EventServiceType (EventServiceType::Value v)
    : v_ (v)
    {
    }

    // CIAOEventsDef
    // 

    CIAOEventsDef::
    CIAOEventsDef ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    CIAOEventsDef::
    CIAOEventsDef (::CIAO::Config_Handlers::CIAOEventsDef const& s)
    :
    ::XSCRT::Type (),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      {
        for (eventServiceConfiguration_const_iterator i (s.eventServiceConfiguration_.begin ());i != s.eventServiceConfiguration_.end ();++i) add_eventServiceConfiguration (*i);
      }

      if (id_.get ()) id_->container (this);
    }

    ::CIAO::Config_Handlers::CIAOEventsDef& CIAOEventsDef::
    operator= (::CIAO::Config_Handlers::CIAOEventsDef const& s)
    {
      eventServiceConfiguration_.clear ();
      {
        for (eventServiceConfiguration_const_iterator i (s.eventServiceConfiguration_.begin ());i != s.eventServiceConfiguration_.end ();++i) add_eventServiceConfiguration (*i);
      }

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // CIAOEventsDef
    // 
    CIAOEventsDef::eventServiceConfiguration_iterator CIAOEventsDef::
    begin_eventServiceConfiguration ()
    {
      return eventServiceConfiguration_.begin ();
    }

    CIAOEventsDef::eventServiceConfiguration_iterator CIAOEventsDef::
    end_eventServiceConfiguration ()
    {
      return eventServiceConfiguration_.end ();
    }

    CIAOEventsDef::eventServiceConfiguration_const_iterator CIAOEventsDef::
    begin_eventServiceConfiguration () const
    {
      return eventServiceConfiguration_.begin ();
    }

    CIAOEventsDef::eventServiceConfiguration_const_iterator CIAOEventsDef::
    end_eventServiceConfiguration () const
    {
      return eventServiceConfiguration_.end ();
    }

    void CIAOEventsDef::
    add_eventServiceConfiguration (::CIAO::Config_Handlers::EventServiceDescription const& e)
    {
      eventServiceConfiguration_.push_back (e);
    }

    size_t CIAOEventsDef::
    count_eventServiceConfiguration(void) const
    {
      return eventServiceConfiguration_.size ();
    }

    // CIAOEventsDef
    // 
    bool CIAOEventsDef::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& CIAOEventsDef::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& CIAOEventsDef::
    id ()
    {
      return *id_;
    }

    void CIAOEventsDef::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // EventServiceDescription
    // 

    EventServiceDescription::
    EventServiceDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                             ::XMLSchema::string< ACE_TCHAR > const& node__,
                             ::CIAO::Config_Handlers::EventServiceType const& type__,
                             ::XMLSchema::string< ACE_TCHAR > const& svc_cfg_file__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    node_ (new ::XMLSchema::string< ACE_TCHAR > (node__)),
    type_ (new ::CIAO::Config_Handlers::EventServiceType (type__)),
    svc_cfg_file_ (new ::XMLSchema::string< ACE_TCHAR > (svc_cfg_file__)),
    regulator__ ()
    {
      name_->container (this);
      node_->container (this);
      type_->container (this);
      svc_cfg_file_->container (this);
    }

    EventServiceDescription::
    EventServiceDescription (::CIAO::Config_Handlers::EventServiceDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    node_ (new ::XMLSchema::string< ACE_TCHAR > (*s.node_)),
    type_ (new ::CIAO::Config_Handlers::EventServiceType (*s.type_)),
    svc_cfg_file_ (new ::XMLSchema::string< ACE_TCHAR > (*s.svc_cfg_file_)),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      name_->container (this);
      node_->container (this);
      type_->container (this);
      svc_cfg_file_->container (this);
      {
        for (filter_const_iterator i (s.filter_.begin ());i != s.filter_.end ();++i) add_filter (*i);
      }

      {
        for (addr_serv_const_iterator i (s.addr_serv_.begin ());i != s.addr_serv_.end ();++i) add_addr_serv (*i);
      }

      {
        for (udp_sender_const_iterator i (s.udp_sender_.begin ());i != s.udp_sender_.end ();++i) add_udp_sender (*i);
      }

      {
        for (udp_receiver_const_iterator i (s.udp_receiver_.begin ());i != s.udp_receiver_.end ();++i) add_udp_receiver (*i);
      }

      if (id_.get ()) id_->container (this);
    }

    ::CIAO::Config_Handlers::EventServiceDescription& EventServiceDescription::
    operator= (::CIAO::Config_Handlers::EventServiceDescription const& s)
    {
      name (s.name ());

      node (s.node ());

      type (s.type ());

      svc_cfg_file (s.svc_cfg_file ());

      filter_.clear ();
      {
        for (filter_const_iterator i (s.filter_.begin ());i != s.filter_.end ();++i) add_filter (*i);
      }

      addr_serv_.clear ();
      {
        for (addr_serv_const_iterator i (s.addr_serv_.begin ());i != s.addr_serv_.end ();++i) add_addr_serv (*i);
      }

      udp_sender_.clear ();
      {
        for (udp_sender_const_iterator i (s.udp_sender_.begin ());i != s.udp_sender_.end ();++i) add_udp_sender (*i);
      }

      udp_receiver_.clear ();
      {
        for (udp_receiver_const_iterator i (s.udp_receiver_.begin ());i != s.udp_receiver_.end ();++i) add_udp_receiver (*i);
      }

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // EventServiceDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& EventServiceDescription::
    name () const
    {
      return *name_;
    }

    void EventServiceDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // EventServiceDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& EventServiceDescription::
    node () const
    {
      return *node_;
    }

    void EventServiceDescription::
    node (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *node_ = e;
    }

    // EventServiceDescription
    // 
    ::CIAO::Config_Handlers::EventServiceType const& EventServiceDescription::
    type () const
    {
      return *type_;
    }

    void EventServiceDescription::
    type (::CIAO::Config_Handlers::EventServiceType const& e)
    {
      *type_ = e;
    }

    // EventServiceDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& EventServiceDescription::
    svc_cfg_file () const
    {
      return *svc_cfg_file_;
    }

    void EventServiceDescription::
    svc_cfg_file (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *svc_cfg_file_ = e;
    }

    // EventServiceDescription
    // 
    EventServiceDescription::filter_iterator EventServiceDescription::
    begin_filter ()
    {
      return filter_.begin ();
    }

    EventServiceDescription::filter_iterator EventServiceDescription::
    end_filter ()
    {
      return filter_.end ();
    }

    EventServiceDescription::filter_const_iterator EventServiceDescription::
    begin_filter () const
    {
      return filter_.begin ();
    }

    EventServiceDescription::filter_const_iterator EventServiceDescription::
    end_filter () const
    {
      return filter_.end ();
    }

    void EventServiceDescription::
    add_filter (::CIAO::Config_Handlers::Filter const& e)
    {
      filter_.push_back (e);
    }

    size_t EventServiceDescription::
    count_filter(void) const
    {
      return filter_.size ();
    }

    // EventServiceDescription
    // 
    EventServiceDescription::addr_serv_iterator EventServiceDescription::
    begin_addr_serv ()
    {
      return addr_serv_.begin ();
    }

    EventServiceDescription::addr_serv_iterator EventServiceDescription::
    end_addr_serv ()
    {
      return addr_serv_.end ();
    }

    EventServiceDescription::addr_serv_const_iterator EventServiceDescription::
    begin_addr_serv () const
    {
      return addr_serv_.begin ();
    }

    EventServiceDescription::addr_serv_const_iterator EventServiceDescription::
    end_addr_serv () const
    {
      return addr_serv_.end ();
    }

    void EventServiceDescription::
    add_addr_serv (::CIAO::Config_Handlers::AddressServerDescription const& e)
    {
      addr_serv_.push_back (e);
    }

    size_t EventServiceDescription::
    count_addr_serv(void) const
    {
      return addr_serv_.size ();
    }

    // EventServiceDescription
    // 
    EventServiceDescription::udp_sender_iterator EventServiceDescription::
    begin_udp_sender ()
    {
      return udp_sender_.begin ();
    }

    EventServiceDescription::udp_sender_iterator EventServiceDescription::
    end_udp_sender ()
    {
      return udp_sender_.end ();
    }

    EventServiceDescription::udp_sender_const_iterator EventServiceDescription::
    begin_udp_sender () const
    {
      return udp_sender_.begin ();
    }

    EventServiceDescription::udp_sender_const_iterator EventServiceDescription::
    end_udp_sender () const
    {
      return udp_sender_.end ();
    }

    void EventServiceDescription::
    add_udp_sender (::CIAO::Config_Handlers::UDPSenderDescription const& e)
    {
      udp_sender_.push_back (e);
    }

    size_t EventServiceDescription::
    count_udp_sender(void) const
    {
      return udp_sender_.size ();
    }

    // EventServiceDescription
    // 
    EventServiceDescription::udp_receiver_iterator EventServiceDescription::
    begin_udp_receiver ()
    {
      return udp_receiver_.begin ();
    }

    EventServiceDescription::udp_receiver_iterator EventServiceDescription::
    end_udp_receiver ()
    {
      return udp_receiver_.end ();
    }

    EventServiceDescription::udp_receiver_const_iterator EventServiceDescription::
    begin_udp_receiver () const
    {
      return udp_receiver_.begin ();
    }

    EventServiceDescription::udp_receiver_const_iterator EventServiceDescription::
    end_udp_receiver () const
    {
      return udp_receiver_.end ();
    }

    void EventServiceDescription::
    add_udp_receiver (::CIAO::Config_Handlers::UDPReceiverDescription const& e)
    {
      udp_receiver_.push_back (e);
    }

    size_t EventServiceDescription::
    count_udp_receiver(void) const
    {
      return udp_receiver_.size ();
    }

    // EventServiceDescription
    // 
    bool EventServiceDescription::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& EventServiceDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& EventServiceDescription::
    id ()
    {
      return *id_;
    }

    void EventServiceDescription::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // FilterType
    // 

    FilterType::Value FilterType::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::CIAO::Config_Handlers::FilterType const& a, ::CIAO::Config_Handlers::FilterType const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::CIAO::Config_Handlers::FilterType const& a, ::CIAO::Config_Handlers::FilterType const& b)
    {
      return a.v_ != b.v_;
    }

    FilterType::
    FilterType (FilterType::Value v)
    : v_ (v)
    {
    }

    // Filter
    // 

    Filter::
    Filter (::XMLSchema::string< ACE_TCHAR > const& name__,
            ::CIAO::Config_Handlers::FilterType const& type__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    type_ (new ::CIAO::Config_Handlers::FilterType (type__)),
    regulator__ ()
    {
      name_->container (this);
      type_->container (this);
    }

    Filter::
    Filter (::CIAO::Config_Handlers::Filter const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    type_ (new ::CIAO::Config_Handlers::FilterType (*s.type_)),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      name_->container (this);
      type_->container (this);
      {
        for (source_const_iterator i (s.source_.begin ());i != s.source_.end ();++i) add_source (*i);
      }

      if (id_.get ()) id_->container (this);
    }

    ::CIAO::Config_Handlers::Filter& Filter::
    operator= (::CIAO::Config_Handlers::Filter const& s)
    {
      name (s.name ());

      type (s.type ());

      source_.clear ();
      {
        for (source_const_iterator i (s.source_.begin ());i != s.source_.end ();++i) add_source (*i);
      }

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // Filter
    // 
    ::XMLSchema::string< ACE_TCHAR > const& Filter::
    name () const
    {
      return *name_;
    }

    void Filter::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Filter
    // 
    ::CIAO::Config_Handlers::FilterType const& Filter::
    type () const
    {
      return *type_;
    }

    void Filter::
    type (::CIAO::Config_Handlers::FilterType const& e)
    {
      *type_ = e;
    }

    // Filter
    // 
    Filter::source_iterator Filter::
    begin_source ()
    {
      return source_.begin ();
    }

    Filter::source_iterator Filter::
    end_source ()
    {
      return source_.end ();
    }

    Filter::source_const_iterator Filter::
    begin_source () const
    {
      return source_.begin ();
    }

    Filter::source_const_iterator Filter::
    end_source () const
    {
      return source_.end ();
    }

    void Filter::
    add_source (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      source_.push_back (e);
    }

    size_t Filter::
    count_source(void) const
    {
      return source_.size ();
    }

    // Filter
    // 
    bool Filter::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& Filter::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& Filter::
    id ()
    {
      return *id_;
    }

    void Filter::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // AddressServerDescription
    // 

    AddressServerDescription::
    AddressServerDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                              ::XMLSchema::unsignedShort const& port__,
                              ::XMLSchema::string< ACE_TCHAR > const& address__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    port_ (new ::XMLSchema::unsignedShort (port__)),
    address_ (new ::XMLSchema::string< ACE_TCHAR > (address__)),
    regulator__ ()
    {
      name_->container (this);
      port_->container (this);
      address_->container (this);
    }

    AddressServerDescription::
    AddressServerDescription (::CIAO::Config_Handlers::AddressServerDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    port_ (new ::XMLSchema::unsignedShort (*s.port_)),
    address_ (new ::XMLSchema::string< ACE_TCHAR > (*s.address_)),
    regulator__ ()
    {
      name_->container (this);
      port_->container (this);
      address_->container (this);
    }

    ::CIAO::Config_Handlers::AddressServerDescription& AddressServerDescription::
    operator= (::CIAO::Config_Handlers::AddressServerDescription const& s)
    {
      name (s.name ());

      port (s.port ());

      address (s.address ());

      return *this;
    }


    // AddressServerDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& AddressServerDescription::
    name () const
    {
      return *name_;
    }

    void AddressServerDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // AddressServerDescription
    // 
    ::XMLSchema::unsignedShort const& AddressServerDescription::
    port () const
    {
      return *port_;
    }

    void AddressServerDescription::
    port (::XMLSchema::unsignedShort const& e)
    {
      *port_ = e;
    }

    // AddressServerDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& AddressServerDescription::
    address () const
    {
      return *address_;
    }

    void AddressServerDescription::
    address (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *address_ = e;
    }


    // UDPSenderDescription
    // 

    UDPSenderDescription::
    UDPSenderDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                          ::XMLSchema::string< ACE_TCHAR > const& addr_serv_id__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    addr_serv_id_ (new ::XMLSchema::string< ACE_TCHAR > (addr_serv_id__)),
    regulator__ ()
    {
      name_->container (this);
      addr_serv_id_->container (this);
    }

    UDPSenderDescription::
    UDPSenderDescription (::CIAO::Config_Handlers::UDPSenderDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    addr_serv_id_ (new ::XMLSchema::string< ACE_TCHAR > (*s.addr_serv_id_)),
    regulator__ ()
    {
      name_->container (this);
      addr_serv_id_->container (this);
    }

    ::CIAO::Config_Handlers::UDPSenderDescription& UDPSenderDescription::
    operator= (::CIAO::Config_Handlers::UDPSenderDescription const& s)
    {
      name (s.name ());

      addr_serv_id (s.addr_serv_id ());

      return *this;
    }


    // UDPSenderDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& UDPSenderDescription::
    name () const
    {
      return *name_;
    }

    void UDPSenderDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // UDPSenderDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& UDPSenderDescription::
    addr_serv_id () const
    {
      return *addr_serv_id_;
    }

    void UDPSenderDescription::
    addr_serv_id (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *addr_serv_id_ = e;
    }


    // UDPReceiverDescription
    // 

    UDPReceiverDescription::
    UDPReceiverDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                            ::XMLSchema::boolean const& is_multicast__,
                            ::XMLSchema::unsignedShort const& listen_port__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    is_multicast_ (new ::XMLSchema::boolean (is_multicast__)),
    listen_port_ (new ::XMLSchema::unsignedShort (listen_port__)),
    regulator__ ()
    {
      name_->container (this);
      is_multicast_->container (this);
      listen_port_->container (this);
    }

    UDPReceiverDescription::
    UDPReceiverDescription (::CIAO::Config_Handlers::UDPReceiverDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    addr_serv_id_ (s.addr_serv_id_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.addr_serv_id_) : 0),
    is_multicast_ (new ::XMLSchema::boolean (*s.is_multicast_)),
    listen_port_ (new ::XMLSchema::unsignedShort (*s.listen_port_)),
    regulator__ ()
    {
      name_->container (this);
      if (addr_serv_id_.get ()) addr_serv_id_->container (this);
      is_multicast_->container (this);
      listen_port_->container (this);
    }

    ::CIAO::Config_Handlers::UDPReceiverDescription& UDPReceiverDescription::
    operator= (::CIAO::Config_Handlers::UDPReceiverDescription const& s)
    {
      name (s.name ());

      if (s.addr_serv_id_.get ()) addr_serv_id (*(s.addr_serv_id_));
      else addr_serv_id_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      is_multicast (s.is_multicast ());

      listen_port (s.listen_port ());

      return *this;
    }


    // UDPReceiverDescription
    // 
    ::XMLSchema::string< ACE_TCHAR > const& UDPReceiverDescription::
    name () const
    {
      return *name_;
    }

    void UDPReceiverDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // UDPReceiverDescription
    // 
    bool UDPReceiverDescription::
    addr_serv_id_p () const
    {
      return addr_serv_id_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& UDPReceiverDescription::
    addr_serv_id () const
    {
      return *addr_serv_id_;
    }

    void UDPReceiverDescription::
    addr_serv_id (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (addr_serv_id_.get ())
      {
        *addr_serv_id_ = e;
      }

      else
      {
        addr_serv_id_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        addr_serv_id_->container (this);
      }
    }

    // UDPReceiverDescription
    // 
    ::XMLSchema::boolean const& UDPReceiverDescription::
    is_multicast () const
    {
      return *is_multicast_;
    }

    void UDPReceiverDescription::
    is_multicast (::XMLSchema::boolean const& e)
    {
      *is_multicast_ = e;
    }

    // UDPReceiverDescription
    // 
    ::XMLSchema::unsignedShort const& UDPReceiverDescription::
    listen_port () const
    {
      return *listen_port_;
    }

    void UDPReceiverDescription::
    listen_port (::XMLSchema::unsignedShort const& e)
    {
      *listen_port_ = e;
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    // EventServiceType
    //

    EventServiceType::
    EventServiceType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == "EC") v_ = EC_l;
      else if (v == "RTEC") v_ = RTEC_l;
      else if (v == "NOTIFY") v_ = NOTIFY_l;
      else if (v == "RTNOTIFY") v_ = RTNOTIFY_l;
      else 
      {
      }
    }

    EventServiceType::
    EventServiceType (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == "EC") v_ = EC_l;
      else if (v == "RTEC") v_ = RTEC_l;
      else if (v == "NOTIFY") v_ = NOTIFY_l;
      else if (v == "RTNOTIFY") v_ = RTNOTIFY_l;
      else 
      {
      }
    }

    EventServiceType const EventServiceType::EC (EventServiceType::EC_l);
    EventServiceType const EventServiceType::RTEC (EventServiceType::RTEC_l);
    EventServiceType const EventServiceType::NOTIFY (EventServiceType::NOTIFY_l);
    EventServiceType const EventServiceType::RTNOTIFY (EventServiceType::RTNOTIFY_l);

    // CIAOEventsDef
    //

    CIAOEventsDef::
    CIAOEventsDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "eventServiceConfiguration")
        {
          ::CIAO::Config_Handlers::EventServiceDescription t (e);
          add_eventServiceConfiguration (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "id")
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
        }

        else 
        {
        }
      }
    }

    // EventServiceDescription
    //

    EventServiceDescription::
    EventServiceDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "node")
        {
          node_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          node_->container (this);
        }

        else if (n == "type")
        {
          type_ = ::std::auto_ptr< ::CIAO::Config_Handlers::EventServiceType > (new ::CIAO::Config_Handlers::EventServiceType (e));
          type_->container (this);
        }

        else if (n == "svc_cfg_file")
        {
          svc_cfg_file_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          svc_cfg_file_->container (this);
        }

        else if (n == "filter")
        {
          ::CIAO::Config_Handlers::Filter t (e);
          add_filter (t);
        }

        else if (n == "addr_serv")
        {
          ::CIAO::Config_Handlers::AddressServerDescription t (e);
          add_addr_serv (t);
        }

        else if (n == "udp_sender")
        {
          ::CIAO::Config_Handlers::UDPSenderDescription t (e);
          add_udp_sender (t);
        }

        else if (n == "udp_receiver")
        {
          ::CIAO::Config_Handlers::UDPReceiverDescription t (e);
          add_udp_receiver (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "id")
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
        }

        else 
        {
        }
      }
    }

    // FilterType
    //

    FilterType::
    FilterType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == "CONJUNCTION") v_ = CONJUNCTION_l;
      else if (v == "DISJUNCTION") v_ = DISJUNCTION_l;
      else if (v == "LOGICAL_AND") v_ = LOGICAL_AND_l;
      else if (v == "NEGATE") v_ = NEGATE_l;
      else 
      {
      }
    }

    FilterType::
    FilterType (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == "CONJUNCTION") v_ = CONJUNCTION_l;
      else if (v == "DISJUNCTION") v_ = DISJUNCTION_l;
      else if (v == "LOGICAL_AND") v_ = LOGICAL_AND_l;
      else if (v == "NEGATE") v_ = NEGATE_l;
      else 
      {
      }
    }

    FilterType const FilterType::CONJUNCTION (FilterType::CONJUNCTION_l);
    FilterType const FilterType::DISJUNCTION (FilterType::DISJUNCTION_l);
    FilterType const FilterType::LOGICAL_AND (FilterType::LOGICAL_AND_l);
    FilterType const FilterType::NEGATE (FilterType::NEGATE_l);

    // Filter
    //

    Filter::
    Filter (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "type")
        {
          type_ = ::std::auto_ptr< ::CIAO::Config_Handlers::FilterType > (new ::CIAO::Config_Handlers::FilterType (e));
          type_->container (this);
        }

        else if (n == "source")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          add_source (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "id")
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
        }

        else 
        {
        }
      }
    }

    // AddressServerDescription
    //

    AddressServerDescription::
    AddressServerDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "port")
        {
          port_ = ::std::auto_ptr< ::XMLSchema::unsignedShort > (new ::XMLSchema::unsignedShort (e));
          port_->container (this);
        }

        else if (n == "address")
        {
          address_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          address_->container (this);
        }

        else 
        {
        }
      }
    }

    // UDPSenderDescription
    //

    UDPSenderDescription::
    UDPSenderDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "addr_serv_id")
        {
          addr_serv_id_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          addr_serv_id_->container (this);
        }

        else 
        {
        }
      }
    }

    // UDPReceiverDescription
    //

    UDPReceiverDescription::
    UDPReceiverDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "addr_serv_id")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          addr_serv_id (t);
        }

        else if (n == "is_multicast")
        {
          is_multicast_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
          is_multicast_->container (this);
        }

        else if (n == "listen_port")
        {
          listen_port_ = ::std::auto_ptr< ::XMLSchema::unsignedShort > (new ::XMLSchema::unsignedShort (e));
          listen_port_->container (this);
        }

        else 
        {
        }
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    ::CIAO::Config_Handlers::CIAOEventsDef
    CIAOEvents (xercesc::DOMDocument const* d)
    {
      ::XSCRT::XML::Element< ACE_TCHAR > e (d->getDocumentElement ());
      if (e.name () == "CIAOEvents")
      {
        ::CIAO::Config_Handlers::CIAOEventsDef r (e);
        return r;
      }

      else
      {
        throw 1;
      }
    }
  }
}

#include "XMLSchema/TypeInfo.hpp"

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace
    {
      ::XMLSchema::TypeInfoInitializer < ACE_TCHAR > XMLSchemaTypeInfoInitializer_ (::XSCRT::extended_type_info_map ());

      struct EventServiceTypeTypeInfoInitializer
      {
        EventServiceTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (EventServiceType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      EventServiceTypeTypeInfoInitializer EventServiceTypeTypeInfoInitializer_;

      struct CIAOEventsDefTypeInfoInitializer
      {
        CIAOEventsDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (CIAOEventsDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      CIAOEventsDefTypeInfoInitializer CIAOEventsDefTypeInfoInitializer_;

      struct EventServiceDescriptionTypeInfoInitializer
      {
        EventServiceDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (EventServiceDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      EventServiceDescriptionTypeInfoInitializer EventServiceDescriptionTypeInfoInitializer_;

      struct FilterTypeTypeInfoInitializer
      {
        FilterTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (FilterType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      FilterTypeTypeInfoInitializer FilterTypeTypeInfoInitializer_;

      struct FilterTypeInfoInitializer
      {
        FilterTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (Filter));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      FilterTypeInfoInitializer FilterTypeInfoInitializer_;

      struct AddressServerDescriptionTypeInfoInitializer
      {
        AddressServerDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (AddressServerDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      AddressServerDescriptionTypeInfoInitializer AddressServerDescriptionTypeInfoInitializer_;

      struct UDPSenderDescriptionTypeInfoInitializer
      {
        UDPSenderDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (UDPSenderDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      UDPSenderDescriptionTypeInfoInitializer UDPSenderDescriptionTypeInfoInitializer_;

      struct UDPReceiverDescriptionTypeInfoInitializer
      {
        UDPReceiverDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (UDPReceiverDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      UDPReceiverDescriptionTypeInfoInitializer UDPReceiverDescriptionTypeInfoInitializer_;
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace Traversal
    {
      // CIAOEventsDef
      //
      //

      void CIAOEventsDef::
      traverse (Type& o)
      {
        pre (o);
        eventServiceConfiguration (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void CIAOEventsDef::
      traverse (Type const& o)
      {
        pre (o);
        eventServiceConfiguration (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void CIAOEventsDef::
      pre (Type&)
      {
      }

      void CIAOEventsDef::
      pre (Type const&)
      {
      }

      void CIAOEventsDef::
      eventServiceConfiguration (Type& o)
      {
        // VC6 anathema strikes again
        //
        CIAOEventsDef::Type::eventServiceConfiguration_iterator b (o.begin_eventServiceConfiguration()), e (o.end_eventServiceConfiguration());

        if (b != e)
        {
          eventServiceConfiguration_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) eventServiceConfiguration_next (o);
          }

          eventServiceConfiguration_post (o);
        }
      }

      void CIAOEventsDef::
      eventServiceConfiguration (Type const& o)
      {
        // VC6 anathema strikes again
        //
        CIAOEventsDef::Type::eventServiceConfiguration_const_iterator b (o.begin_eventServiceConfiguration()), e (o.end_eventServiceConfiguration());

        if (b != e)
        {
          eventServiceConfiguration_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) eventServiceConfiguration_next (o);
          }

          eventServiceConfiguration_post (o);
        }
      }

      void CIAOEventsDef::
      eventServiceConfiguration_pre (Type&)
      {
      }

      void CIAOEventsDef::
      eventServiceConfiguration_pre (Type const&)
      {
      }

      void CIAOEventsDef::
      eventServiceConfiguration_next (Type&)
      {
      }

      void CIAOEventsDef::
      eventServiceConfiguration_next (Type const&)
      {
      }

      void CIAOEventsDef::
      eventServiceConfiguration_post (Type&)
      {
      }

      void CIAOEventsDef::
      eventServiceConfiguration_post (Type const&)
      {
      }

      void CIAOEventsDef::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void CIAOEventsDef::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void CIAOEventsDef::
      id_none (Type&)
      {
      }

      void CIAOEventsDef::
      id_none (Type const&)
      {
      }

      void CIAOEventsDef::
      post (Type&)
      {
      }

      void CIAOEventsDef::
      post (Type const&)
      {
      }

      // EventServiceDescription
      //
      //

      void EventServiceDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        node (o);
        type (o);
        svc_cfg_file (o);
        filter (o);
        addr_serv (o);
        udp_sender (o);
        udp_receiver (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void EventServiceDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        node (o);
        type (o);
        svc_cfg_file (o);
        filter (o);
        addr_serv (o);
        udp_sender (o);
        udp_receiver (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void EventServiceDescription::
      pre (Type&)
      {
      }

      void EventServiceDescription::
      pre (Type const&)
      {
      }

      void EventServiceDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void EventServiceDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void EventServiceDescription::
      node (Type& o)
      {
        dispatch (o.node ());
      }

      void EventServiceDescription::
      node (Type const& o)
      {
        dispatch (o.node ());
      }

      void EventServiceDescription::
      type (Type& o)
      {
        dispatch (o.type ());
      }

      void EventServiceDescription::
      type (Type const& o)
      {
        dispatch (o.type ());
      }

      void EventServiceDescription::
      svc_cfg_file (Type& o)
      {
        dispatch (o.svc_cfg_file ());
      }

      void EventServiceDescription::
      svc_cfg_file (Type const& o)
      {
        dispatch (o.svc_cfg_file ());
      }

      void EventServiceDescription::
      filter (Type& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::filter_iterator b (o.begin_filter()), e (o.end_filter());

        if (b != e)
        {
          filter_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) filter_next (o);
          }

          filter_post (o);
        }

        else filter_none (o);
      }

      void EventServiceDescription::
      filter (Type const& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::filter_const_iterator b (o.begin_filter()), e (o.end_filter());

        if (b != e)
        {
          filter_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) filter_next (o);
          }

          filter_post (o);
        }

        else filter_none (o);
      }

      void EventServiceDescription::
      filter_pre (Type&)
      {
      }

      void EventServiceDescription::
      filter_pre (Type const&)
      {
      }

      void EventServiceDescription::
      filter_next (Type&)
      {
      }

      void EventServiceDescription::
      filter_next (Type const&)
      {
      }

      void EventServiceDescription::
      filter_post (Type&)
      {
      }

      void EventServiceDescription::
      filter_post (Type const&)
      {
      }

      void EventServiceDescription::
      filter_none (Type&)
      {
      }

      void EventServiceDescription::
      filter_none (Type const&)
      {
      }

      void EventServiceDescription::
      addr_serv (Type& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::addr_serv_iterator b (o.begin_addr_serv()), e (o.end_addr_serv());

        if (b != e)
        {
          addr_serv_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) addr_serv_next (o);
          }

          addr_serv_post (o);
        }

        else addr_serv_none (o);
      }

      void EventServiceDescription::
      addr_serv (Type const& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::addr_serv_const_iterator b (o.begin_addr_serv()), e (o.end_addr_serv());

        if (b != e)
        {
          addr_serv_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) addr_serv_next (o);
          }

          addr_serv_post (o);
        }

        else addr_serv_none (o);
      }

      void EventServiceDescription::
      addr_serv_pre (Type&)
      {
      }

      void EventServiceDescription::
      addr_serv_pre (Type const&)
      {
      }

      void EventServiceDescription::
      addr_serv_next (Type&)
      {
      }

      void EventServiceDescription::
      addr_serv_next (Type const&)
      {
      }

      void EventServiceDescription::
      addr_serv_post (Type&)
      {
      }

      void EventServiceDescription::
      addr_serv_post (Type const&)
      {
      }

      void EventServiceDescription::
      addr_serv_none (Type&)
      {
      }

      void EventServiceDescription::
      addr_serv_none (Type const&)
      {
      }

      void EventServiceDescription::
      udp_sender (Type& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::udp_sender_iterator b (o.begin_udp_sender()), e (o.end_udp_sender());

        if (b != e)
        {
          udp_sender_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) udp_sender_next (o);
          }

          udp_sender_post (o);
        }

        else udp_sender_none (o);
      }

      void EventServiceDescription::
      udp_sender (Type const& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::udp_sender_const_iterator b (o.begin_udp_sender()), e (o.end_udp_sender());

        if (b != e)
        {
          udp_sender_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) udp_sender_next (o);
          }

          udp_sender_post (o);
        }

        else udp_sender_none (o);
      }

      void EventServiceDescription::
      udp_sender_pre (Type&)
      {
      }

      void EventServiceDescription::
      udp_sender_pre (Type const&)
      {
      }

      void EventServiceDescription::
      udp_sender_next (Type&)
      {
      }

      void EventServiceDescription::
      udp_sender_next (Type const&)
      {
      }

      void EventServiceDescription::
      udp_sender_post (Type&)
      {
      }

      void EventServiceDescription::
      udp_sender_post (Type const&)
      {
      }

      void EventServiceDescription::
      udp_sender_none (Type&)
      {
      }

      void EventServiceDescription::
      udp_sender_none (Type const&)
      {
      }

      void EventServiceDescription::
      udp_receiver (Type& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::udp_receiver_iterator b (o.begin_udp_receiver()), e (o.end_udp_receiver());

        if (b != e)
        {
          udp_receiver_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) udp_receiver_next (o);
          }

          udp_receiver_post (o);
        }

        else udp_receiver_none (o);
      }

      void EventServiceDescription::
      udp_receiver (Type const& o)
      {
        // VC6 anathema strikes again
        //
        EventServiceDescription::Type::udp_receiver_const_iterator b (o.begin_udp_receiver()), e (o.end_udp_receiver());

        if (b != e)
        {
          udp_receiver_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) udp_receiver_next (o);
          }

          udp_receiver_post (o);
        }

        else udp_receiver_none (o);
      }

      void EventServiceDescription::
      udp_receiver_pre (Type&)
      {
      }

      void EventServiceDescription::
      udp_receiver_pre (Type const&)
      {
      }

      void EventServiceDescription::
      udp_receiver_next (Type&)
      {
      }

      void EventServiceDescription::
      udp_receiver_next (Type const&)
      {
      }

      void EventServiceDescription::
      udp_receiver_post (Type&)
      {
      }

      void EventServiceDescription::
      udp_receiver_post (Type const&)
      {
      }

      void EventServiceDescription::
      udp_receiver_none (Type&)
      {
      }

      void EventServiceDescription::
      udp_receiver_none (Type const&)
      {
      }

      void EventServiceDescription::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void EventServiceDescription::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void EventServiceDescription::
      id_none (Type&)
      {
      }

      void EventServiceDescription::
      id_none (Type const&)
      {
      }

      void EventServiceDescription::
      post (Type&)
      {
      }

      void EventServiceDescription::
      post (Type const&)
      {
      }

      // Filter
      //
      //

      void Filter::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        type (o);
        source (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void Filter::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        type (o);
        source (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void Filter::
      pre (Type&)
      {
      }

      void Filter::
      pre (Type const&)
      {
      }

      void Filter::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Filter::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Filter::
      type (Type& o)
      {
        dispatch (o.type ());
      }

      void Filter::
      type (Type const& o)
      {
        dispatch (o.type ());
      }

      void Filter::
      source (Type& o)
      {
        // VC6 anathema strikes again
        //
        Filter::Type::source_iterator b (o.begin_source()), e (o.end_source());

        if (b != e)
        {
          source_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) source_next (o);
          }

          source_post (o);
        }
      }

      void Filter::
      source (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Filter::Type::source_const_iterator b (o.begin_source()), e (o.end_source());

        if (b != e)
        {
          source_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) source_next (o);
          }

          source_post (o);
        }
      }

      void Filter::
      source_pre (Type&)
      {
      }

      void Filter::
      source_pre (Type const&)
      {
      }

      void Filter::
      source_next (Type&)
      {
      }

      void Filter::
      source_next (Type const&)
      {
      }

      void Filter::
      source_post (Type&)
      {
      }

      void Filter::
      source_post (Type const&)
      {
      }

      void Filter::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void Filter::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void Filter::
      id_none (Type&)
      {
      }

      void Filter::
      id_none (Type const&)
      {
      }

      void Filter::
      post (Type&)
      {
      }

      void Filter::
      post (Type const&)
      {
      }

      // AddressServerDescription
      //
      //

      void AddressServerDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        port (o);
        address (o);
        post (o);
      }

      void AddressServerDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        port (o);
        address (o);
        post (o);
      }

      void AddressServerDescription::
      pre (Type&)
      {
      }

      void AddressServerDescription::
      pre (Type const&)
      {
      }

      void AddressServerDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void AddressServerDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void AddressServerDescription::
      port (Type& o)
      {
        dispatch (o.port ());
      }

      void AddressServerDescription::
      port (Type const& o)
      {
        dispatch (o.port ());
      }

      void AddressServerDescription::
      address (Type& o)
      {
        dispatch (o.address ());
      }

      void AddressServerDescription::
      address (Type const& o)
      {
        dispatch (o.address ());
      }

      void AddressServerDescription::
      post (Type&)
      {
      }

      void AddressServerDescription::
      post (Type const&)
      {
      }

      // UDPSenderDescription
      //
      //

      void UDPSenderDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        addr_serv_id (o);
        post (o);
      }

      void UDPSenderDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        addr_serv_id (o);
        post (o);
      }

      void UDPSenderDescription::
      pre (Type&)
      {
      }

      void UDPSenderDescription::
      pre (Type const&)
      {
      }

      void UDPSenderDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void UDPSenderDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void UDPSenderDescription::
      addr_serv_id (Type& o)
      {
        dispatch (o.addr_serv_id ());
      }

      void UDPSenderDescription::
      addr_serv_id (Type const& o)
      {
        dispatch (o.addr_serv_id ());
      }

      void UDPSenderDescription::
      post (Type&)
      {
      }

      void UDPSenderDescription::
      post (Type const&)
      {
      }

      // UDPReceiverDescription
      //
      //

      void UDPReceiverDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.addr_serv_id_p ()) addr_serv_id (o);
        else addr_serv_id_none (o);
        is_multicast (o);
        listen_port (o);
        post (o);
      }

      void UDPReceiverDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.addr_serv_id_p ()) addr_serv_id (o);
        else addr_serv_id_none (o);
        is_multicast (o);
        listen_port (o);
        post (o);
      }

      void UDPReceiverDescription::
      pre (Type&)
      {
      }

      void UDPReceiverDescription::
      pre (Type const&)
      {
      }

      void UDPReceiverDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void UDPReceiverDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void UDPReceiverDescription::
      addr_serv_id (Type& o)
      {
        dispatch (o.addr_serv_id ());
      }

      void UDPReceiverDescription::
      addr_serv_id (Type const& o)
      {
        dispatch (o.addr_serv_id ());
      }

      void UDPReceiverDescription::
      addr_serv_id_none (Type&)
      {
      }

      void UDPReceiverDescription::
      addr_serv_id_none (Type const&)
      {
      }

      void UDPReceiverDescription::
      is_multicast (Type& o)
      {
        dispatch (o.is_multicast ());
      }

      void UDPReceiverDescription::
      is_multicast (Type const& o)
      {
        dispatch (o.is_multicast ());
      }

      void UDPReceiverDescription::
      listen_port (Type& o)
      {
        dispatch (o.listen_port ());
      }

      void UDPReceiverDescription::
      listen_port (Type const& o)
      {
        dispatch (o.listen_port ());
      }

      void UDPReceiverDescription::
      post (Type&)
      {
      }

      void UDPReceiverDescription::
      post (Type const&)
      {
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace Writer
    {
      // EventServiceType
      //
      //

      EventServiceType::
      EventServiceType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      EventServiceType::
      EventServiceType ()
      {
      }

      void EventServiceType::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::CIAO::Config_Handlers::EventServiceType::EC) s = "EC";
        else if (o == ::CIAO::Config_Handlers::EventServiceType::RTEC) s = "RTEC";
        else if (o == ::CIAO::Config_Handlers::EventServiceType::NOTIFY) s = "NOTIFY";
        else if (o == ::CIAO::Config_Handlers::EventServiceType::RTNOTIFY) s = "RTNOTIFY";
        else 
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // CIAOEventsDef
      //
      //

      CIAOEventsDef::
      CIAOEventsDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      CIAOEventsDef::
      CIAOEventsDef ()
      {
      }

      void CIAOEventsDef::
      traverse (Type const& o)
      {
        Traversal::CIAOEventsDef::traverse (o);
      }

      void CIAOEventsDef::
      eventServiceConfiguration_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("eventServiceConfiguration", top_ ()));
      }

      void CIAOEventsDef::
      eventServiceConfiguration_next (Type const& o)
      {
        eventServiceConfiguration_post (o);
        eventServiceConfiguration_pre (o);
      }

      void CIAOEventsDef::
      eventServiceConfiguration_post (Type const&)
      {
        pop_ ();
      }

      void CIAOEventsDef::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("id", "", top_ ());
        attr_ (&a);
        Traversal::CIAOEventsDef::id (o);
        attr_ (0);
      }

      // EventServiceDescription
      //
      //

      EventServiceDescription::
      EventServiceDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      EventServiceDescription::
      EventServiceDescription ()
      {
      }

      void EventServiceDescription::
      traverse (Type const& o)
      {
        Traversal::EventServiceDescription::traverse (o);
      }

      void EventServiceDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::EventServiceDescription::name (o);
        pop_ ();
      }

      void EventServiceDescription::
      node (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("node", top_ ()));
        Traversal::EventServiceDescription::node (o);
        pop_ ();
      }

      void EventServiceDescription::
      type (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("type", top_ ()));
        Traversal::EventServiceDescription::type (o);
        pop_ ();
      }

      void EventServiceDescription::
      svc_cfg_file (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("svc_cfg_file", top_ ()));
        Traversal::EventServiceDescription::svc_cfg_file (o);
        pop_ ();
      }

      void EventServiceDescription::
      filter_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("filter", top_ ()));
      }

      void EventServiceDescription::
      filter_next (Type const& o)
      {
        filter_post (o);
        filter_pre (o);
      }

      void EventServiceDescription::
      filter_post (Type const&)
      {
        pop_ ();
      }

      void EventServiceDescription::
      addr_serv_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("addr_serv", top_ ()));
      }

      void EventServiceDescription::
      addr_serv_next (Type const& o)
      {
        addr_serv_post (o);
        addr_serv_pre (o);
      }

      void EventServiceDescription::
      addr_serv_post (Type const&)
      {
        pop_ ();
      }

      void EventServiceDescription::
      udp_sender_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("udp_sender", top_ ()));
      }

      void EventServiceDescription::
      udp_sender_next (Type const& o)
      {
        udp_sender_post (o);
        udp_sender_pre (o);
      }

      void EventServiceDescription::
      udp_sender_post (Type const&)
      {
        pop_ ();
      }

      void EventServiceDescription::
      udp_receiver_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("udp_receiver", top_ ()));
      }

      void EventServiceDescription::
      udp_receiver_next (Type const& o)
      {
        udp_receiver_post (o);
        udp_receiver_pre (o);
      }

      void EventServiceDescription::
      udp_receiver_post (Type const&)
      {
        pop_ ();
      }

      void EventServiceDescription::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("id", "", top_ ());
        attr_ (&a);
        Traversal::EventServiceDescription::id (o);
        attr_ (0);
      }

      // FilterType
      //
      //

      FilterType::
      FilterType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      FilterType::
      FilterType ()
      {
      }

      void FilterType::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::CIAO::Config_Handlers::FilterType::CONJUNCTION) s = "CONJUNCTION";
        else if (o == ::CIAO::Config_Handlers::FilterType::DISJUNCTION) s = "DISJUNCTION";
        else if (o == ::CIAO::Config_Handlers::FilterType::LOGICAL_AND) s = "LOGICAL_AND";
        else if (o == ::CIAO::Config_Handlers::FilterType::NEGATE) s = "NEGATE";
        else 
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // Filter
      //
      //

      Filter::
      Filter (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Filter::
      Filter ()
      {
      }

      void Filter::
      traverse (Type const& o)
      {
        Traversal::Filter::traverse (o);
      }

      void Filter::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::Filter::name (o);
        pop_ ();
      }

      void Filter::
      type (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("type", top_ ()));
        Traversal::Filter::type (o);
        pop_ ();
      }

      void Filter::
      source_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("source", top_ ()));
      }

      void Filter::
      source_next (Type const& o)
      {
        source_post (o);
        source_pre (o);
      }

      void Filter::
      source_post (Type const&)
      {
        pop_ ();
      }

      void Filter::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("id", "", top_ ());
        attr_ (&a);
        Traversal::Filter::id (o);
        attr_ (0);
      }

      // AddressServerDescription
      //
      //

      AddressServerDescription::
      AddressServerDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      AddressServerDescription::
      AddressServerDescription ()
      {
      }

      void AddressServerDescription::
      traverse (Type const& o)
      {
        Traversal::AddressServerDescription::traverse (o);
      }

      void AddressServerDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::AddressServerDescription::name (o);
        pop_ ();
      }

      void AddressServerDescription::
      port (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("port", top_ ()));
        Traversal::AddressServerDescription::port (o);
        pop_ ();
      }

      void AddressServerDescription::
      address (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("address", top_ ()));
        Traversal::AddressServerDescription::address (o);
        pop_ ();
      }

      // UDPSenderDescription
      //
      //

      UDPSenderDescription::
      UDPSenderDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      UDPSenderDescription::
      UDPSenderDescription ()
      {
      }

      void UDPSenderDescription::
      traverse (Type const& o)
      {
        Traversal::UDPSenderDescription::traverse (o);
      }

      void UDPSenderDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::UDPSenderDescription::name (o);
        pop_ ();
      }

      void UDPSenderDescription::
      addr_serv_id (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("addr_serv_id", top_ ()));
        Traversal::UDPSenderDescription::addr_serv_id (o);
        pop_ ();
      }

      // UDPReceiverDescription
      //
      //

      UDPReceiverDescription::
      UDPReceiverDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      UDPReceiverDescription::
      UDPReceiverDescription ()
      {
      }

      void UDPReceiverDescription::
      traverse (Type const& o)
      {
        Traversal::UDPReceiverDescription::traverse (o);
      }

      void UDPReceiverDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::UDPReceiverDescription::name (o);
        pop_ ();
      }

      void UDPReceiverDescription::
      addr_serv_id (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("addr_serv_id", top_ ()));
        Traversal::UDPReceiverDescription::addr_serv_id (o);
        pop_ ();
      }

      void UDPReceiverDescription::
      is_multicast (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("is_multicast", top_ ()));
        Traversal::UDPReceiverDescription::is_multicast (o);
        pop_ ();
      }

      void UDPReceiverDescription::
      listen_port (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("listen_port", top_ ()));
        Traversal::UDPReceiverDescription::listen_port (o);
        pop_ ();
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    void
    CIAOEvents (::CIAO::Config_Handlers::CIAOEventsDef const& s, xercesc::DOMDocument* d)
    {
      ::XSCRT::XML::Element< ACE_TCHAR > e (d->getDocumentElement ());
      if (e.name () != "CIAOEvents")
      {
        throw 1;
      }

      struct W : virtual ::CIAO::Config_Handlers::Writer::CIAOEventsDef,
      virtual ::CIAO::Config_Handlers::Writer::EventServiceDescription,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::string< ACE_TCHAR >, ACE_TCHAR >,
      virtual ::CIAO::Config_Handlers::Writer::EventServiceType,
      virtual ::CIAO::Config_Handlers::Writer::Filter,
      virtual ::CIAO::Config_Handlers::Writer::FilterType,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::ID< ACE_TCHAR >, ACE_TCHAR >,
      virtual ::CIAO::Config_Handlers::Writer::AddressServerDescription,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::unsignedShort, ACE_TCHAR >,
      virtual ::CIAO::Config_Handlers::Writer::UDPSenderDescription,
      virtual ::CIAO::Config_Handlers::Writer::UDPReceiverDescription,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::boolean, ACE_TCHAR >,
      virtual ::XSCRT::Writer< ACE_TCHAR >
      {
        W (::XSCRT::XML::Element< ACE_TCHAR >& e)
        : ::XSCRT::Writer< ACE_TCHAR > (e)
        {
        }
      };

      W w (e);
      w.dispatch (s);
    }
  }
}

