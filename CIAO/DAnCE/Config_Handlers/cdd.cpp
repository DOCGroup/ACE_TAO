/* $Id$
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please contact the current XSC maintainer:
 *             Will Otte <wotte@dre.vanderbilt.edu>
 */

// Fix for Borland compilers, which seem to have a broken
// <string> include.
#ifdef __BORLANDC__
# include <string.h>
#endif

#include "cdd.hpp"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // Domain
    // 

    Domain::
    Domain (::std::list< ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Node, ACE_Null_Mutex > > const& node__)
    : 
    ::XSCRT::Type (), 
    node_ (node__),
    regulator__ ()
    {
    }

    Domain::
    Domain (Domain const& s)
    :
    ::XSCRT::Type (),
    UUID_ (s.UUID_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.UUID_) : 0),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    node_ (s.node_),
    interconnect_ (s.interconnect_),
    bridge_ (s.bridge_),
    sharedResource_ (s.sharedResource_),
    infoProperty_ (s.infoProperty_),
    regulator__ ()
    {
      if (UUID_.get ()) UUID_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Domain& Domain::
    operator= (Domain const& s)
    {
      if (s.UUID_.get ())
        UUID (*(s.UUID_));
      else
        UUID_.reset (0);

      if (s.label_.get ())
        label (*(s.label_));
      else
        label_.reset (0);

      node_ = s.node_;

      interconnect_ = s.interconnect_;

      bridge_ = s.bridge_;

      sharedResource_ = s.sharedResource_;

      infoProperty_ = s.infoProperty_;

      return *this;
    }


    // Domain
    // 
    bool Domain::
    UUID_p () const
    {
      return UUID_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Domain::
    UUID () const
    {
      return *UUID_;
    }

    void Domain::
    UUID (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (UUID_.get ())
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        UUID_->container (this);
      }
    }

    // Domain
    // 
    bool Domain::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Domain::
    label () const
    {
      return *label_;
    }

    void Domain::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Domain
    // 
    Domain::node_iterator Domain::
    begin_node ()
    {
      return node_.begin ();
    }

    Domain::node_iterator Domain::
    end_node ()
    {
      return node_.end ();
    }

    Domain::node_const_iterator Domain::
    begin_node () const
    {
      return node_.begin ();
    }

    Domain::node_const_iterator Domain::
    end_node () const
    {
      return node_.end ();
    }

    void Domain::
    add_node (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Node, ACE_Null_Mutex >  const& e)
    {
      node_.push_back (e);
    }

    size_t Domain::
    count_node(void) const
    {
      return node_.size ();
    }

    // Domain
    // 
    Domain::interconnect_iterator Domain::
    begin_interconnect ()
    {
      return interconnect_.begin ();
    }

    Domain::interconnect_iterator Domain::
    end_interconnect ()
    {
      return interconnect_.end ();
    }

    Domain::interconnect_const_iterator Domain::
    begin_interconnect () const
    {
      return interconnect_.begin ();
    }

    Domain::interconnect_const_iterator Domain::
    end_interconnect () const
    {
      return interconnect_.end ();
    }

    void Domain::
    add_interconnect (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Interconnect, ACE_Null_Mutex >  const& e)
    {
      interconnect_.push_back (e);
    }

    size_t Domain::
    count_interconnect(void) const
    {
      return interconnect_.size ();
    }

    // Domain
    // 
    Domain::bridge_iterator Domain::
    begin_bridge ()
    {
      return bridge_.begin ();
    }

    Domain::bridge_iterator Domain::
    end_bridge ()
    {
      return bridge_.end ();
    }

    Domain::bridge_const_iterator Domain::
    begin_bridge () const
    {
      return bridge_.begin ();
    }

    Domain::bridge_const_iterator Domain::
    end_bridge () const
    {
      return bridge_.end ();
    }

    void Domain::
    add_bridge (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Bridge, ACE_Null_Mutex >  const& e)
    {
      bridge_.push_back (e);
    }

    size_t Domain::
    count_bridge(void) const
    {
      return bridge_.size ();
    }

    // Domain
    // 
    Domain::sharedResource_iterator Domain::
    begin_sharedResource ()
    {
      return sharedResource_.begin ();
    }

    Domain::sharedResource_iterator Domain::
    end_sharedResource ()
    {
      return sharedResource_.end ();
    }

    Domain::sharedResource_const_iterator Domain::
    begin_sharedResource () const
    {
      return sharedResource_.begin ();
    }

    Domain::sharedResource_const_iterator Domain::
    end_sharedResource () const
    {
      return sharedResource_.end ();
    }

    void Domain::
    add_sharedResource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SharedResource, ACE_Null_Mutex >  const& e)
    {
      sharedResource_.push_back (e);
    }

    size_t Domain::
    count_sharedResource(void) const
    {
      return sharedResource_.size ();
    }

    // Domain
    // 
    Domain::infoProperty_iterator Domain::
    begin_infoProperty ()
    {
      return infoProperty_.begin ();
    }

    Domain::infoProperty_iterator Domain::
    end_infoProperty ()
    {
      return infoProperty_.end ();
    }

    Domain::infoProperty_const_iterator Domain::
    begin_infoProperty () const
    {
      return infoProperty_.begin ();
    }

    Domain::infoProperty_const_iterator Domain::
    end_infoProperty () const
    {
      return infoProperty_.end ();
    }

    void Domain::
    add_infoProperty (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      infoProperty_.push_back (e);
    }

    size_t Domain::
    count_infoProperty(void) const
    {
      return infoProperty_.size ();
    }


    // Bridge
    // 

    Bridge::
    Bridge (::XMLSchema::string< ACE_TCHAR > const& name__,
            ::std::list< ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Interconnect, ACE_Null_Mutex > > const& connect__)
    : 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    connect_ (connect__),
    regulator__ ()
    {
      name_->container (this);
    }

    Bridge::
    Bridge (Bridge const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    connect_ (s.connect_),
    resource_ (s.resource_),
    regulator__ ()
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Bridge& Bridge::
    operator= (Bridge const& s)
    {
      name (*s.name_);

      if (s.label_.get ())
        label (*(s.label_));
      else
        label_.reset (0);

      connect_ = s.connect_;

      resource_ = s.resource_;

      return *this;
    }


    // Bridge
    // 
    ::XMLSchema::string< ACE_TCHAR > const& Bridge::
    name () const
    {
      return *name_;
    }

    void Bridge::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Bridge
    // 
    bool Bridge::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Bridge::
    label () const
    {
      return *label_;
    }

    void Bridge::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Bridge
    // 
    Bridge::connect_iterator Bridge::
    begin_connect ()
    {
      return connect_.begin ();
    }

    Bridge::connect_iterator Bridge::
    end_connect ()
    {
      return connect_.end ();
    }

    Bridge::connect_const_iterator Bridge::
    begin_connect () const
    {
      return connect_.begin ();
    }

    Bridge::connect_const_iterator Bridge::
    end_connect () const
    {
      return connect_.end ();
    }

    void Bridge::
    add_connect (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Interconnect, ACE_Null_Mutex >  const& e)
    {
      connect_.push_back (e);
    }

    size_t Bridge::
    count_connect(void) const
    {
      return connect_.size ();
    }

    // Bridge
    // 
    Bridge::resource_iterator Bridge::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Bridge::resource_iterator Bridge::
    end_resource ()
    {
      return resource_.end ();
    }

    Bridge::resource_const_iterator Bridge::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Bridge::resource_const_iterator Bridge::
    end_resource () const
    {
      return resource_.end ();
    }

    void Bridge::
    add_resource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Resource, ACE_Null_Mutex >  const& e)
    {
      resource_.push_back (e);
    }

    size_t Bridge::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // Interconnect
    // 

    Interconnect::
    Interconnect (::XMLSchema::string< ACE_TCHAR > const& name__,
                  ::std::list< ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Node, ACE_Null_Mutex > > const& connect__)
    : 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    connect_ (connect__),
    regulator__ ()
    {
      name_->container (this);
    }

    Interconnect::
    Interconnect (Interconnect const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    connection_ (s.connection_),
    connect_ (s.connect_),
    resource_ (s.resource_),
    regulator__ ()
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Interconnect& Interconnect::
    operator= (Interconnect const& s)
    {
      name (*s.name_);

      if (s.label_.get ())
        label (*(s.label_));
      else
        label_.reset (0);

      connection_ = s.connection_;

      connect_ = s.connect_;

      resource_ = s.resource_;

      return *this;
    }


    // Interconnect
    // 
    ::XMLSchema::string< ACE_TCHAR > const& Interconnect::
    name () const
    {
      return *name_;
    }

    void Interconnect::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Interconnect
    // 
    bool Interconnect::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Interconnect::
    label () const
    {
      return *label_;
    }

    void Interconnect::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Interconnect
    // 
    Interconnect::connection_iterator Interconnect::
    begin_connection ()
    {
      return connection_.begin ();
    }

    Interconnect::connection_iterator Interconnect::
    end_connection ()
    {
      return connection_.end ();
    }

    Interconnect::connection_const_iterator Interconnect::
    begin_connection () const
    {
      return connection_.begin ();
    }

    Interconnect::connection_const_iterator Interconnect::
    end_connection () const
    {
      return connection_.end ();
    }

    void Interconnect::
    add_connection (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Bridge, ACE_Null_Mutex >  const& e)
    {
      connection_.push_back (e);
    }

    size_t Interconnect::
    count_connection(void) const
    {
      return connection_.size ();
    }

    // Interconnect
    // 
    Interconnect::connect_iterator Interconnect::
    begin_connect ()
    {
      return connect_.begin ();
    }

    Interconnect::connect_iterator Interconnect::
    end_connect ()
    {
      return connect_.end ();
    }

    Interconnect::connect_const_iterator Interconnect::
    begin_connect () const
    {
      return connect_.begin ();
    }

    Interconnect::connect_const_iterator Interconnect::
    end_connect () const
    {
      return connect_.end ();
    }

    void Interconnect::
    add_connect (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Node, ACE_Null_Mutex >  const& e)
    {
      connect_.push_back (e);
    }

    size_t Interconnect::
    count_connect(void) const
    {
      return connect_.size ();
    }

    // Interconnect
    // 
    Interconnect::resource_iterator Interconnect::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Interconnect::resource_iterator Interconnect::
    end_resource ()
    {
      return resource_.end ();
    }

    Interconnect::resource_const_iterator Interconnect::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Interconnect::resource_const_iterator Interconnect::
    end_resource () const
    {
      return resource_.end ();
    }

    void Interconnect::
    add_resource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Resource, ACE_Null_Mutex >  const& e)
    {
      resource_.push_back (e);
    }

    size_t Interconnect::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // Node
    // 

    Node::
    Node (::XMLSchema::string< ACE_TCHAR > const& name__)
    : 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    Node::
    Node (Node const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    connection_ (s.connection_),
    sharedResource_ (s.sharedResource_),
    resource_ (s.resource_),
    regulator__ ()
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
    }

    Node& Node::
    operator= (Node const& s)
    {
      name (*s.name_);

      if (s.label_.get ())
        label (*(s.label_));
      else
        label_.reset (0);

      connection_ = s.connection_;

      sharedResource_ = s.sharedResource_;

      resource_ = s.resource_;

      return *this;
    }


    // Node
    // 
    ::XMLSchema::string< ACE_TCHAR > const& Node::
    name () const
    {
      return *name_;
    }

    void Node::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Node
    // 
    bool Node::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Node::
    label () const
    {
      return *label_;
    }

    void Node::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Node
    // 
    Node::connection_iterator Node::
    begin_connection ()
    {
      return connection_.begin ();
    }

    Node::connection_iterator Node::
    end_connection ()
    {
      return connection_.end ();
    }

    Node::connection_const_iterator Node::
    begin_connection () const
    {
      return connection_.begin ();
    }

    Node::connection_const_iterator Node::
    end_connection () const
    {
      return connection_.end ();
    }

    void Node::
    add_connection (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Interconnect, ACE_Null_Mutex >  const& e)
    {
      connection_.push_back (e);
    }

    size_t Node::
    count_connection(void) const
    {
      return connection_.size ();
    }

    // Node
    // 
    Node::sharedResource_iterator Node::
    begin_sharedResource ()
    {
      return sharedResource_.begin ();
    }

    Node::sharedResource_iterator Node::
    end_sharedResource ()
    {
      return sharedResource_.end ();
    }

    Node::sharedResource_const_iterator Node::
    begin_sharedResource () const
    {
      return sharedResource_.begin ();
    }

    Node::sharedResource_const_iterator Node::
    end_sharedResource () const
    {
      return sharedResource_.end ();
    }

    void Node::
    add_sharedResource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SharedResource, ACE_Null_Mutex >  const& e)
    {
      sharedResource_.push_back (e);
    }

    size_t Node::
    count_sharedResource(void) const
    {
      return sharedResource_.size ();
    }

    // Node
    // 
    Node::resource_iterator Node::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Node::resource_iterator Node::
    end_resource ()
    {
      return resource_.end ();
    }

    Node::resource_const_iterator Node::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Node::resource_const_iterator Node::
    end_resource () const
    {
      return resource_.end ();
    }

    void Node::
    add_resource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Resource, ACE_Null_Mutex >  const& e)
    {
      resource_.push_back (e);
    }

    size_t Node::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // SharedResource
    // 

    SharedResource::
    SharedResource (::XMLSchema::string< ACE_TCHAR > const& name__,
                    ::XMLSchema::string< ACE_TCHAR > const& resourceType__,
                    ::DAnCE::Config_Handlers::Node const& node__,
                    ::DAnCE::Config_Handlers::SatisfierProperty const& property__)
    : 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (resourceType__)),
    node_ (new ::DAnCE::Config_Handlers::Node (node__)),
    property_ (new ::DAnCE::Config_Handlers::SatisfierProperty (property__)),
    regulator__ ()
    {
      name_->container (this);
      resourceType_->container (this);
      node_->container (this);
      property_->container (this);
    }

    SharedResource::
    SharedResource (SharedResource const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (*s.resourceType_)),
    node_ (new ::DAnCE::Config_Handlers::Node (*s.node_)),
    property_ (new ::DAnCE::Config_Handlers::SatisfierProperty (*s.property_)),
    regulator__ ()
    {
      name_->container (this);
      resourceType_->container (this);
      node_->container (this);
      property_->container (this);
    }

    SharedResource& SharedResource::
    operator= (SharedResource const& s)
    {
      name (*s.name_);

      resourceType (*s.resourceType_);

      node (*s.node_);

      property (*s.property_);

      return *this;
    }


    // SharedResource
    // 
    ::XMLSchema::string< ACE_TCHAR > const& SharedResource::
    name () const
    {
      return *name_;
    }

    void SharedResource::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // SharedResource
    // 
    ::XMLSchema::string< ACE_TCHAR > const& SharedResource::
    resourceType () const
    {
      return *resourceType_;
    }

    void SharedResource::
    resourceType (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *resourceType_ = e;
    }

    // SharedResource
    // 
    ::DAnCE::Config_Handlers::Node const& SharedResource::
    node () const
    {
      return *node_;
    }

    void SharedResource::
    node (::DAnCE::Config_Handlers::Node const& e)
    {
      *node_ = e;
    }

    // SharedResource
    // 
    ::DAnCE::Config_Handlers::SatisfierProperty const& SharedResource::
    property () const
    {
      return *property_;
    }

    void SharedResource::
    property (::DAnCE::Config_Handlers::SatisfierProperty const& e)
    {
      *property_ = e;
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // Domain
    //

    Domain::
    Domain (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("UUID"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          UUID (t);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == ACE_TEXT("node"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Node, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Node (e));
          add_node (t);
        }

        else if (n == ACE_TEXT("interconnect"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Interconnect, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Interconnect (e));
          add_interconnect (t);
        }

        else if (n == ACE_TEXT("bridge"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Bridge, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Bridge (e));
          add_bridge (t);
        }

        else if (n == ACE_TEXT("sharedResource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SharedResource, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::SharedResource (e));
          add_sharedResource (t);
        }

        else if (n == ACE_TEXT("infoProperty"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_infoProperty (t);
        }

        else 
        {
        }
      }
    }

    // Bridge
    //

    Bridge::
    Bridge (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == ACE_TEXT("connect"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Interconnect, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Interconnect (e));
          add_connect (t);
        }

        else if (n == ACE_TEXT("resource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Resource, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Resource (e));
          add_resource (t);
        }

        else 
        {
        }
      }
    }

    // Interconnect
    //

    Interconnect::
    Interconnect (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == ACE_TEXT("connection"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Bridge, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Bridge (e));
          add_connection (t);
        }

        else if (n == ACE_TEXT("connect"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Node, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Node (e));
          add_connect (t);
        }

        else if (n == ACE_TEXT("resource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Resource, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Resource (e));
          add_resource (t);
        }

        else 
        {
        }
      }
    }

    // Node
    //

    Node::
    Node (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("label"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == ACE_TEXT("connection"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Interconnect, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Interconnect (e));
          add_connection (t);
        }

        else if (n == ACE_TEXT("sharedResource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SharedResource, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::SharedResource (e));
          add_sharedResource (t);
        }

        else if (n == ACE_TEXT("resource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Resource, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Resource (e));
          add_resource (t);
        }

        else 
        {
        }
      }
    }

    // SharedResource
    //

    SharedResource::
    SharedResource (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          resourceType_->container (this);
        }

        else if (n == ACE_TEXT("node"))
        {
          node_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::Node > (new ::DAnCE::Config_Handlers::Node (e));
          node_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          property_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::SatisfierProperty > (new ::DAnCE::Config_Handlers::SatisfierProperty (e));
          property_->container (this);
        }

        else 
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

#include "XMLSchema/TypeInfo.hpp"

namespace DAnCE
{
  namespace Config_Handlers
  {
    namespace
    {
      ::XMLSchema::TypeInfoInitializer < ACE_TCHAR > XMLSchemaTypeInfoInitializer_ (::XSCRT::extended_type_info_map ());

      struct DomainTypeInfoInitializer
      {
        DomainTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Domain));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      DomainTypeInfoInitializer DomainTypeInfoInitializer_;

      struct BridgeTypeInfoInitializer
      {
        BridgeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Bridge));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      BridgeTypeInfoInitializer BridgeTypeInfoInitializer_;

      struct InterconnectTypeInfoInitializer
      {
        InterconnectTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Interconnect));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      InterconnectTypeInfoInitializer InterconnectTypeInfoInitializer_;

      struct NodeTypeInfoInitializer
      {
        NodeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Node));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      NodeTypeInfoInitializer NodeTypeInfoInitializer_;

      struct SharedResourceTypeInfoInitializer
      {
        SharedResourceTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::SharedResource));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      SharedResourceTypeInfoInitializer SharedResourceTypeInfoInitializer_;
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    namespace Traversal
    {
      // Domain
      //
      //

      void Domain::
      traverse (Type& o)
      {
        pre (o);
        if (o.UUID_p ()) UUID (o);
        else UUID_none (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        node (o);
        interconnect (o);
        bridge (o);
        sharedResource (o);
        infoProperty (o);
        post (o);
      }

      void Domain::
      traverse (Type const& o)
      {
        pre (o);
        if (o.UUID_p ()) UUID (o);
        else UUID_none (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        node (o);
        interconnect (o);
        bridge (o);
        sharedResource (o);
        infoProperty (o);
        post (o);
      }

      void Domain::
      pre (Type&)
      {
      }

      void Domain::
      pre (Type const&)
      {
      }

      void Domain::
      UUID (Type& o)
      {
        dispatch (o.UUID ());
      }

      void Domain::
      UUID (Type const& o)
      {
        dispatch (o.UUID ());
      }

      void Domain::
      UUID_none (Type&)
      {
      }

      void Domain::
      UUID_none (Type const&)
      {
      }

      void Domain::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Domain::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Domain::
      label_none (Type&)
      {
      }

      void Domain::
      label_none (Type const&)
      {
      }

      void Domain::
      node (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::node_iterator b (o.begin_node()), e (o.end_node());

        if (b != e)
        {
          node_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) node_next (o);
          }

          node_post (o);
        }
      }

      void Domain::
      node (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::node_const_iterator b (o.begin_node()), e (o.end_node());

        if (b != e)
        {
          node_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) node_next (o);
          }

          node_post (o);
        }
      }

      void Domain::
      node_pre (Type&)
      {
      }

      void Domain::
      node_pre (Type const&)
      {
      }

      void Domain::
      node_next (Type&)
      {
      }

      void Domain::
      node_next (Type const&)
      {
      }

      void Domain::
      node_post (Type&)
      {
      }

      void Domain::
      node_post (Type const&)
      {
      }

      void Domain::
      interconnect (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::interconnect_iterator b (o.begin_interconnect()), e (o.end_interconnect());

        if (b != e)
        {
          interconnect_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) interconnect_next (o);
          }

          interconnect_post (o);
        }

        else interconnect_none (o);
      }

      void Domain::
      interconnect (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::interconnect_const_iterator b (o.begin_interconnect()), e (o.end_interconnect());

        if (b != e)
        {
          interconnect_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) interconnect_next (o);
          }

          interconnect_post (o);
        }

        else interconnect_none (o);
      }

      void Domain::
      interconnect_pre (Type&)
      {
      }

      void Domain::
      interconnect_pre (Type const&)
      {
      }

      void Domain::
      interconnect_next (Type&)
      {
      }

      void Domain::
      interconnect_next (Type const&)
      {
      }

      void Domain::
      interconnect_post (Type&)
      {
      }

      void Domain::
      interconnect_post (Type const&)
      {
      }

      void Domain::
      interconnect_none (Type&)
      {
      }

      void Domain::
      interconnect_none (Type const&)
      {
      }

      void Domain::
      bridge (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::bridge_iterator b (o.begin_bridge()), e (o.end_bridge());

        if (b != e)
        {
          bridge_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) bridge_next (o);
          }

          bridge_post (o);
        }

        else bridge_none (o);
      }

      void Domain::
      bridge (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::bridge_const_iterator b (o.begin_bridge()), e (o.end_bridge());

        if (b != e)
        {
          bridge_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) bridge_next (o);
          }

          bridge_post (o);
        }

        else bridge_none (o);
      }

      void Domain::
      bridge_pre (Type&)
      {
      }

      void Domain::
      bridge_pre (Type const&)
      {
      }

      void Domain::
      bridge_next (Type&)
      {
      }

      void Domain::
      bridge_next (Type const&)
      {
      }

      void Domain::
      bridge_post (Type&)
      {
      }

      void Domain::
      bridge_post (Type const&)
      {
      }

      void Domain::
      bridge_none (Type&)
      {
      }

      void Domain::
      bridge_none (Type const&)
      {
      }

      void Domain::
      sharedResource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::sharedResource_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Domain::
      sharedResource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::sharedResource_const_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Domain::
      sharedResource_pre (Type&)
      {
      }

      void Domain::
      sharedResource_pre (Type const&)
      {
      }

      void Domain::
      sharedResource_next (Type&)
      {
      }

      void Domain::
      sharedResource_next (Type const&)
      {
      }

      void Domain::
      sharedResource_post (Type&)
      {
      }

      void Domain::
      sharedResource_post (Type const&)
      {
      }

      void Domain::
      sharedResource_none (Type&)
      {
      }

      void Domain::
      sharedResource_none (Type const&)
      {
      }

      void Domain::
      infoProperty (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::infoProperty_iterator b (o.begin_infoProperty()), e (o.end_infoProperty());

        if (b != e)
        {
          infoProperty_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) infoProperty_next (o);
          }

          infoProperty_post (o);
        }

        else infoProperty_none (o);
      }

      void Domain::
      infoProperty (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Domain::infoProperty_const_iterator b (o.begin_infoProperty()), e (o.end_infoProperty());

        if (b != e)
        {
          infoProperty_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) infoProperty_next (o);
          }

          infoProperty_post (o);
        }

        else infoProperty_none (o);
      }

      void Domain::
      infoProperty_pre (Type&)
      {
      }

      void Domain::
      infoProperty_pre (Type const&)
      {
      }

      void Domain::
      infoProperty_next (Type&)
      {
      }

      void Domain::
      infoProperty_next (Type const&)
      {
      }

      void Domain::
      infoProperty_post (Type&)
      {
      }

      void Domain::
      infoProperty_post (Type const&)
      {
      }

      void Domain::
      infoProperty_none (Type&)
      {
      }

      void Domain::
      infoProperty_none (Type const&)
      {
      }

      void Domain::
      post (Type&)
      {
      }

      void Domain::
      post (Type const&)
      {
      }

      // Bridge
      //
      //

      void Bridge::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Bridge::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Bridge::
      pre (Type&)
      {
      }

      void Bridge::
      pre (Type const&)
      {
      }

      void Bridge::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Bridge::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Bridge::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Bridge::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Bridge::
      label_none (Type&)
      {
      }

      void Bridge::
      label_none (Type const&)
      {
      }

      void Bridge::
      connect (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Bridge::connect_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Bridge::
      connect (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Bridge::connect_const_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Bridge::
      connect_pre (Type&)
      {
      }

      void Bridge::
      connect_pre (Type const&)
      {
      }

      void Bridge::
      connect_next (Type&)
      {
      }

      void Bridge::
      connect_next (Type const&)
      {
      }

      void Bridge::
      connect_post (Type&)
      {
      }

      void Bridge::
      connect_post (Type const&)
      {
      }

      void Bridge::
      resource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Bridge::resource_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Bridge::
      resource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Bridge::resource_const_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Bridge::
      resource_pre (Type&)
      {
      }

      void Bridge::
      resource_pre (Type const&)
      {
      }

      void Bridge::
      resource_next (Type&)
      {
      }

      void Bridge::
      resource_next (Type const&)
      {
      }

      void Bridge::
      resource_post (Type&)
      {
      }

      void Bridge::
      resource_post (Type const&)
      {
      }

      void Bridge::
      resource_none (Type&)
      {
      }

      void Bridge::
      resource_none (Type const&)
      {
      }

      void Bridge::
      post (Type&)
      {
      }

      void Bridge::
      post (Type const&)
      {
      }

      // Interconnect
      //
      //

      void Interconnect::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Interconnect::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Interconnect::
      pre (Type&)
      {
      }

      void Interconnect::
      pre (Type const&)
      {
      }

      void Interconnect::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Interconnect::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Interconnect::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Interconnect::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Interconnect::
      label_none (Type&)
      {
      }

      void Interconnect::
      label_none (Type const&)
      {
      }

      void Interconnect::
      connection (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Interconnect::connection_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Interconnect::
      connection (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Interconnect::connection_const_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Interconnect::
      connection_pre (Type&)
      {
      }

      void Interconnect::
      connection_pre (Type const&)
      {
      }

      void Interconnect::
      connection_next (Type&)
      {
      }

      void Interconnect::
      connection_next (Type const&)
      {
      }

      void Interconnect::
      connection_post (Type&)
      {
      }

      void Interconnect::
      connection_post (Type const&)
      {
      }

      void Interconnect::
      connection_none (Type&)
      {
      }

      void Interconnect::
      connection_none (Type const&)
      {
      }

      void Interconnect::
      connect (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Interconnect::connect_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Interconnect::
      connect (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Interconnect::connect_const_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Interconnect::
      connect_pre (Type&)
      {
      }

      void Interconnect::
      connect_pre (Type const&)
      {
      }

      void Interconnect::
      connect_next (Type&)
      {
      }

      void Interconnect::
      connect_next (Type const&)
      {
      }

      void Interconnect::
      connect_post (Type&)
      {
      }

      void Interconnect::
      connect_post (Type const&)
      {
      }

      void Interconnect::
      resource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Interconnect::resource_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Interconnect::
      resource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Interconnect::resource_const_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Interconnect::
      resource_pre (Type&)
      {
      }

      void Interconnect::
      resource_pre (Type const&)
      {
      }

      void Interconnect::
      resource_next (Type&)
      {
      }

      void Interconnect::
      resource_next (Type const&)
      {
      }

      void Interconnect::
      resource_post (Type&)
      {
      }

      void Interconnect::
      resource_post (Type const&)
      {
      }

      void Interconnect::
      resource_none (Type&)
      {
      }

      void Interconnect::
      resource_none (Type const&)
      {
      }

      void Interconnect::
      post (Type&)
      {
      }

      void Interconnect::
      post (Type const&)
      {
      }

      // Node
      //
      //

      void Node::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        sharedResource (o);
        resource (o);
        post (o);
      }

      void Node::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        sharedResource (o);
        resource (o);
        post (o);
      }

      void Node::
      pre (Type&)
      {
      }

      void Node::
      pre (Type const&)
      {
      }

      void Node::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Node::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Node::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Node::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Node::
      label_none (Type&)
      {
      }

      void Node::
      label_none (Type const&)
      {
      }

      void Node::
      connection (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Node::connection_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Node::
      connection (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Node::connection_const_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Node::
      connection_pre (Type&)
      {
      }

      void Node::
      connection_pre (Type const&)
      {
      }

      void Node::
      connection_next (Type&)
      {
      }

      void Node::
      connection_next (Type const&)
      {
      }

      void Node::
      connection_post (Type&)
      {
      }

      void Node::
      connection_post (Type const&)
      {
      }

      void Node::
      connection_none (Type&)
      {
      }

      void Node::
      connection_none (Type const&)
      {
      }

      void Node::
      sharedResource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Node::sharedResource_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Node::
      sharedResource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Node::sharedResource_const_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Node::
      sharedResource_pre (Type&)
      {
      }

      void Node::
      sharedResource_pre (Type const&)
      {
      }

      void Node::
      sharedResource_next (Type&)
      {
      }

      void Node::
      sharedResource_next (Type const&)
      {
      }

      void Node::
      sharedResource_post (Type&)
      {
      }

      void Node::
      sharedResource_post (Type const&)
      {
      }

      void Node::
      sharedResource_none (Type&)
      {
      }

      void Node::
      sharedResource_none (Type const&)
      {
      }

      void Node::
      resource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Node::resource_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Node::
      resource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Node::resource_const_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Node::
      resource_pre (Type&)
      {
      }

      void Node::
      resource_pre (Type const&)
      {
      }

      void Node::
      resource_next (Type&)
      {
      }

      void Node::
      resource_next (Type const&)
      {
      }

      void Node::
      resource_post (Type&)
      {
      }

      void Node::
      resource_post (Type const&)
      {
      }

      void Node::
      resource_none (Type&)
      {
      }

      void Node::
      resource_none (Type const&)
      {
      }

      void Node::
      post (Type&)
      {
      }

      void Node::
      post (Type const&)
      {
      }

      // SharedResource
      //
      //

      void SharedResource::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        node (o);
        property (o);
        post (o);
      }

      void SharedResource::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        node (o);
        property (o);
        post (o);
      }

      void SharedResource::
      pre (Type&)
      {
      }

      void SharedResource::
      pre (Type const&)
      {
      }

      void SharedResource::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void SharedResource::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void SharedResource::
      resourceType (Type& o)
      {
        dispatch (o.resourceType ());
      }

      void SharedResource::
      resourceType (Type const& o)
      {
        dispatch (o.resourceType ());
      }

      void SharedResource::
      node (Type& o)
      {
        dispatch (o.node ());
      }

      void SharedResource::
      node (Type const& o)
      {
        dispatch (o.node ());
      }

      void SharedResource::
      property (Type& o)
      {
        dispatch (o.property ());
      }

      void SharedResource::
      property (Type const& o)
      {
        dispatch (o.property ());
      }

      void SharedResource::
      post (Type&)
      {
      }

      void SharedResource::
      post (Type const&)
      {
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    namespace Writer
    {
      // Domain
      //
      //

      Domain::
      Domain (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Domain::
      Domain ()
      {
      }

      void Domain::
      traverse (Type const& o)
      {
        Traversal::Domain::traverse (o);
      }

      void Domain::
      UUID (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("UUID"), top_ ()));
        Traversal::Domain::UUID (o);
        pop_ ();
      }

      void Domain::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("label"), top_ ()));
        Traversal::Domain::label (o);
        pop_ ();
      }

      void Domain::
      node_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("node"), top_ ()));
      }

      void Domain::
      node_next (Type const& o)
      {
        node_post (o);
        node_pre (o);
      }

      void Domain::
      node_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      interconnect_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("interconnect"), top_ ()));
      }

      void Domain::
      interconnect_next (Type const& o)
      {
        interconnect_post (o);
        interconnect_pre (o);
      }

      void Domain::
      interconnect_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      bridge_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("bridge"), top_ ()));
      }

      void Domain::
      bridge_next (Type const& o)
      {
        bridge_post (o);
        bridge_pre (o);
      }

      void Domain::
      bridge_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      sharedResource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("sharedResource"), top_ ()));
      }

      void Domain::
      sharedResource_next (Type const& o)
      {
        sharedResource_post (o);
        sharedResource_pre (o);
      }

      void Domain::
      sharedResource_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      infoProperty_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("infoProperty"), top_ ()));
      }

      void Domain::
      infoProperty_next (Type const& o)
      {
        infoProperty_post (o);
        infoProperty_pre (o);
      }

      void Domain::
      infoProperty_post (Type const&)
      {
        pop_ ();
      }

      // Bridge
      //
      //

      Bridge::
      Bridge (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Bridge::
      Bridge ()
      {
      }

      void Bridge::
      traverse (Type const& o)
      {
        Traversal::Bridge::traverse (o);
      }

      void Bridge::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::Bridge::name (o);
        pop_ ();
      }

      void Bridge::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("label"), top_ ()));
        Traversal::Bridge::label (o);
        pop_ ();
      }

      void Bridge::
      connect_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("connect"), top_ ()));
      }

      void Bridge::
      connect_next (Type const& o)
      {
        connect_post (o);
        connect_pre (o);
      }

      void Bridge::
      connect_post (Type const&)
      {
        pop_ ();
      }

      void Bridge::
      resource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resource"), top_ ()));
      }

      void Bridge::
      resource_next (Type const& o)
      {
        resource_post (o);
        resource_pre (o);
      }

      void Bridge::
      resource_post (Type const&)
      {
        pop_ ();
      }

      // Interconnect
      //
      //

      Interconnect::
      Interconnect (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Interconnect::
      Interconnect ()
      {
      }

      void Interconnect::
      traverse (Type const& o)
      {
        Traversal::Interconnect::traverse (o);
      }

      void Interconnect::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::Interconnect::name (o);
        pop_ ();
      }

      void Interconnect::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("label"), top_ ()));
        Traversal::Interconnect::label (o);
        pop_ ();
      }

      void Interconnect::
      connection_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("connection"), top_ ()));
      }

      void Interconnect::
      connection_next (Type const& o)
      {
        connection_post (o);
        connection_pre (o);
      }

      void Interconnect::
      connection_post (Type const&)
      {
        pop_ ();
      }

      void Interconnect::
      connect_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("connect"), top_ ()));
      }

      void Interconnect::
      connect_next (Type const& o)
      {
        connect_post (o);
        connect_pre (o);
      }

      void Interconnect::
      connect_post (Type const&)
      {
        pop_ ();
      }

      void Interconnect::
      resource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resource"), top_ ()));
      }

      void Interconnect::
      resource_next (Type const& o)
      {
        resource_post (o);
        resource_pre (o);
      }

      void Interconnect::
      resource_post (Type const&)
      {
        pop_ ();
      }

      // Node
      //
      //

      Node::
      Node (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Node::
      Node ()
      {
      }

      void Node::
      traverse (Type const& o)
      {
        Traversal::Node::traverse (o);
      }

      void Node::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::Node::name (o);
        pop_ ();
      }

      void Node::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("label"), top_ ()));
        Traversal::Node::label (o);
        pop_ ();
      }

      void Node::
      connection_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("connection"), top_ ()));
      }

      void Node::
      connection_next (Type const& o)
      {
        connection_post (o);
        connection_pre (o);
      }

      void Node::
      connection_post (Type const&)
      {
        pop_ ();
      }

      void Node::
      sharedResource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("sharedResource"), top_ ()));
      }

      void Node::
      sharedResource_next (Type const& o)
      {
        sharedResource_post (o);
        sharedResource_pre (o);
      }

      void Node::
      sharedResource_post (Type const&)
      {
        pop_ ();
      }

      void Node::
      resource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resource"), top_ ()));
      }

      void Node::
      resource_next (Type const& o)
      {
        resource_post (o);
        resource_pre (o);
      }

      void Node::
      resource_post (Type const&)
      {
        pop_ ();
      }

      // SharedResource
      //
      //

      SharedResource::
      SharedResource (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      SharedResource::
      SharedResource ()
      {
      }

      void SharedResource::
      traverse (Type const& o)
      {
        Traversal::SharedResource::traverse (o);
      }

      void SharedResource::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::SharedResource::name (o);
        pop_ ();
      }

      void SharedResource::
      resourceType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceType"), top_ ()));
        Traversal::SharedResource::resourceType (o);
        pop_ ();
      }

      void SharedResource::
      node (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("node"), top_ ()));
        Traversal::SharedResource::node (o);
        pop_ ();
      }

      void SharedResource::
      property (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
        Traversal::SharedResource::property (o);
        pop_ ();
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

