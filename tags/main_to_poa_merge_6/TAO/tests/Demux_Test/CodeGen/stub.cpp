#include "tao.h"

long GenClientHeader(ACE_Unbounded_Queue<ACE_CString> &arr, int limit)
{
  fstream hdr;
  int i;
  ACE_CString *str;

  hdr.open("tao_demuxC.h", ios::out);
 
  hdr << "//******** Generated by the tool: taoidl ********" << endl << endl;

  hdr << "#if !defined (TAO_DEMUXC_H)" << endl;
  hdr << "#define TAO_DEMUXC_H" << endl << endl;

  hdr << "#include <stdlib.h>" << endl;
  hdr << "#include \"tao/corba.h\"" << endl;
  //  hdr << "#include \"tao/orb.h\"" << endl;
  //  hdr << "#include \"tao/stub.h\"" << endl;
  //  hdr << "#include \"tao/optable.h\"" << endl;

  hdr << "class tao_demux;" << endl;
  hdr << "typedef tao_demux *\ttao_demux_ptr;" << endl;
  hdr << "class tao_demux: public virtual CORBA_Object" << endl;
  hdr << "{" << endl;
  hdr << "public:" << endl;
  // define the CORBA compliant mapping
  hdr << "\tstatic tao_demux_ptr _duplicate(tao_demux_ptr obj);" << endl;
  hdr << "\tstatic tao_demux_ptr _narrow(CORBA_Object_ptr obj);" << endl;
  hdr << "\tstatic tao_demux_ptr _nil();" << endl << endl;

  // now generate all the methods
  for(i=0; i < limit; i++)
    {
      if (arr.get(str, i) == -1)
	{
	  return -1;
	}
      hdr << "\tvirtual void " << str->rep() << "(CORBA_Environment &env);" << endl;
    }
  hdr << "protected:" << endl;
  hdr << "\ttao_demux() {}" << endl;
  hdr << "\ttao_demux(STUB_Object *objref): CORBA_Object(objref) {}" << endl;
  hdr << "\tvirtual ~tao_demux() {}" << endl;
  hdr << "private:" << endl;
  hdr << "\t//copy constructor and assignment operator" << endl;
  hdr << "\ttao_demux(const tao_demux&) { }" << endl;
  hdr << "\tvoid operator=(const tao_demux&) { }" << endl;
  hdr << "};" << endl;

  hdr << "#endif" << endl;
  hdr.close();
}

long GenClientStubs(ACE_Unbounded_Queue<ACE_CString> &arr, int limit)
{
  fstream stub;
  int i;
  ACE_CString *str;

  stub.open("tao_demuxC.cpp", ios::out);

  stub << "#include \"tao_demuxC.h\"" << endl << endl;

  // generate the static functions

  // the _duplicate method
  stub << "tao_demux_ptr tao_demux::_duplicate(tao_demux_ptr obj)" << endl;
  stub << "{" << endl;
  stub << "\tif (obj) obj->AddRef();" << endl;
  stub << "\treturn obj;" << endl;
  stub << "}" << endl << endl;

  // the _narrow method
  stub << "tao_demux_ptr tao_demux::_narrow(CORBA_Object_ptr obj)" << endl;
  stub << "{" << endl;
  // check if object "is_a" IDL:tao_demux:1.0 and if so, addref and return a
  // pointer to it
  stub << "\tCORBA_Environment env;" << endl;
  stub << "\tif (obj->_is_a(\"IDL:tao_demux:1.0\", env)){" << endl;
  stub << "\t  STUB_Object *istub;" << endl;
  stub << "\t  if (obj->QueryInterface(IID_STUB_Object, (void **)&istub)" <<
    " != NOERROR){" << endl;
  stub << "\t\treturn tao_demux::_nil();" << endl;
  stub << "\t  }" << endl;
  stub << "\t  tao_demux_ptr new_obj = new tao_demux(istub);" << endl;
  stub << "\t  return tao_demux::_duplicate(new_obj);" << endl;
  stub << "\t}" << endl;
  stub << "\treturn tao_demux::_nil();" << endl;
  stub << "}" << endl << endl;

  // the _nil method
  stub << "tao_demux_ptr tao_demux::_nil()" << endl;
  stub << "{" << endl;
  stub << "\treturn (tao_demux_ptr)NULL;" << endl;
  stub << "}" << endl << endl;

  // All the TAO_Param_Data and TAO_Call_Data structures
  stub <<
    "// All the TAO_Param_Data and TAO_Call_Data structures required for invoking do_call"
     << endl; 
  for(i=0; i < limit; i++){
    if (arr.get(str, i) == -1)
      {
	return -1;
      }

    // generate TAO_Param_Data structure
    stub << "static const TAO_Param_Data tao_demux_" << str->rep() <<
      "_params[] = {" << endl;
    stub << "\t{_tc_CORBA_Void, PARAM_RETURN, 0}" << endl;
    stub << "};" << endl;

    // generate TAO_Call_Data structure
    stub << "static const TAO_Call_Data tao_demux_" << str->rep() << 
      "_calldata = {" << endl;
    stub << "\t\"" << str->rep() << "\"," << endl;
    stub << "\tCORBA_B_TRUE, //twoway" << endl;
    stub << "\t1, &tao_demux_" << str->rep() << "_params[0]," << endl;
    stub << "\t0, 0" << endl;
    stub << "};" << endl;

    // generate TAO_Call_Data structure that uses active demultiplexing
    stub << "static const TAO_Call_Data tao_demux_" << str->rep() << 
      "_active_calldata = {" << endl;
    stub << "\t\"" << i << "\"," << endl;
    stub << "\tCORBA_B_TRUE, //twoway" << endl;
    stub << "\t1, &tao_demux_" << str->rep() << "_params[0]," << endl;
    stub << "\t0, 0" << endl;
    stub << "};" << endl;

    // now the actual stub
    stub << "void tao_demux::" << str->rep() << "(CORBA_Environment &env)"
	 << endl;
    stub << "{" << endl;
    stub << "\tSTUB_Object *istub;" << endl;
    stub << "\tif (this->QueryInterface (IID_STUB_Object, (void **) &istub) "
	 << "!= NOERROR){" << endl;
    stub << "\t  env.exception (new CORBA_DATA_CONVERSION (COMPLETED_NO));" << endl;
    stub << "\t  return;" << endl;
    stub << "\t}" << endl;
    stub << "\tTAO_Operation_Table_Parameters *paramTbl = " << endl;
    stub << "\t\tTAO_OP_TABLE_PARAMETERS::instance();" << endl;
    stub << "\tif (paramTbl->lookup_strategy() == ";
    stub << "TAO_Operation_Table_Parameters::TAO_ACTIVE_DEMUX)" << endl;
    stub << "\t\tistub->do_call(env, &tao_demux_" << str->rep() <<
      "_active_calldata);" << endl;
    stub << "\telse" << endl;
    stub << "\t\tistub->do_call(env, &tao_demux_" << str->rep() <<
      "_calldata);" << endl;
    stub << "}" << endl << endl;
  }
  stub.close();
}

