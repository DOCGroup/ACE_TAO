// $Id$
//=============================================================================
/**
 * @file BasicSP.idl
 *
 * Definition of events, and common interfaces used in the BasicSP module.
 *
 * @author Balachandran Natarajan <bala@dre.vanderbilt.edu>
 */
//=============================================================================

#ifndef CIAO_BASIC_SP_IDL
#define CIAO_BASIC_SP_IDL

#include <Components.idl>
#include <RtecEventChannelAdmin.idl>

// @@NOTE: Do we need a pragma prefix. Anyway its broken now in TAO..
// #pragma prefix ""


module BasicSP
{

  /**
   * @NOTE: Not sure whether this is a good abstraction. Just copying
   *  the stuff from Cadena folks.
   */
  /**
   * @interface ReadData
   *
   */

  interface ReadData {
    string get_data ();
  };

  /**
   * @eventtype Events that represent timeouts
   */
  eventtype TimeOut {};

  /**
   * @eventtype Events that represent data availability
   */
  eventtype DataAvailable {};

};

/*module TimeBase
{
  typedef unsigned long long TimeT;
};


typedef sequence<octet> EventPayload;

struct RtecEventData
{
  long pad1;

  EventPayload payload;

  any any_value;
};

module RtecEventComm
{

  typedef RtecEventData EventData;

  typedef TimeBase::TimeT Time;

  typedef long EventSourceID;

  typedef long _EventType;

  struct EventHeader
  {
    _EventType type;

    EventSourceID source;

    long ttl;

    Time creation_time;

    Time ec_recv_time;

    Time ec_send_time;
  };

  struct Event
  {
    EventHeader header;

    EventData data;
  };

  typedef sequence<Event> EventSet;

  interface PushConsumer
  {
    oneway void push (in EventSet data);

    void disconnect_push_consumer ();
  };

  interface PushSupplier
  {
    void disconnect_push_supplier ();
  };

};

module RtecBase
{

  enum Dependency_Type_t
  {
    ONE_WAY_CALL,
    TWO_WAY_CALL
  };

  typedef long handle_t;

  struct Dependency_Info
  {
    Dependency_Type_t dependency_type;

    long number_of_calls;

    handle_t rt_info;
  };

};

module RtecEventChannelAdmin
{
  exception AlreadyConnected {};

  exception TypeError {};

  struct Dependency
  {
    RtecEventComm::Event event;

    RtecBase::handle_t rt_info;
  };

  typedef sequence<Dependency> DependencySet;

  struct Publication
  {
    RtecEventComm::Event event;

    RtecBase::Dependency_Info dependency_info;
  };

  typedef sequence<Publication> PublicationSet;

  struct ConsumerQOS
  {
    DependencySet dependencies;

    boolean is_gateway;
  };

  struct SupplierQOS
  {
    PublicationSet publications;

    boolean is_gateway;
  };

  interface ProxyPushConsumer : RtecEventComm::PushConsumer
  {
    void connect_push_supplier (in RtecEventComm::PushSupplier push_supplier,
                                in SupplierQOS qos)
      raises (AlreadyConnected);
  };

  interface ProxyPushSupplier : RtecEventComm::PushSupplier
  {
    void connect_push_consumer(in RtecEventComm::PushConsumer push_consumer,
                               in ConsumerQOS qos)
      raises(AlreadyConnected, TypeError);

    void suspend_connection ();

    void resume_connection ();

  };

  interface ConsumerAdmin
  {
    ProxyPushSupplier obtain_push_supplier ();
  };

  interface SupplierAdmin
  {
    ProxyPushConsumer obtain_push_consumer ();
  };

  interface Observer
  {
    void update_consumer (in ConsumerQOS sub);

    void update_supplier (in SupplierQOS pub);
  };

  typedef unsigned long Observer_Handle;

  interface EventChannel
  {

    exception SYNCHRONIZATION_ERROR {};

    exception CANT_APPEND_OBSERVER {};

    exception CANT_REMOVE_OBSERVER {};

    exception QOS_ERROR {};

    exception SUBSCRIPTION_ERROR {};

    exception CORRELATION_ERROR {};

    exception DISPATCH_ERROR {};

    ConsumerAdmin for_consumers ();

    SupplierAdmin for_suppliers ();

    void destroy ();

    Observer_Handle append_observer (in Observer gw)
       raises (SYNCHRONIZATION_ERROR,CANT_APPEND_OBSERVER);

    void remove_observer (in Observer_Handle gw)
       raises (SYNCHRONIZATION_ERROR,CANT_REMOVE_OBSERVER);
  };

};
*/

#endif /*CIAO_BASIC_SP_IDL*/
