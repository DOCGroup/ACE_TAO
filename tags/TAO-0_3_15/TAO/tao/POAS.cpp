// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/POAS.h"
#include "tao/Server_Request.h"
#include "tao/Operation_Table.h"
#include "tao/ORB_Core.h"

#if !defined (__ACE_INLINE__)
#include "tao/POAS.i"
#endif // !defined INLINE

ACE_RCSID(tao, POAS, "$Id$")

#if !defined (TAO_HAS_MINIMUM_CORBA)

static const TAO_operation_db_entry PortableServer_ThreadPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ThreadPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ThreadPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ThreadPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::ThreadPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::ThreadPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ThreadPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_ThreadPolicy_optable_pool [_tao_PortableServer_ThreadPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ThreadPolicy_allocator (_tao_PortableServer_ThreadPolicy_optable_pool, _tao_PortableServer_ThreadPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ThreadPolicy_optable (PortableServer_ThreadPolicy_operations, 5, 10, &_tao_PortableServer_ThreadPolicy_allocator);

// skeleton constructor
POA_PortableServer::ThreadPolicy::ThreadPolicy (void)
{
  this->optable_ = &tao_PortableServer_ThreadPolicy_optable;
}

void POA_PortableServer::ThreadPolicy::_get_value_skel (
                                                        CORBA::ServerRequest &_tao_server_request,
                                                        void *_tao_object_reference,
                                                        void * /* context */,
                                                        CORBA::Environment &_tao_orb_environment
                                                        )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_ThreadPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_ThreadPolicyValue, 0, 0}
  }; // PortableServer_ThreadPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_ThreadPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_ThreadPolicy_value_paramdata};

  POA_PortableServer::ThreadPolicy *_tao_impl = (POA_PortableServer::ThreadPolicy *)_tao_object_reference;
  PortableServer::ThreadPolicyValue _tao_retval;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &_get_PortableServer_ThreadPolicy_value_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
                                  _tao_orb_environment
                                  );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &_get_PortableServer_ThreadPolicy_value_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::ThreadPolicy::_is_a_skel (
                                                   CORBA::ServerRequest &_tao_server_request,
                                                   void * _tao_object_reference,
                                                   void * /*context*/,
                                                   CORBA::Environment &_tao_orb_environment
                                                   )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ThreadPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ThreadPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ThreadPolicy_is_a_paramdata};
  POA_PortableServer::ThreadPolicy_ptr  _tao_impl = (POA_PortableServer::ThreadPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_ThreadPolicy_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_ThreadPolicy_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ThreadPolicy::_is_a (
                                                        const char* value,
                                                        CORBA::Environment &_tao_orb_environment
                                                        )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ThreadPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ThreadPolicy::_downcast (
                                                   const char* logical_type_id
                                                   )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ThreadPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ThreadPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ThreadPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::ThreadPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ThreadPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ThreadPolicy::_tao_collocated_ThreadPolicy (
                                                                                POA_PortableServer::ThreadPolicy_ptr  servant,
                                                                                STUB_Object *stub
                                                                                )
  : ACE_NESTED_CLASS (PortableServer, ThreadPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_ThreadPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ThreadPolicy::_is_a (
                                                                        const char* logical_type_id,
                                                                        CORBA::Environment &_tao_orb_environment
                                                                        )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}


CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ThreadPolicy::copy (
                                                                          CORBA::Environment &_tao_orb_environment
                                                                          )
{
  return this->servant_->copy (
                               _tao_orb_environment
                               );
}

void POA_PortableServer::_tao_collocated_ThreadPolicy::destroy (
                                                                CORBA::Environment &_tao_orb_environment
                                                                )
{
  this->servant_->destroy (
                           _tao_orb_environment
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ThreadPolicy::policy_type (
                                                                                 CORBA::Environment &_tao_orb_environment
                                                                                 )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::ThreadPolicyValue
POA_PortableServer::_tao_collocated_ThreadPolicy::value (
                                                         CORBA::Environment &_tao_orb_environment
                                                         )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::ThreadPolicy*
POA_PortableServer::ThreadPolicy::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ThreadPolicy (this, stub);
}

#endif /* TAO_HAS_MINIMUM_CORBA */

static const TAO_operation_db_entry PortableServer_LifespanPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::LifespanPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::LifespanPolicy::copy_skel},
  {"destroy", &POA_PortableServer::LifespanPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::LifespanPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::LifespanPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_LifespanPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_LifespanPolicy_optable_pool [_tao_PortableServer_LifespanPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_LifespanPolicy_allocator (_tao_PortableServer_LifespanPolicy_optable_pool, _tao_PortableServer_LifespanPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_LifespanPolicy_optable (PortableServer_LifespanPolicy_operations, 5, 10, &_tao_PortableServer_LifespanPolicy_allocator);

// skeleton constructor
POA_PortableServer::LifespanPolicy::LifespanPolicy (void)
{
  this->optable_ = &tao_PortableServer_LifespanPolicy_optable;
}

void POA_PortableServer::LifespanPolicy::_get_value_skel (
                                                          CORBA::ServerRequest &_tao_server_request,
                                                          void *_tao_object_reference,
                                                          void * /* context */,
                                                          CORBA::Environment &_tao_orb_environment
                                                          )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_LifespanPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_LifespanPolicyValue, 0, 0}
  }; // PortableServer_LifespanPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_LifespanPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_LifespanPolicy_value_paramdata};

  POA_PortableServer::LifespanPolicy *_tao_impl = (POA_PortableServer::LifespanPolicy *)_tao_object_reference;
  PortableServer::LifespanPolicyValue _tao_retval;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &_get_PortableServer_LifespanPolicy_value_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
                                  _tao_orb_environment
                                  );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &_get_PortableServer_LifespanPolicy_value_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::LifespanPolicy::_is_a_skel (
                                                     CORBA::ServerRequest &_tao_server_request,
                                                     void * _tao_object_reference,
                                                     void * /*context*/,
                                                     CORBA::Environment &_tao_orb_environment
                                                     )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_LifespanPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_LifespanPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_LifespanPolicy_is_a_paramdata};
  POA_PortableServer::LifespanPolicy_ptr  _tao_impl = (POA_PortableServer::LifespanPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_LifespanPolicy_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_LifespanPolicy_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::LifespanPolicy::_is_a (
                                                          const char* value,
                                                          CORBA::Environment &_tao_orb_environment
                                                          )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/LifespanPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::LifespanPolicy::_downcast (
                                                     const char* logical_type_id
                                                     )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/LifespanPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::LifespanPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::LifespanPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::LifespanPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/LifespanPolicy:1.0";
}

POA_PortableServer::_tao_collocated_LifespanPolicy::_tao_collocated_LifespanPolicy (
                                                                                    POA_PortableServer::LifespanPolicy_ptr  servant,
                                                                                    STUB_Object *stub
                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, LifespanPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_LifespanPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_LifespanPolicy::_is_a (
                                                                          const char* logical_type_id,
                                                                          CORBA::Environment &_tao_orb_environment
                                                                          )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_LifespanPolicy::copy (
                                                                            CORBA::Environment &_tao_orb_environment
                                                                            )
{
  return this->servant_->copy (
                               _tao_orb_environment
                               );
}

void POA_PortableServer::_tao_collocated_LifespanPolicy::destroy (
                                                                  CORBA::Environment &_tao_orb_environment
                                                                  )
{
  this->servant_->destroy (
                           _tao_orb_environment
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_LifespanPolicy::policy_type (
                                                                                   CORBA::Environment &_tao_orb_environment
                                                                                   )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::LifespanPolicyValue
POA_PortableServer::_tao_collocated_LifespanPolicy::value (
                                                           CORBA::Environment &_tao_orb_environment
                                                           )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::LifespanPolicy*
POA_PortableServer::LifespanPolicy::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_LifespanPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_IdUniquenessPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::IdUniquenessPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::IdUniquenessPolicy::copy_skel},
  {"destroy", &POA_PortableServer::IdUniquenessPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::IdUniquenessPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::IdUniquenessPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_IdUniquenessPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_IdUniquenessPolicy_optable_pool [_tao_PortableServer_IdUniquenessPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_IdUniquenessPolicy_allocator (_tao_PortableServer_IdUniquenessPolicy_optable_pool, _tao_PortableServer_IdUniquenessPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_IdUniquenessPolicy_optable (PortableServer_IdUniquenessPolicy_operations, 5, 10, &_tao_PortableServer_IdUniquenessPolicy_allocator);

// skeleton constructor
POA_PortableServer::IdUniquenessPolicy::IdUniquenessPolicy (void)
{
  this->optable_ = &tao_PortableServer_IdUniquenessPolicy_optable;
}

void POA_PortableServer::IdUniquenessPolicy::_get_value_skel (
                                                              CORBA::ServerRequest &_tao_server_request,
                                                              void *_tao_object_reference,
                                                              void * /* context */,
                                                              CORBA::Environment &_tao_orb_environment
                                                              )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_IdUniquenessPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_IdUniquenessPolicyValue, 0, 0}
  }; // PortableServer_IdUniquenessPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_IdUniquenessPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_IdUniquenessPolicy_value_paramdata};

  POA_PortableServer::IdUniquenessPolicy *_tao_impl = (POA_PortableServer::IdUniquenessPolicy *)_tao_object_reference;
  PortableServer::IdUniquenessPolicyValue _tao_retval;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &_get_PortableServer_IdUniquenessPolicy_value_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
                                  _tao_orb_environment
                                  );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &_get_PortableServer_IdUniquenessPolicy_value_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::IdUniquenessPolicy::_is_a_skel (
                                                         CORBA::ServerRequest &_tao_server_request,
                                                         void * _tao_object_reference,
                                                         void * /*context*/,
                                                         CORBA::Environment &_tao_orb_environment
                                                         )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_IdUniquenessPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdUniquenessPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_IdUniquenessPolicy_is_a_paramdata};
  POA_PortableServer::IdUniquenessPolicy_ptr  _tao_impl = (POA_PortableServer::IdUniquenessPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_IdUniquenessPolicy_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_IdUniquenessPolicy_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::IdUniquenessPolicy::_is_a (
                                                              const char* value,
                                                              CORBA::Environment &_tao_orb_environment
                                                              )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdUniquenessPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::IdUniquenessPolicy::_downcast (
                                                         const char* logical_type_id
                                                         )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/IdUniquenessPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdUniquenessPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::IdUniquenessPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::IdUniquenessPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/IdUniquenessPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_tao_collocated_IdUniquenessPolicy (
                                                                                            POA_PortableServer::IdUniquenessPolicy_ptr  servant,
                                                                                            STUB_Object *stub
                                                                                            )
  : ACE_NESTED_CLASS (PortableServer, IdUniquenessPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_is_a (
                                                                              const char* logical_type_id,
                                                                              CORBA::Environment &_tao_orb_environment
                                                                              )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_IdUniquenessPolicy::copy (
                                                                                CORBA::Environment &_tao_orb_environment
                                                                                )
{
  return this->servant_->copy (
                               _tao_orb_environment
                               );
}

void POA_PortableServer::_tao_collocated_IdUniquenessPolicy::destroy (
                                                                      CORBA::Environment &_tao_orb_environment
                                                                      )
{
  this->servant_->destroy (
                           _tao_orb_environment
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_IdUniquenessPolicy::policy_type (
                                                                                       CORBA::Environment &_tao_orb_environment
                                                                                       )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::IdUniquenessPolicyValue
POA_PortableServer::_tao_collocated_IdUniquenessPolicy::value (
                                                               CORBA::Environment &_tao_orb_environment
                                                               )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::IdUniquenessPolicy*
POA_PortableServer::IdUniquenessPolicy::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_IdUniquenessPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_IdAssignmentPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::IdAssignmentPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::IdAssignmentPolicy::copy_skel},
  {"destroy", &POA_PortableServer::IdAssignmentPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::IdAssignmentPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::IdAssignmentPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_IdAssignmentPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_IdAssignmentPolicy_optable_pool [_tao_PortableServer_IdAssignmentPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_IdAssignmentPolicy_allocator (_tao_PortableServer_IdAssignmentPolicy_optable_pool, _tao_PortableServer_IdAssignmentPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_IdAssignmentPolicy_optable (PortableServer_IdAssignmentPolicy_operations, 5, 10, &_tao_PortableServer_IdAssignmentPolicy_allocator);

// skeleton constructor
POA_PortableServer::IdAssignmentPolicy::IdAssignmentPolicy (void)
{
  this->optable_ = &tao_PortableServer_IdAssignmentPolicy_optable;
}

void POA_PortableServer::IdAssignmentPolicy::_get_value_skel (
                                                              CORBA::ServerRequest &_tao_server_request,
                                                              void *_tao_object_reference,
                                                              void * /* context */,
                                                              CORBA::Environment &_tao_orb_environment
                                                              )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_IdAssignmentPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_IdAssignmentPolicyValue, 0, 0}
  }; // PortableServer_IdAssignmentPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_IdAssignmentPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_IdAssignmentPolicy_value_paramdata};

  POA_PortableServer::IdAssignmentPolicy *_tao_impl = (POA_PortableServer::IdAssignmentPolicy *)_tao_object_reference;
  PortableServer::IdAssignmentPolicyValue _tao_retval;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &_get_PortableServer_IdAssignmentPolicy_value_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
                                  _tao_orb_environment
                                  );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &_get_PortableServer_IdAssignmentPolicy_value_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::IdAssignmentPolicy::_is_a_skel (
                                                         CORBA::ServerRequest &_tao_server_request,
                                                         void * _tao_object_reference,
                                                         void * /*context*/,
                                                         CORBA::Environment &_tao_orb_environment
                                                         )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_IdAssignmentPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdAssignmentPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_IdAssignmentPolicy_is_a_paramdata};
  POA_PortableServer::IdAssignmentPolicy_ptr  _tao_impl = (POA_PortableServer::IdAssignmentPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_IdAssignmentPolicy_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_IdAssignmentPolicy_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::IdAssignmentPolicy::_is_a (
                                                              const char* value,
                                                              CORBA::Environment &_tao_orb_environment
                                                              )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdAssignmentPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::IdAssignmentPolicy::_downcast (
                                                         const char* logical_type_id
                                                         )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/IdAssignmentPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdAssignmentPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::IdAssignmentPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::IdAssignmentPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/IdAssignmentPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_tao_collocated_IdAssignmentPolicy (
                                                                                            POA_PortableServer::IdAssignmentPolicy_ptr  servant,
                                                                                            STUB_Object *stub
                                                                                            )
  : ACE_NESTED_CLASS (PortableServer, IdAssignmentPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_is_a (
                                                                              const char* logical_type_id,
                                                                              CORBA::Environment &_tao_orb_environment
                                                                              )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_IdAssignmentPolicy::copy (
                                                                                CORBA::Environment &_tao_orb_environment
                                                                                )
{
  return this->servant_->copy (
                               _tao_orb_environment
                               );
}

void POA_PortableServer::_tao_collocated_IdAssignmentPolicy::destroy (
                                                                      CORBA::Environment &_tao_orb_environment
                                                                      )
{
  this->servant_->destroy (
                           _tao_orb_environment
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_IdAssignmentPolicy::policy_type (
                                                                                       CORBA::Environment &_tao_orb_environment
                                                                                       )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::IdAssignmentPolicyValue
POA_PortableServer::_tao_collocated_IdAssignmentPolicy::value (
                                                               CORBA::Environment &_tao_orb_environment
                                                               )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::IdAssignmentPolicy*
POA_PortableServer::IdAssignmentPolicy::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_IdAssignmentPolicy (this, stub);
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

static const TAO_operation_db_entry PortableServer_ImplicitActivationPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ImplicitActivationPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ImplicitActivationPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ImplicitActivationPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::ImplicitActivationPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::ImplicitActivationPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ImplicitActivationPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_ImplicitActivationPolicy_optable_pool [_tao_PortableServer_ImplicitActivationPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ImplicitActivationPolicy_allocator (_tao_PortableServer_ImplicitActivationPolicy_optable_pool, _tao_PortableServer_ImplicitActivationPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ImplicitActivationPolicy_optable (PortableServer_ImplicitActivationPolicy_operations, 5, 10, &_tao_PortableServer_ImplicitActivationPolicy_allocator);

// skeleton constructor
POA_PortableServer::ImplicitActivationPolicy::ImplicitActivationPolicy (void)
{
  this->optable_ = &tao_PortableServer_ImplicitActivationPolicy_optable;
}

void POA_PortableServer::ImplicitActivationPolicy::_get_value_skel (
                                                                    CORBA::ServerRequest &_tao_server_request,
                                                                    void *_tao_object_reference,
                                                                    void * /* context */,
                                                                    CORBA::Environment &_tao_orb_environment
                                                                    )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_ImplicitActivationPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_ImplicitActivationPolicyValue, 0, 0}
  }; // PortableServer_ImplicitActivationPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_ImplicitActivationPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_ImplicitActivationPolicy_value_paramdata};

  POA_PortableServer::ImplicitActivationPolicy *_tao_impl = (POA_PortableServer::ImplicitActivationPolicy *)_tao_object_reference;
  PortableServer::ImplicitActivationPolicyValue _tao_retval;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &_get_PortableServer_ImplicitActivationPolicy_value_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
                                  _tao_orb_environment
                                  );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &_get_PortableServer_ImplicitActivationPolicy_value_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::ImplicitActivationPolicy::_is_a_skel (
                                                               CORBA::ServerRequest &_tao_server_request,
                                                               void * _tao_object_reference,
                                                               void * /*context*/,
                                                               CORBA::Environment &_tao_orb_environment
                                                               )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ImplicitActivationPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ImplicitActivationPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ImplicitActivationPolicy_is_a_paramdata};
  POA_PortableServer::ImplicitActivationPolicy_ptr  _tao_impl = (POA_PortableServer::ImplicitActivationPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_ImplicitActivationPolicy_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_ImplicitActivationPolicy_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ImplicitActivationPolicy::_is_a (
                                                                    const char* value,
                                                                    CORBA::Environment &_tao_orb_environment
                                                                    )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ImplicitActivationPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ImplicitActivationPolicy::_downcast (
                                                               const char* logical_type_id
                                                               )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ImplicitActivationPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ImplicitActivationPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ImplicitActivationPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::ImplicitActivationPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ImplicitActivationPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_tao_collocated_ImplicitActivationPolicy (
                                                                                                        POA_PortableServer::ImplicitActivationPolicy_ptr  servant,
                                                                                                        STUB_Object *stub
                                                                                                        )
  : ACE_NESTED_CLASS (PortableServer, ImplicitActivationPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_is_a (
                                                                                    const char* logical_type_id,
                                                                                    CORBA::Environment &_tao_orb_environment
                                                                                    )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::copy (
                                                                                      CORBA::Environment &_tao_orb_environment
                                                                                      )
{
  return this->servant_->copy (
                               _tao_orb_environment
                               );
}

void POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::destroy (
                                                                            CORBA::Environment &_tao_orb_environment
                                                                            )
{
  this->servant_->destroy (
                           _tao_orb_environment
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::policy_type (
                                                                                             CORBA::Environment &_tao_orb_environment
                                                                                             )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::ImplicitActivationPolicyValue
POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::value (
                                                                     CORBA::Environment &_tao_orb_environment
                                                                     )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::ImplicitActivationPolicy*
POA_PortableServer::ImplicitActivationPolicy::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ImplicitActivationPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantRetentionPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ServantRetentionPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ServantRetentionPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ServantRetentionPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::ServantRetentionPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::ServantRetentionPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantRetentionPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_ServantRetentionPolicy_optable_pool [_tao_PortableServer_ServantRetentionPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantRetentionPolicy_allocator (_tao_PortableServer_ServantRetentionPolicy_optable_pool, _tao_PortableServer_ServantRetentionPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantRetentionPolicy_optable (PortableServer_ServantRetentionPolicy_operations, 5, 10, &_tao_PortableServer_ServantRetentionPolicy_allocator);

// skeleton constructor
POA_PortableServer::ServantRetentionPolicy::ServantRetentionPolicy (void)
{
  this->optable_ = &tao_PortableServer_ServantRetentionPolicy_optable;
}

void POA_PortableServer::ServantRetentionPolicy::_get_value_skel (
                                                                  CORBA::ServerRequest &_tao_server_request,
                                                                  void *_tao_object_reference,
                                                                  void * /* context */,
                                                                  CORBA::Environment &_tao_orb_environment
                                                                  )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_ServantRetentionPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_ServantRetentionPolicyValue, 0, 0}
  }; // PortableServer_ServantRetentionPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_ServantRetentionPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_ServantRetentionPolicy_value_paramdata};

  POA_PortableServer::ServantRetentionPolicy *_tao_impl = (POA_PortableServer::ServantRetentionPolicy *)_tao_object_reference;
  PortableServer::ServantRetentionPolicyValue _tao_retval;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &_get_PortableServer_ServantRetentionPolicy_value_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
                                  _tao_orb_environment
                                  );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &_get_PortableServer_ServantRetentionPolicy_value_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::ServantRetentionPolicy::_is_a_skel (
                                                             CORBA::ServerRequest &_tao_server_request,
                                                             void * _tao_object_reference,
                                                             void * /*context*/,
                                                             CORBA::Environment &_tao_orb_environment
                                                             )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantRetentionPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantRetentionPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantRetentionPolicy_is_a_paramdata};
  POA_PortableServer::ServantRetentionPolicy_ptr  _tao_impl = (POA_PortableServer::ServantRetentionPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_ServantRetentionPolicy_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_ServantRetentionPolicy_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantRetentionPolicy::_is_a (
                                                                  const char* value,
                                                                  CORBA::Environment &_tao_orb_environment
                                                                  )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantRetentionPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantRetentionPolicy::_downcast (
                                                             const char* logical_type_id
                                                             )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantRetentionPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantRetentionPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantRetentionPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::ServantRetentionPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantRetentionPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_tao_collocated_ServantRetentionPolicy (
                                                                                                    POA_PortableServer::ServantRetentionPolicy_ptr  servant,
                                                                                                    STUB_Object *stub
                                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, ServantRetentionPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_is_a (
                                                                                  const char* logical_type_id,
                                                                                  CORBA::Environment &_tao_orb_environment
                                                                                  )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ServantRetentionPolicy::copy (
                                                                                    CORBA::Environment &_tao_orb_environment
                                                                                    )
{
  return this->servant_->copy (
                               _tao_orb_environment
                               );
}

void POA_PortableServer::_tao_collocated_ServantRetentionPolicy::destroy (
                                                                          CORBA::Environment &_tao_orb_environment
                                                                          )
{
  this->servant_->destroy (
                           _tao_orb_environment
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ServantRetentionPolicy::policy_type (
                                                                                           CORBA::Environment &_tao_orb_environment
                                                                                           )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::ServantRetentionPolicyValue
POA_PortableServer::_tao_collocated_ServantRetentionPolicy::value (
                                                                   CORBA::Environment &_tao_orb_environment
                                                                   )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::ServantRetentionPolicy*
POA_PortableServer::ServantRetentionPolicy::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantRetentionPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_RequestProcessingPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::RequestProcessingPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::RequestProcessingPolicy::copy_skel},
  {"destroy", &POA_PortableServer::RequestProcessingPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::RequestProcessingPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::RequestProcessingPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_RequestProcessingPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_RequestProcessingPolicy_optable_pool [_tao_PortableServer_RequestProcessingPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_RequestProcessingPolicy_allocator (_tao_PortableServer_RequestProcessingPolicy_optable_pool, _tao_PortableServer_RequestProcessingPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_RequestProcessingPolicy_optable (PortableServer_RequestProcessingPolicy_operations, 5, 10, &_tao_PortableServer_RequestProcessingPolicy_allocator);

// skeleton constructor
POA_PortableServer::RequestProcessingPolicy::RequestProcessingPolicy (void)
{
  this->optable_ = &tao_PortableServer_RequestProcessingPolicy_optable;
}

void POA_PortableServer::RequestProcessingPolicy::_get_value_skel (
                                                                   CORBA::ServerRequest &_tao_server_request,
                                                                   void *_tao_object_reference,
                                                                   void * /* context */,
                                                                   CORBA::Environment &_tao_orb_environment
                                                                   )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_RequestProcessingPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_RequestProcessingPolicyValue, 0, 0}
  }; // PortableServer_RequestProcessingPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_RequestProcessingPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_RequestProcessingPolicy_value_paramdata};

  POA_PortableServer::RequestProcessingPolicy *_tao_impl = (POA_PortableServer::RequestProcessingPolicy *)_tao_object_reference;
  PortableServer::RequestProcessingPolicyValue _tao_retval;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &_get_PortableServer_RequestProcessingPolicy_value_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
                                  _tao_orb_environment
                                  );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &_get_PortableServer_RequestProcessingPolicy_value_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::RequestProcessingPolicy::_is_a_skel (
                                                              CORBA::ServerRequest &_tao_server_request,
                                                              void * _tao_object_reference,
                                                              void * /*context*/,
                                                              CORBA::Environment &_tao_orb_environment
                                                              )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_RequestProcessingPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_RequestProcessingPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_RequestProcessingPolicy_is_a_paramdata};
  POA_PortableServer::RequestProcessingPolicy_ptr  _tao_impl = (POA_PortableServer::RequestProcessingPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_RequestProcessingPolicy_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_RequestProcessingPolicy_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::RequestProcessingPolicy::_is_a (
                                                                   const char* value,
                                                                   CORBA::Environment &_tao_orb_environment
                                                                   )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/RequestProcessingPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::RequestProcessingPolicy::_downcast (
                                                              const char* logical_type_id
                                                              )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/RequestProcessingPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::RequestProcessingPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::RequestProcessingPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::RequestProcessingPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/RequestProcessingPolicy:1.0";
}

POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_tao_collocated_RequestProcessingPolicy (
                                                                                                      POA_PortableServer::RequestProcessingPolicy_ptr  servant,
                                                                                                      STUB_Object *stub
                                                                                                      )
  : ACE_NESTED_CLASS (PortableServer, RequestProcessingPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_is_a (
                                                                                   const char* logical_type_id,
                                                                                   CORBA::Environment &_tao_orb_environment
                                                                                   )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_RequestProcessingPolicy::copy (
                                                                                     CORBA::Environment &_tao_orb_environment
                                                                                     )
{
  return this->servant_->copy (
                               _tao_orb_environment
                               );
}

void POA_PortableServer::_tao_collocated_RequestProcessingPolicy::destroy (
                                                                           CORBA::Environment &_tao_orb_environment
                                                                           )
{
  this->servant_->destroy (
                           _tao_orb_environment
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_RequestProcessingPolicy::policy_type (
                                                                                            CORBA::Environment &_tao_orb_environment
                                                                                            )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::RequestProcessingPolicyValue
POA_PortableServer::_tao_collocated_RequestProcessingPolicy::value (
                                                                    CORBA::Environment &_tao_orb_environment
                                                                    )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::RequestProcessingPolicy*
POA_PortableServer::RequestProcessingPolicy::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_RequestProcessingPolicy (this, stub);
}

#endif /* TAO_HAS_MINIMUM_CORBA */

static const TAO_operation_db_entry PortableServer_POAManager_operations [] = {
  {"_is_a", &POA_PortableServer::POAManager::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_POAManager_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_POAManager_optable_pool [_tao_PortableServer_POAManager_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_POAManager_allocator (_tao_PortableServer_POAManager_optable_pool, _tao_PortableServer_POAManager_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_POAManager_optable (PortableServer_POAManager_operations, 1, 1, &_tao_PortableServer_POAManager_allocator);

// skeleton constructor
POA_PortableServer::POAManager::POAManager (void)
{
  this->optable_ = &tao_PortableServer_POAManager_optable;
}

void POA_PortableServer::POAManager::_is_a_skel (
                                                 CORBA::ServerRequest &_tao_server_request,
                                                 void * _tao_object_reference,
                                                 void * /*context*/,
                                                 CORBA::Environment &_tao_orb_environment
                                                 )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_POAManager_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_POAManager_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_POAManager_is_a_paramdata};
  POA_PortableServer::POAManager_ptr  _tao_impl = (POA_PortableServer::POAManager_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_POAManager_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_POAManager_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::POAManager::_is_a (
                                                      const char* value,
                                                      CORBA::Environment &_tao_orb_environment
                                                      )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POAManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::POAManager::_downcast (
                                                 const char* logical_type_id
                                                 )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/POAManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POAManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::POAManager::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::POAManager::_interface_repository_id (void) const
{
  return "IDL:PortableServer/POAManager:1.0";
}

POA_PortableServer::_tao_collocated_POAManager::_tao_collocated_POAManager (
                                                                            POA_PortableServer::POAManager_ptr  servant,
                                                                            STUB_Object *stub
                                                                            )
  : ACE_NESTED_CLASS (PortableServer, POAManager) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::POAManager_ptr POA_PortableServer::_tao_collocated_POAManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POAManager::_is_a (
                                                                      const char* logical_type_id,
                                                                      CORBA::Environment &_tao_orb_environment
                                                                      )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

void POA_PortableServer::_tao_collocated_POAManager::activate (
                                                               CORBA::Environment &_tao_orb_environment
                                                               )
{
  this->servant_->activate (
                            _tao_orb_environment
                            );
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

void POA_PortableServer::_tao_collocated_POAManager::hold_requests (
                                                                    CORBA::Boolean wait_for_completion,
                                                                    CORBA::Environment &_tao_orb_environment
                                                                    )
{
  this->servant_->hold_requests (
                                 wait_for_completion,
                                 _tao_orb_environment
                                 );
}

void POA_PortableServer::_tao_collocated_POAManager::discard_requests (
                                                                       CORBA::Boolean wait_for_completion,
                                                                       CORBA::Environment &_tao_orb_environment
                                                                       )
{
  this->servant_->discard_requests (
                                    wait_for_completion,
                                    _tao_orb_environment
                                    );
}

void POA_PortableServer::_tao_collocated_POAManager::deactivate (
                                                                 CORBA::Boolean etherealize_objects,
                                                                 CORBA::Boolean wait_for_completion,
                                                                 CORBA::Environment &_tao_orb_environment
                                                                 )
{
  this->servant_->deactivate (
                              etherealize_objects,
                              wait_for_completion,
                              _tao_orb_environment
                              );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::POAManager*
POA_PortableServer::POAManager::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_POAManager (this, stub);
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

static const TAO_operation_db_entry PortableServer_AdapterActivator_operations [] = {
  {"_is_a", &POA_PortableServer::AdapterActivator::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_AdapterActivator_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_AdapterActivator_optable_pool [_tao_PortableServer_AdapterActivator_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_AdapterActivator_allocator (_tao_PortableServer_AdapterActivator_optable_pool, _tao_PortableServer_AdapterActivator_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_AdapterActivator_optable (PortableServer_AdapterActivator_operations, 1, 1, &_tao_PortableServer_AdapterActivator_allocator);

// skeleton constructor
POA_PortableServer::AdapterActivator::AdapterActivator (void)
{
  this->optable_ = &tao_PortableServer_AdapterActivator_optable;
}

void POA_PortableServer::AdapterActivator::_is_a_skel (
                                                       CORBA::ServerRequest &_tao_server_request,
                                                       void * _tao_object_reference,
                                                       void * /*context*/,
                                                       CORBA::Environment &_tao_orb_environment
                                                       )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_AdapterActivator_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_AdapterActivator_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_AdapterActivator_is_a_paramdata};
  POA_PortableServer::AdapterActivator_ptr  _tao_impl = (POA_PortableServer::AdapterActivator_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_AdapterActivator_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_AdapterActivator_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::AdapterActivator::_is_a (
                                                            const char* value,
                                                            CORBA::Environment &_tao_orb_environment
                                                            )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/AdapterActivator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::AdapterActivator::_downcast (
                                                       const char* logical_type_id
                                                       )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/AdapterActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::AdapterActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::AdapterActivator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::AdapterActivator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/AdapterActivator:1.0";
}

POA_PortableServer::_tao_collocated_AdapterActivator::_tao_collocated_AdapterActivator (
                                                                                        POA_PortableServer::AdapterActivator_ptr  servant,
                                                                                        STUB_Object *stub
                                                                                        )
  : ACE_NESTED_CLASS (PortableServer, AdapterActivator) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::AdapterActivator_ptr POA_PortableServer::_tao_collocated_AdapterActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::_is_a (
                                                                            const char* logical_type_id,
                                                                            CORBA::Environment &_tao_orb_environment
                                                                            )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::unknown_adapter (
                                                                                      PortableServer::POA_ptr  parent,
                                                                                      const char* name,
                                                                                      CORBA::Environment &_tao_orb_environment
                                                                                      )
{
  return this->servant_->unknown_adapter (
                                          parent,
                                          name,
                                          _tao_orb_environment
                                          );
}


PortableServer::AdapterActivator*
POA_PortableServer::AdapterActivator::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_AdapterActivator (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantManager_operations [] = {
  {"_is_a", &POA_PortableServer::ServantManager::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantManager_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_ServantManager_optable_pool [_tao_PortableServer_ServantManager_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantManager_allocator (_tao_PortableServer_ServantManager_optable_pool, _tao_PortableServer_ServantManager_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantManager_optable (PortableServer_ServantManager_operations, 1, 1, &_tao_PortableServer_ServantManager_allocator);

// skeleton constructor
POA_PortableServer::ServantManager::ServantManager (void)
{
  this->optable_ = &tao_PortableServer_ServantManager_optable;
}

void POA_PortableServer::ServantManager::_is_a_skel (
                                                     CORBA::ServerRequest &_tao_server_request,
                                                     void * _tao_object_reference,
                                                     void * /*context*/,
                                                     CORBA::Environment &_tao_orb_environment
                                                     )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantManager_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantManager_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantManager_is_a_paramdata};
  POA_PortableServer::ServantManager_ptr  _tao_impl = (POA_PortableServer::ServantManager_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_ServantManager_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_ServantManager_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantManager::_is_a (
                                                          const char* value,
                                                          CORBA::Environment &_tao_orb_environment
                                                          )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantManager::_downcast (
                                                     const char* logical_type_id
                                                     )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantManager::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::ServantManager::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantManager:1.0";
}

POA_PortableServer::_tao_collocated_ServantManager::_tao_collocated_ServantManager (
                                                                                    POA_PortableServer::ServantManager_ptr  servant,
                                                                                    STUB_Object *stub
                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, ServantManager) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_ServantManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantManager::_is_a (
                                                                          const char* logical_type_id,
                                                                          CORBA::Environment &_tao_orb_environment
                                                                          )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}


PortableServer::ServantManager*
POA_PortableServer::ServantManager::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantManager (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantActivator_operations [] = {
  {"_is_a", &POA_PortableServer::ServantActivator::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantActivator_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_ServantActivator_optable_pool [_tao_PortableServer_ServantActivator_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantActivator_allocator (_tao_PortableServer_ServantActivator_optable_pool, _tao_PortableServer_ServantActivator_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantActivator_optable (PortableServer_ServantActivator_operations, 1, 1, &_tao_PortableServer_ServantActivator_allocator);

// skeleton constructor
POA_PortableServer::ServantActivator::ServantActivator (void)
{
  this->optable_ = &tao_PortableServer_ServantActivator_optable;
}

void POA_PortableServer::ServantActivator::_is_a_skel (
                                                       CORBA::ServerRequest &_tao_server_request,
                                                       void * _tao_object_reference,
                                                       void * /*context*/,
                                                       CORBA::Environment &_tao_orb_environment
                                                       )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantActivator_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantActivator_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantActivator_is_a_paramdata};
  POA_PortableServer::ServantActivator_ptr  _tao_impl = (POA_PortableServer::ServantActivator_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_ServantActivator_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_ServantActivator_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantActivator::_is_a (
                                                            const char* value,
                                                            CORBA::Environment &_tao_orb_environment
                                                            )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantActivator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantActivator::_downcast (
                                                       const char* logical_type_id
                                                       )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantActivator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::ServantActivator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantActivator:1.0";
}

POA_PortableServer::_tao_collocated_ServantActivator::_tao_collocated_ServantActivator (
                                                                                        POA_PortableServer::ServantActivator_ptr  servant,
                                                                                        STUB_Object *stub
                                                                                        )
  : ACE_NESTED_CLASS (PortableServer, ServantActivator) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_PortableServer, _tao_collocated_ServantManager) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantActivator_ptr POA_PortableServer::_tao_collocated_ServantActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantActivator::_is_a (
                                                                            const char* logical_type_id,
                                                                            CORBA::Environment &_tao_orb_environment
                                                                            )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantActivator::incarnate (
                                                                                         const PortableServer::ObjectId & oid,
                                                                                         PortableServer::POA_ptr  adapter,
                                                                                         CORBA::Environment &_tao_orb_environment
                                                                                         )
{
  return this->servant_->incarnate (
                                    oid,
                                    adapter,
                                    _tao_orb_environment
                                    );
}

void POA_PortableServer::_tao_collocated_ServantActivator::etherealize (
                                                                        const PortableServer::ObjectId & oid,
                                                                        PortableServer::POA_ptr  adapter,
                                                                        PortableServer::Servant serv,
                                                                        CORBA::Boolean cleanup_in_progress,
                                                                        CORBA::Boolean remaining_activations,
                                                                        CORBA::Environment &_tao_orb_environment
                                                                        )
{
  this->servant_->etherealize (
                               oid,
                               adapter,
                               serv,
                               cleanup_in_progress,
                               remaining_activations,
                               _tao_orb_environment
                               );
}


PortableServer::ServantActivator*
POA_PortableServer::ServantActivator::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantActivator (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantLocator_operations [] = {
  {"_is_a", &POA_PortableServer::ServantLocator::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantLocator_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_ServantLocator_optable_pool [_tao_PortableServer_ServantLocator_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantLocator_allocator (_tao_PortableServer_ServantLocator_optable_pool, _tao_PortableServer_ServantLocator_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantLocator_optable (PortableServer_ServantLocator_operations, 1, 1, &_tao_PortableServer_ServantLocator_allocator);

// skeleton constructor
POA_PortableServer::ServantLocator::ServantLocator (void)
{
  this->optable_ = &tao_PortableServer_ServantLocator_optable;
}

void POA_PortableServer::ServantLocator::_is_a_skel (
                                                     CORBA::ServerRequest &_tao_server_request,
                                                     void * _tao_object_reference,
                                                     void * /*context*/,
                                                     CORBA::Environment &_tao_orb_environment
                                                     )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantLocator_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantLocator_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantLocator_is_a_paramdata};
  POA_PortableServer::ServantLocator_ptr  _tao_impl = (POA_PortableServer::ServantLocator_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_ServantLocator_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_ServantLocator_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantLocator::_is_a (
                                                          const char* value,
                                                          CORBA::Environment &_tao_orb_environment
                                                          )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantLocator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantLocator::_downcast (
                                                     const char* logical_type_id
                                                     )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantLocator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantLocator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantLocator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::ServantLocator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantLocator:1.0";
}

POA_PortableServer::_tao_collocated_ServantLocator::_tao_collocated_ServantLocator (
                                                                                    POA_PortableServer::ServantLocator_ptr  servant,
                                                                                    STUB_Object *stub
                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, ServantLocator) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_PortableServer, _tao_collocated_ServantManager) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantLocator_ptr POA_PortableServer::_tao_collocated_ServantLocator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantLocator::_is_a (
                                                                          const char* logical_type_id,
                                                                          CORBA::Environment &_tao_orb_environment
                                                                          )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantLocator::preinvoke (
                                                                                       const PortableServer::ObjectId & oid,
                                                                                       PortableServer::POA_ptr  adapter,
                                                                                       const char * operation,
                                                                                       PortableServer::ServantLocator::Cookie & the_cookie,
                                                                                       CORBA::Environment &_tao_orb_environment
                                                                                       )
{
  return this->servant_->preinvoke (
                                    oid,
                                    adapter,
                                    operation,
                                    the_cookie,
                                    _tao_orb_environment
                                    );
}

void POA_PortableServer::_tao_collocated_ServantLocator::postinvoke (
                                                                     const PortableServer::ObjectId & oid,
                                                                     PortableServer::POA_ptr  adapter,
                                                                     const char * operation,
                                                                     PortableServer::ServantLocator::Cookie the_cookie,
                                                                     PortableServer::Servant the_servant,
                                                                     CORBA::Environment &_tao_orb_environment
                                                                     )
{
  this->servant_->postinvoke (
                              oid,
                              adapter,
                              operation,
                              the_cookie,
                              the_servant,
                              _tao_orb_environment
                              );
}


PortableServer::ServantLocator*
POA_PortableServer::ServantLocator::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantLocator (this, stub);
}

#endif /* TAO_HAS_MINIMUM_CORBA */

static const TAO_operation_db_entry PortableServer_POA_operations [] = {
  {"_is_a", &POA_PortableServer::POA::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_POA_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_POA_optable_pool [_tao_PortableServer_POA_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_POA_allocator (_tao_PortableServer_POA_optable_pool, _tao_PortableServer_POA_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_POA_optable (PortableServer_POA_operations, 1, 1, &_tao_PortableServer_POA_allocator);

// skeleton constructor
POA_PortableServer::POA::POA (void)
{
  this->optable_ = &tao_PortableServer_POA_optable;
}

void POA_PortableServer::POA::_is_a_skel (
                                          CORBA::ServerRequest &_tao_server_request,
                                          void * _tao_object_reference,
                                          void * /*context*/,
                                          CORBA::Environment &_tao_orb_environment
                                          )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_POA_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_POA_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_POA_is_a_paramdata};
  POA_PortableServer::POA_ptr  _tao_impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_POA_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_POA_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::POA::_is_a (
                                               const char* value,
                                               CORBA::Environment &_tao_orb_environment
                                               )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POA:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::POA::_downcast (
                                          const char* logical_type_id
                                          )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/POA:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POA_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::POA::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::POA::_interface_repository_id (void) const
{
  return "IDL:PortableServer/POA:1.0";
}

POA_PortableServer::_tao_collocated_POA::_tao_collocated_POA (
                                                              POA_PortableServer::POA_ptr  servant,
                                                              STUB_Object *stub
                                                              )
  : ACE_NESTED_CLASS (PortableServer, POA) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POA::_is_a (
                                                               const char* logical_type_id,
                                                               CORBA::Environment &_tao_orb_environment
                                                               )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::create_POA (
                                                                             const char* adapter_name,
                                                                             PortableServer::POAManager_ptr  a_POAManager,
                                                                             const CORBA::PolicyList & policies,
                                                                             CORBA::Environment &_tao_orb_environment
                                                                             )
{
  return this->servant_->create_POA (
                                     adapter_name,
                                     a_POAManager,
                                     policies,
                                     _tao_orb_environment
                                     );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::find_POA (
                                                                           const char* adapter_name,
                                                                           CORBA::Boolean activate_it,
                                                                           CORBA::Environment &_tao_orb_environment
                                                                           )
{
  return this->servant_->find_POA (
                                   adapter_name,
                                   activate_it,
                                   _tao_orb_environment
                                   );
}

void POA_PortableServer::_tao_collocated_POA::destroy (
                                                       CORBA::Boolean etherealize_objects,
                                                       CORBA::Boolean wait_for_completion,
                                                       CORBA::Environment &_tao_orb_environment
                                                       )
{
  this->servant_->destroy (
                           etherealize_objects,
                           wait_for_completion,
                           _tao_orb_environment
                           );
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_thread_policy (
                                                                                                PortableServer::ThreadPolicyValue value,
                                                                                                CORBA::Environment &_tao_orb_environment
                                                                                                )
{
  return this->servant_->create_thread_policy (
                                               value,
                                               _tao_orb_environment
                                               );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_lifespan_policy (
                                                                                                    PortableServer::LifespanPolicyValue value,
                                                                                                    CORBA::Environment &_tao_orb_environment
                                                                                                    )
{
  return this->servant_->create_lifespan_policy (
                                                 value,
                                                 _tao_orb_environment
                                                 );
}

PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_uniqueness_policy (
                                                                                                             PortableServer::IdUniquenessPolicyValue value,
                                                                                                             CORBA::Environment &_tao_orb_environment
                                                                                                             )
{
  return this->servant_->create_id_uniqueness_policy (
                                                      value,
                                                      _tao_orb_environment
                                                      );
}

PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_assignment_policy (
                                                                                                             PortableServer::IdAssignmentPolicyValue value,
                                                                                                             CORBA::Environment &_tao_orb_environment
                                                                                                             )
{
  return this->servant_->create_id_assignment_policy (
                                                      value,
                                                      _tao_orb_environment
                                                      );
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_implicit_activation_policy (
                                                                                                                         PortableServer::ImplicitActivationPolicyValue value,
                                                                                                                         CORBA::Environment &_tao_orb_environment
                                                                                                                         )
{
  return this->servant_->create_implicit_activation_policy (
                                                            value,
                                                            _tao_orb_environment
                                                            );
}

PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_servant_retention_policy (
                                                                                                                     PortableServer::ServantRetentionPolicyValue value,
                                                                                                                     CORBA::Environment &_tao_orb_environment
                                                                                                                     )
{
  return this->servant_->create_servant_retention_policy (
                                                          value,
                                                          _tao_orb_environment
                                                          );
}

PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_request_processing_policy (
                                                                                                                       PortableServer::RequestProcessingPolicyValue value,
                                                                                                                       CORBA::Environment &_tao_orb_environment
                                                                                                                       )
{
  return this->servant_->create_request_processing_policy (
                                                           value,
                                                           _tao_orb_environment
                                                           );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

char*
POA_PortableServer::_tao_collocated_POA::the_name (
                                                   CORBA::Environment &_tao_orb_environment
                                                   )
{
  return this->servant_->the_name(_tao_orb_environment);
}
PortableServer::POA_ptr
POA_PortableServer::_tao_collocated_POA::the_parent (
                                                     CORBA::Environment &_tao_orb_environment
                                                     )
{
  return this->servant_->the_parent(_tao_orb_environment);
}
PortableServer::POAManager_ptr
POA_PortableServer::_tao_collocated_POA::the_POAManager (
                                                         CORBA::Environment &_tao_orb_environment
                                                         )
{
  return this->servant_->the_POAManager(_tao_orb_environment);
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

PortableServer::AdapterActivator_ptr
POA_PortableServer::_tao_collocated_POA::the_activator (
                                                        CORBA::Environment &_tao_orb_environment
                                                        )
{
  return this->servant_->the_activator(_tao_orb_environment);
}

void POA_PortableServer::_tao_collocated_POA::the_activator (
                                                             PortableServer::AdapterActivator_ptr _tao_value,
                                                             CORBA::Environment &_tao_orb_environment
                                                             )
{
  this->servant_->the_activator (
                                 _tao_value,
                                 _tao_orb_environment
                                 );
}

PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_POA::get_servant_manager (
                                                                                                 CORBA::Environment &_tao_orb_environment
                                                                                                 )
{
  return this->servant_->get_servant_manager (
                                              _tao_orb_environment
                                              );
}

void POA_PortableServer::_tao_collocated_POA::set_servant_manager (
                                                                   PortableServer::ServantManager_ptr  imgr,
                                                                   CORBA::Environment &_tao_orb_environment
                                                                   )
{
  this->servant_->set_servant_manager (
                                       imgr,
                                       _tao_orb_environment
                                       );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::get_servant (
                                                                              CORBA::Environment &_tao_orb_environment
                                                                              )
{
  return this->servant_->get_servant (
                                      _tao_orb_environment
                                      );
}

void POA_PortableServer::_tao_collocated_POA::set_servant (
                                                           PortableServer::Servant p_servant,
                                                           CORBA::Environment &_tao_orb_environment
                                                           )
{
  this->servant_->set_servant (
                               p_servant,
                               _tao_orb_environment
                               );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::activate_object (
                                                                                     PortableServer::Servant p_servant,
                                                                                     CORBA::Environment &_tao_orb_environment
                                                                                     )
{
  return this->servant_->activate_object (
                                          p_servant,
                                          _tao_orb_environment
                                          );
}

void POA_PortableServer::_tao_collocated_POA::activate_object_with_id (
                                                                       const PortableServer::ObjectId & id,
                                                                       PortableServer::Servant p_servant,
                                                                       CORBA::Environment &_tao_orb_environment
                                                                       )
{
  this->servant_->activate_object_with_id (
                                           id,
                                           p_servant,
                                           _tao_orb_environment
                                           );
}

void POA_PortableServer::_tao_collocated_POA::deactivate_object (
                                                                 const PortableServer::ObjectId & oid,
                                                                 CORBA::Environment &_tao_orb_environment
                                                                 )
{
  this->servant_->deactivate_object (
                                     oid,
                                     _tao_orb_environment
                                     );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference (
                                                                             const char *intf,
                                                                             CORBA::Environment &_tao_orb_environment
                                                                             )
{
  return this->servant_->create_reference (
                                           intf,
                                           _tao_orb_environment
                                           );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference_with_id (
                                                                                     const PortableServer::ObjectId & oid,
                                                                                     const char *intf,
                                                                                     CORBA::Environment &_tao_orb_environment
                                                                                     )
{
  return this->servant_->create_reference_with_id (
                                                   oid,
                                                   intf,
                                                   _tao_orb_environment
                                                   );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::servant_to_id (
                                                                                   PortableServer::Servant p_servant,
                                                                                   CORBA::Environment &_tao_orb_environment
                                                                                   )
{
  return this->servant_->servant_to_id (
                                        p_servant,
                                        _tao_orb_environment
                                        );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::servant_to_reference (
                                                                                 PortableServer::Servant p_servant,
                                                                                 CORBA::Environment &_tao_orb_environment
                                                                                 )
{
  return this->servant_->servant_to_reference (
                                               p_servant,
                                               _tao_orb_environment
                                               );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::reference_to_servant (
                                                                                       CORBA::Object_ptr  reference,
                                                                                       CORBA::Environment &_tao_orb_environment
                                                                                       )
{
  return this->servant_->reference_to_servant (
                                               reference,
                                               _tao_orb_environment
                                               );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::reference_to_id (
                                                                                     CORBA::Object_ptr  reference,
                                                                                     CORBA::Environment &_tao_orb_environment
                                                                                     )
{
  return this->servant_->reference_to_id (
                                          reference,
                                          _tao_orb_environment
                                          );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::id_to_servant (
                                                                                const PortableServer::ObjectId & oid,
                                                                                CORBA::Environment &_tao_orb_environment
                                                                                )
{
  return this->servant_->id_to_servant (
                                        oid,
                                        _tao_orb_environment
                                        );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::id_to_reference (
                                                                            const PortableServer::ObjectId & oid,
                                                                            CORBA::Environment &_tao_orb_environment
                                                                            )
{
  return this->servant_->id_to_reference (
                                          oid,
                                          _tao_orb_environment
                                          );
}


PortableServer::POA*
POA_PortableServer::POA::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_POA (this, stub);
}

static const TAO_operation_db_entry PortableServer_Current_operations [] = {
  {"get_POA", &POA_PortableServer::Current::get_POA_skel},
  {"get_object_id", &POA_PortableServer::Current::get_object_id_skel},
  {"_is_a", &POA_PortableServer::Current::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_Current_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (9);
static char _tao_PortableServer_Current_optable_pool [_tao_PortableServer_Current_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_Current_allocator (_tao_PortableServer_Current_optable_pool, _tao_PortableServer_Current_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_Current_optable (PortableServer_Current_operations, 3, 6, &_tao_PortableServer_Current_allocator);

// skeleton constructor
POA_PortableServer::Current::Current (void)
{
  this->optable_ = &tao_PortableServer_Current_optable;
}

void POA_PortableServer::Current::get_POA_skel (
                                                CORBA::ServerRequest &_tao_server_request,
                                                void *_tao_object_reference,
                                                void * /* context */,
                                                CORBA::Environment &_tao_orb_environment
                                                )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_Current_get_POA_paramdata [] =
  {
    {PortableServer::_tc_POA, 0, 0}
  }; // PortableServer_Current_get_POA_paramdata

  static const TAO_Call_Data_Skel PortableServer_Current_get_POA_calldata =
  {"get_POA", 1, 1, PortableServer_Current_get_POA_paramdata};

  POA_PortableServer::Current *_tao_impl = (POA_PortableServer::Current *)_tao_object_reference;
  CORBA::Object_ptr _tao_retval = CORBA::Object::_nil ();
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_Current_get_POA_calldata,
                                 &_tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->get_POA (
                                    _tao_orb_environment
                                    );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_Current_get_POA_calldata,
                               &_tao_retval
                               );
}

void POA_PortableServer::Current::get_object_id_skel (
                                                      CORBA::ServerRequest &_tao_server_request,
                                                      void *_tao_object_reference,
                                                      void * /* context */,
                                                      CORBA::Environment &_tao_orb_environment
                                                      )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_Current_get_object_id_paramdata [] =
  {
    {PortableServer::_tc_ObjectId, 0, 0}
  }; // PortableServer_Current_get_object_id_paramdata

  static const TAO_Call_Data_Skel PortableServer_Current_get_object_id_calldata =
  {"get_object_id", 1, 1, PortableServer_Current_get_object_id_paramdata};

  POA_PortableServer::Current *_tao_impl = (POA_PortableServer::Current *)_tao_object_reference;
  PortableServer::ObjectId *_tao_retval = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_Current_get_object_id_calldata,
                                 _tao_retval
                                 );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->get_object_id (
                                          _tao_orb_environment
                                          );
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_Current_get_object_id_calldata,
                               _tao_retval
                               );
}

void POA_PortableServer::Current::_is_a_skel (
                                              CORBA::ServerRequest &_tao_server_request,
                                              void * _tao_object_reference,
                                              void * /*context*/,
                                              CORBA::Environment &_tao_orb_environment
                                              )
{
  //  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_Current_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_Current_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_Current_is_a_paramdata};
  POA_PortableServer::Current_ptr  _tao_impl = (POA_PortableServer::Current_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
                                 _tao_orb_environment,
                                 &PortableServer_Current_is_a_calldata,
                                 &_tao_retval,
                                 &_tao_value
                                 );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_orb_environment);
  _tao_server_request.marshal (
                               _tao_orb_environment,
                               //                               _tao_skel_environment,
                               &PortableServer_Current_is_a_calldata,
                               &_tao_retval,
                               &_tao_value
                               );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::Current::_is_a (
                                                   const char* value,
                                                   CORBA::Environment &_tao_orb_environment
                                                   )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Current:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:CORBA/Current:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::Current::_downcast (
                                              const char* logical_type_id
                                              )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Current:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Current_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:CORBA/Current:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Current_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::Current::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
    {
      env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
      ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    }
  else
    skel (req, this, context, env);
}

const char* POA_PortableServer::Current::_interface_repository_id (void) const
{
  return "IDL:PortableServer/Current:1.0";
}

POA_PortableServer::_tao_collocated_Current::_tao_collocated_Current (
                                                                      POA_PortableServer::Current_ptr  servant,
                                                                      STUB_Object *stub
                                                                      )
  : ACE_NESTED_CLASS (PortableServer, Current) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Current) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::Current_ptr POA_PortableServer::_tao_collocated_Current::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_Current::_is_a (
                                                                   const char* logical_type_id,
                                                                   CORBA::Environment &_tao_orb_environment
                                                                   )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                _tao_orb_environment
                                );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_Current::get_POA (
                                                                              CORBA::Environment &_tao_orb_environment
                                                                              )
{
  return this->servant_->get_POA (
                                  _tao_orb_environment
                                  );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_Current::get_object_id (
                                                                                       CORBA::Environment &_tao_orb_environment
                                                                                       )
{
  return this->servant_->get_object_id (
                                        _tao_orb_environment
                                        );
}


PortableServer::Current*
POA_PortableServer::Current::_this (CORBA_Environment &TAO_IN_ENV)
{
  STUB_Object *stub = this->_create_stub (TAO_IN_ENV);
  if (TAO_IN_ENV.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_Current (this, stub);
}
