/* -*- C++ -*- */
// $Id $
// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html
// 
// Hand Modified by Vishal Kachroo <vishal@cs.wustl.edu>
//

#include "ObjectIDList.h"

#if !defined (__ACE_INLINE__)
#include "ObjectIDList.i"
#endif /* !defined INLINE */

#if !defined (_CORBA_ORB_OBJECTIDLIST_CS_)
#define _CORBA_ORB_OBJECTIDLIST_CS_

// *************************************************************
// CORBA_ORB_ObjectIdList
// *************************************************************

CORBA_ORB_ObjectIdList::CORBA_ORB_ObjectIdList (void)
{}
CORBA_ORB_ObjectIdList::CORBA_ORB_ObjectIdList (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA_ORB_ObjectIdList::CORBA_ORB_ObjectIdList (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA_ORB_ObjectIdList::CORBA_ORB_ObjectIdList (const CORBA_ORB_ObjectIdList &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA_ORB_ObjectIdList::~CORBA_ORB_ObjectIdList (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ORB_ObjectIdList[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f52), ACE_NTOHL (0x422f4f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x49644c69), ACE_NTOHL (0x73743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ORB/ObjectIdList:1.0
  13, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744964), ACE_NTOHL (0x4c697374), ACE_NTOHL (0x0),  // name = ObjectIdList
  CORBA::tk_sequence, // typecode kind
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f52), ACE_NTOHL (0x422f4f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ORB/ObjectId:1.0
      9, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744964), ACE_NTOHL (0x0),  // name = ObjectId
      CORBA::tk_string, 
      0, // string length
  0,
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ORB_ObjectIdList (CORBA::tk_alias, sizeof (_oc_CORBA_ORB_ObjectIdList), (char *) &_oc_CORBA_ORB_ObjectIdList, 0, sizeof (CORBA_ORB_ObjectIdList));
CORBA::TypeCode_ptr CORBA::ORB::_tc_ObjectIdList = &_tc_TAO_tc_CORBA_ORB_ObjectIdList;

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA_ORB_ObjectIdList &_tao_elem
  ) // copying
{
  CORBA_ORB_ObjectIdList *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA_ORB_ObjectIdList (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::ORB::_tc_ObjectIdList, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_ORB_ObjectIdList *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::ORB::_tc_ObjectIdList, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_ORB_ObjectIdList *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::ORB::_tc_ObjectIdList, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA_ORB_ObjectIdList *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA_ORB_ObjectIdList, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::ORB::_tc_ObjectIdList, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::ORB::_tc_ObjectIdList, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

