// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_COMPONENTSS_CPP_
#define _TAO_IDL__________ORBSVCS_IFR_SERVICE_ORIG_IFR_COMPONENTSS_CPP_

#include "IFR_ComponentsS.h"

#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"
#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_ComponentsS.i"
#endif /* !defined INLINE */

class TAO_IR_ComponentRepository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentRepository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 11,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 25,
     66,  0, 31, 15, 66, 10, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 25,  0, 30,
     66, 25, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66,  0,  5, 66, 66, 66,  0, 20, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66,
#else
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 11, 66, 25, 66,  0,
     31, 15, 66, 10, 66, 66, 66, 66, 25,  0,
     30, 66, 25, 66, 66,  0,  5, 66, 66, 66,
      0, 20, 66, 66, 66, 66, 66, 66,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 32,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 8,
      MAX_HASH_VALUE = 65,
      HASH_VALUE_RANGE = 58,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"contents", 	&POA_IR::ComponentRepository::contents_skel},
      {"create_enum", 	&POA_IR::ComponentRepository::create_enum_skel},
      {"create_alias", 	&POA_IR::ComponentRepository::create_alias_skel},
      {"create_value_box", 	&POA_IR::ComponentRepository::create_value_box_skel},
      {"create_struct", 	&POA_IR::ComponentRepository::create_struct_skel},
      {"create_constant", 	&POA_IR::ComponentRepository::create_constant_skel},
      {"create_component", 	&POA_IR::ComponentRepository::create_component_skel},
      {"create_string", 	&POA_IR::ComponentRepository::create_string_skel},
      {"create_wstring", 	&POA_IR::ComponentRepository::create_wstring_skel},
      {"create_home", 	&POA_IR::ComponentRepository::create_home_skel},
      {"create_value", 	&POA_IR::ComponentRepository::create_value_skel},
      {"create_module", 	&POA_IR::ComponentRepository::create_module_skel},
      {"create_native", 	&POA_IR::ComponentRepository::create_native_skel},
      {"_non_existent",  &POA_IR::ComponentRepository::_non_existent_skel},
      {"create_sequence", 	&POA_IR::ComponentRepository::create_sequence_skel},
      {"create_interface", 	&POA_IR::ComponentRepository::create_interface_skel},
      {"create_array", 	&POA_IR::ComponentRepository::create_array_skel},
      {"_interface",  &POA_IR::ComponentRepository::_interface_skel},
      {"create_local_interface", 	&POA_IR::ComponentRepository::create_local_interface_skel},
      {"get_primitive", 	&POA_IR::ComponentRepository::get_primitive_skel},
      {"create_abstract_interface", 	&POA_IR::ComponentRepository::create_abstract_interface_skel},
      {"_is_a",  &POA_IR::ComponentRepository::_is_a_skel},
      {"create_union", 	&POA_IR::ComponentRepository::create_union_skel},
      {"create_fixed", 	&POA_IR::ComponentRepository::create_fixed_skel},
      {"create_exception", 	&POA_IR::ComponentRepository::create_exception_skel},
      {"get_canonical_typecode", 	&POA_IR::ComponentRepository::get_canonical_typecode_skel},
      {"describe_contents", 	&POA_IR::ComponentRepository::describe_contents_skel},
      {"lookup_name", 	&POA_IR::ComponentRepository::lookup_name_skel},
      {"_get_def_kind", 	&POA_IR::ComponentRepository::_get_def_kind_skel},
      {"lookup", 	&POA_IR::ComponentRepository::lookup_skel},
      {"destroy", 	&POA_IR::ComponentRepository::destroy_skel},
      {"lookup_id", 	&POA_IR::ComponentRepository::lookup_id_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   8,  -1,  -1,   9,  10,  -1, 
      -19,  -2,  11,  -1,  12,  -1,  13,  14,  -1,  15,  16,  -1,  17,  18, 
      -79,  21,  22,  23,  24,  -1,  -1,  -1,  25,  26,  27,  -1,  28,  29, 
       30,  31,  -1,  -1,  32,  33,  34,  -1,  -1,  35,  -1,  -1,  -1,  36, 
       37,  -1,  38,  -1,  -1,  -1,  -1,  -1,  -1,  39, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_ComponentRepository_Perfect_Hash_OpTable tao_IR_ComponentRepository_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_ComponentRepository_create_component : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_component (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_component (const TAO_ServerRequestInfo_IR_ComponentRepository_create_component &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentRepository_create_component &);
  
private:
  POA_IR::ComponentRepository *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  IR::ComponentDef_ptr base_component_;
  const CORBA_InterfaceDefSeq & supports_interfaces_;
  IR::ComponentDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentRepository_create_component::TAO_ServerRequestInfo_IR_ComponentRepository_create_component (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_component_ (base_component),
    supports_interfaces_ (supports_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_component = parameter_list->length ();
  parameter_list->length (length_base_component + 1);
  (*parameter_list)[length_base_component].argument <<=  this->base_component_;
  
  (*parameter_list)[length_base_component].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_supports_interfaces = parameter_list->length ();
  parameter_list->length (length_supports_interfaces + 1);
  (*parameter_list)[length_supports_interfaces].argument <<=  this->supports_interfaces_;
  
  (*parameter_list)[length_supports_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentRepository_create_component::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentRepository_create_home : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_home (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentRepository_create_home (const TAO_ServerRequestInfo_IR_ComponentRepository_create_home &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentRepository_create_home &);
  
private:
  POA_IR::ComponentRepository *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  IR::HomeDef_ptr base_home_;
  IR::ComponentDef_ptr managed_component_;
  CORBA_ValueDef_ptr primary_key_;
  IR::HomeDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentRepository_create_home::TAO_ServerRequestInfo_IR_ComponentRepository_create_home (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_home_ (base_home),
    managed_component_ (managed_component),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_home = parameter_list->length ();
  parameter_list->length (length_base_home + 1);
  (*parameter_list)[length_base_home].argument <<=  this->base_home_;
  
  (*parameter_list)[length_base_home].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_managed_component = parameter_list->length ();
  parameter_list->length (length_managed_component + 1);
  (*parameter_list)[length_managed_component].argument <<=  this->managed_component_;
  
  (*parameter_list)[length_managed_component].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
  
  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentRepository_create_home::result (IR::HomeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::~_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_ComponentRepository_Proxy_Impl&
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::select_proxy (
    ::IR::ComponentRepository *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ComponentRepository_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ComponentRepository_Proxy_Broker *
IR__TAO_ComponentRepository_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker();
}

int
IR__TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_ComponentRepository_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_ComponentRepository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ComponentRepository_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::_TAO_ComponentRepository_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::ComponentDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const CORBA_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_component (
        id,
        name,
        version,
        base_component,
        supports_interfaces,
        ACE_TRY_ENV
      );
}

IR::HomeDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_home (
        id,
        name,
        version,
        base_home,
        managed_component,
        primary_key,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentRepository::ComponentRepository (void)
{
  this->optable_ = &tao_IR_ComponentRepository_optable;
}

// copy ctor
POA_IR::ComponentRepository::ComponentRepository (const ComponentRepository& rhs)
  :   POA_CORBA_Repository (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentRepository::~ComponentRepository (void)
{
}

void POA_IR::ComponentRepository::create_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;
  
    IR::ComponentDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ComponentDef_var base_component;
  CORBA_InterfaceDefSeq supports_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_component.out ()) &&
    (_tao_in >> supports_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentRepository_create_component ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_component.in (),
      supports_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_component (
          id.in (),
          name.in (),
          version.in (),
          base_component.in (),
          supports_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentRepository::create_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;
  
    IR::HomeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::HomeDef_var base_home;
  IR::ComponentDef_var managed_component;
  CORBA_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_home.out ()) &&
    (_tao_in >> managed_component.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentRepository_create_home ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_home.in (),
      managed_component.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_home (
          id.in (),
          name.in (),
          version.in (),
          base_home.in (),
          managed_component.in (),
          primary_key.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::HomeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentRepository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentRepository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentRepository::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ComponentRepository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentRepository::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentRepository:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentRepository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Repository:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentRepository::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::ComponentRepository*
POA_IR::ComponentRepository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::ComponentRepository::_unchecked_narrow (obj.in ());
}


class TAO_IR_ProvidesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ProvidesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::ProvidesDef::move_skel},
      {"_is_a",  &POA_IR::ProvidesDef::_is_a_skel},
      {"_get_id", 	&POA_IR::ProvidesDef::_get_id_skel},
      {"_set_id", 	&POA_IR::ProvidesDef::_set_id_skel},
      {"describe", 	&POA_IR::ProvidesDef::describe_skel},
      {"_get_name", 	&POA_IR::ProvidesDef::_get_name_skel},
      {"_set_name", 	&POA_IR::ProvidesDef::_set_name_skel},
      {"_interface",  &POA_IR::ProvidesDef::_interface_skel},
      {"_get_version", 	&POA_IR::ProvidesDef::_get_version_skel},
      {"_set_version", 	&POA_IR::ProvidesDef::_set_version_skel},
      {"_get_def_kind", 	&POA_IR::ProvidesDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_IR::ProvidesDef::_get_defined_in_skel},
      {"destroy", 	&POA_IR::ProvidesDef::destroy_skel},
      {"_get_absolute_name", 	&POA_IR::ProvidesDef::_get_absolute_name_skel},
      {"_get_interface_type", 	&POA_IR::ProvidesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::ProvidesDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::ProvidesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  49,   8, -45,  11,  -1, -46,  14, 
       -1,  15,  -1,  16,  17,  18,  -6,  -2,  -1,  19,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_ProvidesDef_Perfect_Hash_OpTable tao_IR_ProvidesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ProvidesDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get (const TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get &);
  
private:
  POA_IR::ProvidesDef *_tao_impl;
  CORBA_InterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ProvidesDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::~_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_ProvidesDef_Proxy_Impl&
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::ProvidesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ProvidesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ProvidesDef_Proxy_Broker *
IR__TAO_ProvidesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_ProvidesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_ProvidesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::_TAO_ProvidesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ProvidesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ProvidesDef:1.0"
        )
    )->interface_type (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ProvidesDef::ProvidesDef (void)
{
  this->optable_ = &tao_IR_ProvidesDef_optable;
}

// copy ctor
POA_IR::ProvidesDef::ProvidesDef (const ProvidesDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ProvidesDef::~ProvidesDef (void)
{
}

void POA_IR::ProvidesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *)_tao_object_reference;
  
    CORBA_InterfaceDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->interface_type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ProvidesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ProvidesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ProvidesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ProvidesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ProvidesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ProvidesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ProvidesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ProvidesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

IR::ProvidesDef*
POA_IR::ProvidesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::ProvidesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_UsesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UsesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UsesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UsesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::UsesDef::move_skel},
      {"_is_a",  &POA_IR::UsesDef::_is_a_skel},
      {"_get_id", 	&POA_IR::UsesDef::_get_id_skel},
      {"_set_id", 	&POA_IR::UsesDef::_set_id_skel},
      {"describe", 	&POA_IR::UsesDef::describe_skel},
      {"_get_name", 	&POA_IR::UsesDef::_get_name_skel},
      {"_set_name", 	&POA_IR::UsesDef::_set_name_skel},
      {"_interface",  &POA_IR::UsesDef::_interface_skel},
      {"_get_version", 	&POA_IR::UsesDef::_get_version_skel},
      {"_set_version", 	&POA_IR::UsesDef::_set_version_skel},
      {"_get_def_kind", 	&POA_IR::UsesDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_IR::UsesDef::_get_defined_in_skel},
      {"_get_is_multiple", 	&POA_IR::UsesDef::_get_is_multiple_skel},
      {"destroy", 	&POA_IR::UsesDef::destroy_skel},
      {"_get_absolute_name", 	&POA_IR::UsesDef::_get_absolute_name_skel},
      {"_get_interface_type", 	&POA_IR::UsesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::UsesDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::UsesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  49,   8, -45,  11,  -1, -46,  14, 
       -1,  15,  16,  17,  18,  19,  -6,  -2,  -1,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_UsesDef_Perfect_Hash_OpTable tao_IR_UsesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_UsesDef_interface_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_UsesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UsesDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_UsesDef_interface_type_get (const TAO_ServerRequestInfo_IR_UsesDef_interface_type_get &);
  void operator= (const TAO_ServerRequestInfo_IR_UsesDef_interface_type_get &);
  
private:
  POA_IR::UsesDef *_tao_impl;
  CORBA_InterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UsesDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::result (CORBA_InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UsesDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get (const TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get &);
  void operator= (const TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get &);
  
private:
  POA_IR::UsesDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UsesDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker *POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::~_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_UsesDef_Proxy_Impl&
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::UsesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_UsesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_UsesDef_Proxy_Broker *
IR__TAO_UsesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_UsesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_UsesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_UsesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_UsesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_UsesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::_TAO_UsesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_InterfaceDef_ptr POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->interface_type (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_multiple",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->is_multiple (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::UsesDef::UsesDef (void)
{
  this->optable_ = &tao_IR_UsesDef_optable;
}

// copy ctor
POA_IR::UsesDef::UsesDef (const UsesDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UsesDef::~UsesDef (void)
{
}

void POA_IR::UsesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;
  
    CORBA_InterfaceDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_UsesDef_interface_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->interface_type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UsesDef::_get_is_multiple_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_multiple (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UsesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UsesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UsesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::UsesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::UsesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UsesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UsesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UsesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

IR::UsesDef*
POA_IR::UsesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::UsesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_EventDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EventDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EventDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EventDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::EventDef::move_skel},
      {"_is_a",  &POA_IR::EventDef::_is_a_skel},
      {"_get_id", 	&POA_IR::EventDef::_get_id_skel},
      {"_set_id", 	&POA_IR::EventDef::_set_id_skel},
      {"describe", 	&POA_IR::EventDef::describe_skel},
      {"_get_name", 	&POA_IR::EventDef::_get_name_skel},
      {"_set_name", 	&POA_IR::EventDef::_set_name_skel},
      {"_interface",  &POA_IR::EventDef::_interface_skel},
      {"_get_version", 	&POA_IR::EventDef::_get_version_skel},
      {"_set_version", 	&POA_IR::EventDef::_set_version_skel},
      {"_get_def_kind", 	&POA_IR::EventDef::_get_def_kind_skel},
      {"is_a", 	&POA_IR::EventDef::is_a_skel},
      {"_get_defined_in", 	&POA_IR::EventDef::_get_defined_in_skel},
      {"destroy", 	&POA_IR::EventDef::destroy_skel},
      {"_get_absolute_name", 	&POA_IR::EventDef::_get_absolute_name_skel},
      {"_get_event", 	&POA_IR::EventDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EventDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::EventDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14, 
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_EventDef_Perfect_Hash_OpTable tao_IR_EventDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_EventDef_is_a : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_EventDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EventDef *tao_impl,
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_EventDef_is_a (const TAO_ServerRequestInfo_IR_EventDef_is_a &);
  void operator= (const TAO_ServerRequestInfo_IR_EventDef_is_a &);
  
private:
  POA_IR::EventDef *_tao_impl;
  const char * event_id_;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_EventDef_is_a::TAO_ServerRequestInfo_IR_EventDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EventDef *tao_impl,
    const char * event_id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    event_id_ (event_id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_EventDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_event_id = parameter_list->length ();
  parameter_list->length (length_event_id + 1);
  (*parameter_list)[length_event_id].argument <<= event_id_;
  (*parameter_list)[length_event_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_EventDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_EventDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_EventDef_is_a::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_EventDef_is_a::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_EventDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_EventDef_event_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_EventDef_event_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EventDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_EventDef_event_get (const TAO_ServerRequestInfo_IR_EventDef_event_get &);
  void operator= (const TAO_ServerRequestInfo_IR_EventDef_event_get &);
  
private:
  POA_IR::EventDef *_tao_impl;
  CORBA_ValueDef_ptr _result;
};

TAO_ServerRequestInfo_IR_EventDef_event_get::TAO_ServerRequestInfo_IR_EventDef_event_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EventDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_EventDef_event_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_EventDef_event_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_EventDef_event_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_EventDef_event_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_EventDef_event_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_EventDef_event_get::result (CORBA_ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker *POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EventDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::~_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_EventDef_Proxy_Impl&
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::EventDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_EventDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_EventDef_Proxy_Broker *
IR__TAO_EventDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker();
}

int
IR__TAO_EventDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_EventDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_EventDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_EventDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_EventDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_EventDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::_TAO_EventDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->is_a (
        event_id,
        ACE_TRY_ENV
      );
}

CORBA_ValueDef_ptr POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "event",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->event (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EventDef::EventDef (void)
{
  this->optable_ = &tao_IR_EventDef_optable;
}

// copy ctor
POA_IR::EventDef::EventDef (const EventDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EventDef::~EventDef (void)
{
}

void POA_IR::EventDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;
  CORBA::String_var event_id;
  if (!(
    (_tao_in >> event_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_EventDef_is_a ri (
      _tao_server_request,
      _tao_impl,
      event_id.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_a (
          event_id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::EventDef::_get_event_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;
  
    CORBA_ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_EventDef_event_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->event (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::EventDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EventDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EventDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::EventDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::EventDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EventDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

IR::EventDef*
POA_IR::EventDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::EventDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_EmitsDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EmitsDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EmitsDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EmitsDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::EmitsDef::move_skel},
      {"_is_a",  &POA_IR::EmitsDef::_is_a_skel},
      {"_get_id", 	&POA_IR::EmitsDef::_get_id_skel},
      {"_set_id", 	&POA_IR::EmitsDef::_set_id_skel},
      {"describe", 	&POA_IR::EmitsDef::describe_skel},
      {"_get_name", 	&POA_IR::EmitsDef::_get_name_skel},
      {"_set_name", 	&POA_IR::EmitsDef::_set_name_skel},
      {"_interface",  &POA_IR::EmitsDef::_interface_skel},
      {"_get_version", 	&POA_IR::EmitsDef::_get_version_skel},
      {"_set_version", 	&POA_IR::EmitsDef::_set_version_skel},
      {"_get_def_kind", 	&POA_IR::EmitsDef::_get_def_kind_skel},
      {"is_a", 	&POA_IR::EmitsDef::is_a_skel},
      {"_get_defined_in", 	&POA_IR::EmitsDef::_get_defined_in_skel},
      {"destroy", 	&POA_IR::EmitsDef::destroy_skel},
      {"_get_absolute_name", 	&POA_IR::EmitsDef::_get_absolute_name_skel},
      {"_get_event", 	&POA_IR::EmitsDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EmitsDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::EmitsDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14, 
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_EmitsDef_Perfect_Hash_OpTable tao_IR_EmitsDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker *POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::~_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_EmitsDef_Proxy_Impl&
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::EmitsDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_EmitsDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_EmitsDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_EmitsDef_Proxy_Broker *
IR__TAO_EmitsDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker();
}

int
IR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_EmitsDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_EmitsDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EmitsDef_ThruPOA_Proxy_Impl::_TAO_EmitsDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EmitsDef::EmitsDef (void)
{
  this->optable_ = &tao_IR_EmitsDef_optable;
}

// copy ctor
POA_IR::EmitsDef::EmitsDef (const EmitsDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EmitsDef::~EmitsDef (void)
{
}

void POA_IR::EmitsDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EmitsDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EmitsDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::EmitsDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::EmitsDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EmitsDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EmitsDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EmitsDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

IR::EmitsDef*
POA_IR::EmitsDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::EmitsDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_PublishesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PublishesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PublishesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PublishesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::PublishesDef::move_skel},
      {"_is_a",  &POA_IR::PublishesDef::_is_a_skel},
      {"_get_id", 	&POA_IR::PublishesDef::_get_id_skel},
      {"_set_id", 	&POA_IR::PublishesDef::_set_id_skel},
      {"describe", 	&POA_IR::PublishesDef::describe_skel},
      {"_get_name", 	&POA_IR::PublishesDef::_get_name_skel},
      {"_set_name", 	&POA_IR::PublishesDef::_set_name_skel},
      {"_interface",  &POA_IR::PublishesDef::_interface_skel},
      {"_get_version", 	&POA_IR::PublishesDef::_get_version_skel},
      {"_set_version", 	&POA_IR::PublishesDef::_set_version_skel},
      {"_get_def_kind", 	&POA_IR::PublishesDef::_get_def_kind_skel},
      {"is_a", 	&POA_IR::PublishesDef::is_a_skel},
      {"_get_defined_in", 	&POA_IR::PublishesDef::_get_defined_in_skel},
      {"destroy", 	&POA_IR::PublishesDef::destroy_skel},
      {"_get_absolute_name", 	&POA_IR::PublishesDef::_get_absolute_name_skel},
      {"_get_event", 	&POA_IR::PublishesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::PublishesDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::PublishesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14, 
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_PublishesDef_Perfect_Hash_OpTable tao_IR_PublishesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker *POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::~_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_PublishesDef_Proxy_Impl&
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::PublishesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_PublishesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_PublishesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_PublishesDef_Proxy_Broker *
IR__TAO_PublishesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_PublishesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_PublishesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PublishesDef_ThruPOA_Proxy_Impl::_TAO_PublishesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PublishesDef::PublishesDef (void)
{
  this->optable_ = &tao_IR_PublishesDef_optable;
}

// copy ctor
POA_IR::PublishesDef::PublishesDef (const PublishesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PublishesDef::~PublishesDef (void)
{
}

void POA_IR::PublishesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PublishesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PublishesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::PublishesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::PublishesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PublishesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PublishesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PublishesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

IR::PublishesDef*
POA_IR::PublishesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::PublishesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_ConsumesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConsumesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::ConsumesDef::move_skel},
      {"_is_a",  &POA_IR::ConsumesDef::_is_a_skel},
      {"_get_id", 	&POA_IR::ConsumesDef::_get_id_skel},
      {"_set_id", 	&POA_IR::ConsumesDef::_set_id_skel},
      {"describe", 	&POA_IR::ConsumesDef::describe_skel},
      {"_get_name", 	&POA_IR::ConsumesDef::_get_name_skel},
      {"_set_name", 	&POA_IR::ConsumesDef::_set_name_skel},
      {"_interface",  &POA_IR::ConsumesDef::_interface_skel},
      {"_get_version", 	&POA_IR::ConsumesDef::_get_version_skel},
      {"_set_version", 	&POA_IR::ConsumesDef::_set_version_skel},
      {"_get_def_kind", 	&POA_IR::ConsumesDef::_get_def_kind_skel},
      {"is_a", 	&POA_IR::ConsumesDef::is_a_skel},
      {"_get_defined_in", 	&POA_IR::ConsumesDef::_get_defined_in_skel},
      {"destroy", 	&POA_IR::ConsumesDef::destroy_skel},
      {"_get_absolute_name", 	&POA_IR::ConsumesDef::_get_absolute_name_skel},
      {"_get_event", 	&POA_IR::ConsumesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::ConsumesDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::ConsumesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14, 
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_ConsumesDef_Perfect_Hash_OpTable tao_IR_ConsumesDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::~_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_ConsumesDef_Proxy_Impl&
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::ConsumesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ConsumesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ConsumesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ConsumesDef_Proxy_Broker *
IR__TAO_ConsumesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker();
}

int
IR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_ConsumesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_ConsumesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ConsumesDef_ThruPOA_Proxy_Impl::_TAO_ConsumesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ConsumesDef::ConsumesDef (void)
{
  this->optable_ = &tao_IR_ConsumesDef_optable;
}

// copy ctor
POA_IR::ConsumesDef::ConsumesDef (const ConsumesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConsumesDef::~ConsumesDef (void)
{
}

void POA_IR::ConsumesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConsumesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConsumesDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ConsumesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ConsumesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConsumesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConsumesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConsumesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

IR::ConsumesDef*
POA_IR::ConsumesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::ConsumesDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_ComponentDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108,   0,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108,   0,
     108,  51,  30,  20, 108, 108, 108,   0, 108, 108,
     108, 108, 108, 108, 108, 108, 108,   5,  15,  40,
     108,   0, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108,   0,  15, 108, 108, 108,   5,   5, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108,
#else
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
     108, 108, 108, 108, 108,   0, 108,   0, 108,  51,
      30,  20, 108, 108, 108,   0, 108, 108,   5,  15,
      40, 108,   0, 108, 108,   0,  15, 108, 108, 108,
       5,   5, 108, 108, 108, 108, 108, 108,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 54,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 107,
      HASH_VALUE_RANGE = 104,
      DUPLICATES = 14
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a", 	&POA_IR::ComponentDef::is_a_skel},
      {"_is_a",  &POA_IR::ComponentDef::_is_a_skel},
      {"lookup", 	&POA_IR::ComponentDef::lookup_skel},
      {"_get_emits_events", 	&POA_IR::ComponentDef::_get_emits_events_skel},
      {"_get_uses_interfaces", 	&POA_IR::ComponentDef::_get_uses_interfaces_skel},
      {"_set_base_interfaces", 	&POA_IR::ComponentDef::_set_base_interfaces_skel},
      {"_get_base_interfaces", 	&POA_IR::ComponentDef::_get_base_interfaces_skel},
      {"_get_consumes_events", 	&POA_IR::ComponentDef::_get_consumes_events_skel},
      {"_get_publishes_events", 	&POA_IR::ComponentDef::_get_publishes_events_skel},
      {"_get_provides_interfaces", 	&POA_IR::ComponentDef::_get_provides_interfaces_skel},
      {"_get_supported_interfaces", 	&POA_IR::ComponentDef::_get_supported_interfaces_skel},
      {"_set_supported_interfaces", 	&POA_IR::ComponentDef::_set_supported_interfaces_skel},
      {"_non_existent",  &POA_IR::ComponentDef::_non_existent_skel},
      {"_get_name", 	&POA_IR::ComponentDef::_get_name_skel},
      {"_get_type", 	&POA_IR::ComponentDef::_get_type_skel},
      {"_set_name", 	&POA_IR::ComponentDef::_set_name_skel},
      {"_interface",  &POA_IR::ComponentDef::_interface_skel},
      {"_get_containing_repository", 	&POA_IR::ComponentDef::_get_containing_repository_skel},
      {"_get_base_component", 	&POA_IR::ComponentDef::_get_base_component_skel},
      {"lookup_name", 	&POA_IR::ComponentDef::lookup_name_skel},
      {"_get_id", 	&POA_IR::ComponentDef::_get_id_skel},
      {"_set_id", 	&POA_IR::ComponentDef::_set_id_skel},
      {"_get_absolute_name", 	&POA_IR::ComponentDef::_get_absolute_name_skel},
      {"move", 	&POA_IR::ComponentDef::move_skel},
      {"destroy", 	&POA_IR::ComponentDef::destroy_skel},
      {"_get_def_kind", 	&POA_IR::ComponentDef::_get_def_kind_skel},
      {"describe_contents", 	&POA_IR::ComponentDef::describe_contents_skel},
      {"_get_version", 	&POA_IR::ComponentDef::_get_version_skel},
      {"_set_version", 	&POA_IR::ComponentDef::_set_version_skel},
      {"_get_defined_in", 	&POA_IR::ComponentDef::_get_defined_in_skel},
      {"describe", 	&POA_IR::ComponentDef::describe_skel},
      {"contents", 	&POA_IR::ComponentDef::contents_skel},
      {"create_uses", 	&POA_IR::ComponentDef::create_uses_skel},
      {"create_emits", 	&POA_IR::ComponentDef::create_emits_skel},
      {"create_alias", 	&POA_IR::ComponentDef::create_alias_skel},
      {"_get_is_basic", 	&POA_IR::ComponentDef::_get_is_basic_skel},
      {"create_provides", 	&POA_IR::ComponentDef::create_provides_skel},
      {"create_consumes", 	&POA_IR::ComponentDef::create_consumes_skel},
      {"create_publishes", 	&POA_IR::ComponentDef::create_publishes_skel},
      {"describe_interface", 	&POA_IR::ComponentDef::describe_interface_skel},
      {"create_value_box", 	&POA_IR::ComponentDef::create_value_box_skel},
      {"create_enum", 	&POA_IR::ComponentDef::create_enum_skel},
      {"create_struct", 	&POA_IR::ComponentDef::create_struct_skel},
      {"create_constant", 	&POA_IR::ComponentDef::create_constant_skel},
      {"create_value", 	&POA_IR::ComponentDef::create_value_skel},
      {"create_module", 	&POA_IR::ComponentDef::create_module_skel},
      {"create_native", 	&POA_IR::ComponentDef::create_native_skel},
      {"create_attribute", 	&POA_IR::ComponentDef::create_attribute_skel},
      {"create_interface", 	&POA_IR::ComponentDef::create_interface_skel},
      {"create_local_interface", 	&POA_IR::ComponentDef::create_local_interface_skel},
      {"create_abstract_interface", 	&POA_IR::ComponentDef::create_abstract_interface_skel},
      {"create_union", 	&POA_IR::ComponentDef::create_union_skel},
      {"create_operation", 	&POA_IR::ComponentDef::create_operation_skel},
      {"create_exception", 	&POA_IR::ComponentDef::create_exception_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -1,   -1,    4,    5,   -1,   -1,   -1,   -1,   -1,    6,   -1,   -1, 
        -1,   -1,   -1,    7,   -8,   -4, -109,   12,  -14,   -2,   13, -110,  -17,   -3, 
        16, -110,   20,   21,  -24,   -2,   22,   -1,   23, -112,   26,   27,   -1,   -1, 
        28,   29,   -1,   -1,   -1,   30,   -1,   -1,  -31,   -2, -109,   -1,   -1,   33, 
       -37,   -2,   34,   35,  -40,   -2,   36, -114,   39,   -1, -113,   42,   43,   -1, 
        -1,   -1,   44,   -1,   -1,  -49,   -2,   45,   -1,   46,   -1,   47,   -1,   48, 
      -116,  -51,   -2, -109,   -1,   -1,   -1,   -1,   -1,   53,   -1,   -1,   54,   -1, 
        -1,   -1,   -1,   -1,   -1,   55,   -1,  -56,   -2, -109, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_ComponentDef_Perfect_Hash_OpTable tao_IR_ComponentDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_InterfaceDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  CORBA_InterfaceDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA_InterfaceDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  const CORBA_InterfaceDefSeq & supported_interfaces_;
  
};

TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_IR_ComponentDef_base_component_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_base_component_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_base_component_get (const TAO_ServerRequestInfo_IR_ComponentDef_base_component_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_base_component_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  IR::ComponentDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get (const TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  IR::ProvidesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::result (IR::ProvidesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get (const TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  IR::UsesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::result (IR::UsesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get (const TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  IR::EmitsDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::result (IR::EmitsDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get (const TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  IR::PublishesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::result (IR::PublishesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get (const TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  IR::ConsumesDefSeq * _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::result (IR::ConsumesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get (const TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_provides : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_provides (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ProvidesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_provides (const TAO_ServerRequestInfo_IR_ComponentDef_create_provides &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_provides &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  IR::ProvidesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_provides::TAO_ServerRequestInfo_IR_ComponentDef_create_provides (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
  
  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_create_provides::result (IR::ProvidesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_uses : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_uses (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::UsesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_uses (const TAO_ServerRequestInfo_IR_ComponentDef_create_uses &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_uses &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_InterfaceDef_ptr interface_type_;
  const CORBA::Boolean & is_multiple_;
  IR::UsesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_uses::TAO_ServerRequestInfo_IR_ComponentDef_create_uses (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type),
    is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
  
  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_multiple = parameter_list->length ();
  parameter_list->length (length_is_multiple + 1);
  (*parameter_list)[length_is_multiple].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[length_is_multiple].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_create_uses::result (IR::UsesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_emits : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_emits (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::EmitsDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_emits (const TAO_ServerRequestInfo_IR_ComponentDef_create_emits &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_emits &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::EmitsDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_emits::TAO_ServerRequestInfo_IR_ComponentDef_create_emits (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_create_emits::result (IR::EmitsDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_publishes : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_publishes (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PublishesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_publishes (const TAO_ServerRequestInfo_IR_ComponentDef_create_publishes &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_publishes &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::PublishesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::result (IR::PublishesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_ComponentDef_create_consumes : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_ComponentDef_create_consumes (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ConsumesDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_ComponentDef_create_consumes (const TAO_ServerRequestInfo_IR_ComponentDef_create_consumes &);
  void operator= (const TAO_ServerRequestInfo_IR_ComponentDef_create_consumes &);
  
private:
  POA_IR::ComponentDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr value_;
  IR::ConsumesDef_ptr _result;
};

TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::result (IR::ConsumesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::~_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_ComponentDef_Proxy_Impl&
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::ComponentDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_ComponentDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_ComponentDef_Proxy_Broker *
IR__TAO_ComponentDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker();
}

int
IR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_ComponentDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_ComponentDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::_TAO_ComponentDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA_InterfaceDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        supported_interfaces,
        ACE_TRY_ENV
      );
  return;
}

IR::ComponentDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->base_component (
        ACE_TRY_ENV
      );
}

IR::ProvidesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::provides_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ProvidesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "provides_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->provides_interfaces (
        ACE_TRY_ENV
      );
}

IR::UsesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::uses_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::UsesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "uses_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->uses_interfaces (
        ACE_TRY_ENV
      );
}

IR::EmitsDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::emits_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::EmitsDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "emits_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->emits_events (
        ACE_TRY_ENV
      );
}

IR::PublishesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::publishes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PublishesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "publishes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->publishes_events (
        ACE_TRY_ENV
      );
}

IR::ConsumesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::consumes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ConsumesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "consumes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->consumes_events (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->is_basic (
        ACE_TRY_ENV
      );
}

IR::ProvidesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ProvidesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_provides",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_provides (
        id,
        name,
        version,
        interface_type,
        ACE_TRY_ENV
      );
}

IR::UsesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::UsesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_uses",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_uses (
        id,
        name,
        version,
        interface_type,
        is_multiple,
        ACE_TRY_ENV
      );
}

IR::EmitsDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::EmitsDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_emits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_emits (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

IR::PublishesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PublishesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_publishes",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_publishes (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

IR::ConsumesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ConsumesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_consumes",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_consumes (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentDef::ComponentDef (void)
{
  this->optable_ = &tao_IR_ComponentDef_optable;
}

// copy ctor
POA_IR::ComponentDef::ComponentDef (const ComponentDef& rhs)
  :   POA_CORBA_InterfaceDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentDef::~ComponentDef (void)
{
}

void POA_IR::ComponentDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    CORBA_InterfaceDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->supported_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_InterfaceDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA_InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set ri (
      _tao_server_request,
      _tao_impl,
      supported_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->supported_interfaces (
          supported_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_base_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::ComponentDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_base_component_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->base_component (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_provides_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::ProvidesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->provides_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ProvidesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_uses_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::UsesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->uses_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::UsesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_emits_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::EmitsDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->emits_events (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::EmitsDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_publishes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::PublishesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->publishes_events (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PublishesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_consumes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::ConsumesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->consumes_events (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ConsumesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_basic (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_provides_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::ProvidesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDef_var interface_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_create_provides ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_provides (
          id.in (),
          name.in (),
          version.in (),
          interface_type.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ProvidesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_uses_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::UsesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_InterfaceDef_var interface_type;
  CORBA::Boolean is_multiple;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_multiple))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_create_uses ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      is_multiple,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_uses (
          id.in (),
          name.in (),
          version.in (),
          interface_type.in (),
          is_multiple,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::UsesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_emits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::EmitsDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_create_emits ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_emits (
          id.in (),
          name.in (),
          version.in (),
          value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::EmitsDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_publishes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::PublishesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_create_publishes ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_publishes (
          id.in (),
          name.in (),
          version.in (),
          value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PublishesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_consumes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;
  
    IR::ConsumesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_ComponentDef_create_consumes ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_consumes (
          id.in (),
          name.in (),
          version.in (),
          value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ConsumesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::ComponentDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

IR::ComponentDef*
POA_IR::ComponentDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::ComponentDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 10, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  5,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 10, 32, 32, 32, 32,  5, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 10, 32, 32, 32,  0,
      5, 32, 32, 32, 32, 32, 10, 32, 32, 32,
     32,  5, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 28,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::PrimaryKeyDef::move_skel},
      {"_is_a",  &POA_IR::PrimaryKeyDef::_is_a_skel},
      {"_get_id", 	&POA_IR::PrimaryKeyDef::_get_id_skel},
      {"_set_id", 	&POA_IR::PrimaryKeyDef::_set_id_skel},
      {"describe", 	&POA_IR::PrimaryKeyDef::describe_skel},
      {"_get_name", 	&POA_IR::PrimaryKeyDef::_get_name_skel},
      {"_set_name", 	&POA_IR::PrimaryKeyDef::_set_name_skel},
      {"_interface",  &POA_IR::PrimaryKeyDef::_interface_skel},
      {"destroy", 	&POA_IR::PrimaryKeyDef::destroy_skel},
      {"_get_def_kind", 	&POA_IR::PrimaryKeyDef::_get_def_kind_skel},
      {"is_a", 	&POA_IR::PrimaryKeyDef::is_a_skel},
      {"_get_version", 	&POA_IR::PrimaryKeyDef::_get_version_skel},
      {"_set_version", 	&POA_IR::PrimaryKeyDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_IR::PrimaryKeyDef::_get_absolute_name_skel},
      {"_get_defined_in", 	&POA_IR::PrimaryKeyDef::_get_defined_in_skel},
      {"_get_primary_key", 	&POA_IR::PrimaryKeyDef::_get_primary_key_skel},
      {"_non_existent",  &POA_IR::PrimaryKeyDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::PrimaryKeyDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -38,   8, -38,  11,  -1,  12,  13, 
       14, -15,  -2, -33,  17,  -1,  18,  19,  -1,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable tao_IR_PrimaryKeyDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::PrimaryKeyDef *tao_impl,
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a &);
  void operator= (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a &);
  
private:
  POA_IR::PrimaryKeyDef *_tao_impl;
  const char * primary_key_id_;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::PrimaryKeyDef *tao_impl,
    const char * primary_key_id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    primary_key_id_ (primary_key_id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_primary_key_id = parameter_list->length ();
  parameter_list->length (length_primary_key_id + 1);
  (*parameter_list)[length_primary_key_id].argument <<= primary_key_id_;
  (*parameter_list)[length_primary_key_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::PrimaryKeyDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA_ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get &);
  void operator= (const TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get &);
  
private:
  POA_IR::PrimaryKeyDef *_tao_impl;
  CORBA_ValueDef_ptr _result;
};

TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::PrimaryKeyDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA_ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker *POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::~_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_PrimaryKeyDef_Proxy_Impl&
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::PrimaryKeyDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_PrimaryKeyDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_PrimaryKeyDef_Proxy_Broker *
IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker();
}

int
IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_PrimaryKeyDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->is_a (
        primary_key_id,
        ACE_TRY_ENV
      );
}

CORBA_ValueDef_ptr POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->primary_key (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (void)
{
  this->optable_ = &tao_IR_PrimaryKeyDef_optable;
}

// copy ctor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (const PrimaryKeyDef& rhs)
  :   POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimaryKeyDef::~PrimaryKeyDef (void)
{
}

void POA_IR::PrimaryKeyDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;
  CORBA::String_var primary_key_id;
  if (!(
    (_tao_in >> primary_key_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a ri (
      _tao_server_request,
      _tao_impl,
      primary_key_id.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_a (
          primary_key_id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::PrimaryKeyDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;
  
    CORBA_ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->primary_key (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::PrimaryKeyDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimaryKeyDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimaryKeyDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::PrimaryKeyDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimaryKeyDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimaryKeyDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimaryKeyDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimaryKeyDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

IR::PrimaryKeyDef*
POA_IR::PrimaryKeyDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::PrimaryKeyDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_FactoryDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FactoryDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FactoryDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FactoryDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::FactoryDef::move_skel},
      {"_is_a",  &POA_IR::FactoryDef::_is_a_skel},
      {"_get_mode", 	&POA_IR::FactoryDef::_get_mode_skel},
      {"_set_name", 	&POA_IR::FactoryDef::_set_name_skel},
      {"_get_name", 	&POA_IR::FactoryDef::_get_name_skel},
      {"_set_mode", 	&POA_IR::FactoryDef::_set_mode_skel},
      {"_interface",  &POA_IR::FactoryDef::_interface_skel},
      {"_get_params", 	&POA_IR::FactoryDef::_get_params_skel},
      {"_set_params", 	&POA_IR::FactoryDef::_set_params_skel},
      {"_get_contexts", 	&POA_IR::FactoryDef::_get_contexts_skel},
      {"_set_contexts", 	&POA_IR::FactoryDef::_set_contexts_skel},
      {"_get_exceptions", 	&POA_IR::FactoryDef::_get_exceptions_skel},
      {"_set_exceptions", 	&POA_IR::FactoryDef::_set_exceptions_skel},
      {"_get_version", 	&POA_IR::FactoryDef::_get_version_skel},
      {"_set_version", 	&POA_IR::FactoryDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_IR::FactoryDef::_get_absolute_name_skel},
      {"_get_defined_in", 	&POA_IR::FactoryDef::_get_defined_in_skel},
      {"_get_id", 	&POA_IR::FactoryDef::_get_id_skel},
      {"_set_id", 	&POA_IR::FactoryDef::_set_id_skel},
      {"describe", 	&POA_IR::FactoryDef::describe_skel},
      {"_get_result_def", 	&POA_IR::FactoryDef::_get_result_def_skel},
      {"_set_result_def", 	&POA_IR::FactoryDef::_set_result_def_skel},
      {"_get_def_kind", 	&POA_IR::FactoryDef::_get_def_kind_skel},
      {"_get_result", 	&POA_IR::FactoryDef::_get_result_skel},
      {"destroy", 	&POA_IR::FactoryDef::destroy_skel},
      {"_non_existent",  &POA_IR::FactoryDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::FactoryDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword; 

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  31:
                  resword = &wordlist[27]; break;
                case  32:
                  resword = &wordlist[28]; break;
                case  33:
                  resword = &wordlist[29]; break;
                case  36:
                  resword = &wordlist[30]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_FactoryDef_Perfect_Hash_OpTable tao_IR_FactoryDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker *POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::~_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_FactoryDef_Proxy_Impl&
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::FactoryDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_FactoryDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_FactoryDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_FactoryDef_Proxy_Broker *
IR__TAO_FactoryDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker();
}

int
IR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_FactoryDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_FactoryDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FactoryDef_ThruPOA_Proxy_Impl::_TAO_FactoryDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FactoryDef::FactoryDef (void)
{
  this->optable_ = &tao_IR_FactoryDef_optable;
}

// copy ctor
POA_IR::FactoryDef::FactoryDef (const FactoryDef& rhs)
  :   POA_CORBA_OperationDef (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FactoryDef::~FactoryDef (void)
{
}

void POA_IR::FactoryDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FactoryDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FactoryDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::FactoryDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::FactoryDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FactoryDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FactoryDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FactoryDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

IR::FactoryDef*
POA_IR::FactoryDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::FactoryDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_FinderDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FinderDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FinderDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FinderDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_IR::FinderDef::move_skel},
      {"_is_a",  &POA_IR::FinderDef::_is_a_skel},
      {"_get_mode", 	&POA_IR::FinderDef::_get_mode_skel},
      {"_set_name", 	&POA_IR::FinderDef::_set_name_skel},
      {"_get_name", 	&POA_IR::FinderDef::_get_name_skel},
      {"_set_mode", 	&POA_IR::FinderDef::_set_mode_skel},
      {"_interface",  &POA_IR::FinderDef::_interface_skel},
      {"_get_params", 	&POA_IR::FinderDef::_get_params_skel},
      {"_set_params", 	&POA_IR::FinderDef::_set_params_skel},
      {"_get_contexts", 	&POA_IR::FinderDef::_get_contexts_skel},
      {"_set_contexts", 	&POA_IR::FinderDef::_set_contexts_skel},
      {"_get_exceptions", 	&POA_IR::FinderDef::_get_exceptions_skel},
      {"_set_exceptions", 	&POA_IR::FinderDef::_set_exceptions_skel},
      {"_get_version", 	&POA_IR::FinderDef::_get_version_skel},
      {"_set_version", 	&POA_IR::FinderDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_IR::FinderDef::_get_absolute_name_skel},
      {"_get_defined_in", 	&POA_IR::FinderDef::_get_defined_in_skel},
      {"_get_id", 	&POA_IR::FinderDef::_get_id_skel},
      {"_set_id", 	&POA_IR::FinderDef::_set_id_skel},
      {"describe", 	&POA_IR::FinderDef::describe_skel},
      {"_get_result_def", 	&POA_IR::FinderDef::_get_result_def_skel},
      {"_set_result_def", 	&POA_IR::FinderDef::_set_result_def_skel},
      {"_get_def_kind", 	&POA_IR::FinderDef::_get_def_kind_skel},
      {"_get_result", 	&POA_IR::FinderDef::_get_result_skel},
      {"destroy", 	&POA_IR::FinderDef::destroy_skel},
      {"_non_existent",  &POA_IR::FinderDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::FinderDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword; 

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  31:
                  resword = &wordlist[27]; break;
                case  32:
                  resword = &wordlist[28]; break;
                case  33:
                  resword = &wordlist[29]; break;
                case  36:
                  resword = &wordlist[30]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_FinderDef_Perfect_Hash_OpTable tao_IR_FinderDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker *POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::~_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_FinderDef_Proxy_Impl&
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::FinderDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_FinderDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_FinderDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_FinderDef_Proxy_Broker *
IR__TAO_FinderDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker();
}

int
IR__TAO_FinderDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_FinderDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_FinderDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_FinderDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_FinderDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FinderDef_ThruPOA_Proxy_Impl::_TAO_FinderDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FinderDef::FinderDef (void)
{
  this->optable_ = &tao_IR_FinderDef_optable;
}

// copy ctor
POA_IR::FinderDef::FinderDef (const FinderDef& rhs)
  :   POA_CORBA_OperationDef (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FinderDef::~FinderDef (void)
{
}

void POA_IR::FinderDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FinderDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FinderDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::FinderDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::FinderDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FinderDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FinderDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FinderDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

IR::FinderDef*
POA_IR::FinderDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::FinderDef::_unchecked_narrow (obj.in ());
}


class TAO_IR_HomeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 13:56:28 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_HomeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_HomeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91,  0,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91,  0,
     91, 20,  5, 40, 91, 91, 91,  0, 91, 91,
     91, 91, 91, 91, 91, 91, 91,  0,  0,  5,
     91,  0, 91,  5, 91, 91, 91, 91, 91, 91,
     91, 91, 20, 55, 91, 91, 91,  0, 45, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91,
#else
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
     91, 91, 91, 91, 91,  0, 91,  0, 91, 20,
      5, 40, 91, 91, 91,  0, 91, 91,  0,  0,
      5, 91,  0, 91,  5, 20, 55, 91, 91, 91,
      0, 45, 91, 91, 91, 91, 91, 91,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_HomeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 90,
      HASH_VALUE_RANGE = 87,
      DUPLICATES = 9
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a", 	&POA_IR::HomeDef::is_a_skel},
      {"_is_a",  &POA_IR::HomeDef::_is_a_skel},
      {"lookup", 	&POA_IR::HomeDef::lookup_skel},
      {"_get_id", 	&POA_IR::HomeDef::_get_id_skel},
      {"_set_id", 	&POA_IR::HomeDef::_set_id_skel},
      {"_get_version", 	&POA_IR::HomeDef::_get_version_skel},
      {"_set_version", 	&POA_IR::HomeDef::_set_version_skel},
      {"_get_def_kind", 	&POA_IR::HomeDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_IR::HomeDef::_get_defined_in_skel},
      {"create_enum", 	&POA_IR::HomeDef::create_enum_skel},
      {"_get_finders", 	&POA_IR::HomeDef::_get_finders_skel},
      {"_get_is_basic", 	&POA_IR::HomeDef::_get_is_basic_skel},
      {"_get_factories", 	&POA_IR::HomeDef::_get_factories_skel},
      {"create_value_box", 	&POA_IR::HomeDef::create_value_box_skel},
      {"create_union", 	&POA_IR::HomeDef::create_union_skel},
      {"create_finder", 	&POA_IR::HomeDef::create_finder_skel},
      {"_get_base_interfaces", 	&POA_IR::HomeDef::_get_base_interfaces_skel},
      {"_set_base_interfaces", 	&POA_IR::HomeDef::_set_base_interfaces_skel},
      {"create_operation", 	&POA_IR::HomeDef::create_operation_skel},
      {"create_exception", 	&POA_IR::HomeDef::create_exception_skel},
      {"describe_contents", 	&POA_IR::HomeDef::describe_contents_skel},
      {"move", 	&POA_IR::HomeDef::move_skel},
      {"contents", 	&POA_IR::HomeDef::contents_skel},
      {"_get_name", 	&POA_IR::HomeDef::_get_name_skel},
      {"_get_type", 	&POA_IR::HomeDef::_get_type_skel},
      {"_set_name", 	&POA_IR::HomeDef::_set_name_skel},
      {"_interface",  &POA_IR::HomeDef::_interface_skel},
      {"lookup_name", 	&POA_IR::HomeDef::lookup_name_skel},
      {"create_alias", 	&POA_IR::HomeDef::create_alias_skel},
      {"describe", 	&POA_IR::HomeDef::describe_skel},
      {"_get_base_home", 	&POA_IR::HomeDef::_get_base_home_skel},
      {"destroy", 	&POA_IR::HomeDef::destroy_skel},
      {"_get_absolute_name", 	&POA_IR::HomeDef::_get_absolute_name_skel},
      {"_get_primary_key", 	&POA_IR::HomeDef::_get_primary_key_skel},
      {"describe_interface", 	&POA_IR::HomeDef::describe_interface_skel},
      {"_non_existent",  &POA_IR::HomeDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_IR::HomeDef::_get_containing_repository_skel},
      {"create_value", 	&POA_IR::HomeDef::create_value_skel},
      {"create_module", 	&POA_IR::HomeDef::create_module_skel},
      {"create_native", 	&POA_IR::HomeDef::create_native_skel},
      {"create_attribute", 	&POA_IR::HomeDef::create_attribute_skel},
      {"create_interface", 	&POA_IR::HomeDef::create_interface_skel},
      {"_get_managed_component", 	&POA_IR::HomeDef::_get_managed_component_skel},
      {"create_factory", 	&POA_IR::HomeDef::create_factory_skel},
      {"create_local_interface", 	&POA_IR::HomeDef::create_local_interface_skel},
      {"create_primary_key", 	&POA_IR::HomeDef::create_primary_key_skel},
      {"create_abstract_interface", 	&POA_IR::HomeDef::create_abstract_interface_skel},
      {"create_struct", 	&POA_IR::HomeDef::create_struct_skel},
      {"create_constant", 	&POA_IR::HomeDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -1,   -1,    4,    5,    6,   -1,   -1,   -1,   -7,   -2,  -92,   -1, 
        -1,   -9,   -2,  -92,   11,   -1,   12,   -1,   -1,   -1,   -1,   -1,   -1,  -20, 
        -2,  -22,   -2,   13,   14,   15,   16,   -1,   17,   18,   19,   -1, -103, -102, 
        24,   -1,   25,   -1,  -27,   -3,   26,  -93,   30,   31,   32,   33,   34,   -1, 
        -1,   35,   36,   -1,   -1,   37,   -1,   38,   -1,   -1,   -1,   -1,   39,  -42, 
        -2,   40,   41,  -94,  -44,   -2,  -92,   46,   -1,   47,   -1,   -1,   48,   49, 
        -1,   50,   -1,   -1,   51,   -1,   52, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 13:56:28 */
static TAO_IR_HomeDef_Perfect_Hash_OpTable tao_IR_HomeDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_IR_HomeDef_base_home_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_base_home_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::HomeDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_base_home_get (const TAO_ServerRequestInfo_IR_HomeDef_base_home_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_base_home_get &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  IR::HomeDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_base_home_get::TAO_ServerRequestInfo_IR_HomeDef_base_home_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_base_home_get::result (IR::HomeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_managed_component_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_managed_component_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::ComponentDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_managed_component_get (const TAO_ServerRequestInfo_IR_HomeDef_managed_component_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_managed_component_get &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  IR::ComponentDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_primary_key_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_primary_key_get (const TAO_ServerRequestInfo_IR_HomeDef_primary_key_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_primary_key_get &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  IR::PrimaryKeyDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::result (IR::PrimaryKeyDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_factories_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_factories_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_factories_get (const TAO_ServerRequestInfo_IR_HomeDef_factories_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_factories_get &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  IR::FactoryDefSeq * _result;
};

TAO_ServerRequestInfo_IR_HomeDef_factories_get::TAO_ServerRequestInfo_IR_HomeDef_factories_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_factories_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_factories_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_factories_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_factories_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_factories_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_factories_get::result (IR::FactoryDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_finders_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_finders_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDefSeq * result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_finders_get (const TAO_ServerRequestInfo_IR_HomeDef_finders_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_finders_get &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  IR::FinderDefSeq * _result;
};

TAO_ServerRequestInfo_IR_HomeDef_finders_get::TAO_ServerRequestInfo_IR_HomeDef_finders_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_finders_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_finders_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_finders_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_finders_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_finders_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_finders_get::result (IR::FinderDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_is_basic_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_is_basic_get (const TAO_ServerRequestInfo_IR_HomeDef_is_basic_get &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_is_basic_get &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_create_primary_key : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_create_primary_key (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::PrimaryKeyDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_create_primary_key (const TAO_ServerRequestInfo_IR_HomeDef_create_primary_key &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_create_primary_key &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA_ValueDef_ptr primary_key_;
  IR::PrimaryKeyDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
  
  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::result (IR::PrimaryKeyDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_create_factory : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_create_factory (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FactoryDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_create_factory (const TAO_ServerRequestInfo_IR_HomeDef_create_factory &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_create_factory &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FactoryDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_create_factory::TAO_ServerRequestInfo_IR_HomeDef_create_factory (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_create_factory::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_create_factory::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_create_factory::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_create_factory::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_create_factory::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_create_factory::result (IR::FactoryDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_IR_HomeDef_create_finder : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_IR_HomeDef_create_finder (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (IR::FinderDef_ptr result);

private:
  TAO_ServerRequestInfo_IR_HomeDef_create_finder (const TAO_ServerRequestInfo_IR_HomeDef_create_finder &);
  void operator= (const TAO_ServerRequestInfo_IR_HomeDef_create_finder &);
  
private:
  POA_IR::HomeDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA_ParDescriptionSeq & params_;
  const CORBA_ExceptionDefSeq & exceptions_;
  IR::FinderDef_ptr _result;
};

TAO_ServerRequestInfo_IR_HomeDef_create_finder::TAO_ServerRequestInfo_IR_HomeDef_create_finder (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_IR_HomeDef_create_finder::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_IR_HomeDef_create_finder::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_IR_HomeDef_create_finder::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_IR_HomeDef_create_finder::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_IR_HomeDef_create_finder::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_IR_HomeDef_create_finder::result (IR::FinderDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker *POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::~_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

IR::_TAO_HomeDef_Proxy_Impl&
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::select_proxy (
    ::IR::HomeDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::IR::_TAO_HomeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


IR::_TAO_HomeDef_Proxy_Broker *
IR__TAO_HomeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker();
}

int
IR__TAO_HomeDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  IR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer = 
    IR__TAO_HomeDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int IR__TAO_HomeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  IR__TAO_HomeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, IR__TAO_HomeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::_TAO_HomeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::HomeDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->base_home (
        ACE_TRY_ENV
      );
}

IR::ComponentDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "managed_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->managed_component (
        ACE_TRY_ENV
      );
}

IR::PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->primary_key (
        ACE_TRY_ENV
      );
}

IR::FactoryDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::factories (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FactoryDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "factories",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->factories (
        ACE_TRY_ENV
      );
}

IR::FinderDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::finders (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FinderDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "finders",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->finders (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->is_basic (
        ACE_TRY_ENV
      );
}

IR::PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_primary_key (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_primary_key (
        id,
        name,
        version,
        primary_key,
        ACE_TRY_ENV
      );
}

IR::FactoryDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FactoryDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_factory",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_factory (
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
}

IR::FinderDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR::FinderDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_finder",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_finder (
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::HomeDef::HomeDef (void)
{
  this->optable_ = &tao_IR_HomeDef_optable;
}

// copy ctor
POA_IR::HomeDef::HomeDef (const HomeDef& rhs)
  :   POA_CORBA_InterfaceDef (rhs),
    POA_CORBA_Container (rhs),
    POA_CORBA_Contained (rhs),
    POA_CORBA_IDLType (rhs),
    POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::HomeDef::~HomeDef (void)
{
}

void POA_IR::HomeDef::_get_base_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::HomeDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_base_home_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->base_home (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::HomeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_managed_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::ComponentDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_managed_component_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->managed_component (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::PrimaryKeyDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_primary_key_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->primary_key (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_factories_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::FactoryDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_factories_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->factories (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FactoryDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_finders_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::FinderDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_finders_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->finders (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FinderDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_is_basic_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_basic (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::create_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::PrimaryKeyDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_create_primary_key ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_primary_key (
          id.in (),
          name.in (),
          version.in (),
          primary_key.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::PrimaryKeyDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::create_factory_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::FactoryDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ParDescriptionSeq params;
  CORBA_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_create_factory ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_factory (
          id.in (),
          name.in (),
          version.in (),
          params,
          exceptions,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FactoryDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::create_finder_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;
  
    IR::FinderDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA_ParDescriptionSeq params;
  CORBA_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_IR_HomeDef_create_finder ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_finder (
          id.in (),
          name.in (),
          version.in (),
          params,
          exceptions,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      IR::FinderDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::HomeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::HomeDef::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = _tao_impl->_get_interface (ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_IR::HomeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_IR::HomeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/HomeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::HomeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA_InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA_Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::HomeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::HomeDef*
POA_IR::HomeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::IR::HomeDef::_unchecked_narrow (obj.in ());
}



#endif /* ifndef */
