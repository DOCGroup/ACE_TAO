/*
 * File generated by CHIC (CHIC-COMMON-970407)
 *        from: cubit.idl
*/
#include <corba/cool.H>
#include "cubit.H"



//=========================================================
//    interface Cubit
//=========================================================



class _TypeCodeImpl_Cubit  {
public:
        static void
    push(COOL_Marshaler& marshaler, const void* t);
        static void*
    pop(COOL_Marshaler& marshaler);
        static size_t
    size(COOL_Marshaler& marshaler, const void* t);
        static void*
    copy(const void* from);
        static void
    release(void* t);

    static CORBA_TypeCode          constant;
    static const _COOL_TypeDefImpl typeDefImpl;
    static const void*const        parameters[];
};

const _COOL_TypeDefImpl _TypeCodeImpl_Cubit::typeDefImpl = {
    _TypeCodeImpl_Cubit::push,
    _TypeCodeImpl_Cubit::pop,
    _TypeCodeImpl_Cubit::size,
    _TypeCodeImpl_Cubit::copy,
    _TypeCodeImpl_Cubit::release
};

    void
_TypeCodeImpl_Cubit::push(COOL_Marshaler& marshaler, const void* t)
{
    const Cubit_ptr obj = *(const Cubit_ptr*) t;
    marshaler.put_Object(obj);
}
    void*
_TypeCodeImpl_Cubit::pop(COOL_Marshaler& marshaler)
{
    Cubit_ptr* t = new Cubit_ptr;
    *t = (Cubit_ptr) NULL;
    CubitMarshaler::get(marshaler, *t);
    return (void*) t;
}    
    size_t
_TypeCodeImpl_Cubit::size(COOL_Marshaler& marshaler, const void* t)
{
    const Cubit_ptr obj = *(const Cubit_ptr*)t;
    return marshaler.size_Object(obj);
}
    void*
_TypeCodeImpl_Cubit::copy(const void* from)
{
    Cubit_ptr* to  = new Cubit_ptr;
    *to = Cubit::_duplicate(*(const Cubit_ptr*)from);
    return (void*) to;
}    
    void
_TypeCodeImpl_Cubit::release(void* t)
{
    CORBA_release(*(Cubit_ptr*)t);
}


const void*const _TypeCodeImpl_Cubit::parameters[] = {
    (const void*) "IDL:Cubit:1.0",
    (const void*) "Cubit"
};


CORBA_TypeCode _TypeCodeImpl_Cubit::constant(
    CORBA_tk_objref,
    0x00750aa6,
    &_TypeCodeImpl_Cubit::typeDefImpl,
    _TypeCodeImpl_Cubit::parameters
);
const CORBA_TypeCode_ptr _tc_Cubit = &_TypeCodeImpl_Cubit::constant;


    Cubit_ptr
Cubit_proxy::operator =(Cubit_ptr ptr) 
{
    if (*ptr_ != ptr) {
        if (release_ == CORBA_TRUE) CORBA_release(*ptr_);
        *ptr_ = ptr;
    }
    return ptr;
}
    Cubit_ptr
Cubit_proxy::_duplicate(Cubit_ptr ptr)
{
    return Cubit::_duplicate(ptr);
}
    void
Cubit_proxy::_release(Cubit_ptr ptr)
{
    CORBA_release(ptr);
}
    Cubit_ptr
Cubit_proxy::_nil()
{
    return Cubit::_nil();
}

    void
CubitMarshaler::put(COOL_Marshaler& marshaler,
    const Cubit_ptr ptr)
{
    marshaler.put_Object(ptr);
}
    void
CubitMarshaler::get(COOL_Marshaler& marshaler,
    Cubit_ptr& ptr)
{
    CORBA_release(ptr);
    Cubit_ptr obj = new Cubit;
    if (marshaler.get_Object(obj) == CORBA_FALSE) {
        obj = Cubit::_nil();
    }
    ptr = obj;
}
    size_t
CubitMarshaler::size(COOL_Marshaler& marshaler,
    const Cubit_ptr ptr)
{
    return marshaler.size_Object(ptr);
}
static const _COOL_OperationDesc Cubit_desc[] = {
  { "cube_long", 2, (const CORBA_TypeCode_ptr*const*const) 0 },
  { "cube_octet", 0, (const CORBA_TypeCode_ptr*const*const) 0 },
  { "cube_short", 1, (const CORBA_TypeCode_ptr*const*const) 0 },
  { "cube_struct", 3, (const CORBA_TypeCode_ptr*const*const) 0 },
  { "cube_union", 4, (const CORBA_TypeCode_ptr*const*const) 0 },
  { "please_exit", 5, (const CORBA_TypeCode_ptr*const*const) 0 }
};
const _COOL_InterfaceDesc Cubit::coOperations = {
    "IDL:Cubit:1.0", 0x00750aa6, 6, Cubit_desc
};

const _COOL_FullInterfaceDesc Cubit::coInterfaceDef[] = {
    { &Cubit::coOperations, 0},
    { (const _COOL_InterfaceDesc*const) 0, 0}
};
Cubit Cubit::coNilObject(Cubit::coInterfaceDef);

Cubit::~Cubit()
{
}

    int
Cubit::_shiftVtbl(CORBA_Environment& _env) const
{
    return switchLocal(this, coOperations.typeId, _env);
}

//
// RPC fct: Cubit::cube_octet()
//
    CORBA_Octet
Cubit::cube_octet(CORBA_Octet o,
                  CORBA_Environment& _env) const
{
    int _error = _shiftVtbl(_env);
    if (_error == C_OK) {
        return cube_octet(o, _env);
    }
    CORBA_Octet _returnValue = 0;
    if (_error == C_EUNKNOWN) {
        return _returnValue;
    }
    _COOL_Request _req(this, coOperations, 1, 1, 0, _env);
    if (_env.exception()) {
        return _returnValue;
    }
    _req.put_Octet(o);

    if (_req.invoke(_env) != C_OK) {
        return _returnValue;
    }
    _returnValue = _req.get_Octet();
    return _returnValue;
}


//
// RPC fct: Cubit::cube_short()
//
    CORBA_Short
Cubit::cube_short(CORBA_Short s,
                  CORBA_Environment& _env) const
{
    int _error = _shiftVtbl(_env);
    if (_error == C_OK) {
        return cube_short(s, _env);
    }
    CORBA_Short _returnValue = 0;
    if (_error == C_EUNKNOWN) {
        return _returnValue;
    }
    _COOL_Request _req(this, coOperations, 2, 2, 0, _env);
    if (_env.exception()) {
        return _returnValue;
    }
    _req.put_Short(s);

    if (_req.invoke(_env) != C_OK) {
        return _returnValue;
    }
    _returnValue = _req.get_Short();
    return _returnValue;
}


//
// RPC fct: Cubit::cube_long()
//
    CORBA_Long
Cubit::cube_long(CORBA_Long l,
                 CORBA_Environment& _env) const
{
    int _error = _shiftVtbl(_env);
    if (_error == C_OK) {
        return cube_long(l, _env);
    }
    CORBA_Long _returnValue = 0;
    if (_error == C_EUNKNOWN) {
        return _returnValue;
    }
    _COOL_Request _req(this, coOperations, 0, 4, 0, _env);
    if (_env.exception()) {
        return _returnValue;
    }
    _req.put_Long(l);

    if (_req.invoke(_env) != C_OK) {
        return _returnValue;
    }
    _returnValue = _req.get_Long();
    return _returnValue;
}


//=========================================================
//    Structure Many
//=========================================================



class _TypeCodeImpl_Cubit_Many  {
public:
        static void
    push(COOL_Marshaler& marshaler, const void* t);
        static void*
    pop(COOL_Marshaler& marshaler);
        static size_t
    size(COOL_Marshaler& marshaler, const void* t);
        static void*
    copy(const void* from);
        static void
    release(void* t);

    static CORBA_TypeCode          constant;
    static const _COOL_TypeDefImpl typeDefImpl;
    static const void*const        parameters[];
};

const _COOL_TypeDefImpl _TypeCodeImpl_Cubit_Many::typeDefImpl = {
    _TypeCodeImpl_Cubit_Many::push,
    _TypeCodeImpl_Cubit_Many::pop,
    _TypeCodeImpl_Cubit_Many::size,
    _TypeCodeImpl_Cubit_Many::copy,
    _TypeCodeImpl_Cubit_Many::release
};

    void
_TypeCodeImpl_Cubit_Many::push(COOL_Marshaler& marshaler, const void* t)
{
    Cubit::ManyMarshaler::put(marshaler, *(const Cubit::Many*)t);
}
    void*
_TypeCodeImpl_Cubit_Many::pop(COOL_Marshaler& marshaler)
{
    Cubit::Many* t = new Cubit::Many;
    Cubit::ManyMarshaler::get(marshaler, *t);
    return (void*) t;
}    
    size_t
_TypeCodeImpl_Cubit_Many::size(COOL_Marshaler&, const void*)
{
    return 10;
}
    void*
_TypeCodeImpl_Cubit_Many::copy(const void* from)
{
    Cubit::Many* to = new Cubit::Many(*(const Cubit::Many*)from);
    return (void*) to;
}    
    void
_TypeCodeImpl_Cubit_Many::release(void* t)
{
    delete (Cubit::Many*)t;
}


const void*const _TypeCodeImpl_Cubit_Many::parameters[] = {
    (const void*) "IDL:Eng.SUN.COM/Cubit/Many:1.0",
    (const void*) "Many",
    (const void*) 3UL,
    (const void*) "o", (const void*) &CORBA__tc_octet,
    (const void*) "l", (const void*) &CORBA__tc_long,
    (const void*) "s", (const void*) &CORBA__tc_short
};


CORBA_TypeCode _TypeCodeImpl_Cubit_Many::constant(
    CORBA_tk_struct,
    0x004e6a97,
    &_TypeCodeImpl_Cubit_Many::typeDefImpl,
    _TypeCodeImpl_Cubit_Many::parameters
);
 CORBA_TypeCode_ptr Cubit::_tc_Many = &_TypeCodeImpl_Cubit_Many::constant;


    void

Cubit::ManyMarshaler::put(COOL_Marshaler& marshaler,
    const Cubit::Many& obj)
{
     marshaler.put_Octet(obj.o);
     marshaler.put_Long(obj.l);
     marshaler.put_Short(obj.s);
}

    void
Cubit::ManyMarshaler::get(COOL_Marshaler& marshaler,
    Cubit::Many& obj)
{
    obj.o =  marshaler.get_Octet();
    obj.l =  marshaler.get_Long();
    obj.s =  marshaler.get_Short();
}


//
// RPC fct: Cubit::cube_struct()
//
    Cubit::Many
Cubit::cube_struct(const Cubit::Many& values,
                   CORBA_Environment& _env) const
{
    int _error = _shiftVtbl(_env);
    if (_error == C_OK) {
        return cube_struct(values, _env);
    }
    Cubit::Many _returnValue;
    if (_error == C_EUNKNOWN) {
        return _returnValue;
    }
    _COOL_Request _req(this, coOperations, 3, 10, 0, _env);
    if (_env.exception()) {
        return _returnValue;
    }
    Cubit::ManyMarshaler::put(_req, values);

    if (_req.invoke(_env) != C_OK) {
        return _returnValue;
    }
    Cubit::ManyMarshaler::get(_req, _returnValue);
    return _returnValue;
}


//=========================================================
//    Enum discrim
//=========================================================



class _TypeCodeImpl_Cubit_discrim  {
public:
        static void
    push(COOL_Marshaler& marshaler, const void* t);
        static void*
    pop(COOL_Marshaler& marshaler);
        static size_t
    size(COOL_Marshaler& marshaler, const void* t);
        static void*
    copy(const void* from);
        static void
    release(void* t);

    static CORBA_TypeCode          constant;
    static const _COOL_TypeDefImpl typeDefImpl;
    static const void*const        parameters[];
};

const _COOL_TypeDefImpl _TypeCodeImpl_Cubit_discrim::typeDefImpl = {
    _TypeCodeImpl_Cubit_discrim::push,
    _TypeCodeImpl_Cubit_discrim::pop,
    _TypeCodeImpl_Cubit_discrim::size,
    _TypeCodeImpl_Cubit_discrim::copy,
    _TypeCodeImpl_Cubit_discrim::release
};

    void
_TypeCodeImpl_Cubit_discrim::push(COOL_Marshaler& marshaler, const void* t)
{
    marshaler.put_ULong((CORBA_ULong) *(const Cubit::discrim*)t);

}
    void*
_TypeCodeImpl_Cubit_discrim::pop(COOL_Marshaler& marshaler)
{
    Cubit::discrim* t = new Cubit::discrim;
    *t = (Cubit::discrim) marshaler.get_ULong();
    return (void*) t;
}    
    size_t
_TypeCodeImpl_Cubit_discrim::size(COOL_Marshaler& marshaler, const void*)
{
    return marshaler.size_ULong();
}
    void*
_TypeCodeImpl_Cubit_discrim::copy(const void* from)
{
    Cubit::discrim* to = new Cubit::discrim(*(const Cubit::discrim*)from);
    return (void*) to;
}    
    void
_TypeCodeImpl_Cubit_discrim::release(void* t)
{
    delete (Cubit::discrim*)t;
}


const void*const _TypeCodeImpl_Cubit_discrim::parameters[] = {
    (const void*) "IDL:Eng.SUN.COM/Cubit/discrim:1.0",
    (const void*) "discrim",
    (const void*) 6UL,
    (const void*) "e_0th",
    (const void*) "e_1st",
    (const void*) "e_2nd",
    (const void*) "e_3rd",
    (const void*) "e_4th",
    (const void*) "e_5th"
};


CORBA_TypeCode _TypeCodeImpl_Cubit_discrim::constant(
    CORBA_tk_enum,
    0x006e1395,
    &_TypeCodeImpl_Cubit_discrim::typeDefImpl,
    _TypeCodeImpl_Cubit_discrim::parameters
);
 CORBA_TypeCode_ptr Cubit::_tc_discrim = &_TypeCodeImpl_Cubit_discrim::constant;

    void
Cubit::oneof::_d(Cubit::discrim val)
{
    switch(val) {
    case Cubit::e_0th:
        if (initialized_ == 1) discriminant_ = val;
        break;
    case Cubit::e_1st:
        if (initialized_ == 2) discriminant_ = val;
        break;
    case Cubit::e_2nd:
        if (initialized_ == 3) discriminant_ = val;
        break;
    case Cubit::e_3rd:
    default:
        if (initialized_ == 4) discriminant_ = val;
        break;
    }
}
    void
Cubit::oneof::build(const oneof& val)
{
    memcpy(this, &val, sizeof(oneof));
}
    void
Cubit::oneofMarshaler::put(COOL_Marshaler& req, const Cubit::oneof& obj)
{
    req.put_ULong((CORBA_ULong) obj.discriminant_);
    switch(obj.initialized_) {
    case 1:
        req.put_Octet(*((CORBA_Octet*) obj.value_));
        break;
    case 2:
        req.put_Short(*((CORBA_Short*) obj.value_));
        break;
    case 3:
        req.put_Long(*((CORBA_Long*) obj.value_));
        break;
    case 4:
        Cubit::ManyMarshaler::put(req, *((Cubit::Many*) obj.value_));
        break;
    }
}
    void
Cubit::oneofMarshaler::get(COOL_Marshaler& req, Cubit::oneof& obj)
{
    obj.discriminant_ = (Cubit::discrim) req.get_ULong();
    switch(obj.discriminant_) {
    case Cubit::e_0th:
        obj.initialized_ = (CORBA_ULong) 1;
        *((CORBA_Octet*) obj.value_) = req.get_Octet();
        break;
    case Cubit::e_1st:
        obj.initialized_ = (CORBA_ULong) 2;
        *((CORBA_Short*) obj.value_) = req.get_Short();
        break;
    case Cubit::e_2nd:
        obj.initialized_ = (CORBA_ULong) 3;
        *((CORBA_Long*) obj.value_) = req.get_Long();
        break;
    case Cubit::e_3rd:
    default:
        obj.initialized_ = (CORBA_ULong) 4;
        new(obj.value_, _new_placement)Cubit::Many();
        Cubit::ManyMarshaler::get(req, *((Cubit::Many*) obj.value_));
        break;
    }
}


class _TypeCodeImpl_Cubit_oneof  {
public:
        static void
    push(COOL_Marshaler& marshaler, const void* t);
        static void*
    pop(COOL_Marshaler& marshaler);
        static size_t
    size(COOL_Marshaler& marshaler, const void* t);
        static void*
    copy(const void* from);
        static void
    release(void* t);

    static CORBA_TypeCode          constant;
    static const _COOL_TypeDefImpl typeDefImpl;
    static const void*const        parameters[];
};

const _COOL_TypeDefImpl _TypeCodeImpl_Cubit_oneof::typeDefImpl = {
    _TypeCodeImpl_Cubit_oneof::push,
    _TypeCodeImpl_Cubit_oneof::pop,
    _TypeCodeImpl_Cubit_oneof::size,
    _TypeCodeImpl_Cubit_oneof::copy,
    _TypeCodeImpl_Cubit_oneof::release
};

    void
_TypeCodeImpl_Cubit_oneof::push(COOL_Marshaler& marshaler, const void* t)
{
    Cubit::oneofMarshaler::put(marshaler, *(const Cubit::oneof*)t);
}
    void*
_TypeCodeImpl_Cubit_oneof::pop(COOL_Marshaler& marshaler)
{
    Cubit::oneof* t = new Cubit::oneof;
    Cubit::oneofMarshaler::get(marshaler, *t);
    return (void*) t;
}    
    size_t
_TypeCodeImpl_Cubit_oneof::size(COOL_Marshaler&, const void*)
{
    return 14;
}
    void*
_TypeCodeImpl_Cubit_oneof::copy(const void* from)
{
    Cubit::oneof* to = new Cubit::oneof(*(const Cubit::oneof*)from);
    return (void*) to;
}    
    void
_TypeCodeImpl_Cubit_oneof::release(void* t)
{
    delete (Cubit::oneof*)t;
}


const void*const _TypeCodeImpl_Cubit_oneof::parameters[] = {
    (const void*) "IDL:Eng.SUN.COM/Cubit/oneof:1.0",
    (const void*) "oneof", 
    (const void*) &Cubit::_tc_discrim,
    (const void*) 4L,
    (const void*) 5UL,
    (const void*) (Cubit::discrim) Cubit::e_0th,
        (const void*) "o", (const void*) &CORBA__tc_octet,
    (const void*) (Cubit::discrim) Cubit::e_1st,
        (const void*) "s", (const void*) &CORBA__tc_short,
    (const void*) (Cubit::discrim) Cubit::e_2nd,
        (const void*) "l", (const void*) &CORBA__tc_long,
    (const void*) (Cubit::discrim) Cubit::e_3rd,
        (const void*) "cm", (const void*) &Cubit::_tc_Many,
    (const void*) (Cubit::discrim) 4,
        (const void*) "cm", (const void*) &Cubit::_tc_Many
};


CORBA_TypeCode _TypeCodeImpl_Cubit_oneof::constant(
    CORBA_tk_union,
    0x0070cd3e,
    &_TypeCodeImpl_Cubit_oneof::typeDefImpl,
    _TypeCodeImpl_Cubit_oneof::parameters
);
 CORBA_TypeCode_ptr Cubit::_tc_oneof = &_TypeCodeImpl_Cubit_oneof::constant;


//
// RPC fct: Cubit::cube_union()
//
    Cubit::oneof
Cubit::cube_union(const Cubit::oneof& values,
                  CORBA_Environment& _env) const
{
    int _error = _shiftVtbl(_env);
    if (_error == C_OK) {
        return cube_union(values, _env);
    }
    Cubit::oneof _returnValue;
    if (_error == C_EUNKNOWN) {
        return _returnValue;
    }
    _COOL_Request _req(this, coOperations, 4, 14, 0, _env);
    if (_env.exception()) {
        return _returnValue;
    }
    Cubit::oneofMarshaler::put(_req, values);

    if (_req.invoke(_env) != C_OK) {
        return _returnValue;
    }
    Cubit::oneofMarshaler::get(_req, _returnValue);
    return _returnValue;
}


//
// RPC fct: Cubit::please_exit()
//
    void
Cubit::please_exit(CORBA_Environment& _env) const
{
    int _error = _shiftVtbl(_env);
    if (_error == C_OK) {
        please_exit(_env);
        return;
    }
    if (_error == C_EUNKNOWN) {
        return;
    }
    _COOL_Request _req(this, coOperations, 5, 0, 1, _env);

    _req.send(_env);
}


