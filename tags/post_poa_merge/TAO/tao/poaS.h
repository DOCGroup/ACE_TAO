// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington 
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#if !defined (_TAO_IDL_POAS_H_)
#define _TAO_IDL_POAS_H_

#include "poaC.h"

class POA_PortableServer
{
public:
  class CurrentBase;
  typedef CurrentBase *CurrentBase_ptr;
  class CurrentBase :  public virtual PortableServer::LocalServantBase
  {
  protected:
    CurrentBase (void);
      public:
    virtual ~CurrentBase (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::CurrentBase *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_CURRENTBASE___COLLOCATED_SH_)
#define _PORTABLESERVER_CURRENTBASE___COLLOCATED_SH_

  class _tao_collocated_CurrentBase    : public virtual PortableServer::CurrentBase
  {
  public:
    _tao_collocated_CurrentBase (
        CurrentBase_ptr  servant,
        STUB_Object *stub
      );
    CurrentBase_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
  
  private:
    CurrentBase_ptr servant_;
  };


#endif // end #if !defined


  class Policy;
  typedef Policy *Policy_ptr;
  class Policy :  public virtual PortableServer::LocalServantBase
  {
  protected:
    Policy (void);
      public:
    virtual ~Policy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::Policy_ptr  copy ( CORBA::Environment &env) = 0; // pure virtual
    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void destroy ( CORBA::Environment &env) = 0; // pure virtual
    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::Policy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_POLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_POLICY___COLLOCATED_SH_

  class _tao_collocated_Policy    : public virtual PortableServer::Policy
  {
  public:
    _tao_collocated_Policy (
        Policy_ptr  servant,
        STUB_Object *stub
      );
    Policy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::Policy_ptr copy (
        CORBA::Environment &_tao_environment
      );
    virtual void destroy (
        CORBA::Environment &_tao_environment
      );
  
  private:
    Policy_ptr servant_;
  };


#endif // end #if !defined


  class ThreadPolicy;
  typedef ThreadPolicy *ThreadPolicy_ptr;
  class ThreadPolicy : public virtual Policy
  {
  protected:
    ThreadPolicy (void);
      public:
    virtual ~ThreadPolicy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::ThreadPolicyValue value (CORBA::Environment &env) = 0;
    static void _get_value_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::ThreadPolicy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_THREADPOLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_THREADPOLICY___COLLOCATED_SH_

  class _tao_collocated_ThreadPolicy    : public virtual PortableServer::ThreadPolicy,
      public virtual _tao_collocated_Policy
  {
  public:
    _tao_collocated_ThreadPolicy (
        ThreadPolicy_ptr  servant,
        STUB_Object *stub
      );
    ThreadPolicy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ThreadPolicyValue value (
        CORBA::Environment &env
      );
  
  private:
    ThreadPolicy_ptr servant_;
  };


#endif // end #if !defined


  class LifespanPolicy;
  typedef LifespanPolicy *LifespanPolicy_ptr;
  class LifespanPolicy : public virtual Policy
  {
  protected:
    LifespanPolicy (void);
      public:
    virtual ~LifespanPolicy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::LifespanPolicyValue value (CORBA::Environment &env) = 0;
    static void _get_value_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::LifespanPolicy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_LIFESPANPOLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_LIFESPANPOLICY___COLLOCATED_SH_

  class _tao_collocated_LifespanPolicy    : public virtual PortableServer::LifespanPolicy,
      public virtual _tao_collocated_Policy
  {
  public:
    _tao_collocated_LifespanPolicy (
        LifespanPolicy_ptr  servant,
        STUB_Object *stub
      );
    LifespanPolicy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::LifespanPolicyValue value (
        CORBA::Environment &env
      );
  
  private:
    LifespanPolicy_ptr servant_;
  };


#endif // end #if !defined


  class IdUniquenessPolicy;
  typedef IdUniquenessPolicy *IdUniquenessPolicy_ptr;
  class IdUniquenessPolicy : public virtual Policy
  {
  protected:
    IdUniquenessPolicy (void);
      public:
    virtual ~IdUniquenessPolicy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::IdUniquenessPolicyValue value (CORBA::Environment &env) = 0;
    static void _get_value_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::IdUniquenessPolicy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY___COLLOCATED_SH_

  class _tao_collocated_IdUniquenessPolicy    : public virtual PortableServer::IdUniquenessPolicy,
      public virtual _tao_collocated_Policy
  {
  public:
    _tao_collocated_IdUniquenessPolicy (
        IdUniquenessPolicy_ptr  servant,
        STUB_Object *stub
      );
    IdUniquenessPolicy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::IdUniquenessPolicyValue value (
        CORBA::Environment &env
      );
  
  private:
    IdUniquenessPolicy_ptr servant_;
  };


#endif // end #if !defined


  class IdAssignmentPolicy;
  typedef IdAssignmentPolicy *IdAssignmentPolicy_ptr;
  class IdAssignmentPolicy : public virtual Policy
  {
  protected:
    IdAssignmentPolicy (void);
      public:
    virtual ~IdAssignmentPolicy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::IdAssignmentPolicyValue value (CORBA::Environment &env) = 0;
    static void _get_value_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::IdAssignmentPolicy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY___COLLOCATED_SH_

  class _tao_collocated_IdAssignmentPolicy    : public virtual PortableServer::IdAssignmentPolicy,
      public virtual _tao_collocated_Policy
  {
  public:
    _tao_collocated_IdAssignmentPolicy (
        IdAssignmentPolicy_ptr  servant,
        STUB_Object *stub
      );
    IdAssignmentPolicy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::IdAssignmentPolicyValue value (
        CORBA::Environment &env
      );
  
  private:
    IdAssignmentPolicy_ptr servant_;
  };


#endif // end #if !defined


  class ImplicitActivationPolicy;
  typedef ImplicitActivationPolicy *ImplicitActivationPolicy_ptr;
  class ImplicitActivationPolicy : public virtual Policy
  {
  protected:
    ImplicitActivationPolicy (void);
      public:
    virtual ~ImplicitActivationPolicy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::ImplicitActivationPolicyValue value (CORBA::Environment &env) = 0;
    static void _get_value_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::ImplicitActivationPolicy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY___COLLOCATED_SH_

  class _tao_collocated_ImplicitActivationPolicy    : public virtual PortableServer::ImplicitActivationPolicy,
      public virtual _tao_collocated_Policy
  {
  public:
    _tao_collocated_ImplicitActivationPolicy (
        ImplicitActivationPolicy_ptr  servant,
        STUB_Object *stub
      );
    ImplicitActivationPolicy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ImplicitActivationPolicyValue value (
        CORBA::Environment &env
      );
  
  private:
    ImplicitActivationPolicy_ptr servant_;
  };


#endif // end #if !defined


  class ServantRetentionPolicy;
  typedef ServantRetentionPolicy *ServantRetentionPolicy_ptr;
  class ServantRetentionPolicy : public virtual Policy
  {
  protected:
    ServantRetentionPolicy (void);
      public:
    virtual ~ServantRetentionPolicy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::ServantRetentionPolicyValue value (CORBA::Environment &env) = 0;
    static void _get_value_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::ServantRetentionPolicy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY___COLLOCATED_SH_

  class _tao_collocated_ServantRetentionPolicy    : public virtual PortableServer::ServantRetentionPolicy,
      public virtual _tao_collocated_Policy
  {
  public:
    _tao_collocated_ServantRetentionPolicy (
        ServantRetentionPolicy_ptr  servant,
        STUB_Object *stub
      );
    ServantRetentionPolicy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ServantRetentionPolicyValue value (
        CORBA::Environment &env
      );
  
  private:
    ServantRetentionPolicy_ptr servant_;
  };


#endif // end #if !defined


  class RequestProcessingPolicy;
  typedef RequestProcessingPolicy *RequestProcessingPolicy_ptr;
  class RequestProcessingPolicy : public virtual Policy
  {
  protected:
    RequestProcessingPolicy (void);
      public:
    virtual ~RequestProcessingPolicy (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::RequestProcessingPolicyValue value (CORBA::Environment &env) = 0;
    static void _get_value_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    static void copy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::RequestProcessingPolicy *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY___COLLOCATED_SH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY___COLLOCATED_SH_

  class _tao_collocated_RequestProcessingPolicy    : public virtual PortableServer::RequestProcessingPolicy,
      public virtual _tao_collocated_Policy
  {
  public:
    _tao_collocated_RequestProcessingPolicy (
        RequestProcessingPolicy_ptr  servant,
        STUB_Object *stub
      );
    RequestProcessingPolicy_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::RequestProcessingPolicyValue value (
        CORBA::Environment &env
      );
  
  private:
    RequestProcessingPolicy_ptr servant_;
  };


#endif // end #if !defined


  class POAManager;
  typedef POAManager *POAManager_ptr;
  class POAManager :  public virtual PortableServer::LocalServantBase
  {
  protected:
    POAManager (void);
      public:
    virtual ~POAManager (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual void activate ( CORBA::Environment &env) = 0; // pure virtual
    static void activate_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void hold_requests (CORBA::Boolean wait_for_completion,  CORBA::Environment &env) = 0; // pure virtual
    static void hold_requests_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void discard_requests (CORBA::Boolean wait_for_completion,  CORBA::Environment &env) = 0; // pure virtual
    static void discard_requests_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void deactivate (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion,  CORBA::Environment &env) = 0; // pure virtual
    static void deactivate_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::POAManager *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_POAMANAGER___COLLOCATED_SH_)
#define _PORTABLESERVER_POAMANAGER___COLLOCATED_SH_

  class _tao_collocated_POAManager    : public virtual PortableServer::POAManager
  {
  public:
    _tao_collocated_POAManager (
        POAManager_ptr  servant,
        STUB_Object *stub
      );
    POAManager_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual void activate (
        CORBA::Environment &_tao_environment
      );
    virtual void hold_requests (
        CORBA::Boolean wait_for_completion,
        CORBA::Environment &_tao_environment
      );
    virtual void discard_requests (
        CORBA::Boolean wait_for_completion,
        CORBA::Environment &_tao_environment
      );
    virtual void deactivate (
        CORBA::Boolean etherealize_objects,
        CORBA::Boolean wait_for_completion,
        CORBA::Environment &_tao_environment
      );
  
  private:
    POAManager_ptr servant_;
  };


#endif // end #if !defined


  class AdapterActivator;
  typedef AdapterActivator *AdapterActivator_ptr;
  class TAO_Export AdapterActivator :  public virtual PortableServer::LocalServantBase
  {
  protected:
    AdapterActivator (void);
      public:
    virtual ~AdapterActivator (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual CORBA::Boolean unknown_adapter (PortableServer::POA_ptr parent, const char *name,  CORBA::Environment &env) = 0; // pure virtual
    static void unknown_adapter_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::AdapterActivator *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR___COLLOCATED_SH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR___COLLOCATED_SH_

  class _tao_collocated_AdapterActivator    : public virtual PortableServer::AdapterActivator
  {
  public:
    _tao_collocated_AdapterActivator (
        AdapterActivator_ptr  servant,
        STUB_Object *stub
      );
    AdapterActivator_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual CORBA::Boolean unknown_adapter (
        PortableServer::POA_ptr  parent,
        const char* name,
        CORBA::Environment &_tao_environment
      );
  
  private:
    AdapterActivator_ptr servant_;
  };


#endif // end #if !defined


  class ServantManager;
  typedef ServantManager *ServantManager_ptr;
  class TAO_Export ServantManager :  public virtual PortableServer::LocalServantBase
  {
  protected:
    ServantManager (void);
      public:
    virtual ~ServantManager (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::ServantManager *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_SERVANTMANAGER___COLLOCATED_SH_)
#define _PORTABLESERVER_SERVANTMANAGER___COLLOCATED_SH_

  class _tao_collocated_ServantManager    : public virtual PortableServer::ServantManager
  {
  public:
    _tao_collocated_ServantManager (
        ServantManager_ptr  servant,
        STUB_Object *stub
      );
    ServantManager_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
  
  private:
    ServantManager_ptr servant_;
  };


#endif // end #if !defined


  class ServantActivator;
  typedef ServantActivator *ServantActivator_ptr;
  class TAO_Export ServantActivator : public virtual ServantManager
  {
  protected:
    ServantActivator (void);
      public:
    virtual ~ServantActivator (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::Servant incarnate (const PortableServer::ObjectId &oid, PortableServer::POA_ptr adapter,  CORBA::Environment &env) = 0; // pure virtual
    static void incarnate_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void etherealize (const PortableServer::ObjectId &oid, PortableServer::POA_ptr adapter, PortableServer::Servant serv, CORBA::Boolean cleanup_in_progress, CORBA::Boolean remaining_activations,  CORBA::Environment &env) = 0; // pure virtual
    static void etherealize_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::ServantActivator *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_SERVANTACTIVATOR___COLLOCATED_SH_)
#define _PORTABLESERVER_SERVANTACTIVATOR___COLLOCATED_SH_

  class _tao_collocated_ServantActivator    : public virtual PortableServer::ServantActivator,
      public virtual _tao_collocated_ServantManager
  {
  public:
    _tao_collocated_ServantActivator (
        ServantActivator_ptr  servant,
        STUB_Object *stub
      );
    ServantActivator_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::Servant incarnate (
        const PortableServer::ObjectId & oid,
        PortableServer::POA_ptr  adapter,
        CORBA::Environment &_tao_environment
      );
    virtual void etherealize (
        const PortableServer::ObjectId & oid,
        PortableServer::POA_ptr  adapter,
        PortableServer::Servant serv,
        CORBA::Boolean cleanup_in_progress,
        CORBA::Boolean remaining_activations,
        CORBA::Environment &_tao_environment
      );
  
  private:
    ServantActivator_ptr servant_;
  };


#endif // end #if !defined


  class ServantLocator;
  typedef ServantLocator *ServantLocator_ptr;
  class TAO_Export ServantLocator : public virtual ServantManager
  {
  protected:
    ServantLocator (void);
      public:
    virtual ~ServantLocator (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::Servant preinvoke (const PortableServer::ObjectId &oid, 
                                               PortableServer::POA_ptr adapter, 
                                               const char *operation, 
                                               PortableServer::ServantLocator::Cookie & the_cookie,  
                                               CORBA::Environment &env) = 0; // pure virtual
    static void preinvoke_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void postinvoke (const PortableServer::ObjectId &oid, PortableServer::POA_ptr adapter, const char *operation, PortableServer::ServantLocator::Cookie the_cookie, PortableServer::Servant the_servant,  CORBA::Environment &env) = 0; // pure virtual
    static void postinvoke_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::ServantLocator *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_SERVANTLOCATOR___COLLOCATED_SH_)
#define _PORTABLESERVER_SERVANTLOCATOR___COLLOCATED_SH_

  class _tao_collocated_ServantLocator    : public virtual PortableServer::ServantLocator,
      public virtual _tao_collocated_ServantManager
  {
  public:
    _tao_collocated_ServantLocator (
        ServantLocator_ptr  servant,
        STUB_Object *stub
      );
    ServantLocator_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::Servant preinvoke (
        const PortableServer::ObjectId & oid,
        PortableServer::POA_ptr  adapter,
        const char * operation,
        PortableServer::ServantLocator::Cookie & the_cookie,
        CORBA::Environment &_tao_environment
      );
    virtual void postinvoke (
        const PortableServer::ObjectId & oid,
        PortableServer::POA_ptr  adapter,
        const char * operation,
        PortableServer::ServantLocator::Cookie the_cookie,
        PortableServer::Servant the_servant,
        CORBA::Environment &_tao_environment
      );
  
  private:
    ServantLocator_ptr servant_;
  };


#endif // end #if !defined


  class POA;
  typedef POA *POA_ptr;
  class POA :  public virtual PortableServer::LocalServantBase
  {
  protected:
    POA (void);
      public:
    virtual ~POA (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::POA_ptr  create_POA (const char *adapter_name, PortableServer::POAManager_ptr a_POAManager, const PortableServer::PolicyList &policies,  CORBA::Environment &env) = 0; // pure virtual
    static void create_POA_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::POA_ptr  find_POA (const char *adapter_name, CORBA::Boolean activate_it,  CORBA::Environment &env) = 0; // pure virtual
    static void find_POA_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void destroy (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion,  CORBA::Environment &env) = 0; // pure virtual
    static void destroy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ThreadPolicy_ptr  create_thread_policy (PortableServer::ThreadPolicyValue value,  CORBA::Environment &env) = 0; // pure virtual
    static void create_thread_policy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::LifespanPolicy_ptr  create_lifespan_policy (PortableServer::LifespanPolicyValue value,  CORBA::Environment &env) = 0; // pure virtual
    static void create_lifespan_policy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::IdUniquenessPolicy_ptr  create_id_uniqueness_policy (PortableServer::IdUniquenessPolicyValue value,  CORBA::Environment &env) = 0; // pure virtual
    static void create_id_uniqueness_policy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::IdAssignmentPolicy_ptr  create_id_assignment_policy (PortableServer::IdAssignmentPolicyValue value,  CORBA::Environment &env) = 0; // pure virtual
    static void create_id_assignment_policy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ImplicitActivationPolicy_ptr  create_implicit_activation_policy (PortableServer::ImplicitActivationPolicyValue value,  CORBA::Environment &env) = 0; // pure virtual
    static void create_implicit_activation_policy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ServantRetentionPolicy_ptr  create_servant_retention_policy (PortableServer::ServantRetentionPolicyValue value,  CORBA::Environment &env) = 0; // pure virtual
    static void create_servant_retention_policy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::RequestProcessingPolicy_ptr  create_request_processing_policy (PortableServer::RequestProcessingPolicyValue value,  CORBA::Environment &env) = 0; // pure virtual
    static void create_request_processing_policy_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual char * the_name (CORBA::Environment &env) = 0;
    static void _get_the_name_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::POA_ptr  the_parent (CORBA::Environment &env) = 0;
    static void _get_the_parent_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::POAManager_ptr  the_POAManager (CORBA::Environment &env) = 0;
    static void _get_the_POAManager_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::AdapterActivator_ptr  the_activator (CORBA::Environment &env) = 0;
    static void _get_the_activator_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void the_activator(PortableServer::AdapterActivator_ptr the_activator, CORBA::Environment &env) = 0;
    static void _set_the_activator_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ServantManager_ptr  get_servant_manager ( CORBA::Environment &env) = 0; // pure virtual
    static void get_servant_manager_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void set_servant_manager (PortableServer::ServantManager_ptr imgr,  CORBA::Environment &env) = 0; // pure virtual
    static void set_servant_manager_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::Servant get_servant ( CORBA::Environment &env) = 0; // pure virtual
    static void get_servant_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void set_servant (PortableServer::Servant p_servant,  CORBA::Environment &env) = 0; // pure virtual
    static void set_servant_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ObjectId * activate_object (PortableServer::Servant p_servant,  CORBA::Environment &env) = 0; // pure virtual
    static void activate_object_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void activate_object_with_id (const PortableServer::ObjectId &id, PortableServer::Servant p_servant,  CORBA::Environment &env) = 0; // pure virtual
    static void activate_object_with_id_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual void deactivate_object (const PortableServer::ObjectId &oid,  CORBA::Environment &env) = 0; // pure virtual
    static void deactivate_object_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual CORBA::Object_ptr create_reference (const char *intf,  CORBA::Environment &env) = 0; // pure virtual
    static void create_reference_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual CORBA::Object_ptr create_reference_with_id (const PortableServer::ObjectId &oid, const char *intf,  CORBA::Environment &env) = 0; // pure virtual
    static void create_reference_with_id_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ObjectId * servant_to_id (PortableServer::Servant p_servant,  CORBA::Environment &env) = 0; // pure virtual
    static void servant_to_id_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual CORBA::Object_ptr servant_to_reference (PortableServer::Servant p_servant,  CORBA::Environment &env) = 0; // pure virtual
    static void servant_to_reference_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::Servant reference_to_servant (CORBA::Object_ptr reference,  CORBA::Environment &env) = 0; // pure virtual
    static void reference_to_servant_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ObjectId * reference_to_id (CORBA::Object_ptr reference,  CORBA::Environment &env) = 0; // pure virtual
    static void reference_to_id_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::Servant id_to_servant (const PortableServer::ObjectId &oid,  CORBA::Environment &env) = 0; // pure virtual
    static void id_to_servant_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual CORBA::Object_ptr id_to_reference (const PortableServer::ObjectId &oid,  CORBA::Environment &env) = 0; // pure virtual
    static void id_to_reference_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::POA *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_POA___COLLOCATED_SH_)
#define _PORTABLESERVER_POA___COLLOCATED_SH_

  class _tao_collocated_POA    : public virtual PortableServer::POA
  {
  public:
    _tao_collocated_POA (
        POA_ptr  servant,
        STUB_Object *stub
      );
    POA_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::POA_ptr create_POA (
        const char* adapter_name,
        PortableServer::POAManager_ptr  a_POAManager,
        const PortableServer::PolicyList & policies,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::POA_ptr find_POA (
        const char* adapter_name,
        CORBA::Boolean activate_it,
        CORBA::Environment &_tao_environment
      );
    virtual void destroy (
        CORBA::Boolean etherealize_objects,
        CORBA::Boolean wait_for_completion,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ThreadPolicy_ptr create_thread_policy (
        PortableServer::ThreadPolicyValue value,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::LifespanPolicy_ptr create_lifespan_policy (
        PortableServer::LifespanPolicyValue value,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::IdUniquenessPolicy_ptr create_id_uniqueness_policy (
        PortableServer::IdUniquenessPolicyValue value,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::IdAssignmentPolicy_ptr create_id_assignment_policy (
        PortableServer::IdAssignmentPolicyValue value,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ImplicitActivationPolicy_ptr create_implicit_activation_policy (
        PortableServer::ImplicitActivationPolicyValue value,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ServantRetentionPolicy_ptr create_servant_retention_policy (
        PortableServer::ServantRetentionPolicyValue value,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::RequestProcessingPolicy_ptr create_request_processing_policy (
        PortableServer::RequestProcessingPolicyValue value,
        CORBA::Environment &_tao_environment
      );
    virtual char*  the_name (
        CORBA::Environment &env
      );
    virtual PortableServer::POA_ptr the_parent (
        CORBA::Environment &env
      );
    virtual PortableServer::POAManager_ptr the_POAManager (
        CORBA::Environment &env
      );
    virtual PortableServer::AdapterActivator_ptr the_activator (
        CORBA::Environment &env
      );
    virtual void the_activator (PortableServer::AdapterActivator_ptr  _tao_value,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ServantManager_ptr get_servant_manager (
        CORBA::Environment &_tao_environment
      );
    virtual void set_servant_manager (
        PortableServer::ServantManager_ptr  imgr,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::Servant get_servant (
        CORBA::Environment &_tao_environment
      );
    virtual void set_servant (
        PortableServer::Servant p_servant,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ObjectId * activate_object (
        PortableServer::Servant p_servant,
        CORBA::Environment &_tao_environment
      );
    virtual void activate_object_with_id (
        const PortableServer::ObjectId & id,
        PortableServer::Servant p_servant,
        CORBA::Environment &_tao_environment
      );
    virtual void deactivate_object (
        const PortableServer::ObjectId & oid,
        CORBA::Environment &_tao_environment
      );
    virtual CORBA::Object_ptr create_reference (
        const char *intf,
        CORBA::Environment &_tao_environment
      );
    virtual CORBA::Object_ptr create_reference_with_id (
        const PortableServer::ObjectId & oid,
        const char *intf,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ObjectId * servant_to_id (
        PortableServer::Servant p_servant,
        CORBA::Environment &_tao_environment
      );
    virtual CORBA::Object_ptr servant_to_reference (
        PortableServer::Servant p_servant,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::Servant reference_to_servant (
        CORBA::Object_ptr  reference,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ObjectId * reference_to_id (
        CORBA::Object_ptr  reference,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::Servant id_to_servant (
        const PortableServer::ObjectId & oid,
        CORBA::Environment &_tao_environment
      );
    virtual CORBA::Object_ptr id_to_reference (
        const PortableServer::ObjectId & oid,
        CORBA::Environment &_tao_environment
      );
  
  private:
    POA_ptr servant_;
  };


#endif // end #if !defined


  class Current;
  typedef Current *Current_ptr;
  class Current : public virtual CurrentBase
  {
  protected:
    Current (void);
      public:
    virtual ~Current (void);
    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &_tao_environment);
    virtual void* _downcast (
        const char* logical_type_id
      );
    virtual PortableServer::POA_ptr  get_POA ( CORBA::Environment &env) = 0; // pure virtual
    static void get_POA_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    virtual PortableServer::ObjectId * get_object_id ( CORBA::Environment &env) = 0; // pure virtual
    static void get_object_id_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &env);

    static void _is_a_skel (CORBA::ServerRequest &req, void *obj, void *context, CORBA::Environment &_tao_enviroment);

    virtual void _dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env);

    PortableServer::Current *_this (CORBA::Environment &_tao_environment);
    virtual const char* _interface_repository_id (void) const;
  };


#if !defined (_PORTABLESERVER_CURRENT___COLLOCATED_SH_)
#define _PORTABLESERVER_CURRENT___COLLOCATED_SH_

  class _tao_collocated_Current    : public virtual PortableServer::Current,
      public virtual _tao_collocated_CurrentBase
  {
  public:
    _tao_collocated_Current (
        Current_ptr  servant,
        STUB_Object *stub
      );
    Current_ptr _get_servant (void) const;
    virtual CORBA::Boolean _is_a (
        const char *logical_type_id,
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::POA_ptr get_POA (
        CORBA::Environment &_tao_environment
      );
    virtual PortableServer::ObjectId * get_object_id (
        CORBA::Environment &_tao_environment
      );
  
  private:
    Current_ptr servant_;
  };


#endif // end #if !defined


};


#if defined (__ACE_INLINE__)
#include "poaS.i"
#endif // defined INLINE


#endif // if !defined
