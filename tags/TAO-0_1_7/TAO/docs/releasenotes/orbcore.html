<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<!-- $Id$ -->

<html>
  <head>
    <title>ORB & ORB Core Status</title>
  </head>

    <HR> <H3><A NAME="orb"></A>ORB &amp; ORB Core</H3> Point of
    contact: <A HREF="mailto:cleeland@cs.wustl.edu">Chris Cleeland</A>

    <p>Last Update: $Date$ </P>

    <P>Current status:

    <UL>
      <LI>Provides dynamically linked wholesale assignment of ORB
      strategies for communication, concurrency, demultiplexing,
      scheduling, and dispatching using the ACE Service Configurator
      framework.</LI>

      <LI>Supports several concurrency models out of the box:
      Reactive, Thread-per-Connection, and ORB-per-thread. The
      ORB-per-thread design is optimized for real-time I/O
      subsystems.</LI>

      <LI>Supports <TT>resolve_initial_references("NameService")</TT>
	using ACE support for multicast.</LI>
    </UL>

    <p>Known issues:
    <dl>
      <dt><em>Servers cannot properly report OS-chosen port.</em></dt>

      <dd>It is often desireable for a server to start up and not have
      to specify the TCP port number on which the ORB will listen,
      i.e., let the OS decide.  While this works properly (by
      providing an argument <code>-ORBport 0</code>), it is very
      difficult for the server to publish the IOR for clients' use.
      This is because the port is not assigned until
      <code>ORB::run</code> is called.</dd>

      <dt><em>Demarshalling problems with complex types</em></dt>

      <dd>The current demarshalling scheme may not work in cases of
      complex types such as sequences of unions or anys or object
      references.  The engine has difficulty determining the dynamic
      type of the objects.</dd>

      <dt><em>Object references for objects dynamically created within
      a server may not have proper host.</em> (See also <a
      href="#hostfix">recent fix</a>.)</dt>

      <dd>When an object is dynamically created and its object
      reference returned, it simply has to "guess" at the host
      information that is returned in the IIOP Profile.  Currently, it
      guesses using the host name, which is a reasonable guess in most
      cases.<p>

      However, if there are multiple interfaces on a machine
      <i>and</i> they have different host names, it is possible that
      the desired effect will not be realized, i.e., the connection to
      that new object may use a different interface from the original
      object.  Currently the only way to change this is to use the <a
      href="../Options.html#-ORBhost"><b>-ORBhost</b> option</a> to
      manually specify that dynamically-created objects bind to a
      specific interface so that their IIOP Profile has the desired
      hostname.  A more desirable fix is being investigated.</dd>

      <dt><em>ORB-per-thread and thread-per-connection models cannot
      be mixed.</em></dt>

      <dd>
	<p>
	  These two concurrency models do not currently mix because
	  there is no way for the connection-handling threads to gain
	  access to the resources held by the ORB in thread-specific
	  storage (TSS).  In order to do this, the Resource Manager
	  will have to implement some sort of inheritance of
	  resources.
	<p>
	  There are other problems which will need to be solved as
	  well for this to work properly.  For example, similar to the
	  problems encountered with
	  <code>ACE_Reactive_Strategy</code>, we will likely also
	  encounter problems with the single
	  <code>ACE_Threaded_Strategy</code>.  Various solutions are
	  possible, some more generalizable into ACE, other (like the
	  solution taken with the reactive strategy) localized to TAO.
      </dd>
    </dl>

    Recently Completed Work:

    <UL>
      <li>Broke the tight coupling between <code>CORBA_Object</code>
      and <code>IIOP_Object</code> so that multiple
      <code>CORBA_Object</code>s can share a single
      <code>IIOP_Object</code>.  This has a big win in
      <code>_narrow</code> operations.</li>

      <li>Eliminated substantial memory leaks in servers.</li>

      <li>Added documentation for <a
      href="../Options.html#-ORBpoa"><b>-ORBpoa</b></a>, which allows
      individual tweaking of the POA's locality (global
      vs. thread-specific) independent of the locality of other ORB
      resources.  Also, <a
      href="../Options.html#-ORBpoalock"><b>-ORBpoalock</b></a> and <a
      href="../Options.html#-ORBpoamgrlock"><b>-ORBpoamgrlock</b></a>
      control locking in the POA and POA manager, respectively,
      according to application needs.</li>

      <li>Began the process of changing the internals of TAO to use
      the "underbar" namespace mapping.  This should be completed
      soon.</li>

      <li>The ORBs manipulation of object keys and object ids is now
      consistent.  Canonically, everything is managed as an opaque
      sequence of octets.  Conversion to/from strings is permitted,
      with non-printables turning into a trigraph <b>\hl</b> where
      <b>h</b> is the high nibble digit in hex, and <b>l</b> is the
      low nibble in hex.</li>

      <li><code>CORBA_ORB::run()</code> should be able to be called
      multiply in the same execution path now.</li>

      <li>Fixed the <b>LOCATION_FORWARD</b> capabilities to work as
      described in the CORBA 2.1 and the POA specification.</li>
      
      <li>Fixed problem in the IDL Cubit example which caused the
      server to dump core when dealing with <code>_out</code> sequence
      types <em>ONLY</em> when compiled with G++.  It seems that G++
      decided to interpret the expression <code>output == 0</code>
      (where <code>output</code> is of type <code>vector_out</code>)
      differently from Sun's C++ compiler.</li>

      <li>Fixed a slight problem in <a href="#hostfix">other recent
      work</a> where a servant listening on <code>INADDR_ANY</code>
      reported an IOR with address <tt>0.0.0.0</tt>.  It now reports
      the default hostname instead.</li>

      <LI>Working version of TAO on VxWorks with VME transport.</li>

      <li>TAO now reacts gracefully in the face of a non-existent
      <code>svc.conf</code> file or simply missing entries in the
      file.  It logs a warning message and uses default values
      versions of items which it would normally obtain from the
      Service Repository.</li>

      <li><a name="hostfix"></a>Fixed problem where object references
      for objects dynamically created within a server do not have
      proper host, at least if the desired host was specified using <a
      href="../Options.html#-ORBhost"><b>-ORBhost</b></a> on the
      command line.</li>

      <li>Added support for <a
      href="../Options.html#-ORBsndsock"><b>-ORBsndsock</b></a> and <a
      href="../Options.html#-ORBrcvsock"><b>-ORBrcvsock</b></a> ORB
      options.  See <a href="../Options.html">options
      documentation</a> for details.</li>

      <li>Added support for pre-established connections using the <a
      href="../Options.html#-ORBpreconnect"><b>-ORBpreconnect</b></a>
      option.  This allows connections to be esablished before any
      CORBA requests are made.  See <a href="../Options.html">options
      documentation</a> for details.</li>

      <li>Eliminated deprecated <b>-OAxxx</b> options parsed by the
      Object Adapter <code>init</code> method but no longer used by
      part of the ORB.</li>

      <li>Made argument parsing within the ORB and POA consume the
      arguments it parses.</li>

      <li>Placed an optimization in IIOP::Profile that should speed up
	invocations on the client side rather substantially.  This was
	done by caching an instance of <code>ACE_INET_Addr</code> in
	the private portion of <code>Profile</code> because the cost
	of constructing one for every invocation (in
	<code>TAO_GIOP_Invocation::start</code>) was simply
	enormous--the construction was something like 100 cycles on
	Solaris.  This is all because deep down this ends up calling
	<code>gethostbyname()</code>, which can be very costly.  Of
	course, this is platform-dependent, so the improvements may
	not be as great on a different platform.</li>

      <li>Got rid of need to have compile in TSS ORB Core
	(<code>-DTAO_HAS_TSS_ORBCORE</code>).  This is accomplished by
	having a Resource Factory (<code>TAO_Resource_Factory</code>)
	singleton which the ORB Core consults in order to get pointers
	to resources.  The Resource Factory can be configured to
	return pointers from thread-specific storage, or
	process-global storage.  By doing this, the ORB Core is
	shielded from ever having to know whether or not its resources
	are global or not.</li>

	<li>Made all command-line like options look like the
	standard-professed options, i.e., <b>-ORBxxx</b> or
	<b>-OAxxxx</b>.</li>

	<li>Moved ORB option parsing into
	<code>TAO_ORB_Core::init()</code> rather than in
	<code>ORB_init()</code>.</li>

	<li>Define <code>_FAR</code> for all cases as an interim fix
	for LynxOS.</li>

	<li>Fixed TAO so that the default port of 5001 is defined in
	<code>orb_core.h</code> config header somewhere rather than in
	<code>orbobj.cpp</code>, and use <b>MAXHOSTNAMELEN</b> ACE
	constant for the hostname buffer.</li>

	<li>Eliminated need for <code>CORBA::Object</code> to keep a
	pointer to its orb sitting around anywhere.</li>

	<LI>Tested <code>CORBA_ORB::shutdown()</code> as a manner in
	which a thread of control can request that
	<code>CORBA_ORB::run()</code> should return and no longer
	service requests.  It only honors a
	<em>wait_for_completion</em> argument of <b>FALSE</b> right
	now because we haven't fully explored the issues which
	surround doing all the completion.</li>

	<li>Fixed bugs reported by Steven Wohlever, David Miron,
	Manojkumar Acharya.</li>

	<li>Created a brief section in <a
	href="../../TAO-INSTALL.html"><code>$TAO_ROOT/TAO-INSTALL.html</code></a>
	that <em>briefly</em> documents installation on Unix
	platforms.  There is also a brief section which documents
	issues that apply across ALL platforms, such as the fact that
	TAO and its application will likely not work well if your ACE
	is linked through Orbix, VisiBroker, or another ORB.  <a
	href="../../ChangeLog">ChangeLog</a> discovery attribution for
	this should go to <em>Steve Wohlever
	&lt;wohlever@mitre.org&gt;</em>.</li>

	<LI>Implemented <code>CORBA_ORB::shutdown()</code> as a manner
	in which a thread of control can request that
	<code>CORBA_ORB::run()</code> should return and no longer
	service requests.</li>

	<LI>Validated movement of Strategy Connector into
	ORB&nbsp;Core.</LI>

	<li>Debated details of <code>Svc_Handler</code> modifications
	with Irfan.</li>

	<li>Tested and commited <code>Connector::connect_n</code>
	changes to ACE</code>.</li>

	<li>ACE & TAO compiling cleanly using Sun's CC on Solaris and
	G++ on Linux.  Also, the ACE tests run properly.</li>

	<li>Use <code>truss</code> to verify for <a
	  href="mailto:PAUL.G.WEHLAGE@cdev.com">Paul Wehlage</a> that
	TAO really uses <code>select</code> vs. <code>recv</code> for
	<b>-R</b> vs. <b>-T</b>.</li>

	<li>Renamed <code>boa.*</code> to <code>poa.*</code>.</li>

	<LI>Renamed following files:&nbsp;Orb_Core.*&nbsp;->orb_core.*
	&amp;&nbsp;orbobj.* -> corba_orb.*.</LI>

	<LI>The lock used in <code>giop.cpp:626</code> originally
	appeared in the IIOP-1.4 code base.  Its purpose was to
	protect access to the <code>fwd_profile</code> data member.
	The original features are available, but they are currently
	not used because none of our concurrency models present a
	thread-unsafe condition.  The <a
	  href="../../ChangeLog">ChangeLog</a> presents more details
	on the subject.</li>

	<li>Fixed problems seen by <a
	  href="mailto:brian.r.mendel@boeing.com">Brian Mendel</a> of
	Boeing where the Cubit server application was crashing in
	<code>TAO_OA_Connection_Handler::handle_message</code> when it
	was trying to call <code>CORBA::POA::handle_request</code>
	through a NULL <code>root_poa</code> pointer.  The NULL
	pointer resulted from the inadvertent use of the
	Thread-per-Connection concurrency model, which is currently
	incompatible with the ORB-per-thread model.  It was not caught
	because the change is normally done in configuration files
	parsed by the Service Configurator, and VxWorks requires
	special code in that area which was not tested until Boeing
	got hold of the code.</li>

	<li>Clean up build under g++.  All 'function used before
	declared inline' warnings have been eliminated.  Also, all
	other warnings (except for one that is nearly unavoidable)
	have been eliminated.
	</li>

	<LI>Removed BOA and ROA names from the ORB.</LI>

	<LI>Changed <code>CORBA_ORB::open()</code> to return an error
	status (first cut at this already there--needs to be checked
	out).</LI>

	<LI>Added README file to multiCubit test.</li>
    </UL>

    Ongoing Work:

    <UL>
      <LI>Verify ACE & TAO on Linux using g++, Solaris using CC, and
	Solaris using g++.</LI>

      <LI>Use Purify to eliminate straggling problems.</LI>

      <LI>Clean up the internals and analyze for performance
	bottlenecks using Quantify.</LI>

      <li>Resolve <code>// @@</code> comment blocks.  These are
      questions or comments placed in the code by a reviewer
      (typically Doug).</li>

      <li>Make more and better documentation on the internals of
      TAO.</li>
    </UL>

    Current Work:

    <UL>
      <LI>
	<p>Verify that, in the ORB-per-thread concurrency model,
	  it's possible to have a factory in each thread that creates
	  a client and returns an object reference to that client
	  within that thread.  This is different from the model that
	  Sumedh originally had where the factory was trying to turn
	  out a client in a separate thread/ORB combination.</p>

	<p>There is no application which attempts this at the moment,
	  so both a client and a server will need to be manufactured.
	  Using existing Cubit-like examples (that poor app is so
	  weary) should reduce development time to a couple of
	  hours.</p>

	<p>The real strategy/solution is to make
	<code>CORBA::Object</code> not keep a pointer to its orb
	sitting around anywhere.  It should only get it when it needs
	it.  This should not be difficult to change.</p>
      </LI>
    </UL>

    Critical Work:

    <UL>
      <LI>Support new concurrency models, e.g., Thread-per-Request,
      thread pool, etc..</LI>

    </UL> 

    Future work:
    <UL>
      <li>Performance optimizations, such as:
	<ol>
	  <li>Strategize the connection management scheme so that we
	  don't always have to pay the price of a look up in the
	  connection cache.  Basically, we want to be able to "hold" a
	  service handler for a string of requests.  And, of course,
	  do this in a portable manner.</LI>
	  
	  <li>Replace all uses of <code>new</code> and
	  <code>delete</code> with allocators that can be put into
	  TSS.  The main motivation for this is to eliminate lock
	  contention when multiple threads need to allocate/deallocate
	  memory, however it might also be possible to substitute an
	  allocator better-tuned to an application's specific
	  usage.</li>
	</ol>
      </li>

      <li>Robustness improvements:
	<ol>
	  <li>Improve connection cache so that it won't crash when there
	    are no more slots or sockets.</li>

	  <li>Add an option to the ORB core, e.g.,
	  <b>-ORBnameservicetimeout</b>, to allow specification of an
	  upper bound on the itime-to-wait for a response from the
	  ORB's multicast "search" for a running name server.</li>
	</ol>
      </li>

      <li>New features:
	<ol>
	  <li>Implement <code>ORB::perform_work</code> and
	    <code>ORB::work_pending</code> so that <code>ORB::run</code>
	    <em>could</em> be implemented in terms of them.</li>

	  <li>Improve the <code>Service Configurator</code> service
	    entry faking on VxWorks.</li>

	  <li>Integrate with realtime upcalls (RTUs).</li>

	</ol>
      </li>

      <li>Internal restructuring:
	<ol>
      <li>Remove <code>_FAR</code> from all code.</li>

      <li>Rework underlayment to eliminate <code>IUnknown</code> class.</li>

	  <li>Create some sort of internal "request" object which
	  carries enough context to suport deferred method invocation
	  such as one might find in the thread-pool approach or
	  wherever queuing might occur.</li>

	  <li>Rethink the entire memory allocation model used by the
	  ORB.  The current one from SSIIOP may no longer be suitable
	  for our purposes.</li>
	</ol>
      </li>

      <li>Documentation:
	<ol>
	  <li>Update ORB Patterns paper to reflect the latest TAO has to
	    offer.  Specifically
	    <ul>
	      <li>sections on the Abstract Factory and Concurrency
		strategies need to be updated, and the entire paper needs to
		be reviewed for accuracy w.r.t the current TAO.</li>
	      <li>Metrics must be re-computed.</li>
	      <li>Tighten existing discussions.</li>
	      <li>Add information on new patterns (such as TSS) which
	      have been used since initial work.</li>
	    </ul>

	  <li>Make the section in <a
	  href="../../TAO-Install.html"><code>$TAO_ROOT/TAO-Install.html</code></a>
	  that documents installation on Unix platforms more
	  complete.</li>
      </li>

	</ol>
      </li>

      <li>Miscellany:
	<ol>
	  <LI>Assist in porting higher level services (e.g., <A
	      HREF="#eventchannel">Event Channel</A>) to TAO.</LI>

	  <li>Compile and verify ACE and TAO on Linux using the Kuck and
	    Associates, Inc. (KAI) compiler tools.</li>
          <LI>CORBA::TypeCode is causing a memory leak.  Since objects
              of this type are rather static in nature, this is
              currently not a big deal.  However, it should be fixed
              soon. </LI>
         <LI>CORBA_Exception::Release is not working correctly as the
             memory is never really freed. </LI>
	</ol>
      </li>


    </UL>

  </body>
</html>
