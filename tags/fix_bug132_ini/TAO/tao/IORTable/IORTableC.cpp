/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "IORTableC.h"

#if !defined (__ACE_INLINE__)
#include "IORTableC.i"
#endif /* !defined INLINE */

// default constructor
IORTable::AlreadyBound::AlreadyBound (void)
  : CORBA_UserException ("IDL:IORTable/AlreadyBound:1.0")
{
}

// destructor - all members are of self managing types
IORTable::AlreadyBound::~AlreadyBound (void)
{
}

void IORTable::AlreadyBound::_tao_any_destructor (void *x)
{
  AlreadyBound *tmp = ACE_static_cast (AlreadyBound*,x);
  delete tmp;
}

// copy constructor
IORTable::AlreadyBound::AlreadyBound (const ::IORTable::AlreadyBound &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// assignment operator
IORTable::AlreadyBound&
IORTable::AlreadyBound::operator= (const ::IORTable::AlreadyBound &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
IORTable::AlreadyBound *
IORTable::AlreadyBound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:IORTable/AlreadyBound:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (AlreadyBound *, exc);
  else
    return 0;
}


void IORTable::AlreadyBound::_raise ()
{
  TAO_RAISE(*this);
}


void IORTable::AlreadyBound::_tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}


void IORTable::AlreadyBound::_tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *IORTable::AlreadyBound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::IORTable::AlreadyBound, 0);
  return retval;
}

// default constructor
IORTable::NotFound::NotFound (void)
  : CORBA_UserException ("IDL:IORTable/NotFound:1.0")
{
}

// destructor - all members are of self managing types
IORTable::NotFound::~NotFound (void)
{
}

void IORTable::NotFound::_tao_any_destructor (void *x)
{
  NotFound *tmp = ACE_static_cast (NotFound*,x);
  delete tmp;
}

// copy constructor
IORTable::NotFound::NotFound (const ::IORTable::NotFound &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// assignment operator
IORTable::NotFound&
IORTable::NotFound::operator= (const ::IORTable::NotFound &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
IORTable::NotFound *
IORTable::NotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:IORTable/NotFound:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (NotFound *, exc);
  else
    return 0;
}


void IORTable::NotFound::_raise ()
{
  TAO_RAISE(*this);
}


void IORTable::NotFound::_tao_encode (
    TAO_OutputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}


void IORTable::NotFound::_tao_decode (
    TAO_InputCDR &,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *IORTable::NotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::IORTable::NotFound, 0);
  return retval;
}


// default constructor
IORTable::Table::Table (void)
{}

// destructor
IORTable::Table::~Table (void)
{}

IORTable::Table_ptr IORTable::Table::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return Table::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IORTable::Table_ptr IORTable::Table::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Table::_nil ();
  return
      ACE_reinterpret_cast
        (
          Table_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Table::_narrow
                  )
              )
        );
}

IORTable::Table_ptr
IORTable::Table::_duplicate (Table_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *IORTable::Table::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IORTable, Table)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IORTable::Table::_interface_repository_id (void) const
{
  return "IDL:IORTable/Table:1.0";
}


// default constructor
IORTable::Locator::Locator (void)
{}

// destructor
IORTable::Locator::~Locator (void)
{}

IORTable::Locator_ptr IORTable::Locator::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  return Locator::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IORTable::Locator_ptr IORTable::Locator::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Locator::_nil ();
  return
      ACE_reinterpret_cast
        (
          Locator_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Locator::_narrow
                  )
              )
        );
}

IORTable::Locator_ptr
IORTable::Locator::_duplicate (Locator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *IORTable::Locator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::IORTable, Locator)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IORTable::Locator::_interface_repository_id (void) const
{
  return "IDL:IORTable/Locator:1.0";
}

