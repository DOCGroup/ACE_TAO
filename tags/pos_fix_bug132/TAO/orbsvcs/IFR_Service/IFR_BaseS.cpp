// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef TAO_IDL_IFR_BASES_CPP
#define TAO_IDL_IFR_BASES_CPP

#include "IFR_BaseS.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BaseS.i"
#endif /* !defined INLINE */

class TAO_CORBA_IRObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:43:18 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15,  0, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15,  1, 15, 15, 15, 15,  0, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,
#else
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15,  0, 15,  0, 15, 15,
      0, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,  1, 15, 15, 15,
     15,  0, 15, 15, 15, 15, 15, 15,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 4,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 14,
      HASH_VALUE_RANGE = 10,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::IRObject::_is_a_skel},
      {"",0},
      {"destroy", 	&POA_CORBA::IRObject::destroy_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA::IRObject::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::IRObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 10:43:18 */
static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::IRObject *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::DefinitionKind result);

private:
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (const TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get &);
  
private:
  POA_CORBA::IRObject *_tao_impl;
  CORBA::DefinitionKind _result;
};

TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::IRObject *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::DefinitionKind result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_IRObject_destroy : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IRObject_destroy (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::IRObject *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_IRObject_destroy (const TAO_ServerRequestInfo_CORBA_IRObject_destroy &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IRObject_destroy &);
  
private:
  POA_CORBA::IRObject *_tao_impl;
  
};

TAO_ServerRequestInfo_CORBA_IRObject_destroy::TAO_ServerRequestInfo_CORBA_IRObject_destroy (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::IRObject *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_IRObject_destroy::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker *POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker::the_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker::_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker::~_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_IRObject_Proxy_Impl&
POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::IRObject *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IRObject_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_IRObject_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_IRObject_Proxy_Broker *
CORBA__TAO_IRObject_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_IRObject_Strategized_Proxy_Broker::the_TAO_IRObject_Strategized_Proxy_Broker();
}

int
CORBA__TAO_IRObject_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_IRObject_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_IRObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_IRObject_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_IRObject_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_IRObject_ThruPOA_Proxy_Impl::_TAO_IRObject_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::DefinitionKind POA_CORBA::_TAO_IRObject_ThruPOA_Proxy_Impl::def_kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::DefinitionKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "def_kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->def_kind (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_IRObject_ThruPOA_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "destroy",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->destroy (
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::IRObject::IRObject (void)
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

// copy ctor
POA_CORBA::IRObject::IRObject (const IRObject& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::IRObject::~IRObject (void)
{
}

void POA_CORBA::IRObject::_get_def_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *)_tao_object_reference;
  
    CORBA::DefinitionKind _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->def_kind (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::DefinitionKind _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::IRObject::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_IRObject_destroy ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->destroy (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::IRObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::IRObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::IRObject::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::IRObject::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::IRObject::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

CORBA::IRObject*
POA_CORBA::IRObject::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::IRObject::_unchecked_narrow (obj.in ());
}

class TAO_CORBA_Contained_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:43:18 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::Contained::move_skel},
      {"_is_a",  &POA_CORBA::Contained::_is_a_skel},
      {"_get_id", 	&POA_CORBA::Contained::_get_id_skel},
      {"_set_id", 	&POA_CORBA::Contained::_set_id_skel},
      {"describe", 	&POA_CORBA::Contained::describe_skel},
      {"_get_name", 	&POA_CORBA::Contained::_get_name_skel},
      {"_set_name", 	&POA_CORBA::Contained::_set_name_skel},
      {"_get_version", 	&POA_CORBA::Contained::_get_version_skel},
      {"_set_version", 	&POA_CORBA::Contained::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::Contained::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::Contained::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::Contained::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::Contained::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA::Contained::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::Contained::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13, 
       -1,  14,  -1,  15,  16,  -1,  -1,  -1,  -1,  17,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  18, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 10:43:18 */
static TAO_CORBA_Contained_Perfect_Hash_OpTable tao_CORBA_Contained_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_Contained_id_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_id_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_id_get (const TAO_ServerRequestInfo_CORBA_Contained_id_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_id_get &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_id_get::TAO_ServerRequestInfo_CORBA_Contained_id_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_id_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_id_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_id_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_id_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_id_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_id_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_id_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_id_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_id_set (const TAO_ServerRequestInfo_CORBA_Contained_id_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_id_set &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  const char * id_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_id_set::TAO_ServerRequestInfo_CORBA_Contained_id_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    const char * id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_id_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_id_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_id_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_id_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_id_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_Contained_name_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_name_get (const TAO_ServerRequestInfo_CORBA_Contained_name_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_name_get &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_name_get::TAO_ServerRequestInfo_CORBA_Contained_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_name_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_name_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_name_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_name_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_name_set (const TAO_ServerRequestInfo_CORBA_Contained_name_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_name_set &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  const char * name_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_name_set::TAO_ServerRequestInfo_CORBA_Contained_name_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    const char * name,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    name_ (name)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_name_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_name_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_name_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_name_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_name_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_Contained_version_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_version_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_version_get (const TAO_ServerRequestInfo_CORBA_Contained_version_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_version_get &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_version_get::TAO_ServerRequestInfo_CORBA_Contained_version_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_version_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_version_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_version_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_version_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_version_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_version_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_version_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_version_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_version_set (const TAO_ServerRequestInfo_CORBA_Contained_version_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_version_set &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  const char * version_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_version_set::TAO_ServerRequestInfo_CORBA_Contained_version_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_version_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_version_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_version_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_version_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_version_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_Contained_defined_in_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Container_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (const TAO_ServerRequestInfo_CORBA_Contained_defined_in_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_defined_in_get &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  CORBA::Container_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::TAO_ServerRequestInfo_CORBA_Contained_defined_in_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_defined_in_get::result (CORBA::Container_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (const TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  char * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Repository_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (const TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  CORBA::Repository_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get::result (CORBA::Repository_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_describe : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_describe (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Contained::Description * result);

private:
  TAO_ServerRequestInfo_CORBA_Contained_describe (const TAO_ServerRequestInfo_CORBA_Contained_describe &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_describe &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  CORBA::Contained::Description * _result;
};

TAO_ServerRequestInfo_CORBA_Contained_describe::TAO_ServerRequestInfo_CORBA_Contained_describe (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_describe::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_describe::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_describe::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Contained_describe::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_describe::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Contained_describe::result (CORBA::Contained::Description * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Contained_move : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Contained_move (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_Contained_move (const TAO_ServerRequestInfo_CORBA_Contained_move &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Contained_move &);
  
private:
  POA_CORBA::Contained *_tao_impl;
  CORBA::Container_ptr new_container_;
  const char * new_name_;
  const char * new_version_;
  
};

TAO_ServerRequestInfo_CORBA_Contained_move::TAO_ServerRequestInfo_CORBA_Contained_move (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Contained *tao_impl,
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    new_container_ (new_container),
    new_name_ (new_name),
    new_version_ (new_version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Contained_move::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_new_container = parameter_list->length ();
  parameter_list->length (length_new_container + 1);
  (*parameter_list)[length_new_container].argument <<=  this->new_container_;
  
  (*parameter_list)[length_new_container].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_name = parameter_list->length ();
  parameter_list->length (length_new_name + 1);
  (*parameter_list)[length_new_name].argument <<= new_name_;
  (*parameter_list)[length_new_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_version = parameter_list->length ();
  parameter_list->length (length_new_version + 1);
  (*parameter_list)[length_new_version].argument <<= new_version_;
  (*parameter_list)[length_new_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Contained_move::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Contained_move::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_Contained_move::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Contained_move::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker *POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker::the_TAO_Contained_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker::_TAO_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker::~_TAO_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_Contained_Proxy_Impl&
POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::Contained *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Contained_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_Contained_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Contained_Proxy_Broker *
CORBA__TAO_Contained_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_Contained_Strategized_Proxy_Broker::the_TAO_Contained_Strategized_Proxy_Broker();
}

int
CORBA__TAO_Contained_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_Contained_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_Contained_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_Contained_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_Contained_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::_TAO_Contained_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

char * POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->id (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->id (
        id,
        ACE_TRY_ENV
      );
  return;
}

char * POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->name (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->name (
        name,
        ACE_TRY_ENV
      );
  return;
}

char * POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->version (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->version (
        version,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Container_ptr POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::defined_in (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Container_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "defined_in",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->defined_in (
        ACE_TRY_ENV
      );
}

char * POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::absolute_name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "absolute_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->absolute_name (
        ACE_TRY_ENV
      );
}

CORBA::Repository_ptr POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::containing_repository (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Repository_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "containing_repository",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->containing_repository (
        ACE_TRY_ENV
      );
}

CORBA::Contained::Description * POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::describe (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Contained::Description_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->describe (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_Contained_ThruPOA_Proxy_Impl::move (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "move",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->move (
        new_container,
        new_name,
        new_version,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::Contained::Contained (void)
{
  this->optable_ = &tao_CORBA_Contained_optable;
}

// copy ctor
POA_CORBA::Contained::Contained (const Contained& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::Contained::~Contained (void)
{
}

void POA_CORBA::Contained::_get_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_id_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->id (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_set_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_id_set ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->id (
          id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_get_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_name_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->name (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_set_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_name_set ri (
      _tao_server_request,
      _tao_impl,
      name.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->name (
          name.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_get_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_version_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->version (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_set_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::String_var version;
  if (!(
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_version_set ri (
      _tao_server_request,
      _tao_impl,
      version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->version (
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_get_defined_in_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
    CORBA::Container_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_defined_in_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->defined_in (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Container_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_get_absolute_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
    CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_absolute_name_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->absolute_name (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_get_containing_repository_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
    CORBA::Repository_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_containing_repository_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->containing_repository (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Repository_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::describe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
    CORBA::Contained::Description_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_describe ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->describe (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Contained::Description * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::move_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::Container_var new_container;
  CORBA::String_var new_name;
  CORBA::String_var new_version;
  if (!(
    (_tao_in >> new_container.out ()) &&
    (_tao_in >> new_name.out ()) &&
    (_tao_in >> new_version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Contained_move ri (
      _tao_server_request,
      _tao_impl,
      new_container.in (),
      new_name.in (),
      new_version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->move (
          new_container.in (),
          new_name.in (),
          new_version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Contained::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::Contained::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::Contained::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::Contained::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::Contained::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

CORBA::Contained*
POA_CORBA::Contained::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::Contained::_unchecked_narrow (obj.in ());
}

class TAO_CORBA_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:43:18 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 15,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 10,
     34,  0,  0,  0, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34,  0, 20,  5,
     34,  0, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 15,  5, 34, 34, 34, 10,  0, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34,
#else
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
     34, 34, 34, 34, 34, 15, 34, 10, 34,  0,
      0,  0, 34, 34, 34, 34, 34, 34,  0, 20,
      5, 34,  0, 34, 34, 15,  5, 34, 34, 34,
     10,  0, 34, 34, 34, 34, 34, 34,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 33,
      HASH_VALUE_RANGE = 28,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup", 	&POA_CORBA::Container::lookup_skel},
      {"destroy", 	&POA_CORBA::Container::destroy_skel},
      {"lookup_name", 	&POA_CORBA::Container::lookup_name_skel},
      {"create_value", 	&POA_CORBA::Container::create_value_skel},
      {"create_module", 	&POA_CORBA::Container::create_module_skel},
      {"create_native", 	&POA_CORBA::Container::create_native_skel},
      {"create_interface", 	&POA_CORBA::Container::create_interface_skel},
      {"create_union", 	&POA_CORBA::Container::create_union_skel},
      {"create_struct", 	&POA_CORBA::Container::create_struct_skel},
      {"create_constant", 	&POA_CORBA::Container::create_constant_skel},
      {"create_exception", 	&POA_CORBA::Container::create_exception_skel},
      {"create_local_interface", 	&POA_CORBA::Container::create_local_interface_skel},
      {"contents", 	&POA_CORBA::Container::contents_skel},
      {"create_abstract_interface", 	&POA_CORBA::Container::create_abstract_interface_skel},
      {"create_value_box", 	&POA_CORBA::Container::create_value_box_skel},
      {"create_alias", 	&POA_CORBA::Container::create_alias_skel},
      {"_get_def_kind", 	&POA_CORBA::Container::_get_def_kind_skel},
      {"_is_a",  &POA_CORBA::Container::_is_a_skel},
      {"create_enum", 	&POA_CORBA::Container::create_enum_skel},
      {"describe_contents", 	&POA_CORBA::Container::describe_contents_skel},
      {"_non_existent",  &POA_CORBA::Container::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,   7,  -1, -10,  -2,   8,   9, -37, 
       -1,  -1,  12,  13,  14,  -1,  15,  16,  17,  18,  -1,  19,  20,  21, 
       22,  -1,  23,  24,  25,  26, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 10:43:18 */
static TAO_CORBA_Container_Perfect_Hash_OpTable tao_CORBA_Container_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_Container_lookup : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_lookup (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Contained_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_lookup (const TAO_ServerRequestInfo_CORBA_Container_lookup &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_lookup &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * search_name_;
  CORBA::Contained_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_lookup::TAO_ServerRequestInfo_CORBA_Container_lookup (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * search_name,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    search_name_ (search_name)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_lookup::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_lookup::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_lookup::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_lookup::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_lookup::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_lookup::result (CORBA::Contained_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_contents : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ContainedSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_contents (const TAO_ServerRequestInfo_CORBA_Container_contents &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_contents &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA::ContainedSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_contents::TAO_ServerRequestInfo_CORBA_Container_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_contents::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_contents::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_contents::result (CORBA::ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_lookup_name : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_lookup_name (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ContainedSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_lookup_name (const TAO_ServerRequestInfo_CORBA_Container_lookup_name &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_lookup_name &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * search_name_;
  const CORBA::Long & levels_to_search_;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  CORBA::ContainedSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_lookup_name::TAO_ServerRequestInfo_CORBA_Container_lookup_name (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    search_name_ (search_name),
    levels_to_search_ (levels_to_search),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_levels_to_search = parameter_list->length ();
  parameter_list->length (length_levels_to_search + 1);
  (*parameter_list)[length_levels_to_search].argument <<= levels_to_search_;
  (*parameter_list)[length_levels_to_search].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_lookup_name::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_lookup_name::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_lookup_name::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_lookup_name::result (CORBA::ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_describe_contents : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_describe_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Container::DescriptionSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_Container_describe_contents (const TAO_ServerRequestInfo_CORBA_Container_describe_contents &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_describe_contents &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const CORBA::DefinitionKind & limit_type_;
  const CORBA::Boolean & exclude_inherited_;
  const CORBA::Long & max_returned_objs_;
  CORBA::Container::DescriptionSeq * _result;
};

TAO_ServerRequestInfo_CORBA_Container_describe_contents::TAO_ServerRequestInfo_CORBA_Container_describe_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    CORBA::DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited),
    max_returned_objs_ (max_returned_objs)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_max_returned_objs = parameter_list->length ();
  parameter_list->length (length_max_returned_objs + 1);
  (*parameter_list)[length_max_returned_objs].argument <<= max_returned_objs_;
  (*parameter_list)[length_max_returned_objs].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_describe_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_describe_contents::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_describe_contents::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_describe_contents::result (CORBA::Container::DescriptionSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_module : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_module (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ModuleDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_module (const TAO_ServerRequestInfo_CORBA_Container_create_module &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_module &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::ModuleDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_module::TAO_ServerRequestInfo_CORBA_Container_create_module (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_module::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_module::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_module::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_module::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_module::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_module::result (CORBA::ModuleDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_constant : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_constant (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ConstantDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_constant (const TAO_ServerRequestInfo_CORBA_Container_create_constant &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_constant &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr type_;
  const CORBA::Any & value_;
  CORBA::ConstantDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_constant::TAO_ServerRequestInfo_CORBA_Container_create_constant (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    value_ (value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_constant::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<= value_;
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_constant::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_constant::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_constant::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_constant::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_constant::result (CORBA::ConstantDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_struct : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_struct (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::StructDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_struct (const TAO_ServerRequestInfo_CORBA_Container_create_struct &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_struct &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::StructMemberSeq & members_;
  CORBA::StructDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_struct::TAO_ServerRequestInfo_CORBA_Container_create_struct (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_struct::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_struct::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_struct::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_struct::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_struct::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_struct::result (CORBA::StructDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_union : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_union (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::UnionDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_union (const TAO_ServerRequestInfo_CORBA_Container_create_union &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_union &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr discriminator_type_;
  const CORBA::UnionMemberSeq & members_;
  CORBA::UnionDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_union::TAO_ServerRequestInfo_CORBA_Container_create_union (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    discriminator_type_ (discriminator_type),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_union::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_discriminator_type = parameter_list->length ();
  parameter_list->length (length_discriminator_type + 1);
  (*parameter_list)[length_discriminator_type].argument <<=  this->discriminator_type_;
  
  (*parameter_list)[length_discriminator_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_union::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_union::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_union::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_union::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_union::result (CORBA::UnionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_enum : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_enum (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::EnumDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_enum (const TAO_ServerRequestInfo_CORBA_Container_create_enum &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_enum &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::EnumMemberSeq & members_;
  CORBA::EnumDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_enum::TAO_ServerRequestInfo_CORBA_Container_create_enum (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_enum::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_enum::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_enum::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_enum::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_enum::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_enum::result (CORBA::EnumDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_alias : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_alias (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::AliasDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_alias (const TAO_ServerRequestInfo_CORBA_Container_create_alias &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_alias &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr original_type_;
  CORBA::AliasDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_alias::TAO_ServerRequestInfo_CORBA_Container_create_alias (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_ (original_type)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_alias::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type = parameter_list->length ();
  parameter_list->length (length_original_type + 1);
  (*parameter_list)[length_original_type].argument <<=  this->original_type_;
  
  (*parameter_list)[length_original_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_alias::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_alias::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_alias::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_alias::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_alias::result (CORBA::AliasDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::InterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_interface (const TAO_ServerRequestInfo_CORBA_Container_create_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_interface &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::InterfaceDefSeq & base_interfaces_;
  CORBA::InterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_interface::TAO_ServerRequestInfo_CORBA_Container_create_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_interface::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_interface::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_interface::result (CORBA::InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_value : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_value (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    CORBA::ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_value (const TAO_ServerRequestInfo_CORBA_Container_create_value &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_value &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::Boolean & is_custom_;
  const CORBA::Boolean & is_abstract_;
  CORBA::ValueDef_ptr base_value_;
  const CORBA::Boolean & is_truncatable_;
  const CORBA::ValueDefSeq & abstract_base_values_;
  const CORBA::InterfaceDefSeq & supported_interfaces_;
  const CORBA::InitializerSeq & initializers_;
  CORBA::ValueDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_value::TAO_ServerRequestInfo_CORBA_Container_create_value (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    CORBA::ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    is_custom_ (is_custom),
    is_abstract_ (is_abstract),
    base_value_ (base_value),
    is_truncatable_ (is_truncatable),
    abstract_base_values_ (abstract_base_values),
    supported_interfaces_ (supported_interfaces),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_value::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_custom = parameter_list->length ();
  parameter_list->length (length_is_custom + 1);
  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_value = parameter_list->length ();
  parameter_list->length (length_base_value + 1);
  (*parameter_list)[length_base_value].argument <<=  this->base_value_;
  
  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_truncatable = parameter_list->length ();
  parameter_list->length (length_is_truncatable + 1);
  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_abstract_base_values = parameter_list->length ();
  parameter_list->length (length_abstract_base_values + 1);
  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;
  
  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_initializers = parameter_list->length ();
  parameter_list->length (length_initializers + 1);
  (*parameter_list)[length_initializers].argument <<=  this->initializers_;
  
  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_value::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_value::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_value::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_value::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_value::result (CORBA::ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_value_box : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_value_box (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueBoxDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_value_box (const TAO_ServerRequestInfo_CORBA_Container_create_value_box &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_value_box &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr original_type_def_;
  CORBA::ValueBoxDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_value_box::TAO_ServerRequestInfo_CORBA_Container_create_value_box (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
  
  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_value_box::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_value_box::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_value_box::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_value_box::result (CORBA::ValueBoxDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_exception : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_exception (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ExceptionDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_exception (const TAO_ServerRequestInfo_CORBA_Container_create_exception &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_exception &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::StructMemberSeq & members_;
  CORBA::ExceptionDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_exception::TAO_ServerRequestInfo_CORBA_Container_create_exception (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_exception::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_exception::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_exception::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_exception::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_exception::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_exception::result (CORBA::ExceptionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_native : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_native (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::NativeDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_native (const TAO_ServerRequestInfo_CORBA_Container_create_native &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_native &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::NativeDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_native::TAO_ServerRequestInfo_CORBA_Container_create_native (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_native::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_native::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_native::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_native::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_native::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_native::result (CORBA::NativeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::AbstractInterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (const TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::AbstractInterfaceDefSeq & base_interfaces_;
  CORBA::AbstractInterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface::result (CORBA::AbstractInterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_Container_create_local_interface : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::LocalInterfaceDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface (const TAO_ServerRequestInfo_CORBA_Container_create_local_interface &);
  void operator= (const TAO_ServerRequestInfo_CORBA_Container_create_local_interface &);
  
private:
  POA_CORBA::Container *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  const CORBA::InterfaceDefSeq & base_interfaces_;
  CORBA::LocalInterfaceDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_Container_create_local_interface::TAO_ServerRequestInfo_CORBA_Container_create_local_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_Container_create_local_interface::result (CORBA::LocalInterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_Container_Strategized_Proxy_Broker *POA_CORBA::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_Container_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_Container_Strategized_Proxy_Broker::_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_Container_Strategized_Proxy_Broker::~_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_Container_Proxy_Impl&
POA_CORBA::_TAO_Container_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::Container *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_Container_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Container_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_Container_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Container_Proxy_Broker *
CORBA__TAO_Container_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker();
}

int
CORBA__TAO_Container_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_Container_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_Container_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_Container_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::_TAO_Container_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Contained_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->lookup (
        search_name,
        ACE_TRY_ENV
      );
}

CORBA::ContainedSeq * POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->contents (
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

CORBA::ContainedSeq * POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::lookup_name (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->lookup_name (
        search_name,
        levels_to_search,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

CORBA::Container::DescriptionSeq * POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::describe_contents (
    CORBA_Object *_collocated_tao_target_,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Container::DescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe_contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->describe_contents (
        limit_type,
        exclude_inherited,
        max_returned_objs,
        ACE_TRY_ENV
      );
}

CORBA::ModuleDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_module (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ModuleDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_module",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_module (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

CORBA::ConstantDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_constant (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ConstantDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_constant",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_constant (
        id,
        name,
        version,
        type,
        value,
        ACE_TRY_ENV
      );
}

CORBA::StructDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_struct (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::StructDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_struct",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_struct (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

CORBA::UnionDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_union (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::UnionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_union",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_union (
        id,
        name,
        version,
        discriminator_type,
        members,
        ACE_TRY_ENV
      );
}

CORBA::EnumDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_enum (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::EnumDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_enum",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_enum (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

CORBA::AliasDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_alias (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::AliasDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_alias",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_alias (
        id,
        name,
        version,
        original_type,
        ACE_TRY_ENV
      );
}

CORBA::InterfaceDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_interface (
        id,
        name,
        version,
        base_interfaces,
        ACE_TRY_ENV
      );
}

CORBA::ValueDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_value (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_value (
        id,
        name,
        version,
        is_custom,
        is_abstract,
        base_value,
        is_truncatable,
        abstract_base_values,
        supported_interfaces,
        initializers,
        ACE_TRY_ENV
      );
}

CORBA::ValueBoxDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_value_box (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ValueBoxDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_box",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_value_box (
        id,
        name,
        version,
        original_type_def,
        ACE_TRY_ENV
      );
}

CORBA::ExceptionDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_exception (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ExceptionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_exception",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_exception (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

CORBA::NativeDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_native (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::NativeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_native",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_native (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

CORBA::AbstractInterfaceDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_abstract_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::AbstractInterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::AbstractInterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_abstract_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_abstract_interface (
        id,
        name,
        version,
        base_interfaces,
        ACE_TRY_ENV
      );
}

CORBA::LocalInterfaceDef_ptr POA_CORBA::_TAO_Container_ThruPOA_Proxy_Impl::create_local_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::LocalInterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_local_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_local_interface (
        id,
        name,
        version,
        base_interfaces,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::Container::Container (void)
{
  this->optable_ = &tao_CORBA_Container_optable;
}

// copy ctor
POA_CORBA::Container::Container (const Container& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::Container::~Container (void)
{
}

void POA_CORBA::Container::lookup_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::Contained_var _tao_retval;
  CORBA::String_var search_name;
  if (!(
    (_tao_in >> search_name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_lookup ri (
      _tao_server_request,
      _tao_impl,
      search_name.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->lookup (
          search_name.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Contained_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::ContainedSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_contents ri (
      _tao_server_request,
      _tao_impl,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->contents (
          limit_type,
          exclude_inherited,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::lookup_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::ContainedSeq_var _tao_retval;
  CORBA::String_var search_name;
  CORBA::Long levels_to_search;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> search_name.out ()) &&
    (_tao_in >> levels_to_search) &&
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_lookup_name ri (
      _tao_server_request,
      _tao_impl,
      search_name.in (),
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->lookup_name (
          search_name.in (),
          levels_to_search,
          limit_type,
          exclude_inherited,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::describe_contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::Container::DescriptionSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  CORBA::Long max_returned_objs;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited)) &&
    (_tao_in >> max_returned_objs)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_describe_contents ri (
      _tao_server_request,
      _tao_impl,
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->describe_contents (
          limit_type,
          exclude_inherited,
          max_returned_objs,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Container::DescriptionSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_module_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::ModuleDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_module ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_module (
          id.in (),
          name.in (),
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ModuleDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_constant_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::ConstantDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var type;
  CORBA::Any value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_constant ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      value,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_constant (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          value,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ConstantDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_struct_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::StructDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_struct ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_struct (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::StructDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_union_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::UnionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var discriminator_type;
  CORBA::UnionMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> discriminator_type.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_union ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      discriminator_type.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_union (
          id.in (),
          name.in (),
          version.in (),
          discriminator_type.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::UnionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_enum_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::EnumDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::EnumMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_enum ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_enum (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::EnumDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_alias_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::AliasDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var original_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_alias ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_alias (
          id.in (),
          name.in (),
          version.in (),
          original_type.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::AliasDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::InterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_interface ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::ValueDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::Boolean is_custom;
  CORBA::Boolean is_abstract;
  CORBA::ValueDef_var base_value;
  CORBA::Boolean is_truncatable;
  CORBA::ValueDefSeq abstract_base_values;
  CORBA::InterfaceDefSeq supported_interfaces;
  CORBA::InitializerSeq initializers;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_custom)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> base_value.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable)) &&
    (_tao_in >> abstract_base_values) &&
    (_tao_in >> supported_interfaces) &&
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_value ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      is_custom,
      is_abstract,
      base_value.in (),
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_value (
          id.in (),
          name.in (),
          version.in (),
          is_custom,
          is_abstract,
          base_value.in (),
          is_truncatable,
          abstract_base_values,
          supported_interfaces,
          initializers,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_value_box_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::ValueBoxDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var original_type_def;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_value_box ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type_def.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_value_box (
          id.in (),
          name.in (),
          version.in (),
          original_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ValueBoxDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_exception_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::ExceptionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_exception ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_exception (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ExceptionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_native_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::NativeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_native ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_native (
          id.in (),
          name.in (),
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::NativeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_abstract_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::AbstractInterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::AbstractInterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_abstract_interface ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_abstract_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::AbstractInterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::create_local_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;
  
    CORBA::LocalInterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_Container_create_local_interface ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_local_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::LocalInterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::Container::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::Container::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::Container::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::Container::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::Container::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

CORBA::Container*
POA_CORBA::Container::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::Container::_unchecked_narrow (obj.in ());
}

class TAO_CORBA_IDLType_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:43:19 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::IDLType::_is_a_skel},
      {"",0},
      {"destroy", 	&POA_CORBA::IDLType::destroy_skel},
      {"",0},
      {"_get_type", 	&POA_CORBA::IDLType::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA::IDLType::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA::IDLType::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 10:43:19 */
static TAO_CORBA_IDLType_Perfect_Hash_OpTable tao_CORBA_IDLType_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_IDLType_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_IDLType_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::IDLType *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_IDLType_type_get (const TAO_ServerRequestInfo_CORBA_IDLType_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_IDLType_type_get &);
  
private:
  POA_CORBA::IDLType *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_IDLType_type_get::TAO_ServerRequestInfo_CORBA_IDLType_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::IDLType *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_IDLType_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_IDLType_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_IDLType_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_IDLType_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker *POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker::the_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker::_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker::~_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_IDLType_Proxy_Impl&
POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::IDLType *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IDLType_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_IDLType_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_IDLType_Proxy_Broker *
CORBA__TAO_IDLType_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_IDLType_Strategized_Proxy_Broker::the_TAO_IDLType_Strategized_Proxy_Broker();
}

int
CORBA__TAO_IDLType_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_IDLType_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_IDLType_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_IDLType_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_IDLType_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_IDLType_ThruPOA_Proxy_Impl::_TAO_IDLType_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_CORBA::_TAO_IDLType_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IDLType:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::IDLType::IDLType (void)
{
  this->optable_ = &tao_CORBA_IDLType_optable;
}

// copy ctor
POA_CORBA::IDLType::IDLType (const IDLType& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::IDLType::~IDLType (void)
{
}

void POA_CORBA::IDLType::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IDLType *_tao_impl = (POA_CORBA::IDLType *)_tao_object_reference;
  
    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_IDLType_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::IDLType::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::IDLType *_tao_impl = (POA_CORBA::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::IDLType::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IDLType *_tao_impl = (POA_CORBA::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::IDLType::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::IDLType::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::IDLType::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

CORBA::IDLType*
POA_CORBA::IDLType::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::IDLType::_unchecked_narrow (obj.in ());
}


class TAO_CORBA_TypedefDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:43:19 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::TypedefDef::move_skel},
      {"_is_a",  &POA_CORBA::TypedefDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::TypedefDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::TypedefDef::_set_id_skel},
      {"describe", 	&POA_CORBA::TypedefDef::describe_skel},
      {"_get_name", 	&POA_CORBA::TypedefDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::TypedefDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::TypedefDef::_set_name_skel},
      {"_get_version", 	&POA_CORBA::TypedefDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::TypedefDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::TypedefDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::TypedefDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::TypedefDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::TypedefDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA::TypedefDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::TypedefDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14, 
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 10:43:19 */
static TAO_CORBA_TypedefDef_Perfect_Hash_OpTable tao_CORBA_TypedefDef_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker *POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker::the_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker::_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker::~_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_TypedefDef_Proxy_Impl&
POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::TypedefDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_TypedefDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_TypedefDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_TypedefDef_Proxy_Broker *
CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_TypedefDef_Strategized_Proxy_Broker::the_TAO_TypedefDef_Strategized_Proxy_Broker();
}

int
CORBA__TAO_TypedefDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_TypedefDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_TypedefDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_TypedefDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_TypedefDef_ThruPOA_Proxy_Impl::_TAO_TypedefDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::TypedefDef::TypedefDef (void)
{
  this->optable_ = &tao_CORBA_TypedefDef_optable;
}

// copy ctor
POA_CORBA::TypedefDef::TypedefDef (const TypedefDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::TypedefDef::~TypedefDef (void)
{
}

void POA_CORBA::TypedefDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::TypedefDef *_tao_impl = (POA_CORBA::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::TypedefDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::TypedefDef *_tao_impl = (POA_CORBA::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::TypedefDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::TypedefDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::TypedefDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

CORBA::TypedefDef*
POA_CORBA::TypedefDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::TypedefDef::_unchecked_narrow (obj.in ());
}

#endif /* ifndef */
