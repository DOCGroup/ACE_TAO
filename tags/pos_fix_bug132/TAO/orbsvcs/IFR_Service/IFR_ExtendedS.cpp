// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef TAO_IDL_IFR_EXTENDEDS_CPP
#define TAO_IDL_IFR_EXTENDEDS_CPP

#include "IFR_ExtendedS.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_ExtendedS.i"
#endif /* !defined INLINE */

class TAO_CORBA_FixedDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:44:40 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_FixedDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_FixedDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19,  0,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_FixedDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::FixedDef::_is_a_skel},
      {"destroy", 	&POA_CORBA::FixedDef::destroy_skel},
      {"_get_type", 	&POA_CORBA::FixedDef::_get_type_skel},
      {"_get_scale", 	&POA_CORBA::FixedDef::_get_scale_skel},
      {"_set_scale", 	&POA_CORBA::FixedDef::_set_scale_skel},
      {"_get_digits", 	&POA_CORBA::FixedDef::_get_digits_skel},
      {"_set_digits", 	&POA_CORBA::FixedDef::_set_digits_skel},
      {"_get_def_kind", 	&POA_CORBA::FixedDef::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::FixedDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -8,  -2, -10,  -2,   5,  -1,   6,  -1,   7, -27, -26,  -1,  12, 
       -1,  -1,  -1,  -1,  13, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 10:44:40 */
static TAO_CORBA_FixedDef_Perfect_Hash_OpTable tao_CORBA_FixedDef_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_FixedDef_digits_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_FixedDef_digits_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::UShort result);

private:
  TAO_ServerRequestInfo_CORBA_FixedDef_digits_get (const TAO_ServerRequestInfo_CORBA_FixedDef_digits_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_FixedDef_digits_get &);
  
private:
  POA_CORBA::FixedDef *_tao_impl;
  CORBA::UShort _result;
};

TAO_ServerRequestInfo_CORBA_FixedDef_digits_get::TAO_ServerRequestInfo_CORBA_FixedDef_digits_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_FixedDef_digits_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_FixedDef_digits_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_FixedDef_digits_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_FixedDef_digits_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_FixedDef_digits_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_FixedDef_digits_get::result (CORBA::UShort result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_FixedDef_digits_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_FixedDef_digits_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    const CORBA::UShort & digits,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_FixedDef_digits_set (const TAO_ServerRequestInfo_CORBA_FixedDef_digits_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_FixedDef_digits_set &);
  
private:
  POA_CORBA::FixedDef *_tao_impl;
  const CORBA::UShort & digits_;
  
};

TAO_ServerRequestInfo_CORBA_FixedDef_digits_set::TAO_ServerRequestInfo_CORBA_FixedDef_digits_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    const CORBA::UShort & digits,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    digits_ (digits)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_FixedDef_digits_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_digits = parameter_list->length ();
  parameter_list->length (length_digits + 1);
  (*parameter_list)[length_digits].argument <<= digits_;
  (*parameter_list)[length_digits].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_FixedDef_digits_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_FixedDef_digits_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_FixedDef_digits_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_FixedDef_digits_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_FixedDef_scale_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_FixedDef_scale_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Short result);

private:
  TAO_ServerRequestInfo_CORBA_FixedDef_scale_get (const TAO_ServerRequestInfo_CORBA_FixedDef_scale_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_FixedDef_scale_get &);
  
private:
  POA_CORBA::FixedDef *_tao_impl;
  CORBA::Short _result;
};

TAO_ServerRequestInfo_CORBA_FixedDef_scale_get::TAO_ServerRequestInfo_CORBA_FixedDef_scale_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_FixedDef_scale_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_FixedDef_scale_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_FixedDef_scale_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_FixedDef_scale_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_FixedDef_scale_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_FixedDef_scale_get::result (CORBA::Short result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_FixedDef_scale_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_FixedDef_scale_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    const CORBA::Short & scale,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_FixedDef_scale_set (const TAO_ServerRequestInfo_CORBA_FixedDef_scale_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_FixedDef_scale_set &);
  
private:
  POA_CORBA::FixedDef *_tao_impl;
  const CORBA::Short & scale_;
  
};

TAO_ServerRequestInfo_CORBA_FixedDef_scale_set::TAO_ServerRequestInfo_CORBA_FixedDef_scale_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::FixedDef *tao_impl,
    const CORBA::Short & scale,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    scale_ (scale)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_FixedDef_scale_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_scale = parameter_list->length ();
  parameter_list->length (length_scale + 1);
  (*parameter_list)[length_scale].argument <<= scale_;
  (*parameter_list)[length_scale].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_FixedDef_scale_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_FixedDef_scale_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_FixedDef_scale_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_FixedDef_scale_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker *POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker::the_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker::_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker::~_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_FixedDef_Proxy_Impl&
POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::FixedDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FixedDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_FixedDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_FixedDef_Proxy_Broker *
CORBA__TAO_FixedDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_FixedDef_Strategized_Proxy_Broker::the_TAO_FixedDef_Strategized_Proxy_Broker();
}

int
CORBA__TAO_FixedDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_FixedDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_FixedDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_FixedDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_FixedDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_FixedDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_FixedDef_ThruPOA_Proxy_Impl::_TAO_FixedDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::UShort POA_CORBA::_TAO_FixedDef_ThruPOA_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::UShort _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "digits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->digits (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_FixedDef_ThruPOA_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "digits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->digits (
        digits,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Short POA_CORBA::_TAO_FixedDef_ThruPOA_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Short _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->scale (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_FixedDef_ThruPOA_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->scale (
        scale,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::FixedDef::FixedDef (void)
{
  this->optable_ = &tao_CORBA_FixedDef_optable;
}

// copy ctor
POA_CORBA::FixedDef::FixedDef (const FixedDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::FixedDef::~FixedDef (void)
{
}

void POA_CORBA::FixedDef::_get_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;
  
    CORBA::UShort _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_FixedDef_digits_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->digits (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::UShort _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::FixedDef::_set_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::UShort digits;
  if (!(
    (_tao_in >> digits)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_FixedDef_digits_set ri (
      _tao_server_request,
      _tao_impl,
      digits,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->digits (
          digits,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::FixedDef::_get_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;
  
    CORBA::Short _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_FixedDef_scale_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->scale (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Short _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::FixedDef::_set_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::Short scale;
  if (!(
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_FixedDef_scale_set ri (
      _tao_server_request,
      _tao_impl,
      scale,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->scale (
          scale,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::FixedDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::FixedDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::FixedDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::FixedDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/FixedDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::FixedDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::FixedDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/FixedDef:1.0";
}

CORBA::FixedDef*
POA_CORBA::FixedDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::FixedDef::_unchecked_narrow (obj.in ());
}

class TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:44:40 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37,  0, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::ValueMemberDef::move_skel},
      {"_is_a",  &POA_CORBA::ValueMemberDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::ValueMemberDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ValueMemberDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ValueMemberDef::describe_skel},
      {"_get_type", 	&POA_CORBA::ValueMemberDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::ValueMemberDef::_set_name_skel},
      {"_get_name", 	&POA_CORBA::ValueMemberDef::_get_name_skel},
      {"_get_access", 	&POA_CORBA::ValueMemberDef::_get_access_skel},
      {"_set_access", 	&POA_CORBA::ValueMemberDef::_set_access_skel},
      {"_get_version", 	&POA_CORBA::ValueMemberDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ValueMemberDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::ValueMemberDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::ValueMemberDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::ValueMemberDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::ValueMemberDef::_get_absolute_name_skel},
      {"_get_type_def", 	&POA_CORBA::ValueMemberDef::_get_type_def_skel},
      {"_set_type_def", 	&POA_CORBA::ValueMemberDef::_set_type_def_skel},
      {"_non_existent",  &POA_CORBA::ValueMemberDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::ValueMemberDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46,  -1, -47, -46,  16, 
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1, 
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 10:44:40 */
static TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable tao_CORBA_ValueMemberDef_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::TypeCode_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get &);
  
private:
  POA_CORBA::ValueMemberDef *_tao_impl;
  CORBA::TypeCode_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get::TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get &);
  
private:
  POA_CORBA::ValueMemberDef *_tao_impl;
  CORBA::IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get::TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get::result (CORBA::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set &);
  
private:
  POA_CORBA::ValueMemberDef *_tao_impl;
  CORBA::IDLType_ptr type_def_;
  
};

TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set::TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_type_def = parameter_list->length ();
  parameter_list->length (length_type_def + 1);
  (*parameter_list)[length_type_def].argument <<=  this->type_def_;
  
  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Visibility result);

private:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get &);
  
private:
  POA_CORBA::ValueMemberDef *_tao_impl;
  CORBA::Visibility _result;
};

TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get::TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get::result (CORBA::Visibility result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    const CORBA::Visibility & access,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set &);
  
private:
  POA_CORBA::ValueMemberDef *_tao_impl;
  const CORBA::Visibility & access_;
  
};

TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set::TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueMemberDef *tao_impl,
    const CORBA::Visibility & access,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    access_ (access)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_access = parameter_list->length ();
  parameter_list->length (length_access + 1);
  (*parameter_list)[length_access].argument <<= access_;
  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker *POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker::the_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker::_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker::~_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ValueMemberDef_Proxy_Impl&
POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::ValueMemberDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueMemberDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_ValueMemberDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueMemberDef_Proxy_Broker *
CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_ValueMemberDef_Strategized_Proxy_Broker::the_TAO_ValueMemberDef_Strategized_Proxy_Broker();
}

int
CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_ValueMemberDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_CORBA::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

CORBA::IDLType_ptr POA_CORBA::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->type_def (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->type_def (
        type_def,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Visibility POA_CORBA::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Visibility _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->access (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->access (
        access,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::ValueMemberDef::ValueMemberDef (void)
{
  this->optable_ = &tao_CORBA_ValueMemberDef_optable;
}

// copy ctor
POA_CORBA::ValueMemberDef::ValueMemberDef (const ValueMemberDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ValueMemberDef::~ValueMemberDef (void)
{
}

void POA_CORBA::ValueMemberDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;
  
    CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueMemberDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;
  
    CORBA::IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueMemberDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      type_def.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->type_def (
          type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueMemberDef::_get_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;
  
    CORBA::Visibility _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->access (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Visibility _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueMemberDef::_set_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::Visibility access;
  if (!(
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueMemberDef_access_set ri (
      _tao_server_request,
      _tao_impl,
      access,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->access (
          access,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueMemberDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ValueMemberDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ValueMemberDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ValueMemberDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ValueMemberDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ValueMemberDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ValueMemberDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueMemberDef:1.0";
}

CORBA::ValueMemberDef*
POA_CORBA::ValueMemberDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::ValueMemberDef::_unchecked_narrow (obj.in ());
}

class TAO_CORBA_ValueDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:44:40 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ValueDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ValueDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 55, 30,  0, 86, 86, 86, 20, 86, 86,
     86, 86, 86, 86, 86, 86, 86,  0,  0,  5,
     86,  0, 86,  0, 86, 86, 86, 86, 86, 86,
     86, 86, 15, 15, 86, 86, 86, 10, 10, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86,
#else
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86,  0, 86,  0, 86, 55,
     30,  0, 86, 86, 86, 20, 86, 86,  0,  0,
      5, 86,  0, 86,  0, 15, 15, 86, 86, 86,
     10, 10, 86, 86, 86, 86, 86, 86,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ValueDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 52,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 85,
      HASH_VALUE_RANGE = 82,
      DUPLICATES = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::ValueDef::move_skel},
      {"_is_a",  &POA_CORBA::ValueDef::_is_a_skel},
      {"lookup", 	&POA_CORBA::ValueDef::lookup_skel},
      {"_get_name", 	&POA_CORBA::ValueDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::ValueDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::ValueDef::_set_name_skel},
      {"lookup_name", 	&POA_CORBA::ValueDef::lookup_name_skel},
      {"_get_is_custom", 	&POA_CORBA::ValueDef::_get_is_custom_skel},
      {"_set_is_custom", 	&POA_CORBA::ValueDef::_set_is_custom_skel},
      {"_get_base_value", 	&POA_CORBA::ValueDef::_get_base_value_skel},
      {"_set_base_value", 	&POA_CORBA::ValueDef::_set_base_value_skel},
      {"_get_version", 	&POA_CORBA::ValueDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ValueDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_CORBA::ValueDef::_get_absolute_name_skel},
      {"_get_is_truncatable", 	&POA_CORBA::ValueDef::_get_is_truncatable_skel},
      {"_set_is_truncatable", 	&POA_CORBA::ValueDef::_set_is_truncatable_skel},
      {"_get_defined_in", 	&POA_CORBA::ValueDef::_get_defined_in_skel},
      {"is_a", 	&POA_CORBA::ValueDef::is_a_skel},
      {"_non_existent",  &POA_CORBA::ValueDef::_non_existent_skel},
      {"_get_is_abstract", 	&POA_CORBA::ValueDef::_get_is_abstract_skel},
      {"_set_is_abstract", 	&POA_CORBA::ValueDef::_set_is_abstract_skel},
      {"_get_initializers", 	&POA_CORBA::ValueDef::_get_initializers_skel},
      {"_set_initializers", 	&POA_CORBA::ValueDef::_set_initializers_skel},
      {"_get_containing_repository", 	&POA_CORBA::ValueDef::_get_containing_repository_skel},
      {"_get_id", 	&POA_CORBA::ValueDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ValueDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ValueDef::describe_skel},
      {"_get_supported_interfaces", 	&POA_CORBA::ValueDef::_get_supported_interfaces_skel},
      {"_set_abstract_base_values", 	&POA_CORBA::ValueDef::_set_abstract_base_values_skel},
      {"_get_abstract_base_values", 	&POA_CORBA::ValueDef::_get_abstract_base_values_skel},
      {"_set_supported_interfaces", 	&POA_CORBA::ValueDef::_set_supported_interfaces_skel},
      {"_get_def_kind", 	&POA_CORBA::ValueDef::_get_def_kind_skel},
      {"describe_value", 	&POA_CORBA::ValueDef::describe_value_skel},
      {"destroy", 	&POA_CORBA::ValueDef::destroy_skel},
      {"describe_contents", 	&POA_CORBA::ValueDef::describe_contents_skel},
      {"create_enum", 	&POA_CORBA::ValueDef::create_enum_skel},
      {"create_value", 	&POA_CORBA::ValueDef::create_value_skel},
      {"create_module", 	&POA_CORBA::ValueDef::create_module_skel},
      {"create_native", 	&POA_CORBA::ValueDef::create_native_skel},
      {"create_attribute", 	&POA_CORBA::ValueDef::create_attribute_skel},
      {"create_interface", 	&POA_CORBA::ValueDef::create_interface_skel},
      {"create_union", 	&POA_CORBA::ValueDef::create_union_skel},
      {"create_value_member", 	&POA_CORBA::ValueDef::create_value_member_skel},
      {"create_operation", 	&POA_CORBA::ValueDef::create_operation_skel},
      {"create_exception", 	&POA_CORBA::ValueDef::create_exception_skel},
      {"create_local_interface", 	&POA_CORBA::ValueDef::create_local_interface_skel},
      {"contents", 	&POA_CORBA::ValueDef::contents_skel},
      {"create_abstract_interface", 	&POA_CORBA::ValueDef::create_abstract_interface_skel},
      {"create_value_box", 	&POA_CORBA::ValueDef::create_value_box_skel},
      {"create_alias", 	&POA_CORBA::ValueDef::create_alias_skel},
      {"create_struct", 	&POA_CORBA::ValueDef::create_struct_skel},
      {"create_constant", 	&POA_CORBA::ValueDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -11,   -2,  -13,   -2,    4,    5,    6,  -15,   -2,  117,   -1,   10,  -18,   -2, 
       -99,  -98,   -1,  -95,   17,  -92,   20,   -1,  -23,   -2,   21,   -1,  -25,   -2, 
        22,  -28,   -2,  -94,  -91,   -1,  -31,   -4,   27,  -93,   30,   -1,  -91,   -7, 
        -3,   35,   36,   -1,   -1,   37,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, 
        -1,   -1,   -1,   -1,  -41,   -2,   38,   -1,  -43,   -2,   39,   40,  -93,  -47, 
        -2,  -92,   45,   -1,   46,   -1,  -92,   49,   50,   -1,   51,   52,   53,   54, 
        -1,   55, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 10:44:40 */
static TAO_CORBA_ValueDef_Perfect_Hash_OpTable tao_CORBA_ValueDef_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::InterfaceDefSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get (const TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::InterfaceDefSeq * _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get::TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get::result (CORBA::InterfaceDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set (const TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const CORBA::InterfaceDefSeq & supported_interfaces_;
  
};

TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set::TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::InitializerSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get (const TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::InitializerSeq * _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get::TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get::result (CORBA::InitializerSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set (const TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const CORBA::InitializerSeq & initializers_;
  
};

TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set::TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_initializers = parameter_list->length ();
  parameter_list->length (length_initializers + 1);
  (*parameter_list)[length_initializers].argument <<=  this->initializers_;
  
  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get (const TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::ValueDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get::TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get::result (CORBA::ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set (const TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::ValueDef_ptr base_value_;
  
};

TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set::TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::ValueDef_ptr base_value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    base_value_ (base_value)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_base_value = parameter_list->length ();
  parameter_list->length (length_base_value + 1);
  (*parameter_list)[length_base_value].argument <<=  this->base_value_;
  
  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueDefSeq * result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get (const TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::ValueDefSeq * _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get::TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get::result (CORBA::ValueDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set (const TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const CORBA::ValueDefSeq & abstract_base_values_;
  
};

TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set::TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::ValueDefSeq & abstract_base_values,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    abstract_base_values_ (abstract_base_values)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_abstract_base_values = parameter_list->length ();
  parameter_list->length (length_abstract_base_values + 1);
  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;
  
  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get (const TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get::TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::Boolean & is_abstract,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set (const TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const CORBA::Boolean & is_abstract_;
  
};

TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set::TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::Boolean & is_abstract,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_abstract_ (is_abstract)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get (const TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get::TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::Boolean & is_custom,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set (const TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const CORBA::Boolean & is_custom_;
  
};

TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set::TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::Boolean & is_custom,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_custom_ (is_custom)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_custom = parameter_list->length ();
  parameter_list->length (length_is_custom + 1);
  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get (const TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get::TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::Boolean & is_truncatable,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set (const TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const CORBA::Boolean & is_truncatable_;
  
};

TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set::TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const CORBA::Boolean & is_truncatable,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_truncatable_ (is_truncatable)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_truncatable = parameter_list->length ();
  parameter_list->length (length_is_truncatable + 1);
  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

class TAO_ServerRequestInfo_CORBA_ValueDef_is_a : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_is_a (const TAO_ServerRequestInfo_CORBA_ValueDef_is_a &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_is_a &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const char * id_;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_is_a::TAO_ServerRequestInfo_CORBA_ValueDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_is_a::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_is_a::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_describe_value : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_describe_value (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueDef::FullValueDescription * result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_describe_value (const TAO_ServerRequestInfo_CORBA_ValueDef_describe_value &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_describe_value &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  CORBA::ValueDef::FullValueDescription * _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_describe_value::TAO_ServerRequestInfo_CORBA_ValueDef_describe_value (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_describe_value::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_describe_value::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_describe_value::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_describe_value::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_describe_value::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_describe_value::result (CORBA::ValueDef::FullValueDescription * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Visibility & access,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::ValueMemberDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member (const TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr type_;
  const CORBA::Visibility & access_;
  CORBA::ValueMemberDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member::TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Visibility & access,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    access_ (access)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_access = parameter_list->length ();
  parameter_list->length (length_access + 1);
  (*parameter_list)[length_access].argument <<= access_;
  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member::result (CORBA::ValueMemberDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode & mode,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::AttributeDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute (const TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr type_;
  const CORBA::AttributeMode & mode_;
  CORBA::AttributeDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute::TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode & mode,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    mode_ (mode)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute::result (CORBA::AttributeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueDef_create_operation : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueDef_create_operation (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode & mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::OperationDef_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ValueDef_create_operation (const TAO_ServerRequestInfo_CORBA_ValueDef_create_operation &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueDef_create_operation &);
  
private:
  POA_CORBA::ValueDef *_tao_impl;
  const char * id_;
  const char * name_;
  const char * version_;
  CORBA::IDLType_ptr result_;
  const CORBA::OperationMode & mode_;
  const CORBA::ParDescriptionSeq & params_;
  const CORBA::ExceptionDefSeq & exceptions_;
  const CORBA::ContextIdSeq & contexts_;
  CORBA::OperationDef_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ValueDef_create_operation::TAO_ServerRequestInfo_CORBA_ValueDef_create_operation (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode & mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    result_ (result),
    mode_ (mode),
    params_ (params),
    exceptions_ (exceptions),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueDef_create_operation::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_result = parameter_list->length ();
  parameter_list->length (length_result + 1);
  (*parameter_list)[length_result].argument <<=  this->result_;
  
  (*parameter_list)[length_result].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_contexts = parameter_list->length ();
  parameter_list->length (length_contexts + 1);
  (*parameter_list)[length_contexts].argument <<=  this->contexts_;
  
  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueDef_create_operation::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueDef_create_operation::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueDef_create_operation::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueDef_create_operation::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueDef_create_operation::result (CORBA::OperationDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker *POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker::the_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker::_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker::~_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ValueDef_Proxy_Impl&
POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::ValueDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_ValueDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueDef_Proxy_Broker *
CORBA__TAO_ValueDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_ValueDef_Strategized_Proxy_Broker::the_TAO_ValueDef_Strategized_Proxy_Broker();
}

int
CORBA__TAO_ValueDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_ValueDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ValueDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_ValueDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_ValueDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_ValueDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::_TAO_ValueDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::InterfaceDefSeq * POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->supported_interfaces (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->supported_interfaces (
        supported_interfaces,
        ACE_TRY_ENV
      );
  return;
}

CORBA::InitializerSeq * POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::InitializerSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->initializers (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->initializers (
        initializers,
        ACE_TRY_ENV
      );
  return;
}

CORBA::ValueDef_ptr POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->base_value (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->base_value (
        base_value,
        ACE_TRY_ENV
      );
  return;
}

CORBA::ValueDefSeq * POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ValueDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->abstract_base_values (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->abstract_base_values (
        abstract_base_values,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_abstract (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_abstract (
        is_abstract,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_custom (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_custom (
        is_custom,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_truncatable (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_truncatable (
        is_truncatable,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_a (
        id,
        ACE_TRY_ENV
      );
}

CORBA::ValueDef::FullValueDescription * POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::describe_value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ValueDef::FullValueDescription_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->describe_value (
        ACE_TRY_ENV
      );
}

CORBA::ValueMemberDef_ptr POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_value_member (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ValueMemberDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_member",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->create_value_member (
        id,
        name,
        version,
        type,
        access,
        ACE_TRY_ENV
      );
}

CORBA::AttributeDef_ptr POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_attribute",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->create_attribute (
        id,
        name,
        version,
        type,
        mode,
        ACE_TRY_ENV
      );
}

CORBA::OperationDef_ptr POA_CORBA::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_operation",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->create_operation (
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::ValueDef::ValueDef (void)
{
  this->optable_ = &tao_CORBA_ValueDef_optable;
}

// copy ctor
POA_CORBA::ValueDef::ValueDef (const ValueDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ValueDef::~ValueDef (void)
{
}

void POA_CORBA::ValueDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::InterfaceDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->supported_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::InterfaceDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_supported_interfaces_set ri (
      _tao_server_request,
      _tao_impl,
      supported_interfaces,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->supported_interfaces (
          supported_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_get_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::InitializerSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_initializers_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->initializers (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::InitializerSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_set_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::InitializerSeq initializers;
  if (!(
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_initializers_set ri (
      _tao_server_request,
      _tao_impl,
      initializers,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->initializers (
          initializers,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_get_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_base_value_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->base_value (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_set_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::ValueDef_var base_value;
  if (!(
    (_tao_in >> base_value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_base_value_set ri (
      _tao_server_request,
      _tao_impl,
      base_value.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->base_value (
          base_value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_get_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::ValueDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->abstract_base_values (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ValueDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_set_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::ValueDefSeq abstract_base_values;
  if (!(
    (_tao_in >> abstract_base_values)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_abstract_base_values_set ri (
      _tao_server_request,
      _tao_impl,
      abstract_base_values,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->abstract_base_values (
          abstract_base_values,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_get_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_abstract (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_set_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_is_abstract_set ri (
      _tao_server_request,
      _tao_impl,
      is_abstract,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->is_abstract (
          is_abstract,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_get_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_custom (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_set_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::Boolean is_custom;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_custom))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_is_custom_set ri (
      _tao_server_request,
      _tao_impl,
      is_custom,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->is_custom (
          is_custom,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_get_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_truncatable (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_set_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::Boolean is_truncatable;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable))
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_is_truncatable_set ri (
      _tao_server_request,
      _tao_impl,
      is_truncatable,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->is_truncatable (
          is_truncatable,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::Boolean _tao_retval = 0;
  CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_is_a ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->is_a (
          id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::describe_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::ValueDef::FullValueDescription_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_describe_value ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->describe_value (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ValueDef::FullValueDescription * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::create_value_member_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::ValueMemberDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var type;
  CORBA::Visibility access;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_create_value_member ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      access,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_value_member (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          access,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ValueMemberDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var type;
  CORBA::AttributeMode mode;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_create_attribute ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_attribute (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          mode,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::AttributeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;
  
    CORBA::OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var result;
  CORBA::OperationMode mode;
  CORBA::ParDescriptionSeq params;
  CORBA::ExceptionDefSeq exceptions;
  CORBA::ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueDef_create_operation ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->create_operation (
          id.in (),
          name.in (),
          version.in (),
          result.in (),
          mode,
          params,
          exceptions,
          contexts,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::OperationDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ValueDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ValueDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ValueDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ValueDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ValueDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ValueDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueDef:1.0";
}

CORBA::ValueDef*
POA_CORBA::ValueDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::ValueDef::_unchecked_narrow (obj.in ());
}

class TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:44:40 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::ValueBoxDef::move_skel},
      {"_is_a",  &POA_CORBA::ValueBoxDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::ValueBoxDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ValueBoxDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ValueBoxDef::describe_skel},
      {"_get_name", 	&POA_CORBA::ValueBoxDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::ValueBoxDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::ValueBoxDef::_set_name_skel},
      {"_get_version", 	&POA_CORBA::ValueBoxDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ValueBoxDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::ValueBoxDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::ValueBoxDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::ValueBoxDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::ValueBoxDef::_get_absolute_name_skel},
      {"_get_original_type_def", 	&POA_CORBA::ValueBoxDef::_get_original_type_def_skel},
      {"_set_original_type_def", 	&POA_CORBA::ValueBoxDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_CORBA::ValueBoxDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::ValueBoxDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14, 
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 10:44:40 */
static TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable tao_CORBA_ValueBoxDef_optable;


#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueBoxDef *tao_impl,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::IDLType_ptr result);

private:
  TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get (const TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get &);
  
private:
  POA_CORBA::ValueBoxDef *_tao_impl;
  CORBA::IDLType_ptr _result;
};

TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get::TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueBoxDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void 
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get::result (CORBA::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueBoxDef *tao_impl,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV = 
      TAO_default_environment ()
  );

  virtual Dynamic::ParameterList * arguments (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV = TAO_default_environment ())
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set (const TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set &);
  void operator= (const TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set &);
  
private:
  POA_CORBA::ValueBoxDef *_tao_impl;
  CORBA::IDLType_ptr original_type_def_;
  
};

TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set::TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA::ValueBoxDef *tao_impl,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
  
  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}

CORBA::Any * 
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker *POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker::the_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker::_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker::~_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ValueBoxDef_Proxy_Impl&
POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::ValueBoxDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueBoxDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_ValueBoxDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueBoxDef_Proxy_Broker *
CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_CORBA::_TAO_ValueBoxDef_Strategized_Proxy_Broker::the_TAO_ValueBoxDef_Strategized_Proxy_Broker();
}

int
CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int CORBA__TAO_ValueBoxDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, CORBA__TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_CORBA::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::IDLType_ptr POA_CORBA::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_CORBA::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueBoxDef:1.0"
        )
    )->original_type_def (
        ACE_TRY_ENV
      );
}

void POA_CORBA::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueBoxDef:1.0"
        )
    )->original_type_def (
        original_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA::ValueBoxDef::ValueBoxDef (void)
{
  this->optable_ = &tao_CORBA_ValueBoxDef_optable;
}

// copy ctor
POA_CORBA::ValueBoxDef::ValueBoxDef (const ValueBoxDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ValueBoxDef::~ValueBoxDef (void)
{
}

void POA_CORBA::ValueBoxDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *)_tao_object_reference;
  
    CORBA::IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval = 
      _tao_impl->original_type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueBoxDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *)_tao_object_reference;
  
  _tao_server_request.argument_flag (0);
    CORBA::IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_CORBA_ValueBoxDef_original_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      original_type_def.in (),
      ACE_TRY_ENV
    );
  
  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */
      
      _tao_impl->original_type_def (
          original_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
      
#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc); 
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA::ValueBoxDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ValueBoxDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ValueBoxDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  const char *base_id = CORBA::_tc_Object->id (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ValueBoxDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ValueBoxDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ValueBoxDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ValueBoxDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueBoxDef:1.0";
}

CORBA::ValueBoxDef*
POA_CORBA::ValueBoxDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::ValueBoxDef::_unchecked_narrow (obj.in ());
}

#endif /* ifndef */
