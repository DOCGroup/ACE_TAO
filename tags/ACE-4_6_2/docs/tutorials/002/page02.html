<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; Linux 2.0.32 i486) [Netscape]">
   <META NAME="Author" CONTENT="James CE Johnson">
   <META NAME="Description" CONTENT="A first step towards using ACE productively">
   <TITLE>ACE Tutorial 002</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000FFF" VLINK="#FF0F0F">

<CENTER><B><FONT SIZE=+2>ACE Tutorial 002</FONT></B></CENTER>

<CENTER><B><FONT SIZE=+2>Creating a Better Server</FONT></B></CENTER>


<P>
<HR WIDTH="100%">

<P>Like Tutorial 1, this is also a rather small program.&nbsp; I'm going
to add a couple of new ideas along the way but to make up for it I'm also
going to simplify the acceptor a great deal.

<P>We begin by looking at the <A HREF="server.cpp">main</A> portion program:

<P>
<HR WIDTH="100%">
<PRE>
/*
&nbsp; As before, we need a few ACE objects as well as our Logging_Handler declaration.
&nbsp;*/
#include "ace/Acceptor.h"
#include "ace/SOCK_Acceptor.h"
#include "ace/Reactor.h"
#include "handler.h"

/*
&nbsp; We'll still use the global reactor pointer.&nbsp; There's a snappy way around this
&nbsp; that shows up in later server tutorials.
&nbsp;*/
ACE_Reactor * g_reactor;

/*
&nbsp; This was hinted at in Tutorial 1.&nbsp; Remember the hand-coded acceptor that we
&nbsp; created there?&nbsp; This template does all of that and more and better.&nbsp; If you
&nbsp; find yourself creating code that doesn't feel like a part of your application,
&nbsp; there's a good chance that ACE has a template or framework component to do
&nbsp; it for you.
&nbsp;*/
typedef ACE_Acceptor &lt; Logging_Handler, ACE_SOCK_ACCEPTOR > Logging_Acceptor;

/*
&nbsp; One of the new things will be a signal handler so that we can exit the application
&nbsp; somewhat cleanly.&nbsp; The 'finished' flag is used instead of the previous infninite
&nbsp; loop and the 'handler' will set that flag in respose to SIGINT (CTRL-C).
&nbsp;*/
static sig_atomic_t finished = 0;
extern "C" void handler (int)
{
&nbsp; finished = 1;
}

static const u_short PORT = ACE_DEFAULT_SERVER_PORT;

int main (int, char **)
{
&nbsp; // Create the reactor we'll register our event handler derivatives with.
&nbsp; g_reactor = new ACE_Reactor;

&nbsp; // Create the acceptor that will listen for client connetions
&nbsp; Logging_Acceptor peer_acceptor;

&nbsp; /*
&nbsp;&nbsp;&nbsp; Notice how similar this is to the open() call in Tutorial 1.&nbsp; I read
&nbsp;&nbsp;&nbsp; ahead when I created that one so that it would come out this way...
&nbsp;&nbsp; */
&nbsp; if (peer_acceptor.open (ACE_INET_Addr (PORT), g_reactor) == -1)
&nbsp;&nbsp;&nbsp; ACE_ERROR_RETURN ((LM_ERROR, "%p\n", "open"), -1);

&nbsp; /*
&nbsp;&nbsp;&nbsp; Here's the easiest way to respond to signals in your application.&nbsp; Simply
&nbsp;&nbsp;&nbsp; construct an ACE_Sig_Action object with a "C" function and the signal you
&nbsp;&nbsp;&nbsp; want to capture.&nbsp; As you might expect, there is also a way to register
&nbsp;&nbsp;&nbsp; signal handlers with a reactor but we take the easy-out here.
&nbsp;&nbsp; */
&nbsp; ACE_Sig_Action sa ((ACE_SignalHandler) handler, SIGINT);

&nbsp; ACE_DEBUG ((LM_DEBUG, "(%P|%t) starting up server logging daemon\n"));

&nbsp; // Perform logging service until the signal handler receives SIGINT.
&nbsp; while (!finished)
&nbsp;&nbsp;&nbsp; g_reactor->handle_events ();

&nbsp; // Close the acceptor so that no more clients will be taken in.
&nbsp; peer_acceptor.close();

&nbsp; // Free up the memory allocated for the reactor.
&nbsp; delete g_reactor;

&nbsp; ACE_DEBUG ((LM_DEBUG, "(%P|%t) shutting down server logging daemon\n"));

&nbsp; return 0;
}</PRE>


<P>
<HR WIDTH="100%">
<CENTER></CENTER>

<CENTER>[<A HREF="..">Tutorial
Index</A>] [<A HREF="page01.html">Previous
Page</A>] [<A HREF="page03.html">Continue
This Tutorial</A>]</CENTER>

</BODY>
</HTML>
