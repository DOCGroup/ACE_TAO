/* -*- C++ -*- */
//$Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "InterfaceC.h"

#if !defined (__ACE_INLINE__)
#include "InterfaceC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_CORBA_Identifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Identifier (CORBA::tk_alias, sizeof (_oc_CORBA_Identifier), (char *) &_oc_CORBA_Identifier, 0, sizeof (CORBA::Identifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_CORBA_Identifier)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ScopedName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5363), ACE_NTOHL (0x6f706564), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ScopedName:1.0
  11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ScopedName (CORBA::tk_alias, sizeof (_oc_CORBA_ScopedName), (char *) &_oc_CORBA_ScopedName, 0, sizeof (CORBA::ScopedName));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_CORBA_ScopedName)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_RepositoryId (CORBA::tk_alias, sizeof (_oc_CORBA_RepositoryId), (char *) &_oc_CORBA_RepositoryId, 0, sizeof (CORBA::RepositoryId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_CORBA_RepositoryId)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_DefinitionKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
  15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
  24, // member count
  8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
  7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
  13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
  12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
  13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
  13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
  10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
  13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
  11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
  9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
  8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
  13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
  12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
  14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
  11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
  9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
  9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
  12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
  15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
  10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_DefinitionKind (CORBA::tk_enum, sizeof (_oc_CORBA_DefinitionKind), (char *) &_oc_CORBA_DefinitionKind, 0, sizeof (CORBA::DefinitionKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_DefinitionKind, &_tc_TAO_tc_CORBA_DefinitionKind)
TAO_NAMESPACE_END
CORBA::IRObject_ptr CORBA::IRObject::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IRObject::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IRObject:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::IRObject::_nil ());
  if (is_a == 0)
    return CORBA::IRObject::_nil ();
  return CORBA::IRObject::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::IRObject_ptr CORBA::IRObject::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IRObject::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer != 0)
    {
      CORBA_IRObject_ptr retv = _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::IRObject(stub);
}

CORBA::IRObject_ptr 
CORBA::IRObject::_duplicate (CORBA::IRObject_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::DefinitionKind CORBA::IRObject::def_kind (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::DefinitionKind _tao_retval = (CORBA::DefinitionKind)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""def_kind",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::IRObject::destroy (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::IRObject::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

static const CORBA::Long _oc_CORBA_IRObject[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4952), ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/IRObject:1.0
  9, ACE_NTOHL (0x49524f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = IRObject
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_IRObject (CORBA::tk_objref, sizeof (_oc_CORBA_IRObject), (char *) &_oc_CORBA_IRObject, 0, sizeof (CORBA::IRObject));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IRObject, &_tc_TAO_tc_CORBA_IRObject)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_VersionSpec[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
  12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_VersionSpec (CORBA::tk_alias, sizeof (_oc_CORBA_VersionSpec), (char *) &_oc_CORBA_VersionSpec, 0, sizeof (CORBA::VersionSpec));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_VersionSpec, &_tc_TAO_tc_CORBA_VersionSpec)
TAO_NAMESPACE_END
CORBA::Contained_ptr CORBA::Contained::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Contained::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Contained:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::Contained::_nil ());
  if (is_a == 0)
    return CORBA::Contained::_nil ();
  return CORBA::Contained::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::Contained_ptr CORBA::Contained::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Contained::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer != 0)
    {
      CORBA_Contained_ptr retv = _TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::Contained(stub);
}

CORBA::Contained_ptr 
CORBA::Contained::_duplicate (CORBA::Contained_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

char * CORBA::Contained::id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  char* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""id",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::Contained::id (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""id",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

char * CORBA::Contained::name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  char* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""name",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::Contained::name (
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""name",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << name)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

char * CORBA::Contained::version (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  char* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""version",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::Contained::version (
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""version",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << version)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Container_ptr CORBA::Contained::defined_in (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Container_ptr _tao_retval = CORBA::Container::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""defined_in",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

char * CORBA::Contained::absolute_name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  char* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""absolute_name",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Repository_ptr CORBA::Contained::containing_repository (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Repository_ptr _tao_retval = CORBA::Repository::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""containing_repository",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_Contained_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65642f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  2, // member count
  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  472, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    24, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Contained_Description (CORBA::tk_struct, sizeof (_oc_CORBA_Contained_Description), (char *) &_oc_CORBA_Contained_Description, 0, sizeof (CORBA::Contained::Description));
CORBA::TypeCode_ptr CORBA::Contained::_tc_Description = &_tc_TAO_tc_CORBA_Contained_Description;

CORBA::Contained::Description * CORBA::Contained::describe (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Contained::Description* _tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Contained::Description, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::Contained::move (
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "move",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << new_container) &&
          (_tao_out << new_name) &&
          (_tao_out << new_version)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::Contained::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

static const CORBA::Long _oc_CORBA_Contained[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Contained (CORBA::tk_objref, sizeof (_oc_CORBA_Contained), (char *) &_oc_CORBA_Contained, 0, sizeof (CORBA::Contained));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Contained, &_tc_TAO_tc_CORBA_Contained)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::InterfaceDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::InterfaceDef **old = ACE_reinterpret_cast (CORBA::InterfaceDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA::InterfaceDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA::InterfaceDef **tmp = ACE_reinterpret_cast (CORBA::InterfaceDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::InterfaceDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA::InterfaceDef **tmp = ACE_reinterpret_cast (CORBA::InterfaceDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::InterfaceDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA::InterfaceDef **tmp = ACE_static_cast (CORBA::InterfaceDef**, target);
    *tmp = CORBA::InterfaceDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_upcast (void *src) const
  {
    CORBA::InterfaceDef **tmp = ACE_static_cast (CORBA::InterfaceDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_INTERFACEDEFSEQ_CS_)
#define _CORBA_INTERFACEDEFSEQ_CS_

// *************************************************************
// CORBA::InterfaceDefSeq
// *************************************************************

CORBA::InterfaceDefSeq::CORBA_InterfaceDefSeq (void)
{}
CORBA::InterfaceDefSeq::CORBA_InterfaceDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::InterfaceDef,CORBA::InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::InterfaceDefSeq::CORBA_InterfaceDefSeq (CORBA::ULong max, CORBA::ULong length, CORBA::InterfaceDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::InterfaceDef,CORBA::InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::InterfaceDefSeq::CORBA_InterfaceDefSeq (const CORBA_InterfaceDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::InterfaceDef,CORBA::InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::InterfaceDefSeq::~CORBA_InterfaceDefSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_InterfaceDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/InterfaceDefSeq:1.0
  16, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = InterfaceDefSeq
  CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
      13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDefSeq (CORBA::tk_alias, sizeof (_oc_CORBA_InterfaceDefSeq), (char *) &_oc_CORBA_InterfaceDefSeq, 0, sizeof (CORBA::InterfaceDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDefSeq, &_tc_TAO_tc_CORBA_InterfaceDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::ValueDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::ValueDef **old = ACE_reinterpret_cast (CORBA::ValueDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA::ValueDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA::ValueDef **tmp = ACE_reinterpret_cast (CORBA::ValueDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::ValueDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA::ValueDef **tmp = ACE_reinterpret_cast (CORBA::ValueDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::ValueDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA::ValueDef **tmp = ACE_static_cast (CORBA::ValueDef**, target);
    *tmp = CORBA::ValueDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_upcast (void *src) const
  {
    CORBA::ValueDef **tmp = ACE_static_cast (CORBA::ValueDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_VALUEDEFSEQ_CS_)
#define _CORBA_VALUEDEFSEQ_CS_

// *************************************************************
// CORBA::ValueDefSeq
// *************************************************************

CORBA::ValueDefSeq::CORBA_ValueDefSeq (void)
{}
CORBA::ValueDefSeq::CORBA_ValueDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::ValueDef,CORBA::ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::ValueDefSeq::CORBA_ValueDefSeq (CORBA::ULong max, CORBA::ULong length, CORBA::ValueDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::ValueDef,CORBA::ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::ValueDefSeq::CORBA_ValueDefSeq (const CORBA_ValueDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::ValueDef,CORBA::ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::ValueDefSeq::~CORBA_ValueDefSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ValueDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueDefSeq:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = ValueDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
      9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDefSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ValueDefSeq), (char *) &_oc_CORBA_ValueDefSeq, 0, sizeof (CORBA::ValueDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDefSeq, &_tc_TAO_tc_CORBA_ValueDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::Contained **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::Contained **old = ACE_reinterpret_cast (CORBA::Contained**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA::Contained::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA::Contained **tmp = ACE_reinterpret_cast (CORBA::Contained**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::Contained::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA::Contained **tmp = ACE_reinterpret_cast (CORBA::Contained**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::Contained::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA::Contained **tmp = ACE_static_cast (CORBA::Contained**, target);
    *tmp = CORBA::Contained::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_upcast (void *src) const
  {
    CORBA::Contained **tmp = ACE_static_cast (CORBA::Contained**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_CONTAINEDSEQ_CS_)
#define _CORBA_CONTAINEDSEQ_CS_

// *************************************************************
// CORBA::ContainedSeq
// *************************************************************

CORBA::ContainedSeq::CORBA_ContainedSeq (void)
{}
CORBA::ContainedSeq::CORBA_ContainedSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::ContainedSeq::CORBA_ContainedSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Contained_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::ContainedSeq::CORBA_ContainedSeq (const CORBA_ContainedSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::Contained,CORBA::Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::ContainedSeq::~CORBA_ContainedSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ContainedSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e656453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContainedSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContainedSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
      10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ContainedSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ContainedSeq), (char *) &_oc_CORBA_ContainedSeq, 0, sizeof (CORBA::ContainedSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContainedSeq, &_tc_TAO_tc_CORBA_ContainedSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_StructMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
  13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
  3, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StructMember (CORBA::tk_struct, sizeof (_oc_CORBA_StructMember), (char *) &_oc_CORBA_StructMember, 0, sizeof (CORBA::StructMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMember, &_tc_TAO_tc_CORBA_StructMember)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::StructMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::StructMember *old = ACE_reinterpret_cast (CORBA::StructMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::StructMember *tmp = ACE_reinterpret_cast (CORBA::StructMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::~_TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_STRUCTMEMBERSEQ_CS_)
#define _CORBA_STRUCTMEMBERSEQ_CS_

// *************************************************************
// CORBA::StructMemberSeq
// *************************************************************

CORBA::StructMemberSeq::CORBA_StructMemberSeq (void)
{}
CORBA::StructMemberSeq::CORBA_StructMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::StructMemberSeq::CORBA_StructMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA::StructMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::StructMemberSeq::CORBA_StructMemberSeq (const CORBA_StructMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::StructMemberSeq::~CORBA_StructMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_StructMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
  16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
  CORBA::tk_sequence, // typecode kind
  264, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    248, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
      13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
      3, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StructMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_StructMemberSeq), (char *) &_oc_CORBA_StructMemberSeq, 0, sizeof (CORBA::StructMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMemberSeq, &_tc_TAO_tc_CORBA_StructMemberSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_Initializer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
  12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
  1, // member count
  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
    16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
    CORBA::tk_sequence, // typecode kind
    264, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      248, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
        13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
        3, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Initializer (CORBA::tk_struct, sizeof (_oc_CORBA_Initializer), (char *) &_oc_CORBA_Initializer, 0, sizeof (CORBA::Initializer));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Initializer, &_tc_TAO_tc_CORBA_Initializer)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::Initializer* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_InitializerSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::Initializer *old = ACE_reinterpret_cast (CORBA::Initializer *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::Initializer *tmp = ACE_reinterpret_cast (CORBA::Initializer *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::~_TAO_Unbounded_Sequence_CORBA_InitializerSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_INITIALIZERSEQ_CS_)
#define _CORBA_INITIALIZERSEQ_CS_

// *************************************************************
// CORBA::InitializerSeq
// *************************************************************

CORBA::InitializerSeq::CORBA_InitializerSeq (void)
{}
CORBA::InitializerSeq::CORBA_InitializerSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::InitializerSeq::CORBA_InitializerSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Initializer *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::InitializerSeq::CORBA_InitializerSeq (const CORBA_InitializerSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::InitializerSeq::~CORBA_InitializerSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_InitializerSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InitializerSeq:1.0
  15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
  CORBA::tk_sequence, // typecode kind
  440, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    424, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
      12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
      1, // member count
      8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
      CORBA::tk_alias, // typecode kind for typedefs
      340, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
        16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
        CORBA::tk_sequence, // typecode kind
        264, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          248, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
            13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
            3, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            52, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InitializerSeq (CORBA::tk_alias, sizeof (_oc_CORBA_InitializerSeq), (char *) &_oc_CORBA_InitializerSeq, 0, sizeof (CORBA::InitializerSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InitializerSeq, &_tc_TAO_tc_CORBA_InitializerSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_UnionMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/UnionMember:1.0
  12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
  CORBA::tk_any,

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionMember (CORBA::tk_struct, sizeof (_oc_CORBA_UnionMember), (char *) &_oc_CORBA_UnionMember, 0, sizeof (CORBA::UnionMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMember, &_tc_TAO_tc_CORBA_UnionMember)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::UnionMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::UnionMember *old = ACE_reinterpret_cast (CORBA::UnionMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::UnionMember *tmp = ACE_reinterpret_cast (CORBA::UnionMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::~_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_UNIONMEMBERSEQ_CS_)
#define _CORBA_UNIONMEMBERSEQ_CS_

// *************************************************************
// CORBA::UnionMemberSeq
// *************************************************************

CORBA::UnionMemberSeq::CORBA_UnionMemberSeq (void)
{}
CORBA::UnionMemberSeq::CORBA_UnionMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::UnionMemberSeq::CORBA_UnionMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA::UnionMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::UnionMemberSeq::CORBA_UnionMemberSeq (const CORBA_UnionMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::UnionMemberSeq::~CORBA_UnionMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_UnionMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/UnionMemberSeq:1.0
  15, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = UnionMemberSeq
  CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/UnionMember:1.0
      12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
      CORBA::tk_any,

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_UnionMemberSeq), (char *) &_oc_CORBA_UnionMemberSeq, 0, sizeof (CORBA::UnionMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMemberSeq, &_tc_TAO_tc_CORBA_UnionMemberSeq)
TAO_NAMESPACE_END

#if !defined (_CORBA_ENUMMEMBERSEQ_CS_)
#define _CORBA_ENUMMEMBERSEQ_CS_

// *************************************************************
// CORBA::EnumMemberSeq
// *************************************************************

CORBA::EnumMemberSeq::CORBA_EnumMemberSeq (void)
{}
CORBA::EnumMemberSeq::CORBA_EnumMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::EnumMemberSeq::CORBA_EnumMemberSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::EnumMemberSeq::CORBA_EnumMemberSeq (const CORBA_EnumMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::EnumMemberSeq::~CORBA_EnumMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_EnumMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f456e), ACE_NTOHL (0x756d4d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/EnumMemberSeq:1.0
  14, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x71000000),  // name = EnumMemberSeq
  CORBA::tk_sequence, // typecode kind
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_EnumMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_EnumMemberSeq), (char *) &_oc_CORBA_EnumMemberSeq, 0, sizeof (CORBA::EnumMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumMemberSeq, &_tc_TAO_tc_CORBA_EnumMemberSeq)
TAO_NAMESPACE_END
CORBA::Container_ptr CORBA::Container::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Container::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Container:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::Container::_nil ());
  if (is_a == 0)
    return CORBA::Container::_nil ();
  return CORBA::Container::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::Container_ptr CORBA::Container::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Container::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_Container_Stub_Factory_function_pointer != 0)
    {
      CORBA_Container_ptr retv = _TAO_collocation_CORBA_Container_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::Container(stub);
}

CORBA::Container_ptr 
CORBA::Container::_duplicate (CORBA::Container_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Contained_ptr CORBA::Container::lookup (
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Contained_ptr _tao_retval = CORBA::Contained::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << search_name)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ContainedSeq * CORBA::Container::contents (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ContainedSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ContainedSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "contents",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << limit_type) &&
          (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ContainedSeq * CORBA::Container::lookup_name (
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ContainedSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ContainedSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_name",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << search_name) &&
          (_tao_out << levels_to_search) &&
          (_tao_out << limit_type) &&
          (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_Container_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65722f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  3, // member count
  17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
    10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  472, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    24, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_Description (CORBA::tk_struct, sizeof (_oc_CORBA_Container_Description), (char *) &_oc_CORBA_Container_Description, 0, sizeof (CORBA::Container::Description));
CORBA::TypeCode_ptr CORBA::Container::_tc_Description = &_tc_TAO_tc_CORBA_Container_Description;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

  void
  CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::Container::Description* tmp = 0;
    tmp = CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::Container::Description *old = ACE_reinterpret_cast (CORBA::Container::Description *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::Container::Description *tmp = ACE_reinterpret_cast (CORBA::Container::Description *,this->buffer_);
    
    CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  CORBA::Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA::Container::DescriptionSeq
// *************************************************************

CORBA::Container::DescriptionSeq::DescriptionSeq (void)
{}
CORBA::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Container::Description *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::Container::DescriptionSeq::~DescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_Container_DescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65722f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/Container/DescriptionSeq:1.0
  15, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = DescriptionSeq
  CORBA::tk_sequence, // typecode kind
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    668, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65722f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
      12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
      3, // member count
      17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
        10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

      5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
      CORBA::tk_enum, // typecode kind
      472, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
        15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
        24, // member count
        8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
        7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
        13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
        12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
        13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
        13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
        10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
        13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
        11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
        9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
        8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
        13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
        12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
        14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
        11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
        9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
        9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
        12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
        15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
        10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native

      6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_DescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_Container_DescriptionSeq), (char *) &_oc_CORBA_Container_DescriptionSeq, 0, sizeof (CORBA::Container::DescriptionSeq));
CORBA::TypeCode_ptr CORBA::Container::_tc_DescriptionSeq = &_tc_TAO_tc_CORBA_Container_DescriptionSeq;

CORBA::Container::DescriptionSeq * CORBA::Container::describe_contents (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Container::DescriptionSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Container::DescriptionSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_contents",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << limit_type) &&
          (_tao_out << CORBA::Any::from_boolean (exclude_inherited)) &&
          (_tao_out << max_returned_objs)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ModuleDef_ptr CORBA::Container::create_module (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ModuleDef_ptr _tao_retval = CORBA::ModuleDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_module",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ConstantDef_ptr CORBA::Container::create_constant (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ConstantDef_ptr _tao_retval = CORBA::ConstantDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_constant",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << value)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::StructDef_ptr CORBA::Container::create_struct (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::StructDef_ptr _tao_retval = CORBA::StructDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_struct",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::UnionDef_ptr CORBA::Container::create_union (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::UnionDef_ptr _tao_retval = CORBA::UnionDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_union",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << discriminator_type) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::EnumDef_ptr CORBA::Container::create_enum (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::EnumDef_ptr _tao_retval = CORBA::EnumDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_enum",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::AliasDef_ptr CORBA::Container::create_alias (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::AliasDef_ptr _tao_retval = CORBA::AliasDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_alias",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << original_type)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::InterfaceDef_ptr CORBA::Container::create_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::InterfaceDef_ptr _tao_retval = CORBA::InterfaceDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_interface",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << base_interfaces)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ValueDef_ptr CORBA::Container::create_value (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    CORBA::InterfaceDef_ptr supported_interface,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ValueDef_ptr _tao_retval = CORBA::ValueDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << CORBA::Any::from_boolean (is_custom)) &&
          (_tao_out << CORBA::Any::from_boolean (is_abstract)) &&
          (_tao_out << base_value) &&
          (_tao_out << CORBA::Any::from_boolean (is_truncatable)) &&
          (_tao_out << abstract_base_values) &&
          (_tao_out << supported_interface) &&
          (_tao_out << initializers)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ValueBoxDef_ptr CORBA::Container::create_value_box (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ValueBoxDef_ptr _tao_retval = CORBA::ValueBoxDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_box",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << original_type_def)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ExceptionDef_ptr CORBA::Container::create_exception (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ExceptionDef_ptr _tao_retval = CORBA::ExceptionDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_exception",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA::Container::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

static const CORBA::Long _oc_CORBA_Container[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x72000000),  // name = Container
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Container (CORBA::tk_objref, sizeof (_oc_CORBA_Container), (char *) &_oc_CORBA_Container, 0, sizeof (CORBA::Container));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Container, &_tc_TAO_tc_CORBA_Container)
TAO_NAMESPACE_END
CORBA::IDLType_ptr CORBA::IDLType::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IDLType::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IDLType:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::IDLType::_nil ());
  if (is_a == 0)
    return CORBA::IDLType::_nil ();
  return CORBA::IDLType::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::IDLType_ptr CORBA::IDLType::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::IDLType::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer != 0)
    {
      CORBA_IDLType_ptr retv = _TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::IDLType(stub);
}

CORBA::IDLType_ptr 
CORBA::IDLType::_duplicate (CORBA::IDLType_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::IDLType::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA::IDLType::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

static const CORBA::Long _oc_CORBA_IDLType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
  8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_IDLType (CORBA::tk_objref, sizeof (_oc_CORBA_IDLType), (char *) &_oc_CORBA_IDLType, 0, sizeof (CORBA::IDLType));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IDLType, &_tc_TAO_tc_CORBA_IDLType)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_PrimitiveKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5072), ACE_NTOHL (0x696d6974), ACE_NTOHL (0x6976654b), ACE_NTOHL (0x696e643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/PrimitiveKind:1.0
  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x654b696e), ACE_NTOHL (0x64000000),  // name = PrimitiveKind
  21, // member count
  8, ACE_NTOHL (0x706b5f6e), ACE_NTOHL (0x756c6c00),  // name = pk_null
  8, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x6f696400),  // name = pk_void
  9, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x686f7274), ACE_NTOHL (0x0),  // name = pk_short
  8, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6700),  // name = pk_long
  10, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x73686f72), ACE_NTOHL (0x74000000),  // name = pk_ushort
  9, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulong
  9, ACE_NTOHL (0x706b5f66), ACE_NTOHL (0x6c6f6174), ACE_NTOHL (0x0),  // name = pk_float
  10, ACE_NTOHL (0x706b5f64), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_double
  11, ACE_NTOHL (0x706b5f62), ACE_NTOHL (0x6f6f6c65), ACE_NTOHL (0x616e0000),  // name = pk_boolean
  8, ACE_NTOHL (0x706b5f63), ACE_NTOHL (0x68617200),  // name = pk_char
  9, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x63746574), ACE_NTOHL (0x0),  // name = pk_octet
  7, ACE_NTOHL (0x706b5f61), ACE_NTOHL (0x6e790000),  // name = pk_any
  12, ACE_NTOHL (0x706b5f54), ACE_NTOHL (0x79706543), ACE_NTOHL (0x6f646500),  // name = pk_TypeCode
  13, ACE_NTOHL (0x706b5f50), ACE_NTOHL (0x72696e63), ACE_NTOHL (0x6970616c), ACE_NTOHL (0x0),  // name = pk_Principal
  10, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = pk_string
  10, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x626a7265), ACE_NTOHL (0x66000000),  // name = pk_objref
  12, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e676c), ACE_NTOHL (0x6f6e6700),  // name = pk_longlong
  13, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulonglong
  14, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6764), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_longdouble
  9, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x63686172), ACE_NTOHL (0x0),  // name = pk_wchar
  11, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = pk_wstring
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_PrimitiveKind (CORBA::tk_enum, sizeof (_oc_CORBA_PrimitiveKind), (char *) &_oc_CORBA_PrimitiveKind, 0, sizeof (CORBA::PrimitiveKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveKind, &_tc_TAO_tc_CORBA_PrimitiveKind)
TAO_NAMESPACE_END
CORBA::Repository_ptr CORBA::Repository::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Repository::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Repository:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::Repository::_nil ());
  if (is_a == 0)
    return CORBA::Repository::_nil ();
  return CORBA::Repository::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::Repository_ptr CORBA::Repository::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::Repository::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer != 0)
    {
      CORBA_Repository_ptr retv = _TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::Repository(stub);
}

CORBA::Repository_ptr 
CORBA::Repository::_duplicate (CORBA::Repository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Contained_ptr CORBA::Repository::lookup_id (
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Contained_ptr _tao_retval = CORBA::Contained::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_id",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << search_id)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::PrimitiveDef_ptr CORBA::Repository::get_primitive (
    CORBA::PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::PrimitiveDef_ptr _tao_retval = CORBA::PrimitiveDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primitive",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << kind)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::StringDef_ptr CORBA::Repository::create_string (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::StringDef_ptr _tao_retval = CORBA::StringDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_string",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::WstringDef_ptr CORBA::Repository::create_wstring (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::WstringDef_ptr _tao_retval = CORBA::WstringDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_wstring",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::SequenceDef_ptr CORBA::Repository::create_sequence (
    CORBA::ULong bound,
    CORBA::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::SequenceDef_ptr _tao_retval = CORBA::SequenceDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_sequence",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound) &&
          (_tao_out << element_type)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ArrayDef_ptr CORBA::Repository::create_array (
    CORBA::ULong length,
    CORBA::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ArrayDef_ptr _tao_retval = CORBA::ArrayDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_array",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << length) &&
          (_tao_out << element_type)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::FixedDef_ptr CORBA::Repository::create_fixed (
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::FixedDef_ptr _tao_retval = CORBA::FixedDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_fixed",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << digits) &&
          (_tao_out << scale)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA::Repository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

static const CORBA::Long _oc_CORBA_Repository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Repository:1.0
  11, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72790000),  // name = Repository
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Repository (CORBA::tk_objref, sizeof (_oc_CORBA_Repository), (char *) &_oc_CORBA_Repository, 0, sizeof (CORBA::Repository));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Repository, &_tc_TAO_tc_CORBA_Repository)
TAO_NAMESPACE_END
CORBA::ModuleDef_ptr CORBA::ModuleDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ModuleDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ModuleDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::ModuleDef::_nil ());
  if (is_a == 0)
    return CORBA::ModuleDef::_nil ();
  return CORBA::ModuleDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::ModuleDef_ptr CORBA::ModuleDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ModuleDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ModuleDef_ptr retv = _TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::ModuleDef(stub);
}

CORBA::ModuleDef_ptr 
CORBA::ModuleDef::_duplicate (CORBA::ModuleDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean CORBA::ModuleDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

static const CORBA::Long _oc_CORBA_ModuleDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4d6f), ACE_NTOHL (0x64756c65), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ModuleDef:1.0
  10, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x66000000),  // name = ModuleDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ModuleDef (CORBA::tk_objref, sizeof (_oc_CORBA_ModuleDef), (char *) &_oc_CORBA_ModuleDef, 0, sizeof (CORBA::ModuleDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDef, &_tc_TAO_tc_CORBA_ModuleDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ModuleDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4d6f), ACE_NTOHL (0x64756c65), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ModuleDescription:1.0
  18, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = ModuleDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ModuleDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ModuleDescription), (char *) &_oc_CORBA_ModuleDescription, 0, sizeof (CORBA::ModuleDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDescription, &_tc_TAO_tc_CORBA_ModuleDescription)
TAO_NAMESPACE_END
CORBA::ConstantDef_ptr CORBA::ConstantDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ConstantDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ConstantDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::ConstantDef::_nil ());
  if (is_a == 0)
    return CORBA::ConstantDef::_nil ();
  return CORBA::ConstantDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::ConstantDef_ptr CORBA::ConstantDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ConstantDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ConstantDef_ptr retv = _TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::ConstantDef(stub);
}

CORBA::ConstantDef_ptr 
CORBA::ConstantDef::_duplicate (CORBA::ConstantDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::ConstantDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::IDLType_ptr CORBA::ConstantDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ConstantDef::type_def (
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Any * CORBA::ConstantDef::value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Any* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ConstantDef::value (
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""value",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << value)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ConstantDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

static const CORBA::Long _oc_CORBA_ConstantDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e737461), ACE_NTOHL (0x6e744465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ConstantDef:1.0
  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44656600),  // name = ConstantDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ConstantDef (CORBA::tk_objref, sizeof (_oc_CORBA_ConstantDef), (char *) &_oc_CORBA_ConstantDef, 0, sizeof (CORBA::ConstantDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDef, &_tc_TAO_tc_CORBA_ConstantDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ConstantDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e737461), ACE_NTOHL (0x6e744465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e3a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ConstantDescription:1.0
  20, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ConstantDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ConstantDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ConstantDescription), (char *) &_oc_CORBA_ConstantDescription, 0, sizeof (CORBA::ConstantDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDescription, &_tc_TAO_tc_CORBA_ConstantDescription)
TAO_NAMESPACE_END
CORBA::TypedefDef_ptr CORBA::TypedefDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::TypedefDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/TypedefDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::TypedefDef::_nil ());
  if (is_a == 0)
    return CORBA::TypedefDef::_nil ();
  return CORBA::TypedefDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::TypedefDef_ptr CORBA::TypedefDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::TypedefDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_TypedefDef_ptr retv = _TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::TypedefDef(stub);
}

CORBA::TypedefDef_ptr 
CORBA::TypedefDef::_duplicate (CORBA::TypedefDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean CORBA::TypedefDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

static const CORBA::Long _oc_CORBA_TypedefDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5479), ACE_NTOHL (0x70656465), ACE_NTOHL (0x66446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/TypedefDef:1.0
  11, ACE_NTOHL (0x54797065), ACE_NTOHL (0x64656644), ACE_NTOHL (0x65660000),  // name = TypedefDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_TypedefDef (CORBA::tk_objref, sizeof (_oc_CORBA_TypedefDef), (char *) &_oc_CORBA_TypedefDef, 0, sizeof (CORBA::TypedefDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypedefDef, &_tc_TAO_tc_CORBA_TypedefDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_TypeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5479), ACE_NTOHL (0x70654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e3a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/TypeDescription:1.0
  16, ACE_NTOHL (0x54797065), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = TypeDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_TypeDescription (CORBA::tk_struct, sizeof (_oc_CORBA_TypeDescription), (char *) &_oc_CORBA_TypeDescription, 0, sizeof (CORBA::TypeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeDescription, &_tc_TAO_tc_CORBA_TypeDescription)
TAO_NAMESPACE_END
CORBA::StructDef_ptr CORBA::StructDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::StructDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/StructDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::StructDef::_nil ());
  if (is_a == 0)
    return CORBA::StructDef::_nil ();
  return CORBA::StructDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::StructDef_ptr CORBA::StructDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::StructDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_StructDef_ptr retv = _TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::StructDef(stub);
}

CORBA::StructDef_ptr 
CORBA::StructDef::_duplicate (CORBA::StructDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::StructMemberSeq * CORBA::StructDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::StructMemberSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::StructMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::StructDef::members (
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::StructDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

static const CORBA::Long _oc_CORBA_StructDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/StructDef:1.0
  10, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744465), ACE_NTOHL (0x66000000),  // name = StructDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StructDef (CORBA::tk_objref, sizeof (_oc_CORBA_StructDef), (char *) &_oc_CORBA_StructDef, 0, sizeof (CORBA::StructDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructDef, &_tc_TAO_tc_CORBA_StructDef)
TAO_NAMESPACE_END
CORBA::UnionDef_ptr CORBA::UnionDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::UnionDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/UnionDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::UnionDef::_nil ());
  if (is_a == 0)
    return CORBA::UnionDef::_nil ();
  return CORBA::UnionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::UnionDef_ptr CORBA::UnionDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::UnionDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_UnionDef_ptr retv = _TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::UnionDef(stub);
}

CORBA::UnionDef_ptr 
CORBA::UnionDef::_duplicate (CORBA::UnionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::UnionDef::discriminator_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""discriminator_type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::IDLType_ptr CORBA::UnionDef::discriminator_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""discriminator_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::UnionDef::discriminator_type_def (
    CORBA::IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""discriminator_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << discriminator_type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::UnionMemberSeq * CORBA::UnionDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::UnionMemberSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::UnionMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::UnionDef::members (
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::UnionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

static const CORBA::Long _oc_CORBA_UnionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/UnionDef:1.0
  9, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = UnionDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionDef (CORBA::tk_objref, sizeof (_oc_CORBA_UnionDef), (char *) &_oc_CORBA_UnionDef, 0, sizeof (CORBA::UnionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionDef, &_tc_TAO_tc_CORBA_UnionDef)
TAO_NAMESPACE_END
CORBA::EnumDef_ptr CORBA::EnumDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::EnumDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/EnumDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::EnumDef::_nil ());
  if (is_a == 0)
    return CORBA::EnumDef::_nil ();
  return CORBA::EnumDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::EnumDef_ptr CORBA::EnumDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::EnumDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_EnumDef_ptr retv = _TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::EnumDef(stub);
}

CORBA::EnumDef_ptr 
CORBA::EnumDef::_duplicate (CORBA::EnumDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::EnumMemberSeq * CORBA::EnumDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::EnumMemberSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::EnumMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::EnumDef::members (
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::EnumDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

static const CORBA::Long _oc_CORBA_EnumDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f456e), ACE_NTOHL (0x756d4465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/EnumDef:1.0
  8, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x44656600),  // name = EnumDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_EnumDef (CORBA::tk_objref, sizeof (_oc_CORBA_EnumDef), (char *) &_oc_CORBA_EnumDef, 0, sizeof (CORBA::EnumDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumDef, &_tc_TAO_tc_CORBA_EnumDef)
TAO_NAMESPACE_END
CORBA::AliasDef_ptr CORBA::AliasDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::AliasDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/AliasDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::AliasDef::_nil ());
  if (is_a == 0)
    return CORBA::AliasDef::_nil ();
  return CORBA::AliasDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::AliasDef_ptr CORBA::AliasDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::AliasDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_AliasDef_ptr retv = _TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::AliasDef(stub);
}

CORBA::AliasDef_ptr 
CORBA::AliasDef::_duplicate (CORBA::AliasDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::IDLType_ptr CORBA::AliasDef::original_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""original_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::AliasDef::original_type_def (
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""original_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << original_type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::AliasDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

static const CORBA::Long _oc_CORBA_AliasDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f416c), ACE_NTOHL (0x69617344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AliasDef:1.0
  9, ACE_NTOHL (0x416c6961), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = AliasDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AliasDef (CORBA::tk_objref, sizeof (_oc_CORBA_AliasDef), (char *) &_oc_CORBA_AliasDef, 0, sizeof (CORBA::AliasDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AliasDef, &_tc_TAO_tc_CORBA_AliasDef)
TAO_NAMESPACE_END
CORBA::PrimitiveDef_ptr CORBA::PrimitiveDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::PrimitiveDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/PrimitiveDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::PrimitiveDef::_nil ());
  if (is_a == 0)
    return CORBA::PrimitiveDef::_nil ();
  return CORBA::PrimitiveDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::PrimitiveDef_ptr CORBA::PrimitiveDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::PrimitiveDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_PrimitiveDef_ptr retv = _TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::PrimitiveDef(stub);
}

CORBA::PrimitiveDef_ptr 
CORBA::PrimitiveDef::_duplicate (CORBA::PrimitiveDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::PrimitiveKind CORBA::PrimitiveDef::kind (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::PrimitiveKind _tao_retval = (CORBA::PrimitiveKind)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""kind",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA::PrimitiveDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

static const CORBA::Long _oc_CORBA_PrimitiveDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5072), ACE_NTOHL (0x696d6974), ACE_NTOHL (0x69766544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/PrimitiveDef:1.0
  13, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = PrimitiveDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_PrimitiveDef (CORBA::tk_objref, sizeof (_oc_CORBA_PrimitiveDef), (char *) &_oc_CORBA_PrimitiveDef, 0, sizeof (CORBA::PrimitiveDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveDef, &_tc_TAO_tc_CORBA_PrimitiveDef)
TAO_NAMESPACE_END
CORBA::StringDef_ptr CORBA::StringDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::StringDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/StringDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::StringDef::_nil ());
  if (is_a == 0)
    return CORBA::StringDef::_nil ();
  return CORBA::StringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::StringDef_ptr CORBA::StringDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::StringDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_StringDef_ptr retv = _TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::StringDef(stub);
}

CORBA::StringDef_ptr 
CORBA::StringDef::_duplicate (CORBA::StringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA::StringDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""bound",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::StringDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""bound",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::StringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

static const CORBA::Long _oc_CORBA_StringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72696e67), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/StringDef:1.0
  10, ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x66000000),  // name = StringDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StringDef (CORBA::tk_objref, sizeof (_oc_CORBA_StringDef), (char *) &_oc_CORBA_StringDef, 0, sizeof (CORBA::StringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StringDef, &_tc_TAO_tc_CORBA_StringDef)
TAO_NAMESPACE_END
CORBA::WstringDef_ptr CORBA::WstringDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::WstringDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/WstringDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::WstringDef::_nil ());
  if (is_a == 0)
    return CORBA::WstringDef::_nil ();
  return CORBA::WstringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::WstringDef_ptr CORBA::WstringDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::WstringDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_WstringDef_ptr retv = _TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::WstringDef(stub);
}

CORBA::WstringDef_ptr 
CORBA::WstringDef::_duplicate (CORBA::WstringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA::WstringDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""bound",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::WstringDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""bound",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::WstringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

static const CORBA::Long _oc_CORBA_WstringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5773), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/WstringDef:1.0
  11, ACE_NTOHL (0x57737472), ACE_NTOHL (0x696e6744), ACE_NTOHL (0x65660000),  // name = WstringDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_WstringDef (CORBA::tk_objref, sizeof (_oc_CORBA_WstringDef), (char *) &_oc_CORBA_WstringDef, 0, sizeof (CORBA::WstringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_WstringDef, &_tc_TAO_tc_CORBA_WstringDef)
TAO_NAMESPACE_END
CORBA::FixedDef_ptr CORBA::FixedDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::FixedDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/FixedDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::FixedDef::_nil ());
  if (is_a == 0)
    return CORBA::FixedDef::_nil ();
  return CORBA::FixedDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::FixedDef_ptr CORBA::FixedDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::FixedDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_FixedDef_ptr retv = _TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::FixedDef(stub);
}

CORBA::FixedDef_ptr 
CORBA::FixedDef::_duplicate (CORBA::FixedDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::UShort CORBA::FixedDef::digits (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::UShort _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""digits",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::FixedDef::digits (
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""digits",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << digits)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Short CORBA::FixedDef::scale (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Short _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""scale",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::FixedDef::scale (
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""scale",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << scale)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::FixedDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/FixedDef:1.0";
}

static const CORBA::Long _oc_CORBA_FixedDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4669), ACE_NTOHL (0x78656444), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/FixedDef:1.0
  9, ACE_NTOHL (0x46697865), ACE_NTOHL (0x64446566), ACE_NTOHL (0x0),  // name = FixedDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_FixedDef (CORBA::tk_objref, sizeof (_oc_CORBA_FixedDef), (char *) &_oc_CORBA_FixedDef, 0, sizeof (CORBA::FixedDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FixedDef, &_tc_TAO_tc_CORBA_FixedDef)
TAO_NAMESPACE_END
CORBA::SequenceDef_ptr CORBA::SequenceDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::SequenceDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/SequenceDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::SequenceDef::_nil ());
  if (is_a == 0)
    return CORBA::SequenceDef::_nil ();
  return CORBA::SequenceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::SequenceDef_ptr CORBA::SequenceDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::SequenceDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_SequenceDef_ptr retv = _TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::SequenceDef(stub);
}

CORBA::SequenceDef_ptr 
CORBA::SequenceDef::_duplicate (CORBA::SequenceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA::SequenceDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""bound",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::SequenceDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""bound",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::TypeCode_ptr CORBA::SequenceDef::element_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::IDLType_ptr CORBA::SequenceDef::element_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::SequenceDef::element_type_def (
    CORBA::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""element_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << element_type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::SequenceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

static const CORBA::Long _oc_CORBA_SequenceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5365), ACE_NTOHL (0x7175656e), ACE_NTOHL (0x63654465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/SequenceDef:1.0
  12, ACE_NTOHL (0x53657175), ACE_NTOHL (0x656e6365), ACE_NTOHL (0x44656600),  // name = SequenceDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_SequenceDef (CORBA::tk_objref, sizeof (_oc_CORBA_SequenceDef), (char *) &_oc_CORBA_SequenceDef, 0, sizeof (CORBA::SequenceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SequenceDef, &_tc_TAO_tc_CORBA_SequenceDef)
TAO_NAMESPACE_END
CORBA::ArrayDef_ptr CORBA::ArrayDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ArrayDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ArrayDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::ArrayDef::_nil ());
  if (is_a == 0)
    return CORBA::ArrayDef::_nil ();
  return CORBA::ArrayDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::ArrayDef_ptr CORBA::ArrayDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ArrayDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ArrayDef_ptr retv = _TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::ArrayDef(stub);
}

CORBA::ArrayDef_ptr 
CORBA::ArrayDef::_duplicate (CORBA::ArrayDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA::ArrayDef::length (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""length",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ArrayDef::length (
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""length",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << length)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::TypeCode_ptr CORBA::ArrayDef::element_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::IDLType_ptr CORBA::ArrayDef::element_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ArrayDef::element_type_def (
    CORBA::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""element_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << element_type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ArrayDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

static const CORBA::Long _oc_CORBA_ArrayDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4172), ACE_NTOHL (0x72617944), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ArrayDef:1.0
  9, ACE_NTOHL (0x41727261), ACE_NTOHL (0x79446566), ACE_NTOHL (0x0),  // name = ArrayDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ArrayDef (CORBA::tk_objref, sizeof (_oc_CORBA_ArrayDef), (char *) &_oc_CORBA_ArrayDef, 0, sizeof (CORBA::ArrayDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ArrayDef, &_tc_TAO_tc_CORBA_ArrayDef)
TAO_NAMESPACE_END
CORBA::ExceptionDef_ptr CORBA::ExceptionDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ExceptionDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ExceptionDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::ExceptionDef::_nil ());
  if (is_a == 0)
    return CORBA::ExceptionDef::_nil ();
  return CORBA::ExceptionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::ExceptionDef_ptr CORBA::ExceptionDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ExceptionDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ExceptionDef_ptr retv = _TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::ExceptionDef(stub);
}

CORBA::ExceptionDef_ptr 
CORBA::ExceptionDef::_duplicate (CORBA::ExceptionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::ExceptionDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::StructMemberSeq * CORBA::ExceptionDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::StructMemberSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::StructMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ExceptionDef::members (
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ExceptionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

static const CORBA::Long _oc_CORBA_ExceptionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDef:1.0
  13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDef (CORBA::tk_objref, sizeof (_oc_CORBA_ExceptionDef), (char *) &_oc_CORBA_ExceptionDef, 0, sizeof (CORBA::ExceptionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDef, &_tc_TAO_tc_CORBA_ExceptionDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ExceptionDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
  21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ExceptionDescription), (char *) &_oc_CORBA_ExceptionDescription, 0, sizeof (CORBA::ExceptionDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDescription, &_tc_TAO_tc_CORBA_ExceptionDescription)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_AttributeMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
  14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
  2, // member count
  12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
  14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeMode (CORBA::tk_enum, sizeof (_oc_CORBA_AttributeMode), (char *) &_oc_CORBA_AttributeMode, 0, sizeof (CORBA::AttributeMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeMode, &_tc_TAO_tc_CORBA_AttributeMode)
TAO_NAMESPACE_END
CORBA::AttributeDef_ptr CORBA::AttributeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::AttributeDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/AttributeDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::AttributeDef::_nil ());
  if (is_a == 0)
    return CORBA::AttributeDef::_nil ();
  return CORBA::AttributeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::AttributeDef_ptr CORBA::AttributeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::AttributeDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_AttributeDef_ptr retv = _TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::AttributeDef(stub);
}

CORBA::AttributeDef_ptr 
CORBA::AttributeDef::_duplicate (CORBA::AttributeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::AttributeDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::IDLType_ptr CORBA::AttributeDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::AttributeDef::type_def (
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::AttributeMode CORBA::AttributeDef::mode (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::AttributeMode _tao_retval = (CORBA::AttributeMode)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""mode",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::AttributeDef::mode (
    CORBA::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""mode",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << mode)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::AttributeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

static const CORBA::Long _oc_CORBA_AttributeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDef:1.0
  13, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = AttributeDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeDef (CORBA::tk_objref, sizeof (_oc_CORBA_AttributeDef), (char *) &_oc_CORBA_AttributeDef, 0, sizeof (CORBA::AttributeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDef, &_tc_TAO_tc_CORBA_AttributeDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_AttributeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
  21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  104, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
    14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
    2, // member count
    12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
    14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeDescription (CORBA::tk_struct, sizeof (_oc_CORBA_AttributeDescription), (char *) &_oc_CORBA_AttributeDescription, 0, sizeof (CORBA::AttributeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDescription, &_tc_TAO_tc_CORBA_AttributeDescription)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_OperationMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
  14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
  2, // member count
  10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
  10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationMode (CORBA::tk_enum, sizeof (_oc_CORBA_OperationMode), (char *) &_oc_CORBA_OperationMode, 0, sizeof (CORBA::OperationMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationMode, &_tc_TAO_tc_CORBA_OperationMode)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ParameterMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
  14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
  3, // member count
  9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
  10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
  12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ParameterMode (CORBA::tk_enum, sizeof (_oc_CORBA_ParameterMode), (char *) &_oc_CORBA_ParameterMode, 0, sizeof (CORBA::ParameterMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterMode, &_tc_TAO_tc_CORBA_ParameterMode)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ParameterDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
  21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  116, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
    14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
    3, // member count
    9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
    10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
    12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ParameterDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ParameterDescription), (char *) &_oc_CORBA_ParameterDescription, 0, sizeof (CORBA::ParameterDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterDescription, &_tc_TAO_tc_CORBA_ParameterDescription)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::ParameterDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::ParameterDescription *old = ACE_reinterpret_cast (CORBA::ParameterDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::ParameterDescription *tmp = ACE_reinterpret_cast (CORBA::ParameterDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_PARDESCRIPTIONSEQ_CS_)
#define _CORBA_PARDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA::ParDescriptionSeq
// *************************************************************

CORBA::ParDescriptionSeq::CORBA_ParDescriptionSeq (void)
{}
CORBA::ParDescriptionSeq::CORBA_ParDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::ParDescriptionSeq::CORBA_ParDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA::ParameterDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::ParDescriptionSeq::CORBA_ParDescriptionSeq (const CORBA_ParDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::ParDescriptionSeq::~CORBA_ParDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ParDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
  18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  416, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    400, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
      21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      116, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
        14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
        3, // member count
        9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
        10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
        12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ParDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ParDescriptionSeq), (char *) &_oc_CORBA_ParDescriptionSeq, 0, sizeof (CORBA::ParDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParDescriptionSeq, &_tc_TAO_tc_CORBA_ParDescriptionSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ContextIdentifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
  18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ContextIdentifier (CORBA::tk_alias, sizeof (_oc_CORBA_ContextIdentifier), (char *) &_oc_CORBA_ContextIdentifier, 0, sizeof (CORBA::ContextIdentifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdentifier, &_tc_TAO_tc_CORBA_ContextIdentifier)
TAO_NAMESPACE_END

#if !defined (_CORBA_CONTEXTIDSEQ_CS_)
#define _CORBA_CONTEXTIDSEQ_CS_

// *************************************************************
// CORBA::ContextIdSeq
// *************************************************************

CORBA::ContextIdSeq::CORBA_ContextIdSeq (void)
{}
CORBA::ContextIdSeq::CORBA_ContextIdSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::ContextIdSeq::CORBA_ContextIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::ContextIdSeq::CORBA_ContextIdSeq (const CORBA_ContextIdSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::ContextIdSeq::~CORBA_ContextIdSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ContextIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
  CORBA::tk_sequence, // typecode kind
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    148, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
      18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ContextIdSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ContextIdSeq), (char *) &_oc_CORBA_ContextIdSeq, 0, sizeof (CORBA::ContextIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdSeq, &_tc_TAO_tc_CORBA_ContextIdSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::ExceptionDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::ExceptionDef **old = ACE_reinterpret_cast (CORBA::ExceptionDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA::ExceptionDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA::ExceptionDef **tmp = ACE_reinterpret_cast (CORBA::ExceptionDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::ExceptionDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA::ExceptionDef **tmp = ACE_reinterpret_cast (CORBA::ExceptionDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA::ExceptionDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA::ExceptionDef **tmp = ACE_static_cast (CORBA::ExceptionDef**, target);
    *tmp = CORBA::ExceptionDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_upcast (void *src) const
  {
    CORBA::ExceptionDef **tmp = ACE_static_cast (CORBA::ExceptionDef**, src);
    return *tmp;
  }
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_EXCEPTIONDEFSEQ_CS_)
#define _CORBA_EXCEPTIONDEFSEQ_CS_

// *************************************************************
// CORBA::ExceptionDefSeq
// *************************************************************

CORBA::ExceptionDefSeq::CORBA_ExceptionDefSeq (void)
{}
CORBA::ExceptionDefSeq::CORBA_ExceptionDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::ExceptionDef,CORBA::ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::ExceptionDefSeq::CORBA_ExceptionDefSeq (CORBA::ULong max, CORBA::ULong length, CORBA::ExceptionDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::ExceptionDef,CORBA::ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::ExceptionDefSeq::CORBA_ExceptionDefSeq (const CORBA_ExceptionDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA::ExceptionDef,CORBA::ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::ExceptionDefSeq::~CORBA_ExceptionDefSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ExceptionDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExceptionDefSeq:1.0
  16, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x53657100),  // name = ExceptionDefSeq
  CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDef:1.0
      13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDefSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ExceptionDefSeq), (char *) &_oc_CORBA_ExceptionDefSeq, 0, sizeof (CORBA::ExceptionDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDefSeq, &_tc_TAO_tc_CORBA_ExceptionDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::ExceptionDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::ExceptionDescription *old = ACE_reinterpret_cast (CORBA::ExceptionDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::ExceptionDescription *tmp = ACE_reinterpret_cast (CORBA::ExceptionDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_EXCDESCRIPTIONSEQ_CS_)
#define _CORBA_EXCDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA::ExcDescriptionSeq
// *************************************************************

CORBA::ExcDescriptionSeq::CORBA_ExcDescriptionSeq (void)
{}
CORBA::ExcDescriptionSeq::CORBA_ExcDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::ExcDescriptionSeq::CORBA_ExcDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA::ExceptionDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::ExcDescriptionSeq::CORBA_ExcDescriptionSeq (const CORBA_ExcDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::ExcDescriptionSeq::~CORBA_ExcDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ExcDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
  18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  476, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    460, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
      21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
      5, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExcDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ExcDescriptionSeq), (char *) &_oc_CORBA_ExcDescriptionSeq, 0, sizeof (CORBA::ExcDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExcDescriptionSeq, &_tc_TAO_tc_CORBA_ExcDescriptionSeq)
TAO_NAMESPACE_END
CORBA::OperationDef_ptr CORBA::OperationDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::OperationDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/OperationDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::OperationDef::_nil ());
  if (is_a == 0)
    return CORBA::OperationDef::_nil ();
  return CORBA::OperationDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::OperationDef_ptr CORBA::OperationDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::OperationDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_OperationDef_ptr retv = _TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::OperationDef(stub);
}

CORBA::OperationDef_ptr 
CORBA::OperationDef::_duplicate (CORBA::OperationDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::OperationDef::result (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""result",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::IDLType_ptr CORBA::OperationDef::result_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""result_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::OperationDef::result_def (
    CORBA::IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""result_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << result_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::ParDescriptionSeq * CORBA::OperationDef::params (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ParDescriptionSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ParDescriptionSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""params",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::OperationDef::params (
    const CORBA::ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""params",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << params)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::OperationMode CORBA::OperationDef::mode (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::OperationMode _tao_retval = (CORBA::OperationMode)0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""mode",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::OperationDef::mode (
    CORBA::OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""mode",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << mode)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::ContextIdSeq * CORBA::OperationDef::contexts (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ContextIdSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ContextIdSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""contexts",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::OperationDef::contexts (
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""contexts",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << contexts)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::ExceptionDefSeq * CORBA::OperationDef::exceptions (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ExceptionDefSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ExceptionDefSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""exceptions",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::OperationDef::exceptions (
    const CORBA::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""exceptions",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << exceptions)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::OperationDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

static const CORBA::Long _oc_CORBA_OperationDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDef:1.0
  13, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = OperationDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationDef (CORBA::tk_objref, sizeof (_oc_CORBA_OperationDef), (char *) &_oc_CORBA_OperationDef, 0, sizeof (CORBA::OperationDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDef, &_tc_TAO_tc_CORBA_OperationDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_OperationDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
  21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
  9, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  100, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
    14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
    2, // member count
    10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
    10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

  9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
  CORBA::tk_alias, // typecode kind for typedefs
  236, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
    13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
    CORBA::tk_sequence, // typecode kind
    164, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      148, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
        18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      0U,


  11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
  CORBA::tk_alias, // typecode kind for typedefs
  496, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
    18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    416, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      400, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
        21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
        4, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        116, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
          14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
          3, // member count
          9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
          10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
          12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


      0U,


  11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  556, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    476, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      460, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationDescription (CORBA::tk_struct, sizeof (_oc_CORBA_OperationDescription), (char *) &_oc_CORBA_OperationDescription, 0, sizeof (CORBA::OperationDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDescription, &_tc_TAO_tc_CORBA_OperationDescription)
TAO_NAMESPACE_END

#if !defined (_CORBA_REPOSITORYIDSEQ_CS_)
#define _CORBA_REPOSITORYIDSEQ_CS_

// *************************************************************
// CORBA::RepositoryIdSeq
// *************************************************************

CORBA::RepositoryIdSeq::CORBA_RepositoryIdSeq (void)
{}
CORBA::RepositoryIdSeq::CORBA_RepositoryIdSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::RepositoryIdSeq::CORBA_RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::RepositoryIdSeq::CORBA_RepositoryIdSeq (const CORBA_RepositoryIdSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::RepositoryIdSeq::~CORBA_RepositoryIdSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_RepositoryIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
  16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
  CORBA::tk_sequence, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_RepositoryIdSeq (CORBA::tk_alias, sizeof (_oc_CORBA_RepositoryIdSeq), (char *) &_oc_CORBA_RepositoryIdSeq, 0, sizeof (CORBA::RepositoryIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_CORBA_RepositoryIdSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::OperationDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::OperationDescription *old = ACE_reinterpret_cast (CORBA::OperationDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::OperationDescription *tmp = ACE_reinterpret_cast (CORBA::OperationDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_OPDESCRIPTIONSEQ_CS_)
#define _CORBA_OPDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA::OpDescriptionSeq
// *************************************************************

CORBA::OpDescriptionSeq::CORBA_OpDescriptionSeq (void)
{}
CORBA::OpDescriptionSeq::CORBA_OpDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::OpDescriptionSeq::CORBA_OpDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA::OperationDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::OpDescriptionSeq::CORBA_OpDescriptionSeq (const CORBA_OpDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::OpDescriptionSeq::~CORBA_OpDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_OpDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
  17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  1956, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    1940, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
      21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
      9, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      100, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
        14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
        2, // member count
        10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
        10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

      9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
      CORBA::tk_alias, // typecode kind for typedefs
      236, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
        13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
        CORBA::tk_sequence, // typecode kind
        164, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_alias, // typecode kind for typedefs
          148, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
            18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length


          0U,


      11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
      CORBA::tk_alias, // typecode kind for typedefs
      496, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
        18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        416, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          400, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
            21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
            4, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            52, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

            5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
            116, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
              14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
              3, // member count
              9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
              10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
              12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


          0U,


      11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      556, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        476, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          460, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            72, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            72, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OpDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_OpDescriptionSeq), (char *) &_oc_CORBA_OpDescriptionSeq, 0, sizeof (CORBA::OpDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OpDescriptionSeq, &_tc_TAO_tc_CORBA_OpDescriptionSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::AttributeDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::AttributeDescription *old = ACE_reinterpret_cast (CORBA::AttributeDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::AttributeDescription *tmp = ACE_reinterpret_cast (CORBA::AttributeDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_ATTRDESCRIPTIONSEQ_CS_)
#define _CORBA_ATTRDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA::AttrDescriptionSeq
// *************************************************************

CORBA::AttrDescriptionSeq::CORBA_AttrDescriptionSeq (void)
{}
CORBA::AttrDescriptionSeq::CORBA_AttrDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::AttrDescriptionSeq::CORBA_AttrDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA::AttributeDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::AttrDescriptionSeq::CORBA_AttrDescriptionSeq (const CORBA_AttrDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::AttrDescriptionSeq::~CORBA_AttrDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_AttrDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
  19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  600, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    584, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
      21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
      6, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      104, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
        14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
        2, // member count
        12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
        14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttrDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_AttrDescriptionSeq), (char *) &_oc_CORBA_AttrDescriptionSeq, 0, sizeof (CORBA::AttrDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttrDescriptionSeq, &_tc_TAO_tc_CORBA_AttrDescriptionSeq)
TAO_NAMESPACE_END
CORBA::InterfaceDef_ptr CORBA::InterfaceDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::InterfaceDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/InterfaceDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::InterfaceDef::_nil ());
  if (is_a == 0)
    return CORBA::InterfaceDef::_nil ();
  return CORBA::InterfaceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::InterfaceDef_ptr CORBA::InterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::InterfaceDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_InterfaceDef_ptr retv = _TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::InterfaceDef(stub);
}

CORBA::InterfaceDef_ptr 
CORBA::InterfaceDef::_duplicate (CORBA::InterfaceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::InterfaceDefSeq * CORBA::InterfaceDef::base_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::InterfaceDefSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::InterfaceDefSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""base_interfaces",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::InterfaceDef::base_interfaces (
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""base_interfaces",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << base_interfaces)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::InterfaceDef::is_a (
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << interface_id)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_InterfaceDef_FullInterfaceDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  60, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65662f46), ACE_NTOHL (0x756c6c49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef/FullInterfaceDescription:1.0
  25, ACE_NTOHL (0x46756c6c), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = FullInterfaceDescription
  9, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2036, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1956, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1940, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          164, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            148, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        496, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          416, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            400, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      584, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        6, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


      0U,


  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription (CORBA::tk_struct, sizeof (_oc_CORBA_InterfaceDef_FullInterfaceDescription), (char *) &_oc_CORBA_InterfaceDef_FullInterfaceDescription, 0, sizeof (CORBA::InterfaceDef::FullInterfaceDescription));
CORBA::TypeCode_ptr CORBA::InterfaceDef::_tc_FullInterfaceDescription = &_tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription;

CORBA::InterfaceDef::FullInterfaceDescription * CORBA::InterfaceDef::describe_interface (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::InterfaceDef::FullInterfaceDescription* _tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::InterfaceDef::FullInterfaceDescription, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_interface",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::AttributeDef_ptr CORBA::InterfaceDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::AttributeDef_ptr _tao_retval = CORBA::AttributeDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << mode)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::OperationDef_ptr CORBA::InterfaceDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::OperationDef_ptr _tao_retval = CORBA::OperationDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << result) &&
          (_tao_out << mode) &&
          (_tao_out << params) &&
          (_tao_out << exceptions) &&
          (_tao_out << contexts)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA::InterfaceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

static const CORBA::Long _oc_CORBA_InterfaceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
  13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDef (CORBA::tk_objref, sizeof (_oc_CORBA_InterfaceDef), (char *) &_oc_CORBA_InterfaceDef, 0, sizeof (CORBA::InterfaceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDef, &_tc_TAO_tc_CORBA_InterfaceDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_InterfaceDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDescription:1.0
  21, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = InterfaceDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDescription (CORBA::tk_struct, sizeof (_oc_CORBA_InterfaceDescription), (char *) &_oc_CORBA_InterfaceDescription, 0, sizeof (CORBA::InterfaceDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDescription, &_tc_TAO_tc_CORBA_InterfaceDescription)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_Visibility[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
  11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Visibility (CORBA::tk_alias, sizeof (_oc_CORBA_Visibility), (char *) &_oc_CORBA_Visibility, 0, sizeof (CORBA::Visibility));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Visibility, &_tc_TAO_tc_CORBA_Visibility)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, PRIVATE_MEMBER, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, PUBLIC_MEMBER, 1)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ValueMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
  7, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

  7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
    11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
    CORBA::tk_short,


};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMember (CORBA::tk_struct, sizeof (_oc_CORBA_ValueMember), (char *) &_oc_CORBA_ValueMember, 0, sizeof (CORBA::ValueMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMember, &_tc_TAO_tc_CORBA_ValueMember)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::ValueMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::ValueMember *old = ACE_reinterpret_cast (CORBA::ValueMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::ValueMember *tmp = ACE_reinterpret_cast (CORBA::ValueMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::~_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_CORBA_VALUEMEMBERSEQ_CS_)
#define _CORBA_VALUEMEMBERSEQ_CS_

// *************************************************************
// CORBA::ValueMemberSeq
// *************************************************************

CORBA::ValueMemberSeq::CORBA_ValueMemberSeq (void)
{}
CORBA::ValueMemberSeq::CORBA_ValueMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
CORBA::ValueMemberSeq::CORBA_ValueMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA::ValueMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
CORBA::ValueMemberSeq::CORBA_ValueMemberSeq (const CORBA_ValueMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
CORBA::ValueMemberSeq::~CORBA_ValueMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ValueMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberSeq:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
  CORBA::tk_sequence, // typecode kind
  616, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
      12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
      7, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

      7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
        11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
        CORBA::tk_short,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ValueMemberSeq), (char *) &_oc_CORBA_ValueMemberSeq, 0, sizeof (CORBA::ValueMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberSeq, &_tc_TAO_tc_CORBA_ValueMemberSeq)
TAO_NAMESPACE_END
CORBA::ValueMemberDef_ptr CORBA::ValueMemberDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ValueMemberDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ValueMemberDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::ValueMemberDef::_nil ());
  if (is_a == 0)
    return CORBA::ValueMemberDef::_nil ();
  return CORBA::ValueMemberDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::ValueMemberDef_ptr CORBA::ValueMemberDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ValueMemberDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ValueMemberDef_ptr retv = _TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::ValueMemberDef(stub);
}

CORBA::ValueMemberDef_ptr 
CORBA::ValueMemberDef::_duplicate (CORBA::ValueMemberDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA::ValueMemberDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::IDLType_ptr CORBA::ValueMemberDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueMemberDef::type_def (
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Visibility CORBA::ValueMemberDef::access (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Visibility _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""access",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueMemberDef::access (
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""access",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << access)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ValueMemberDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueMemberDef:1.0";
}

static const CORBA::Long _oc_CORBA_ValueMemberDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberDef:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657244), ACE_NTOHL (0x65660000),  // name = ValueMemberDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMemberDef (CORBA::tk_objref, sizeof (_oc_CORBA_ValueMemberDef), (char *) &_oc_CORBA_ValueMemberDef, 0, sizeof (CORBA::ValueMemberDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberDef, &_tc_TAO_tc_CORBA_ValueMemberDef)
TAO_NAMESPACE_END
CORBA::ValueDef_ptr CORBA::ValueDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ValueDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ValueDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::ValueDef::_nil ());
  if (is_a == 0)
    return CORBA::ValueDef::_nil ();
  return CORBA::ValueDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::ValueDef_ptr CORBA::ValueDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ValueDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ValueDef_ptr retv = _TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::ValueDef(stub);
}

CORBA::ValueDef_ptr 
CORBA::ValueDef::_duplicate (CORBA::ValueDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::InterfaceDef_ptr CORBA::ValueDef::supported_interface (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::InterfaceDef_ptr _tao_retval = CORBA::InterfaceDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""supported_interface",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueDef::supported_interface (
    CORBA::InterfaceDef_ptr supported_interface,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""supported_interface",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << supported_interface)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::InitializerSeq * CORBA::ValueDef::initializers (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::InitializerSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::InitializerSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""initializers",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueDef::initializers (
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""initializers",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << initializers)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::ValueDef_ptr CORBA::ValueDef::base_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ValueDef_ptr _tao_retval = CORBA::ValueDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""base_value",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueDef::base_value (
    CORBA::ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""base_value",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << base_value)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::ValueDefSeq * CORBA::ValueDef::abstract_base_values (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ValueDefSeq* _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ValueDefSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""abstract_base_values",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueDef::abstract_base_values (
    const CORBA::ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""abstract_base_values",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << abstract_base_values)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ValueDef::is_abstract (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_abstract",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueDef::is_abstract (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""is_abstract",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << CORBA::Any::from_boolean (is_abstract))
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ValueDef::is_custom (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_custom",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueDef::is_custom (
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""is_custom",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << CORBA::Any::from_boolean (is_custom))
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ValueDef::is_truncatable (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_truncatable",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueDef::is_truncatable (
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""is_truncatable",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << CORBA::Any::from_boolean (is_truncatable))
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ValueDef::is_a (
    const char * value_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << value_id)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_ValueDef_FullValueDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65662f46), ACE_NTOHL (0x756c6c56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ValueDef/FullValueDescription:1.0
  21, ACE_NTOHL (0x46756c6c), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = FullValueDescription
  15, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2036, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1956, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1940, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          164, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            148, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        496, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          416, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            400, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      584, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        6, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


      0U,


  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  692, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberSeq:1.0
    15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
    CORBA::tk_sequence, // typecode kind
    616, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      600, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
        12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
        7, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

        7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
          11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
          CORBA::tk_short,



      0U,


  13, ACE_NTOHL (0x696e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657273), ACE_NTOHL (0x0),  // name = initializers
  CORBA::tk_alias, // typecode kind for typedefs
  516, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InitializerSeq:1.0
    15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
    CORBA::tk_sequence, // typecode kind
    440, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      424, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
        12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
        1, // member count
        8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
        CORBA::tk_alias, // typecode kind for typedefs
        340, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
          16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
          CORBA::tk_sequence, // typecode kind
          264, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            248, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
              13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
              3, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


            0U,



      0U,


  21, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636573), ACE_NTOHL (0x0),  // name = supported_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDef_FullValueDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ValueDef_FullValueDescription), (char *) &_oc_CORBA_ValueDef_FullValueDescription, 0, sizeof (CORBA::ValueDef::FullValueDescription));
CORBA::TypeCode_ptr CORBA::ValueDef::_tc_FullValueDescription = &_tc_TAO_tc_CORBA_ValueDef_FullValueDescription;

CORBA::ValueDef::FullValueDescription * CORBA::ValueDef::describe_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ValueDef::FullValueDescription* _tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::ValueDef::FullValueDescription, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_value",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::ValueMemberDef_ptr CORBA::ValueDef::create_value_member (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ValueMemberDef_ptr _tao_retval = CORBA::ValueMemberDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_member",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << access)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::AttributeDef_ptr CORBA::ValueDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::AttributeDef_ptr _tao_retval = CORBA::AttributeDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << mode)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::OperationDef_ptr CORBA::ValueDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::OperationDef_ptr _tao_retval = CORBA::OperationDef::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << result) &&
          (_tao_out << mode) &&
          (_tao_out << params) &&
          (_tao_out << exceptions) &&
          (_tao_out << contexts)
      ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA::ValueDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueDef:1.0";
}

static const CORBA::Long _oc_CORBA_ValueDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
  9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDef (CORBA::tk_objref, sizeof (_oc_CORBA_ValueDef), (char *) &_oc_CORBA_ValueDef, 0, sizeof (CORBA::ValueDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDef, &_tc_TAO_tc_CORBA_ValueDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ValueDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDescription:1.0
  17, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ValueDescription
  10, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  20, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636500),  // name = supported_interface
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ValueDescription), (char *) &_oc_CORBA_ValueDescription, 0, sizeof (CORBA::ValueDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDescription, &_tc_TAO_tc_CORBA_ValueDescription)
TAO_NAMESPACE_END
CORBA::ValueBoxDef_ptr CORBA::ValueBoxDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ValueBoxDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ValueBoxDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA::ValueBoxDef::_nil ());
  if (is_a == 0)
    return CORBA::ValueBoxDef::_nil ();
  return CORBA::ValueBoxDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA::ValueBoxDef_ptr CORBA::ValueBoxDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA::ValueBoxDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ValueBoxDef_ptr retv = _TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }
  return new CORBA::ValueBoxDef(stub);
}

CORBA::ValueBoxDef_ptr 
CORBA::ValueBoxDef::_duplicate (CORBA::ValueBoxDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::IDLType_ptr CORBA::ValueBoxDef::original_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::IDLType_ptr _tao_retval = CORBA::IDLType::_nil ();
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""original_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;
    
  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA::ValueBoxDef::original_type_def (
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""original_type_def",
      istub->orb_core ()
    );
  

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << original_type_def)
      ))
      ACE_THROW (CORBA::MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;
    
  }
  
}

CORBA::Boolean CORBA::ValueBoxDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueBoxDef:1.0";
}

static const CORBA::Long _oc_CORBA_ValueBoxDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756542), ACE_NTOHL (0x6f784465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueBoxDef:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65426f78), ACE_NTOHL (0x44656600),  // name = ValueBoxDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueBoxDef (CORBA::tk_objref, sizeof (_oc_CORBA_ValueBoxDef), (char *) &_oc_CORBA_ValueBoxDef, 0, sizeof (CORBA::ValueBoxDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueBoxDef, &_tc_TAO_tc_CORBA_ValueBoxDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ValueModifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x6f646966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ValueModifier:1.0
  14, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ValueModifier
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueModifier (CORBA::tk_alias, sizeof (_oc_CORBA_ValueModifier), (char *) &_oc_CORBA_ValueModifier, 0, sizeof (CORBA::ValueModifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueModifier, &_tc_TAO_tc_CORBA_ValueModifier)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_NONE, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_CUSTOM, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_ABSTRACT, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_TRUNCATABLE, 3)
TAO_NAMESPACE_END
void operator<<= (CORBA::Any &_tao_any, CORBA::DefinitionKind _tao_elem)
{
  CORBA::DefinitionKind *_any_val;
  ACE_NEW (_any_val, CORBA::DefinitionKind (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_DefinitionKind, _any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::DefinitionKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_DefinitionKind, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    if (stream.decode (CORBA::_tc_DefinitionKind, &_tao_elem, 0, ACE_TRY_ENV)
      == CORBA::TypeCode::TRAVERSE_CONTINUE)
      return 1;
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::IRObject_ptr (*_TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::IRObject_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::IRObject::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_IRObject, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IRObject_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IRObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_IRObject, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_IRObject, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::IRObject::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_IRObject, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::IRObject,CORBA::IRObject_var>;
template class TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::IRObject,CORBA::IRObject_var>
#  pragma instantiate TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Contained_ptr (*_TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::Contained_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::Contained::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_Contained, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Contained_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Contained::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_Contained, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_Contained, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::Contained::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_Contained, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::Contained,CORBA::Contained_var>;
template class TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::Contained,CORBA::Contained_var>
#  pragma instantiate TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::Contained::Description &_tao_elem) // copying
{
  CORBA::Contained::Description *_any_val;
  ACE_NEW (_any_val, CORBA::Contained::Description (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::Contained::_tc_Description, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Contained::Description *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::Contained::_tc_Description, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Contained::Description *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::Contained::_tc_Description, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Contained::Description *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Contained::Description, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::Contained::_tc_Description, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::Contained::_tc_Description, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InterfaceDefSeq &_tao_elem
  ) // copying
{
  CORBA::InterfaceDefSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::InterfaceDefSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_InterfaceDefSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDefSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_InterfaceDefSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_InterfaceDefSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDefSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_InterfaceDefSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_InterfaceDefSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueDefSeq &_tao_elem
  ) // copying
{
  CORBA::ValueDefSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ValueDefSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueDefSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDefSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueDefSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ValueDefSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDefSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ValueDefSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ValueDefSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ContainedSeq &_tao_elem
  ) // copying
{
  CORBA::ContainedSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ContainedSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ContainedSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ContainedSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ContainedSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ContainedSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ContainedSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ContainedSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ContainedSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ContainedSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ContainedSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::StructMember &_tao_elem) // copying
{
  CORBA::StructMember *_any_val;
  ACE_NEW (_any_val, CORBA::StructMember (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_StructMember, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::StructMember *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_StructMember, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_StructMember, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::StructMember *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::StructMember, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_StructMember, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_StructMember, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::StructMemberSeq &_tao_elem
  ) // copying
{
  CORBA::StructMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::StructMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_StructMemberSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::StructMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_StructMemberSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_StructMemberSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::StructMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::StructMemberSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_StructMemberSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_StructMemberSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::Initializer &_tao_elem) // copying
{
  CORBA::Initializer *_any_val;
  ACE_NEW (_any_val, CORBA::Initializer (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_Initializer, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Initializer *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_Initializer, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Initializer *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_Initializer, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Initializer *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Initializer, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_Initializer, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_Initializer, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InitializerSeq &_tao_elem
  ) // copying
{
  CORBA::InitializerSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::InitializerSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_InitializerSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InitializerSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_InitializerSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InitializerSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_InitializerSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InitializerSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InitializerSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_InitializerSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_InitializerSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::UnionMember &_tao_elem) // copying
{
  CORBA::UnionMember *_any_val;
  ACE_NEW (_any_val, CORBA::UnionMember (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_UnionMember, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::UnionMember *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_UnionMember, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_UnionMember, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::UnionMember *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::UnionMember, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_UnionMember, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_UnionMember, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::UnionMemberSeq &_tao_elem
  ) // copying
{
  CORBA::UnionMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::UnionMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_UnionMemberSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::UnionMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_UnionMemberSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_UnionMemberSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::UnionMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::UnionMemberSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_UnionMemberSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_UnionMemberSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::EnumMemberSeq &_tao_elem
  ) // copying
{
  CORBA::EnumMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::EnumMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_EnumMemberSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::EnumMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_EnumMemberSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::EnumMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_EnumMemberSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::EnumMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::EnumMemberSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_EnumMemberSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_EnumMemberSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Container_ptr (*_TAO_collocation_CORBA_Container_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::Container_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::Container::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_Container, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Container::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_Container, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_Container, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::Container::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_Container, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::Container,CORBA::Container_var>;
template class TAO_Object_Manager<CORBA::Container,CORBA::Container_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::Container,CORBA::Container_var>
#  pragma instantiate TAO_Object_Manager<CORBA::Container,CORBA::Container_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::Container::Description &_tao_elem) // copying
{
  CORBA::Container::Description *_any_val;
  ACE_NEW (_any_val, CORBA::Container::Description (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::Container::_tc_Description, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Container::Description *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::Container::_tc_Description, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container::Description *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::Container::_tc_Description, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Container::Description *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Container::Description, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::Container::_tc_Description, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::Container::_tc_Description, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::Container::DescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::Container::DescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::Container::DescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::Container::_tc_DescriptionSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Container::DescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::Container::_tc_DescriptionSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container::DescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::Container::_tc_DescriptionSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Container::DescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Container::DescriptionSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::Container::_tc_DescriptionSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::Container::_tc_DescriptionSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::IDLType_ptr (*_TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::IDLType_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::IDLType::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_IDLType, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IDLType_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IDLType::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_IDLType, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_IDLType, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::IDLType::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_IDLType, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::IDLType,CORBA::IDLType_var>;
template class TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::IDLType,CORBA::IDLType_var>
#  pragma instantiate TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA::PrimitiveKind _tao_elem)
{
  CORBA::PrimitiveKind *_any_val;
  ACE_NEW (_any_val, CORBA::PrimitiveKind (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_PrimitiveKind, _any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PrimitiveKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_PrimitiveKind, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    if (stream.decode (CORBA::_tc_PrimitiveKind, &_tao_elem, 0, ACE_TRY_ENV)
      == CORBA::TypeCode::TRAVERSE_CONTINUE)
      return 1;
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Repository_ptr (*_TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::Repository_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::Repository::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_Repository, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Repository_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Repository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_Repository, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_Repository, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::Repository::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_Repository, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::Repository,CORBA::Repository_var>;
template class TAO_Object_Manager<CORBA::Repository,CORBA::Repository_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::Repository,CORBA::Repository_var>
#  pragma instantiate TAO_Object_Manager<CORBA::Repository,CORBA::Repository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ModuleDef_ptr (*_TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ModuleDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ModuleDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_ModuleDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ModuleDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ModuleDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ModuleDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_ModuleDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::ModuleDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ModuleDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::ModuleDef,CORBA::ModuleDef_var>;
template class TAO_Object_Manager<CORBA::ModuleDef,CORBA::ModuleDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ModuleDef,CORBA::ModuleDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ModuleDef,CORBA::ModuleDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ModuleDescription &_tao_elem) // copying
{
  CORBA::ModuleDescription *_any_val;
  ACE_NEW (_any_val, CORBA::ModuleDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ModuleDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ModuleDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ModuleDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ModuleDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ModuleDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ModuleDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ModuleDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ModuleDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ModuleDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::ConstantDef_ptr (*_TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ConstantDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ConstantDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_ConstantDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ConstantDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ConstantDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ConstantDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_ConstantDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::ConstantDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ConstantDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::ConstantDef,CORBA::ConstantDef_var>;
template class TAO_Object_Manager<CORBA::ConstantDef,CORBA::ConstantDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ConstantDef,CORBA::ConstantDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ConstantDef,CORBA::ConstantDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ConstantDescription &_tao_elem) // copying
{
  CORBA::ConstantDescription *_any_val;
  ACE_NEW (_any_val, CORBA::ConstantDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ConstantDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ConstantDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ConstantDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ConstantDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ConstantDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ConstantDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ConstantDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ConstantDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ConstantDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::TypedefDef_ptr (*_TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::TypedefDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::TypedefDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_TypedefDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::TypedefDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::TypedefDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_TypedefDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_TypedefDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::TypedefDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_TypedefDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::TypedefDef,CORBA::TypedefDef_var>;
template class TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::TypedefDef,CORBA::TypedefDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::TypeDescription &_tao_elem) // copying
{
  CORBA::TypeDescription *_any_val;
  ACE_NEW (_any_val, CORBA::TypeDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_TypeDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::TypeDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_TypeDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::TypeDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_TypeDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::TypeDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::TypeDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_TypeDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_TypeDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::StructDef_ptr (*_TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::StructDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::StructDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_StructDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::StructDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_StructDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_StructDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::StructDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_StructDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::StructDef,CORBA::StructDef_var>;
template class TAO_Object_Manager<CORBA::StructDef,CORBA::StructDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::StructDef,CORBA::StructDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::StructDef,CORBA::StructDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::UnionDef_ptr (*_TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::UnionDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::UnionDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_UnionDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::UnionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_UnionDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_UnionDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::UnionDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_UnionDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::UnionDef,CORBA::UnionDef_var>;
template class TAO_Object_Manager<CORBA::UnionDef,CORBA::UnionDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::UnionDef,CORBA::UnionDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::UnionDef,CORBA::UnionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::EnumDef_ptr (*_TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::EnumDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::EnumDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_EnumDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::EnumDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::EnumDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_EnumDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_EnumDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::EnumDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_EnumDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::EnumDef,CORBA::EnumDef_var>;
template class TAO_Object_Manager<CORBA::EnumDef,CORBA::EnumDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::EnumDef,CORBA::EnumDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::EnumDef,CORBA::EnumDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::AliasDef_ptr (*_TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::AliasDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::AliasDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_AliasDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AliasDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::AliasDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_AliasDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_AliasDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::AliasDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_AliasDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::AliasDef,CORBA::AliasDef_var>;
template class TAO_Object_Manager<CORBA::AliasDef,CORBA::AliasDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::AliasDef,CORBA::AliasDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::AliasDef,CORBA::AliasDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::PrimitiveDef_ptr (*_TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::PrimitiveDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::PrimitiveDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_PrimitiveDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PrimitiveDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::PrimitiveDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_PrimitiveDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_PrimitiveDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::PrimitiveDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_PrimitiveDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>;
template class TAO_Object_Manager<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::StringDef_ptr (*_TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::StringDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::StringDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_StringDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StringDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::StringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_StringDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_StringDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::StringDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_StringDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::StringDef,CORBA::StringDef_var>;
template class TAO_Object_Manager<CORBA::StringDef,CORBA::StringDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::StringDef,CORBA::StringDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::StringDef,CORBA::StringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::WstringDef_ptr (*_TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::WstringDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::WstringDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_WstringDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::WstringDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::WstringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_WstringDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_WstringDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::WstringDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_WstringDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::WstringDef,CORBA::WstringDef_var>;
template class TAO_Object_Manager<CORBA::WstringDef,CORBA::WstringDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::WstringDef,CORBA::WstringDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::WstringDef,CORBA::WstringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::FixedDef_ptr (*_TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::FixedDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::FixedDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_FixedDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::FixedDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::FixedDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_FixedDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_FixedDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::FixedDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_FixedDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::FixedDef,CORBA::FixedDef_var>;
template class TAO_Object_Manager<CORBA::FixedDef,CORBA::FixedDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::FixedDef,CORBA::FixedDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::FixedDef,CORBA::FixedDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::SequenceDef_ptr (*_TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::SequenceDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::SequenceDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_SequenceDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::SequenceDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::SequenceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_SequenceDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_SequenceDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::SequenceDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_SequenceDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::SequenceDef,CORBA::SequenceDef_var>;
template class TAO_Object_Manager<CORBA::SequenceDef,CORBA::SequenceDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::SequenceDef,CORBA::SequenceDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::SequenceDef,CORBA::SequenceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ArrayDef_ptr (*_TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ArrayDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ArrayDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_ArrayDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ArrayDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ArrayDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ArrayDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_ArrayDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::ArrayDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ArrayDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::ArrayDef,CORBA::ArrayDef_var>;
template class TAO_Object_Manager<CORBA::ArrayDef,CORBA::ArrayDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ArrayDef,CORBA::ArrayDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ArrayDef,CORBA::ArrayDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ExceptionDef_ptr (*_TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ExceptionDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ExceptionDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_ExceptionDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExceptionDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ExceptionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ExceptionDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_ExceptionDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::ExceptionDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ExceptionDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::ExceptionDef,CORBA::ExceptionDef_var>;
template class TAO_Object_Manager<CORBA::ExceptionDef,CORBA::ExceptionDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ExceptionDef,CORBA::ExceptionDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ExceptionDef,CORBA::ExceptionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ExceptionDescription &_tao_elem) // copying
{
  CORBA::ExceptionDescription *_any_val;
  ACE_NEW (_any_val, CORBA::ExceptionDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ExceptionDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ExceptionDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ExceptionDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExceptionDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ExceptionDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExceptionDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExceptionDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ExceptionDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ExceptionDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::AttributeMode _tao_elem)
{
  CORBA::AttributeMode *_any_val;
  ACE_NEW (_any_val, CORBA::AttributeMode (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_AttributeMode, _any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttributeMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_AttributeMode, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    if (stream.decode (CORBA::_tc_AttributeMode, &_tao_elem, 0, ACE_TRY_ENV)
      == CORBA::TypeCode::TRAVERSE_CONTINUE)
      return 1;
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::AttributeDef_ptr (*_TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::AttributeDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::AttributeDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_AttributeDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttributeDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::AttributeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_AttributeDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_AttributeDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::AttributeDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_AttributeDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::AttributeDef,CORBA::AttributeDef_var>;
template class TAO_Object_Manager<CORBA::AttributeDef,CORBA::AttributeDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::AttributeDef,CORBA::AttributeDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::AttributeDef,CORBA::AttributeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::AttributeDescription &_tao_elem) // copying
{
  CORBA::AttributeDescription *_any_val;
  ACE_NEW (_any_val, CORBA::AttributeDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_AttributeDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::AttributeDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_AttributeDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttributeDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_AttributeDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::AttributeDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::AttributeDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_AttributeDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_AttributeDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::OperationMode _tao_elem)
{
  CORBA::OperationMode *_any_val;
  ACE_NEW (_any_val, CORBA::OperationMode (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_OperationMode, _any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OperationMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_OperationMode, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    if (stream.decode (CORBA::_tc_OperationMode, &_tao_elem, 0, ACE_TRY_ENV)
      == CORBA::TypeCode::TRAVERSE_CONTINUE)
      return 1;
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ParameterMode _tao_elem)
{
  CORBA::ParameterMode *_any_val;
  ACE_NEW (_any_val, CORBA::ParameterMode (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ParameterMode, _any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ParameterMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ParameterMode, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    if (stream.decode (CORBA::_tc_ParameterMode, &_tao_elem, 0, ACE_TRY_ENV)
      == CORBA::TypeCode::TRAVERSE_CONTINUE)
      return 1;
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::ParameterDescription &_tao_elem) // copying
{
  CORBA::ParameterDescription *_any_val;
  ACE_NEW (_any_val, CORBA::ParameterDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ParameterDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ParameterDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ParameterDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ParameterDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ParameterDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ParameterDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ParameterDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ParameterDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ParameterDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ParDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::ParDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ParDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ParDescriptionSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ParDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ParDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ParDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ParDescriptionSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ParDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ParDescriptionSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ParDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ParDescriptionSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ContextIdSeq &_tao_elem
  ) // copying
{
  CORBA::ContextIdSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ContextIdSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ContextIdSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ContextIdSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ContextIdSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ContextIdSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ContextIdSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ContextIdSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ContextIdSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ContextIdSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ContextIdSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExceptionDefSeq &_tao_elem
  ) // copying
{
  CORBA::ExceptionDefSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ExceptionDefSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ExceptionDefSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ExceptionDefSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ExceptionDefSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExceptionDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ExceptionDefSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExceptionDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExceptionDefSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ExceptionDefSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ExceptionDefSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExcDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::ExcDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ExcDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ExcDescriptionSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ExcDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ExcDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExcDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ExcDescriptionSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExcDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExcDescriptionSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ExcDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ExcDescriptionSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::OperationDef_ptr (*_TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::OperationDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::OperationDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_OperationDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OperationDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::OperationDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_OperationDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_OperationDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::OperationDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_OperationDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::OperationDef,CORBA::OperationDef_var>;
template class TAO_Object_Manager<CORBA::OperationDef,CORBA::OperationDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::OperationDef,CORBA::OperationDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::OperationDef,CORBA::OperationDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::OperationDescription &_tao_elem) // copying
{
  CORBA::OperationDescription *_any_val;
  ACE_NEW (_any_val, CORBA::OperationDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_OperationDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::OperationDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_OperationDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OperationDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_OperationDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::OperationDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::OperationDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_OperationDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_OperationDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::RepositoryIdSeq &_tao_elem
  ) // copying
{
  CORBA::RepositoryIdSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::RepositoryIdSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_RepositoryIdSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::RepositoryIdSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_RepositoryIdSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::RepositoryIdSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_RepositoryIdSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::RepositoryIdSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::RepositoryIdSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_RepositoryIdSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_RepositoryIdSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::OpDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::OpDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::OpDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_OpDescriptionSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::OpDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_OpDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OpDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_OpDescriptionSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::OpDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::OpDescriptionSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_OpDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_OpDescriptionSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::AttrDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::AttrDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::AttrDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_AttrDescriptionSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::AttrDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_AttrDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttrDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_AttrDescriptionSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::AttrDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::AttrDescriptionSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_AttrDescriptionSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_AttrDescriptionSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::InterfaceDef_ptr (*_TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::InterfaceDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_InterfaceDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::InterfaceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_InterfaceDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_InterfaceDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::InterfaceDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_InterfaceDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::InterfaceDef,CORBA::InterfaceDef_var>;
template class TAO_Object_Manager<CORBA::InterfaceDef,CORBA::InterfaceDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::InterfaceDef,CORBA::InterfaceDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::InterfaceDef,CORBA::InterfaceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::InterfaceDef::FullInterfaceDescription &_tao_elem) // copying
{
  CORBA::InterfaceDef::FullInterfaceDescription *_any_val;
  ACE_NEW (_any_val, CORBA::InterfaceDef::FullInterfaceDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::InterfaceDef::_tc_FullInterfaceDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDef::FullInterfaceDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::InterfaceDef::_tc_FullInterfaceDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDef::FullInterfaceDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::InterfaceDef::_tc_FullInterfaceDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDef::FullInterfaceDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDef::FullInterfaceDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::InterfaceDef::_tc_FullInterfaceDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::InterfaceDef::_tc_FullInterfaceDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::InterfaceDescription &_tao_elem) // copying
{
  CORBA::InterfaceDescription *_any_val;
  ACE_NEW (_any_val, CORBA::InterfaceDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_InterfaceDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_InterfaceDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_InterfaceDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_InterfaceDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_InterfaceDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::ValueMember &_tao_elem) // copying
{
  CORBA::ValueMember *_any_val;
  ACE_NEW (_any_val, CORBA::ValueMember (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueMember, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueMember *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueMember, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ValueMember, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueMember *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueMember, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ValueMember, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ValueMember, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueMemberSeq &_tao_elem
  ) // copying
{
  CORBA::ValueMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ValueMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueMemberSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK; 
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueMemberSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ValueMemberSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueMemberSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ValueMemberSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ValueMemberSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::ValueMemberDef_ptr (*_TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ValueMemberDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ValueMemberDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_ValueMemberDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueMemberDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ValueMemberDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ValueMemberDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_ValueMemberDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::ValueMemberDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ValueMemberDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>;
template class TAO_Object_Manager<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ValueDef_ptr (*_TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ValueDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_ValueDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ValueDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ValueDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_ValueDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::ValueDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ValueDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::ValueDef,CORBA::ValueDef_var>;
template class TAO_Object_Manager<CORBA::ValueDef,CORBA::ValueDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ValueDef,CORBA::ValueDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ValueDef,CORBA::ValueDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ValueDef::FullValueDescription &_tao_elem) // copying
{
  CORBA::ValueDef::FullValueDescription *_any_val;
  ACE_NEW (_any_val, CORBA::ValueDef::FullValueDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::ValueDef::_tc_FullValueDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDef::FullValueDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::ValueDef::_tc_FullValueDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDef::FullValueDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::ValueDef::_tc_FullValueDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDef::FullValueDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDef::FullValueDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::ValueDef::_tc_FullValueDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::ValueDef::_tc_FullValueDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::ValueDescription &_tao_elem) // copying
{
  CORBA::ValueDescription *_any_val;
  ACE_NEW (_any_val, CORBA::ValueDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueDescription, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (CORBA::_tc_ValueDescription, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ValueDescription, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDescription, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (CORBA::_tc_ValueDescription, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ValueDescription, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::ValueBoxDef_ptr (*_TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ValueBoxDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ValueBoxDef::_duplicate (_tao_elem);
    _tao_any.replace (CORBA::_tc_ValueBoxDef, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueBoxDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ValueBoxDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (CORBA::_tc_ValueBoxDef, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (CORBA::_tc_ValueBoxDef, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = CORBA::ValueBoxDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (CORBA::_tc_ValueBoxDef, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>;
template class TAO_Object_Manager<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::InterfaceDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::InterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ValueDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ValueDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ContainedSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ContainedSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::StructMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::StructMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::InitializerSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::InitializerSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::UnionMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::UnionMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::EnumMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::EnumMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::Container::DescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::Container::DescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ParDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ParDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ContextIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ContextIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExceptionDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExceptionDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ExcDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ExcDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::RepositoryIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::OpDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::OpDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::AttrDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::AttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA::ValueMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA::ValueMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

