// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from
// be\be_codegen.cpp:603

#ifndef _TAO_IDL____ORBSVCS_ORBSVCS_IFRSERVICE_IFR_COMPONENTSS_CPP_
#define _TAO_IDL____ORBSVCS_ORBSVCS_IFRSERVICE_IFR_COMPONENTSS_CPP_


#include "IFR_ComponentsS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/PortableServer/get_arg.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "IFR_ComponentsS.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:72


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_DEFINITIONKIND__SARG_TRAITS_)
#define _CORBA_DEFINITIONKIND__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::DefinitionKind>
    : public
        Basic_SArg_Traits_T<
            CORBA::DefinitionKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_REPOSITORY__SARG_TRAITS_)
#define _CORBA_REPOSITORY__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Repository>
    : public
        Object_SArg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINER__SARG_TRAITS_)
#define _CORBA_CONTAINER__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Container>
    : public
        Object_SArg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_IDLTYPE__SARG_TRAITS_)
#define _CORBA_IDLTYPE__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::IDLType>
    : public
        Object_SArg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INTERFACEDEFSEQ__SARG_TRAITS_)
#define _CORBA_INTERFACEDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_VALUEDEFSEQ__SARG_TRAITS_)
#define _CORBA_VALUEDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ValueDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ValueDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INITIALIZERSEQ__SARG_TRAITS_)
#define _CORBA_INITIALIZERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::InitializerSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXTINITIALIZERSEQ__SARG_TRAITS_)
#define _CORBA_EXTINITIALIZERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ExtInitializerSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExtInitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_)
#define _CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ExceptionDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExceptionDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_OPERATIONMODE__SARG_TRAITS_)
#define _CORBA_OPERATIONMODE__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::OperationMode>
    : public
        Basic_SArg_Traits_T<
            CORBA::OperationMode,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_)
#define _CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ParDescriptionSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ParDescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTEXTIDSEQ__SARG_TRAITS_)
#define _CORBA_CONTEXTIDSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ContextIdSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ContextIdSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_INTERFACEDEF__SARG_TRAITS_)
#define _CORBA_INTERFACEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::InterfaceDef>
    : public
        Object_SArg_Traits_T<
            CORBA::InterfaceDef_ptr,
            CORBA::InterfaceDef_var,
            CORBA::InterfaceDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_VALUEDEF__SARG_TRAITS_)
#define _CORBA_VALUEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ValueDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ValueDef_ptr,
            CORBA::ValueDef_var,
            CORBA::ValueDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_COMPONENTDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_COMPONENTDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::ComponentDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::ComponentDef_ptr,
            CORBA::ComponentIR::ComponentDef_var,
            CORBA::ComponentIR::ComponentDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_HOMEDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_HOMEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::HomeDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::HomeDef_ptr,
            CORBA::ComponentIR::HomeDef_var,
            CORBA::ComponentIR::HomeDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_EVENTDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_EVENTDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::EventDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::EventDef_ptr,
            CORBA::ComponentIR::EventDef_var,
            CORBA::ComponentIR::EventDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_PROVIDESDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_PROVIDESDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::ProvidesDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::ProvidesDef_ptr,
            CORBA::ComponentIR::ProvidesDef_var,
            CORBA::ComponentIR::ProvidesDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_USESDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_USESDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::UsesDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::UsesDef_ptr,
            CORBA::ComponentIR::UsesDef_var,
            CORBA::ComponentIR::UsesDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_EMITSDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_EMITSDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::EmitsDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::EmitsDef_ptr,
            CORBA::ComponentIR::EmitsDef_var,
            CORBA::ComponentIR::EmitsDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_PUBLISHESDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_PUBLISHESDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::PublishesDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::PublishesDef_ptr,
            CORBA::ComponentIR::PublishesDef_var,
            CORBA::ComponentIR::PublishesDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_CONSUMESDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_CONSUMESDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::ConsumesDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::ConsumesDef_ptr,
            CORBA::ComponentIR::ConsumesDef_var,
            CORBA::ComponentIR::ConsumesDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_FACTORYDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_FACTORYDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::FactoryDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::FactoryDef_ptr,
            CORBA::ComponentIR::FactoryDef_var,
            CORBA::ComponentIR::FactoryDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_FINDERDEF__SARG_TRAITS_)
#define _CORBA_COMPONENTIR_FINDERDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ComponentIR::FinderDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ComponentIR::FinderDef_ptr,
            CORBA::ComponentIR::FinderDef_var,
            CORBA::ComponentIR::FinderDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:72


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_DEFINITIONKIND__ARG_TRAITS_)
#define _CORBA_DEFINITIONKIND__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::DefinitionKind>
    : public
        Basic_Arg_Traits_T<
            CORBA::DefinitionKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_REPOSITORY__ARG_TRAITS_)
#define _CORBA_REPOSITORY__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Repository>
    : public
        Object_Arg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out,
            TAO::Objref_Traits<CORBA::Repository>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINER__ARG_TRAITS_)
#define _CORBA_CONTAINER__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Container>
    : public
        Object_Arg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out,
            TAO::Objref_Traits<CORBA::Container>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_IDLTYPE__ARG_TRAITS_)
#define _CORBA_IDLTYPE__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::IDLType>
    : public
        Object_Arg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out,
            TAO::Objref_Traits<CORBA::IDLType>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INTERFACEDEFSEQ__ARG_TRAITS_)
#define _CORBA_INTERFACEDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_VALUEDEFSEQ__ARG_TRAITS_)
#define _CORBA_VALUEDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ValueDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ValueDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INITIALIZERSEQ__ARG_TRAITS_)
#define _CORBA_INITIALIZERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::InitializerSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXTINITIALIZERSEQ__ARG_TRAITS_)
#define _CORBA_EXTINITIALIZERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ExtInitializerSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExtInitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXCEPTIONDEFSEQ__ARG_TRAITS_)
#define _CORBA_EXCEPTIONDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ExceptionDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExceptionDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_OPERATIONMODE__ARG_TRAITS_)
#define _CORBA_OPERATIONMODE__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::OperationMode>
    : public
        Basic_Arg_Traits_T<
            CORBA::OperationMode,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_PARDESCRIPTIONSEQ__ARG_TRAITS_)
#define _CORBA_PARDESCRIPTIONSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ParDescriptionSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ParDescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTEXTIDSEQ__ARG_TRAITS_)
#define _CORBA_CONTEXTIDSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ContextIdSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ContextIdSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_INTERFACEDEF__ARG_TRAITS_)
#define _CORBA_INTERFACEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::InterfaceDef>
    : public
        Object_Arg_Traits_T<
            CORBA::InterfaceDef_ptr,
            CORBA::InterfaceDef_var,
            CORBA::InterfaceDef_out,
            TAO::Objref_Traits<CORBA::InterfaceDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_VALUEDEF__ARG_TRAITS_)
#define _CORBA_VALUEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ValueDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ValueDef_ptr,
            CORBA::ValueDef_var,
            CORBA::ValueDef_out,
            TAO::Objref_Traits<CORBA::ValueDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_COMPONENTDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_COMPONENTDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::ComponentDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::ComponentDef_ptr,
            CORBA::ComponentIR::ComponentDef_var,
            CORBA::ComponentIR::ComponentDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::ComponentDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_HOMEDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_HOMEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::HomeDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::HomeDef_ptr,
            CORBA::ComponentIR::HomeDef_var,
            CORBA::ComponentIR::HomeDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::HomeDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_EVENTDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_EVENTDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::EventDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::EventDef_ptr,
            CORBA::ComponentIR::EventDef_var,
            CORBA::ComponentIR::EventDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::EventDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_PROVIDESDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_PROVIDESDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::ProvidesDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::ProvidesDef_ptr,
            CORBA::ComponentIR::ProvidesDef_var,
            CORBA::ComponentIR::ProvidesDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::ProvidesDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_USESDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_USESDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::UsesDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::UsesDef_ptr,
            CORBA::ComponentIR::UsesDef_var,
            CORBA::ComponentIR::UsesDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::UsesDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_EMITSDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_EMITSDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::EmitsDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::EmitsDef_ptr,
            CORBA::ComponentIR::EmitsDef_var,
            CORBA::ComponentIR::EmitsDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::EmitsDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_PUBLISHESDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_PUBLISHESDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::PublishesDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::PublishesDef_ptr,
            CORBA::ComponentIR::PublishesDef_var,
            CORBA::ComponentIR::PublishesDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::PublishesDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_CONSUMESDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_CONSUMESDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::ConsumesDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::ConsumesDef_ptr,
            CORBA::ComponentIR::ConsumesDef_var,
            CORBA::ComponentIR::ConsumesDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::ConsumesDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_FACTORYDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_FACTORYDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::FactoryDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::FactoryDef_ptr,
            CORBA::ComponentIR::FactoryDef_var,
            CORBA::ComponentIR::FactoryDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::FactoryDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_COMPONENTIR_FINDERDEF__ARG_TRAITS_)
#define _CORBA_COMPONENTIR_FINDERDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ComponentIR::FinderDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ComponentIR::FinderDef_ptr,
            CORBA::ComponentIR::FinderDef_var,
            CORBA::ComponentIR::FinderDef_out,
            TAO::Objref_Traits<CORBA::ComponentIR::FinderDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_EventDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_EventDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_EventDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109,   0,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109,   0,
     109,  15,  50,  40, 109, 109, 109,   0, 109, 109,
     109, 109, 109, 109, 109, 109, 109,   0,   0,   0,
     109,   0, 109,   0, 109, 109, 109, 109, 109, 109,
     109, 109,  15,   0, 109, 109, 109,  15,  15, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109,
#else
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109, 109, 109, 109, 109, 109,
     109, 109, 109, 109, 109,   0, 109,   0, 109,  15,
      50,  40, 109, 109, 109,   0, 109, 109,   0,   0,
       0, 109,   0, 109,   0,  15,   0, 109, 109, 109,
      15,  15, 109, 109, 109, 109, 109, 109,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_EventDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 60,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 108,
      HASH_VALUE_RANGE = 105,
      DUPLICATES = 18,
      WORDLIST_SIZE = 64
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"is_a", &POA_CORBA::ComponentIR::EventDef::is_a_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::EventDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ComponentIR::EventDef::lookup_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::EventDef::_component_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::EventDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::EventDef::_set_version_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::EventDef::_non_existent_skel, 0},
      {"_get_is_custom", &POA_CORBA::ComponentIR::EventDef::_get_is_custom_skel, 0},
      {"_set_is_custom", &POA_CORBA::ComponentIR::EventDef::_set_is_custom_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::EventDef::_get_defined_in_skel, 0},
      {"_get_is_abstract", &POA_CORBA::ComponentIR::EventDef::_get_is_abstract_skel, 0},
      {"_set_is_abstract", &POA_CORBA::ComponentIR::EventDef::_set_is_abstract_skel, 0},
      {"create_enum", &POA_CORBA::ComponentIR::EventDef::create_enum_skel, 0},
      {"create_union", &POA_CORBA::ComponentIR::EventDef::create_union_skel, 0},
      {"create_struct", &POA_CORBA::ComponentIR::EventDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ComponentIR::EventDef::create_constant_skel, 0},
      {"create_exception", &POA_CORBA::ComponentIR::EventDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ComponentIR::EventDef::create_operation_skel, 0},
      {"_get_initializers", &POA_CORBA::ComponentIR::EventDef::_get_initializers_skel, 0},
      {"_set_initializers", &POA_CORBA::ComponentIR::EventDef::_set_initializers_skel, 0},
      {"create_value_member", &POA_CORBA::ComponentIR::EventDef::create_value_member_skel, 0},
      {"_get_ext_initializers", &POA_CORBA::ComponentIR::EventDef::_get_ext_initializers_skel, 0},
      {"_set_ext_initializers", &POA_CORBA::ComponentIR::EventDef::_set_ext_initializers_skel, 0},
      {"contents", &POA_CORBA::ComponentIR::EventDef::contents_skel, 0},
      {"_get_supported_interfaces", &POA_CORBA::ComponentIR::EventDef::_get_supported_interfaces_skel, 0},
      {"_set_abstract_base_values", &POA_CORBA::ComponentIR::EventDef::_set_abstract_base_values_skel, 0},
      {"_get_abstract_base_values", &POA_CORBA::ComponentIR::EventDef::_get_abstract_base_values_skel, 0},
      {"_set_supported_interfaces", &POA_CORBA::ComponentIR::EventDef::_set_supported_interfaces_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::EventDef::_get_containing_repository_skel, 0},
      {"create_alias", &POA_CORBA::ComponentIR::EventDef::create_alias_skel, 0},
      {"move", &POA_CORBA::ComponentIR::EventDef::move_skel, 0},
      {"create_value_box", &POA_CORBA::ComponentIR::EventDef::create_value_box_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::EventDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ComponentIR::EventDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::EventDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::EventDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ComponentIR::EventDef::lookup_name_skel, 0},
      {"_get_base_value", &POA_CORBA::ComponentIR::EventDef::_get_base_value_skel, 0},
      {"_set_base_value", &POA_CORBA::ComponentIR::EventDef::_set_base_value_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::EventDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::EventDef::_set_id_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::EventDef::_get_absolute_name_skel, 0},
      {"_get_is_truncatable", &POA_CORBA::ComponentIR::EventDef::_get_is_truncatable_skel, 0},
      {"_set_is_truncatable", &POA_CORBA::ComponentIR::EventDef::_set_is_truncatable_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::EventDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::EventDef::_repository_id_skel, 0},
      {"create_value", &POA_CORBA::ComponentIR::EventDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ComponentIR::EventDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ComponentIR::EventDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ComponentIR::EventDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ComponentIR::EventDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ComponentIR::EventDef::create_ext_value_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::EventDef::destroy_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ComponentIR::EventDef::create_ext_attribute_skel, 0},
      {"create_local_interface", &POA_CORBA::ComponentIR::EventDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ComponentIR::EventDef::create_abstract_interface_skel, 0},
      {"describe_contents", &POA_CORBA::ComponentIR::EventDef::describe_contents_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::EventDef::describe_skel, 0},
      {"describe_value", &POA_CORBA::ComponentIR::EventDef::describe_value_skel, 0},
      {"describe_ext_value", &POA_CORBA::ComponentIR::EventDef::describe_ext_value_skel, 0},
    };

  static const signed short lookup[] =
    {
       -14,   -2,  -20,   -2,    4,    5,    6,   -1,  -22,   -2,    7,   -1,  169,   10,
       154,   13, -124,   -1,  -25,   -2,  -28,   -4,  -36,   -3,  -41,   -2,   16,   17,
        18,   -1,   19, -137, -132,   -1,   24,   -1, -126,   -1,   27,   -1, -128,   32,
        33,   -1,   34,   -1,   35,  -43,   -2, -135,   39,   40,   -1,  -46,   -2, -139,
        -1, -118,   45, -114,  -11,   -2,   -1,   48,   49,  -51,   -2,   50, -111,  -53,
        -3, -110,   56,   -8,   -2,   57,   -1,   58,   -1,   -1,   59,   -1,   60,   -1,
        -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
        61,   -1,   -1,   -1,   -1,   -1,   62,   -1,   -1,   -1,   63,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_EventDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_EventDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::EventDef::EventDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_EventDef_optable;
}

POA_CORBA::ComponentIR::EventDef::EventDef (const EventDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::ValueDef (rhs),
    POA_CORBA::ExtValueDef (rhs)
{
}

POA_CORBA::ComponentIR::EventDef::~EventDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_EventDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_EventDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::EventDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::EventDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventDef *> (servant);

  _is_a_EventDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_EventDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_EventDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::EventDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EventDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventDef *> (servant);

  _non_existent_EventDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_EventDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_EventDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::EventDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EventDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventDef *> (servant);

  _repository_id_EventDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::EventDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::EventDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_EventDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_EventDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::EventDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EventDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventDef *> (servant);

  _get_component_EventDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::EventDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ValueDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtValueDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/EventDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/EventDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::EventDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::EventDef *
POA_CORBA::ComponentIR::EventDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::EventDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_EventDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_Container_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 20,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 15,
     47,  0,  0,  0, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 30, 20, 30,
     47,  0, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 15,  5, 47, 47, 47, 10,  0, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47,
#else
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
     47, 47, 47, 47, 47, 20, 47, 15, 47,  0,
      0,  0, 47, 47, 47, 47, 47, 47, 30, 20,
     30, 47,  0, 47, 47, 15,  5, 47, 47, 47,
     10,  0, 47, 47, 47, 47, 47, 47,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 7,
      MAX_HASH_VALUE = 46,
      HASH_VALUE_RANGE = 40,
      DUPLICATES = 3,
      WORDLIST_SIZE = 35
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"destroy", &POA_CORBA::ComponentIR::Container::destroy_skel, 0},
      {"create_home", &POA_CORBA::ComponentIR::Container::create_home_skel, 0},
      {"create_value", &POA_CORBA::ComponentIR::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::ComponentIR::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::ComponentIR::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ComponentIR::Container::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::ComponentIR::Container::create_ext_value_skel, 0},
      {"create_event", &POA_CORBA::ComponentIR::Container::create_event_skel, 0},
      {"create_struct", &POA_CORBA::ComponentIR::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ComponentIR::Container::create_constant_skel, 0},
      {"create_component", &POA_CORBA::ComponentIR::Container::create_component_skel, 0},
      {"create_local_interface", &POA_CORBA::ComponentIR::Container::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ComponentIR::Container::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ComponentIR::Container::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::ComponentIR::Container::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::ComponentIR::Container::create_alias_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::Container::_interface_skel, 0},
      {"create_enum", &POA_CORBA::ComponentIR::Container::create_enum_skel, 0},
      {"describe_contents", &POA_CORBA::ComponentIR::Container::describe_contents_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::Container::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::Container::_repository_id_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::Container::_component_skel, 0},
      {"lookup", &POA_CORBA::ComponentIR::Container::lookup_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::Container::_non_existent_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::Container::_is_a_skel, 0},
      {"lookup_name", &POA_CORBA::ComponentIR::Container::lookup_name_skel, 0},
      {"create_union", &POA_CORBA::ComponentIR::Container::create_union_skel, 0},
      {"create_exception", &POA_CORBA::ComponentIR::Container::create_exception_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,   7,  -1, -10,  -2,   8,   9, -50,
      -12,  -2, -48,  14,  15,  -1,  16,  17,  18,  19,  -1,  20,  21,  22,
       -1,  -1,  23,  24,  25,  26,  27,  28,  29,  -1,  30,  -1,  31,  32,
       33,  -1,  -1,  -1,  34,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_Container_Perfect_Hash_OpTable tao_CORBA_ComponentIR_Container_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::Container::Container (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_Container_optable;
}

POA_CORBA::ComponentIR::Container::Container (const Container& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs)
{
}

POA_CORBA::ComponentIR::Container::~Container (void)
{
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_component_Container
      : public TAO::Upcall_Command
    {
    public:
      inline create_component_Container (
        POA_CORBA::ComponentIR::Container * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::ComponentDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::ComponentDef> (
            this->operation_details_,
            this->args_,
            4);

        TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_5 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
            this->operation_details_,
            this->args_,
            5);

        retval =
          this->servant_->create_component (
            arg_1
            , arg_2
            , arg_3
            , arg_4
            , arg_5);
      }

    private:
      POA_CORBA::ComponentIR::Container * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::Container::create_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_val _tao_base_component;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_supports_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_base_component,
      &_tao_supports_interfaces
    };

  static size_t const nargs = 6;

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);

  create_component_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_home_Container
      : public TAO::Upcall_Command
    {
    public:
      inline create_home_Container (
        POA_CORBA::ComponentIR::Container * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::HomeDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::HomeDef> (
            this->operation_details_,
            this->args_,
            4);

        TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_type arg_5 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::ComponentDef> (
            this->operation_details_,
            this->args_,
            5);

        TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_6 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
            this->operation_details_,
            this->args_,
            6);

        TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_type arg_7 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ValueDef> (
            this->operation_details_,
            this->args_,
            7);

        retval =
          this->servant_->create_home (
            arg_1
            , arg_2
            , arg_3
            , arg_4
            , arg_5
            , arg_6
            , arg_7);
      }

    private:
      POA_CORBA::ComponentIR::Container * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::Container::create_home_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::in_arg_val _tao_base_home;
  TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_val _tao_managed_component;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_supports_interfaces;
  TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_val _tao_primary_key;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_base_home,
      &_tao_managed_component,
      &_tao_supports_interfaces,
      &_tao_primary_key
    };

  static size_t const nargs = 8;

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);

  create_home_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_event_Container
      : public TAO::Upcall_Command
    {
    public:
      inline create_event_Container (
        POA_CORBA::ComponentIR::Container * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::EventDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_,
            4);

        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_5 =
          TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_,
            5);

        TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_type arg_6 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ValueDef> (
            this->operation_details_,
            this->args_,
            6);

        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_7 =
          TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_,
            7);

        TAO::SArg_Traits< ::CORBA::ValueDefSeq>::in_arg_type arg_8 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ValueDefSeq> (
            this->operation_details_,
            this->args_,
            8);

        TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_9 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
            this->operation_details_,
            this->args_,
            9);

        TAO::SArg_Traits< ::CORBA::ExtInitializerSeq>::in_arg_type arg_10 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ExtInitializerSeq> (
            this->operation_details_,
            this->args_,
            10);

        retval =
          this->servant_->create_event (
            arg_1
            , arg_2
            , arg_3
            , arg_4
            , arg_5
            , arg_6
            , arg_7
            , arg_8
            , arg_9
            , arg_10);
      }

    private:
      POA_CORBA::ComponentIR::Container * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::Container::create_event_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_custom;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_abstract;
  TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_val _tao_base_value;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_truncatable;
  TAO::SArg_Traits< ::CORBA::ValueDefSeq>::in_arg_val _tao_abstract_base_values;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_supported_interfaces;
  TAO::SArg_Traits< ::CORBA::ExtInitializerSeq>::in_arg_val _tao_initializers;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_is_custom,
      &_tao_is_abstract,
      &_tao_base_value,
      &_tao_is_truncatable,
      &_tao_abstract_base_values,
      &_tao_supported_interfaces,
      &_tao_initializers
    };

  static size_t const nargs = 11;

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);

  create_event_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_Container_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_Container_Upcall_Command (
        POA_CORBA::ComponentIR::Container * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::Container * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Container::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);

  _is_a_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_Container_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_Container_Upcall_Command (
        POA_CORBA::ComponentIR::Container * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::Container * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Container::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);

  _non_existent_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_Container_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_Container_Upcall_Command (
        POA_CORBA::ComponentIR::Container * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::Container * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Container::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);

  _repository_id_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::Container::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_Container_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_Container_Upcall_Command (
        POA_CORBA::ComponentIR::Container * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::Container * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Container::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::Container * const impl =
    static_cast<POA_CORBA::ComponentIR::Container *> (servant);

  _get_component_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::Container::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/Container:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::Container::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::Container *
POA_CORBA::ComponentIR::Container::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::Container STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_Container_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_ModuleDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 25,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 10,
     58,  0,  0,  0, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 30, 15,  5,
     58, 10, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 40, 15, 58, 58, 58, 20,  0, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58,
#else
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 25, 58, 10, 58,  0,
      0,  0, 58, 58, 58, 58, 58, 58, 30, 15,
      5, 58, 10, 58, 58, 40, 15, 58, 58, 58,
     20,  0, 58, 58, 58, 58, 58, 58,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 39,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 7,
      MAX_HASH_VALUE = 57,
      HASH_VALUE_RANGE = 51,
      DUPLICATES = 6,
      WORDLIST_SIZE = 46
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"destroy", &POA_CORBA::ComponentIR::ModuleDef::destroy_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::ModuleDef::describe_skel, 0},
      {"create_home", &POA_CORBA::ComponentIR::ModuleDef::create_home_skel, 0},
      {"create_value", &POA_CORBA::ComponentIR::ModuleDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ComponentIR::ModuleDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ComponentIR::ModuleDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ComponentIR::ModuleDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::ComponentIR::ModuleDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ComponentIR::ModuleDef::create_union_skel, 0},
      {"move", &POA_CORBA::ComponentIR::ModuleDef::move_skel, 0},
      {"create_exception", &POA_CORBA::ComponentIR::ModuleDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::ComponentIR::ModuleDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ComponentIR::ModuleDef::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::ComponentIR::ModuleDef::create_enum_skel, 0},
      {"create_event", &POA_CORBA::ComponentIR::ModuleDef::create_event_skel, 0},
      {"create_struct", &POA_CORBA::ComponentIR::ModuleDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ComponentIR::ModuleDef::create_constant_skel, 0},
      {"create_component", &POA_CORBA::ComponentIR::ModuleDef::create_component_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::ModuleDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::ModuleDef::_set_id_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::ModuleDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::ModuleDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::ModuleDef::_interface_skel, 0},
      {"create_value_box", &POA_CORBA::ComponentIR::ModuleDef::create_value_box_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::ModuleDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::ModuleDef::_repository_id_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::ModuleDef::_is_a_skel, 0},
      {"lookup_name", &POA_CORBA::ComponentIR::ModuleDef::lookup_name_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::ModuleDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::ModuleDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::ModuleDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::ModuleDef::_get_defined_in_skel, 0},
      {"lookup", &POA_CORBA::ComponentIR::ModuleDef::lookup_skel, 0},
      {"contents", &POA_CORBA::ComponentIR::ModuleDef::contents_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::ModuleDef::_component_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::ModuleDef::_get_containing_repository_skel, 0},
      {"create_alias", &POA_CORBA::ComponentIR::ModuleDef::create_alias_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::ModuleDef::_non_existent_skel, 0},
      {"describe_contents", &POA_CORBA::ComponentIR::ModuleDef::describe_contents_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1, -11,  -2, -13,  -2,   7,   8, -25,  -2,   9,  10, -67,
      -27,  -2, -68,  15,  -1,  16,  -1,  17,  18, -35,  -2,  19,  20,  21,
       22,  -1,  23,  24, -80,  -1, -77,  29,  30,  -1,  31,  32,  33,  34,
      -76,  37,  -1,  38,  39,  -1,  40,  -1,  41,  42,  43,  44,  -1,  -1,
       -1,  45,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_ModuleDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_ModuleDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::ModuleDef::ModuleDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_ModuleDef_optable;
}

POA_CORBA::ComponentIR::ModuleDef::ModuleDef (const ModuleDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::ModuleDef (rhs),
    POA_CORBA::ComponentIR::Container (rhs)
{
}

POA_CORBA::ComponentIR::ModuleDef::~ModuleDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_ModuleDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_ModuleDef_Upcall_Command (
        POA_CORBA::ComponentIR::ModuleDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::ModuleDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ModuleDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::ModuleDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ModuleDef *> (servant);

  _is_a_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_ModuleDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_ModuleDef_Upcall_Command (
        POA_CORBA::ComponentIR::ModuleDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::ModuleDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ModuleDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ModuleDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ModuleDef *> (servant);

  _non_existent_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_ModuleDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_ModuleDef_Upcall_Command (
        POA_CORBA::ComponentIR::ModuleDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::ModuleDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ModuleDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ModuleDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ModuleDef *> (servant);

  _repository_id_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::ModuleDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::ModuleDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ModuleDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_ModuleDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_ModuleDef_Upcall_Command (
        POA_CORBA::ComponentIR::ModuleDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::ModuleDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ModuleDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ModuleDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ModuleDef *> (servant);

  _get_component_ModuleDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::ModuleDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/ModuleDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ModuleDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::ModuleDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::ModuleDef *
POA_CORBA::ComponentIR::ModuleDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::ModuleDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_Repository_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 10,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78,  0,
     78,  0, 15, 20, 78, 10, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 20,  0, 25,
     78,  0, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 45,  5, 78, 78, 78,  0,  0, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78,
#else
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
     78, 78, 78, 78, 78, 10, 78,  0, 78,  0,
     15, 20, 78, 10, 78, 78, 78, 78, 20,  0,
     25, 78,  0, 78, 78, 45,  5, 78, 78, 78,
      0,  0, 78, 78, 78, 78, 78, 78,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 11,
      MAX_HASH_VALUE = 77,
      HASH_VALUE_RANGE = 67,
      DUPLICATES = 3,
      WORDLIST_SIZE = 47
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},{"",0,0},
      {"create_enum", &POA_CORBA::ComponentIR::Repository::create_enum_skel, 0},
      {"create_array", &POA_CORBA::ComponentIR::Repository::create_array_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::Repository::_is_a_skel, 0},
      {"create_value_box", &POA_CORBA::ComponentIR::Repository::create_value_box_skel, 0},
      {"create_event", &POA_CORBA::ComponentIR::Repository::create_event_skel, 0},
      {"create_struct", &POA_CORBA::ComponentIR::Repository::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ComponentIR::Repository::create_constant_skel, 0},
      {"create_component", &POA_CORBA::ComponentIR::Repository::create_component_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::Repository::destroy_skel, 0},
      {"create_string", &POA_CORBA::ComponentIR::Repository::create_string_skel, 0},
      {"create_wstring", &POA_CORBA::ComponentIR::Repository::create_wstring_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::Repository::_component_skel, 0},
      {"lookup", &POA_CORBA::ComponentIR::Repository::lookup_skel, 0},
      {"create_fixed", &POA_CORBA::ComponentIR::Repository::create_fixed_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::Repository::_non_existent_skel, 0},
      {"create_home", &POA_CORBA::ComponentIR::Repository::create_home_skel, 0},
      {"create_value", &POA_CORBA::ComponentIR::Repository::create_value_skel, 0},
      {"create_module", &POA_CORBA::ComponentIR::Repository::create_module_skel, 0},
      {"create_native", &POA_CORBA::ComponentIR::Repository::create_native_skel, 0},
      {"create_sequence", &POA_CORBA::ComponentIR::Repository::create_sequence_skel, 0},
      {"create_interface", &POA_CORBA::ComponentIR::Repository::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::ComponentIR::Repository::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ComponentIR::Repository::create_union_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::Repository::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::Repository::_repository_id_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::Repository::_interface_skel, 0},
      {"create_exception", &POA_CORBA::ComponentIR::Repository::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::ComponentIR::Repository::create_local_interface_skel, 0},
      {"get_primitive", &POA_CORBA::ComponentIR::Repository::get_primitive_skel, 0},
      {"lookup_id", &POA_CORBA::ComponentIR::Repository::lookup_id_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ComponentIR::Repository::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ComponentIR::Repository::lookup_name_skel, 0},
      {"get_canonical_typecode", &POA_CORBA::ComponentIR::Repository::get_canonical_typecode_skel, 0},
      {"contents", &POA_CORBA::ComponentIR::Repository::contents_skel, 0},
      {"create_alias", &POA_CORBA::ComponentIR::Repository::create_alias_skel, 0},
      {"describe_contents", &POA_CORBA::ComponentIR::Repository::describe_contents_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  11,  12, -28,
       -2,  13,  14,  15,  16,  -1,  17,  18,  19,  20,  21,  22,  23,  24,
       25, -31,  -2,  26,  27, -97,  -1,  30, -84,  33,  34,  35,  36,  37,
       38,  39,  40,  41,  -1,  -1,  -1,  -1,  -1,  42,  43,  44,  -1,  -1,
       -1,  45,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  46,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_Repository_Perfect_Hash_OpTable tao_CORBA_ComponentIR_Repository_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::Repository::Repository (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_Repository_optable;
}

POA_CORBA::ComponentIR::Repository::Repository (const Repository& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Repository (rhs),
    POA_CORBA::ComponentIR::Container (rhs)
{
}

POA_CORBA::ComponentIR::Repository::~Repository (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_Repository_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_Repository_Upcall_Command (
        POA_CORBA::ComponentIR::Repository * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::Repository * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Repository::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::Repository * const impl =
    static_cast<POA_CORBA::ComponentIR::Repository *> (servant);

  _is_a_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_Repository_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_Repository_Upcall_Command (
        POA_CORBA::ComponentIR::Repository * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::Repository * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Repository::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::Repository * const impl =
    static_cast<POA_CORBA::ComponentIR::Repository *> (servant);

  _non_existent_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_Repository_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_Repository_Upcall_Command (
        POA_CORBA::ComponentIR::Repository * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::Repository * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Repository::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::Repository * const impl =
    static_cast<POA_CORBA::ComponentIR::Repository *> (servant);

  _repository_id_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::Repository::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::Repository * const impl =
    static_cast<POA_CORBA::ComponentIR::Repository *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_Repository_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_Repository_Upcall_Command (
        POA_CORBA::ComponentIR::Repository * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::Repository * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::Repository::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::Repository * const impl =
    static_cast<POA_CORBA::ComponentIR::Repository *> (servant);

  _get_component_Repository_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::Repository::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Repository:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/Repository:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/Repository:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::Repository::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::Repository *
POA_CORBA::ComponentIR::Repository::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::Repository STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_Repository_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_ProvidesDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_ProvidesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_ProvidesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_ProvidesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5,
      WORDLIST_SIZE = 24
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::ProvidesDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::ProvidesDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::ProvidesDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::ProvidesDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::ProvidesDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::ProvidesDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::ProvidesDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::ProvidesDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::ProvidesDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::ProvidesDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::ProvidesDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::ProvidesDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::ProvidesDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::ProvidesDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::ProvidesDef::_get_absolute_name_skel, 0},
      {"_get_interface_type", &POA_CORBA::ComponentIR::ProvidesDef::_get_interface_type_skel, 0},
      {"_set_interface_type", &POA_CORBA::ComponentIR::ProvidesDef::_set_interface_type_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::ProvidesDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::ProvidesDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::ProvidesDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -19,  -2,   4,   5,  -1,  53,   8,  48,  11,  -1, -48,  14,
       15,  16,  -1,  17,  18, -53,  21,  -9,  -2,  22,  -6,  -2,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_ProvidesDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_ProvidesDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::ProvidesDef::ProvidesDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_ProvidesDef_optable;
}

POA_CORBA::ComponentIR::ProvidesDef::ProvidesDef (const ProvidesDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::ComponentIR::ProvidesDef::~ProvidesDef (void)
{
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_interface_type_ProvidesDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_interface_type_ProvidesDef (
        POA_CORBA::ComponentIR::ProvidesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDef> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->interface_type ();
      }

    private:
      POA_CORBA::ComponentIR::ProvidesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ProvidesDef::_get_interface_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDef>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ProvidesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ProvidesDef *> (servant);

  _get_interface_type_ProvidesDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_interface_type_ProvidesDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_interface_type_ProvidesDef (
        POA_CORBA::ComponentIR::ProvidesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDef> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->interface_type (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::ProvidesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ProvidesDef::_set_interface_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_val _tao_interface_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_interface_type
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::ProvidesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ProvidesDef *> (servant);

  _set_interface_type_ProvidesDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_ProvidesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_ProvidesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ProvidesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::ProvidesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ProvidesDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::ProvidesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ProvidesDef *> (servant);

  _is_a_ProvidesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_ProvidesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_ProvidesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ProvidesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::ProvidesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ProvidesDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ProvidesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ProvidesDef *> (servant);

  _non_existent_ProvidesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_ProvidesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_ProvidesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ProvidesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::ProvidesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ProvidesDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ProvidesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ProvidesDef *> (servant);

  _repository_id_ProvidesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::ProvidesDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::ProvidesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ProvidesDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_ProvidesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_ProvidesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ProvidesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::ProvidesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ProvidesDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ProvidesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ProvidesDef *> (servant);

  _get_component_ProvidesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::ProvidesDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/ProvidesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ProvidesDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::ProvidesDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::ProvidesDef *
POA_CORBA::ComponentIR::ProvidesDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::ProvidesDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_UsesDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_UsesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_UsesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_UsesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 22,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 26
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::UsesDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::UsesDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::UsesDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::UsesDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::UsesDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::UsesDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::UsesDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::UsesDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::UsesDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::UsesDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::UsesDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::UsesDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::UsesDef::_get_defined_in_skel, 0},
      {"_get_is_multiple", &POA_CORBA::ComponentIR::UsesDef::_get_is_multiple_skel, 0},
      {"_set_is_multiple", &POA_CORBA::ComponentIR::UsesDef::_set_is_multiple_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::UsesDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::UsesDef::_get_absolute_name_skel, 0},
      {"_get_interface_type", &POA_CORBA::ComponentIR::UsesDef::_get_interface_type_skel, 0},
      {"_set_interface_type", &POA_CORBA::ComponentIR::UsesDef::_set_interface_type_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::UsesDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::UsesDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::UsesDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -17,  -2, -21,  -2,   4,   5,  -1,  55,   8,  51,  11,  -1,  45,  14,
       15,  16, -52,  19,  20, -53,  23, -12,  -2,  24,  -9,  -2,  -6,  -2,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  25,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_UsesDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_UsesDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::UsesDef::UsesDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_UsesDef_optable;
}

POA_CORBA::ComponentIR::UsesDef::UsesDef (const UsesDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::ComponentIR::UsesDef::~UsesDef (void)
{
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_interface_type_UsesDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_interface_type_UsesDef (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDef> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->interface_type ();
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::UsesDef::_get_interface_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDef>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _get_interface_type_UsesDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_interface_type_UsesDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_interface_type_UsesDef (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDef> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->interface_type (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::UsesDef::_set_interface_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_val _tao_interface_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_interface_type
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _set_interface_type_UsesDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_is_multiple_UsesDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_is_multiple_UsesDef (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->is_multiple ();
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::UsesDef::_get_is_multiple_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _get_is_multiple_UsesDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_is_multiple_UsesDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_is_multiple_UsesDef (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->is_multiple (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::UsesDef::_set_is_multiple_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_multiple;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_is_multiple
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _set_is_multiple_UsesDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_UsesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_UsesDef_Upcall_Command (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::UsesDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _is_a_UsesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_UsesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_UsesDef_Upcall_Command (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::UsesDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _non_existent_UsesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_UsesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_UsesDef_Upcall_Command (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::UsesDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _repository_id_UsesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::UsesDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_UsesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_UsesDef_Upcall_Command (
        POA_CORBA::ComponentIR::UsesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::UsesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::UsesDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::UsesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::UsesDef *> (servant);

  _get_component_UsesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::UsesDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/UsesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/UsesDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::UsesDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::UsesDef *
POA_CORBA::ComponentIR::UsesDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::UsesDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_UsesDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_EventPortDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_EventPortDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_EventPortDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 15, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 15, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_EventPortDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::EventPortDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::EventPortDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::EventPortDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::EventPortDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::EventPortDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::EventPortDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::EventPortDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::EventPortDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::EventPortDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::EventPortDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::EventPortDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::EventPortDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::EventPortDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::EventPortDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::EventPortDef::_get_absolute_name_skel, 0},
      {"is_a", &POA_CORBA::ComponentIR::EventPortDef::is_a_skel, 0},
      {"_get_event", &POA_CORBA::ComponentIR::EventPortDef::_get_event_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::EventPortDef::_component_skel, 0},
      {"_set_event", &POA_CORBA::ComponentIR::EventPortDef::_set_event_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::EventPortDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::EventPortDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -20,  -3,   4,   5,  -1,  53,   8,  48,  11,  -1, -48,  14,
       15,  16,  -1,  17,  18,  19, -54,  -9,  -2,  23,  -6,  -2,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_EventPortDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_EventPortDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::EventPortDef::EventPortDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_EventPortDef_optable;
}

POA_CORBA::ComponentIR::EventPortDef::EventPortDef (const EventPortDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs)
{
}

POA_CORBA::ComponentIR::EventPortDef::~EventPortDef (void)
{
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_event_EventPortDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_event_EventPortDef (
        POA_CORBA::ComponentIR::EventPortDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::EventDef> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->event ();
      }

    private:
      POA_CORBA::ComponentIR::EventPortDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::EventPortDef::_get_event_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);

  _get_event_EventPortDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_event_EventPortDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_event_EventPortDef (
        POA_CORBA::ComponentIR::EventPortDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::EventDef> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->event (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::EventPortDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::EventPortDef::_set_event_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_val _tao_event;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_event
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);

  _set_event_EventPortDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class is_a_EventPortDef
      : public TAO::Upcall_Command
    {
    public:
      inline is_a_EventPortDef (
        POA_CORBA::ComponentIR::EventPortDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_->is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::EventPortDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::EventPortDef::is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_event_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_event_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);

  is_a_EventPortDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_EventPortDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_EventPortDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventPortDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::EventPortDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventPortDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);

  _is_a_EventPortDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_EventPortDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_EventPortDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventPortDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::EventPortDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventPortDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);

  _non_existent_EventPortDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_EventPortDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_EventPortDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventPortDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::EventPortDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventPortDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);

  _repository_id_EventPortDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::EventPortDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_EventPortDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_EventPortDef_Upcall_Command (
        POA_CORBA::ComponentIR::EventPortDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::EventPortDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EventPortDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EventPortDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EventPortDef *> (servant);

  _get_component_EventPortDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::EventPortDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::EventPortDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::EventPortDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::EventPortDef *
POA_CORBA::ComponentIR::EventPortDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::EventPortDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_EventPortDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_EmitsDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_EmitsDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_EmitsDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 15, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 15, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_EmitsDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::EmitsDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::EmitsDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::EmitsDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::EmitsDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::EmitsDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::EmitsDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::EmitsDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::EmitsDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::EmitsDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::EmitsDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::EmitsDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::EmitsDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::EmitsDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::EmitsDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::EmitsDef::_get_absolute_name_skel, 0},
      {"is_a", &POA_CORBA::ComponentIR::EmitsDef::is_a_skel, 0},
      {"_get_event", &POA_CORBA::ComponentIR::EmitsDef::_get_event_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::EmitsDef::_component_skel, 0},
      {"_set_event", &POA_CORBA::ComponentIR::EmitsDef::_set_event_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::EmitsDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::EmitsDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -20,  -3,   4,   5,  -1,  53,   8,  48,  11,  -1, -48,  14,
       15,  16,  -1,  17,  18,  19, -54,  -9,  -2,  23,  -6,  -2,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_EmitsDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_EmitsDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::EmitsDef::EmitsDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_EmitsDef_optable;
}

POA_CORBA::ComponentIR::EmitsDef::EmitsDef (const EmitsDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::ComponentIR::EventPortDef (rhs)
{
}

POA_CORBA::ComponentIR::EmitsDef::~EmitsDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_EmitsDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_EmitsDef_Upcall_Command (
        POA_CORBA::ComponentIR::EmitsDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::EmitsDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EmitsDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::EmitsDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EmitsDef *> (servant);

  _is_a_EmitsDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_EmitsDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_EmitsDef_Upcall_Command (
        POA_CORBA::ComponentIR::EmitsDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::EmitsDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EmitsDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EmitsDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EmitsDef *> (servant);

  _non_existent_EmitsDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_EmitsDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_EmitsDef_Upcall_Command (
        POA_CORBA::ComponentIR::EmitsDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::EmitsDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EmitsDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EmitsDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EmitsDef *> (servant);

  _repository_id_EmitsDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::EmitsDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::EmitsDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EmitsDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_EmitsDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_EmitsDef_Upcall_Command (
        POA_CORBA::ComponentIR::EmitsDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::EmitsDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::EmitsDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::EmitsDef * const impl =
    static_cast<POA_CORBA::ComponentIR::EmitsDef *> (servant);

  _get_component_EmitsDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::EmitsDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/EmitsDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/EmitsDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::EmitsDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::EmitsDef *
POA_CORBA::ComponentIR::EmitsDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::EmitsDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_EmitsDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_PublishesDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_PublishesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_PublishesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 15, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 15, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_PublishesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::PublishesDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::PublishesDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::PublishesDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::PublishesDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::PublishesDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::PublishesDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::PublishesDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::PublishesDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::PublishesDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::PublishesDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::PublishesDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::PublishesDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::PublishesDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::PublishesDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::PublishesDef::_get_absolute_name_skel, 0},
      {"is_a", &POA_CORBA::ComponentIR::PublishesDef::is_a_skel, 0},
      {"_get_event", &POA_CORBA::ComponentIR::PublishesDef::_get_event_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::PublishesDef::_component_skel, 0},
      {"_set_event", &POA_CORBA::ComponentIR::PublishesDef::_set_event_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::PublishesDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::PublishesDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -20,  -3,   4,   5,  -1,  53,   8,  48,  11,  -1, -48,  14,
       15,  16,  -1,  17,  18,  19, -54,  -9,  -2,  23,  -6,  -2,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_PublishesDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_PublishesDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::PublishesDef::PublishesDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_PublishesDef_optable;
}

POA_CORBA::ComponentIR::PublishesDef::PublishesDef (const PublishesDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::ComponentIR::EventPortDef (rhs)
{
}

POA_CORBA::ComponentIR::PublishesDef::~PublishesDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_PublishesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_PublishesDef_Upcall_Command (
        POA_CORBA::ComponentIR::PublishesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::PublishesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::PublishesDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::PublishesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::PublishesDef *> (servant);

  _is_a_PublishesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_PublishesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_PublishesDef_Upcall_Command (
        POA_CORBA::ComponentIR::PublishesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::PublishesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::PublishesDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::PublishesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::PublishesDef *> (servant);

  _non_existent_PublishesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_PublishesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_PublishesDef_Upcall_Command (
        POA_CORBA::ComponentIR::PublishesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::PublishesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::PublishesDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::PublishesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::PublishesDef *> (servant);

  _repository_id_PublishesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::PublishesDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::PublishesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::PublishesDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_PublishesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_PublishesDef_Upcall_Command (
        POA_CORBA::ComponentIR::PublishesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::PublishesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::PublishesDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::PublishesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::PublishesDef *> (servant);

  _get_component_PublishesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::PublishesDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/PublishesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/PublishesDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::PublishesDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::PublishesDef *
POA_CORBA::ComponentIR::PublishesDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::PublishesDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_PublishesDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_ConsumesDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_ConsumesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_ConsumesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 15, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 15, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_ConsumesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 21,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 25
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::ConsumesDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::ConsumesDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::ConsumesDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::ConsumesDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::ConsumesDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::ConsumesDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::ConsumesDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::ConsumesDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::ConsumesDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::ConsumesDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::ConsumesDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::ConsumesDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::ConsumesDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::ConsumesDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::ConsumesDef::_get_absolute_name_skel, 0},
      {"is_a", &POA_CORBA::ComponentIR::ConsumesDef::is_a_skel, 0},
      {"_get_event", &POA_CORBA::ComponentIR::ConsumesDef::_get_event_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::ConsumesDef::_component_skel, 0},
      {"_set_event", &POA_CORBA::ComponentIR::ConsumesDef::_set_event_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::ConsumesDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::ConsumesDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -20,  -3,   4,   5,  -1,  53,   8,  48,  11,  -1, -48,  14,
       15,  16,  -1,  17,  18,  19, -54,  -9,  -2,  23,  -6,  -2,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_ConsumesDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_ConsumesDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::ConsumesDef::ConsumesDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_ConsumesDef_optable;
}

POA_CORBA::ComponentIR::ConsumesDef::ConsumesDef (const ConsumesDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::ComponentIR::EventPortDef (rhs)
{
}

POA_CORBA::ComponentIR::ConsumesDef::~ConsumesDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_ConsumesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_ConsumesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ConsumesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::ConsumesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ConsumesDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::ConsumesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ConsumesDef *> (servant);

  _is_a_ConsumesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_ConsumesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_ConsumesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ConsumesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::ConsumesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ConsumesDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ConsumesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ConsumesDef *> (servant);

  _non_existent_ConsumesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_ConsumesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_ConsumesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ConsumesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::ConsumesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ConsumesDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ConsumesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ConsumesDef *> (servant);

  _repository_id_ConsumesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::ConsumesDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::ConsumesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ConsumesDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_ConsumesDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_ConsumesDef_Upcall_Command (
        POA_CORBA::ComponentIR::ConsumesDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::ConsumesDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ConsumesDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ConsumesDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ConsumesDef *> (servant);

  _get_component_ConsumesDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::ConsumesDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/EventPortDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/ConsumesDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ConsumesDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::ConsumesDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::ConsumesDef *
POA_CORBA::ComponentIR::ConsumesDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::ConsumesDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_ComponentDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_ComponentDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_ComponentDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 35,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90,  0,
     90,  0, 25,  0, 90, 90, 90,  5, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 30,  0,  5,
     90, 10, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 15, 35, 90, 90, 90, 20,  0, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90,
#else
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
     90, 90, 90, 90, 90, 35, 90,  0, 90,  0,
     25,  0, 90, 90, 90,  5, 90, 90, 30,  0,
      5, 90, 10, 90, 90, 15, 35, 90, 90, 90,
     20,  0, 90, 90, 90, 90, 90, 90,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_ComponentDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 54,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 89,
      HASH_VALUE_RANGE = 86,
      DUPLICATES = 14,
      WORDLIST_SIZE = 58
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::ComponentDef::move_skel, 0},
      {"is_a", &POA_CORBA::ComponentIR::ComponentDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::ComponentIR::ComponentDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ComponentIR::ComponentDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ComponentIR::ComponentDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ComponentIR::ComponentDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ComponentIR::ComponentDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ComponentIR::ComponentDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ComponentIR::ComponentDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ComponentIR::ComponentDef::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ComponentIR::ComponentDef::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::ComponentIR::ComponentDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ComponentIR::ComponentDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::ComponentIR::ComponentDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ComponentIR::ComponentDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ComponentIR::ComponentDef::create_abstract_interface_skel, 0},
      {"create_uses", &POA_CORBA::ComponentIR::ComponentDef::create_uses_skel, 0},
      {"create_alias", &POA_CORBA::ComponentIR::ComponentDef::create_alias_skel, 0},
      {"create_emits", &POA_CORBA::ComponentIR::ComponentDef::create_emits_skel, 0},
      {"create_provides", &POA_CORBA::ComponentIR::ComponentDef::create_provides_skel, 0},
      {"create_consumes", &POA_CORBA::ComponentIR::ComponentDef::create_consumes_skel, 0},
      {"create_publishes", &POA_CORBA::ComponentIR::ComponentDef::create_publishes_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::ComponentDef::destroy_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::ComponentDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::ComponentIR::ComponentDef::create_value_box_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::ComponentDef::_is_a_skel, 0},
      {"lookup_name", &POA_CORBA::ComponentIR::ComponentDef::lookup_name_skel, 0},
      {"describe_interface", &POA_CORBA::ComponentIR::ComponentDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::ComponentDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ComponentIR::ComponentDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::ComponentDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::ComponentDef::_interface_skel, 0},
      {"lookup", &POA_CORBA::ComponentIR::ComponentDef::lookup_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ComponentIR::ComponentDef::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::ComponentIR::ComponentDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ComponentIR::ComponentDef::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::ComponentDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::ComponentDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::ComponentDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::ComponentDef::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::ComponentIR::ComponentDef::describe_contents_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::ComponentDef::_get_containing_repository_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::ComponentDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::ComponentDef::_set_id_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ComponentIR::ComponentDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ComponentIR::ComponentDef::_set_base_interfaces_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::ComponentDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::ComponentDef::_repository_id_skel, 0},
      {"_get_supported_interfaces", &POA_CORBA::ComponentIR::ComponentDef::_get_supported_interfaces_skel, 0},
      {"_set_supported_interfaces", &POA_CORBA::ComponentIR::ComponentDef::_set_supported_interfaces_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::ComponentDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::ComponentDef::_non_existent_skel, 0},
      {"_get_base_component", &POA_CORBA::ComponentIR::ComponentDef::_get_base_component_skel, 0},
      {"_set_base_component", &POA_CORBA::ComponentIR::ComponentDef::_set_base_component_skel, 0},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -1,   -1,    4,   -8,   -2,  -10,   -3,    5,   -1,    6,    7,  -97,
       -15,   -2,  -98,   13,  -21,   -2,   14,  -96,   17,   18,   -1,   19,   20,  -98,
       -23,   -2,  -91,   25,   26,   27,  -32,   -3,   28,   -1,  -40,   -2,   29,   30,
        -1,   31,  -99,   35,   36,   37,   38,   -1,   39,   -1, -103,   42,   -1,   43,
        -1,   44,   -1,   -1,   -1,   45,   -1,   -1,   -1,  -46,   -2,  -91,  -48,   -2,
       -91,  -52,   -2,   50,   51,  -93,   -1,   -1,   -1,   -1,   54,   -1,   -1,   55,
        -1,   -1,   -1,  -56,   -2,  -91,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_ComponentDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_ComponentDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::ComponentDef::ComponentDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_ComponentDef_optable;
}

POA_CORBA::ComponentIR::ComponentDef::ComponentDef (const ComponentDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs),
    POA_CORBA::ExtInterfaceDef (rhs)
{
}

POA_CORBA::ComponentIR::ComponentDef::~ComponentDef (void)
{
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_base_component_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_base_component_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::ComponentDef> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->base_component ();
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::_get_base_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _get_base_component_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_base_component_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_base_component_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::ComponentDef> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->base_component (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::_set_base_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_val _tao_base_component;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_base_component
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _set_base_component_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_supported_interfaces_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_supported_interfaces_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDefSeq> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->supported_interfaces ();
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::_get_supported_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _get_supported_interfaces_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_supported_interfaces_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_supported_interfaces_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->supported_interfaces (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::_set_supported_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_supported_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_supported_interfaces
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _set_supported_interfaces_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_provides_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline create_provides_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::ProvidesDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::ProvidesDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDef> (
            this->operation_details_,
            this->args_,
            4);

        retval =
          this->servant_->create_provides (
            arg_1
            , arg_2
            , arg_3
            , arg_4);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::create_provides_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::ProvidesDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_val _tao_interface_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_interface_type
    };

  static size_t const nargs = 5;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  create_provides_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_uses_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline create_uses_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::UsesDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::UsesDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDef> (
            this->operation_details_,
            this->args_,
            4);

        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_5 =
          TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_,
            5);

        retval =
          this->servant_->create_uses (
            arg_1
            , arg_2
            , arg_3
            , arg_4
            , arg_5);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::create_uses_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::UsesDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::InterfaceDef>::in_arg_val _tao_interface_type;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_multiple;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_interface_type,
      &_tao_is_multiple
    };

  static size_t const nargs = 6;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  create_uses_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_emits_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline create_emits_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::EmitsDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::EmitsDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::EventDef> (
            this->operation_details_,
            this->args_,
            4);

        retval =
          this->servant_->create_emits (
            arg_1
            , arg_2
            , arg_3
            , arg_4);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::create_emits_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::EmitsDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_val _tao_event;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_event
    };

  static size_t const nargs = 5;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  create_emits_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_publishes_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline create_publishes_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::PublishesDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::PublishesDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::EventDef> (
            this->operation_details_,
            this->args_,
            4);

        retval =
          this->servant_->create_publishes (
            arg_1
            , arg_2
            , arg_3
            , arg_4);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::create_publishes_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::PublishesDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_val _tao_event;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_event
    };

  static size_t const nargs = 5;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  create_publishes_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_consumes_ComponentDef
      : public TAO::Upcall_Command
    {
    public:
      inline create_consumes_ComponentDef (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::ConsumesDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::ConsumesDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::EventDef> (
            this->operation_details_,
            this->args_,
            4);

        retval =
          this->servant_->create_consumes (
            arg_1
            , arg_2
            , arg_3
            , arg_4);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::ComponentDef::create_consumes_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::ConsumesDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::ComponentIR::EventDef>::in_arg_val _tao_event;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_event
    };

  static size_t const nargs = 5;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  create_consumes_ComponentDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_ComponentDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_ComponentDef_Upcall_Command (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ComponentDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _is_a_ComponentDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_ComponentDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_ComponentDef_Upcall_Command (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ComponentDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _non_existent_ComponentDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_ComponentDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_ComponentDef_Upcall_Command (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ComponentDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _repository_id_ComponentDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::ComponentDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_ComponentDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_ComponentDef_Upcall_Command (
        POA_CORBA::ComponentIR::ComponentDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::ComponentDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::ComponentDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::ComponentDef * const impl =
    static_cast<POA_CORBA::ComponentIR::ComponentDef *> (servant);

  _get_component_ComponentDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::ComponentDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/ComponentDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/ComponentDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::ComponentDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::ComponentDef *
POA_CORBA::ComponentIR::ComponentDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::ComponentDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_ComponentDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_FactoryDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_FactoryDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_FactoryDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_FactoryDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::FactoryDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::FactoryDef::_is_a_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::FactoryDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::ComponentIR::FactoryDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::ComponentIR::FactoryDef::_get_mode_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::FactoryDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::FactoryDef::_interface_skel, 0},
      {"_get_params", &POA_CORBA::ComponentIR::FactoryDef::_get_params_skel, 0},
      {"_set_params", &POA_CORBA::ComponentIR::FactoryDef::_set_params_skel, 0},
      {"_get_contexts", &POA_CORBA::ComponentIR::FactoryDef::_get_contexts_skel, 0},
      {"_set_contexts", &POA_CORBA::ComponentIR::FactoryDef::_set_contexts_skel, 0},
      {"_get_exceptions", &POA_CORBA::ComponentIR::FactoryDef::_get_exceptions_skel, 0},
      {"_set_exceptions", &POA_CORBA::ComponentIR::FactoryDef::_set_exceptions_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::FactoryDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::FactoryDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::FactoryDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::FactoryDef::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::FactoryDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::FactoryDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::FactoryDef::describe_skel, 0},
      {"_get_result_def", &POA_CORBA::ComponentIR::FactoryDef::_get_result_def_skel, 0},
      {"_set_result_def", &POA_CORBA::ComponentIR::FactoryDef::_set_result_def_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::FactoryDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::FactoryDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::FactoryDef::_component_skel, 0},
      {"_get_result", &POA_CORBA::ComponentIR::FactoryDef::_get_result_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::FactoryDef::destroy_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::FactoryDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::FactoryDef::_get_containing_repository_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  29:
                  resword = &wordlist[27]; break;
                case  30:
                  resword = &wordlist[28]; break;
                case  31:
                  resword = &wordlist[29]; break;
                case  32:
                  resword = &wordlist[30]; break;
                case  33:
                  resword = &wordlist[31]; break;
                case  36:
                  resword = &wordlist[32]; break;
                default: return 0;
                }
              if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_FactoryDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_FactoryDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::FactoryDef::FactoryDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_FactoryDef_optable;
}

POA_CORBA::ComponentIR::FactoryDef::FactoryDef (const FactoryDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::OperationDef (rhs)
{
}

POA_CORBA::ComponentIR::FactoryDef::~FactoryDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_FactoryDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_FactoryDef_Upcall_Command (
        POA_CORBA::ComponentIR::FactoryDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::FactoryDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FactoryDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::FactoryDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FactoryDef *> (servant);

  _is_a_FactoryDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_FactoryDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_FactoryDef_Upcall_Command (
        POA_CORBA::ComponentIR::FactoryDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::FactoryDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FactoryDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::FactoryDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FactoryDef *> (servant);

  _non_existent_FactoryDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_FactoryDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_FactoryDef_Upcall_Command (
        POA_CORBA::ComponentIR::FactoryDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::FactoryDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FactoryDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::FactoryDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FactoryDef *> (servant);

  _repository_id_FactoryDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::FactoryDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::FactoryDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FactoryDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_FactoryDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_FactoryDef_Upcall_Command (
        POA_CORBA::ComponentIR::FactoryDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::FactoryDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FactoryDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::FactoryDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FactoryDef *> (servant);

  _get_component_FactoryDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::FactoryDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/FactoryDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/FactoryDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::FactoryDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::FactoryDef *
POA_CORBA::ComponentIR::FactoryDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::FactoryDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_FactoryDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_FinderDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_FinderDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_FinderDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_FinderDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 33
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::FinderDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::FinderDef::_is_a_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::FinderDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::ComponentIR::FinderDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::ComponentIR::FinderDef::_get_mode_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::FinderDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::FinderDef::_interface_skel, 0},
      {"_get_params", &POA_CORBA::ComponentIR::FinderDef::_get_params_skel, 0},
      {"_set_params", &POA_CORBA::ComponentIR::FinderDef::_set_params_skel, 0},
      {"_get_contexts", &POA_CORBA::ComponentIR::FinderDef::_get_contexts_skel, 0},
      {"_set_contexts", &POA_CORBA::ComponentIR::FinderDef::_set_contexts_skel, 0},
      {"_get_exceptions", &POA_CORBA::ComponentIR::FinderDef::_get_exceptions_skel, 0},
      {"_set_exceptions", &POA_CORBA::ComponentIR::FinderDef::_set_exceptions_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::FinderDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::FinderDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::FinderDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::FinderDef::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::FinderDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::FinderDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::FinderDef::describe_skel, 0},
      {"_get_result_def", &POA_CORBA::ComponentIR::FinderDef::_get_result_def_skel, 0},
      {"_set_result_def", &POA_CORBA::ComponentIR::FinderDef::_set_result_def_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::FinderDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::FinderDef::_repository_id_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::FinderDef::_component_skel, 0},
      {"_get_result", &POA_CORBA::ComponentIR::FinderDef::_get_result_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::FinderDef::destroy_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::FinderDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::FinderDef::_get_containing_repository_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  29:
                  resword = &wordlist[27]; break;
                case  30:
                  resword = &wordlist[28]; break;
                case  31:
                  resword = &wordlist[29]; break;
                case  32:
                  resword = &wordlist[30]; break;
                case  33:
                  resword = &wordlist[31]; break;
                case  36:
                  resword = &wordlist[32]; break;
                default: return 0;
                }
              if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_FinderDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_FinderDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::FinderDef::FinderDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_FinderDef_optable;
}

POA_CORBA::ComponentIR::FinderDef::FinderDef (const FinderDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::OperationDef (rhs)
{
}

POA_CORBA::ComponentIR::FinderDef::~FinderDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_FinderDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_FinderDef_Upcall_Command (
        POA_CORBA::ComponentIR::FinderDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::FinderDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FinderDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::FinderDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FinderDef *> (servant);

  _is_a_FinderDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_FinderDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_FinderDef_Upcall_Command (
        POA_CORBA::ComponentIR::FinderDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::FinderDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FinderDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::FinderDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FinderDef *> (servant);

  _non_existent_FinderDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_FinderDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_FinderDef_Upcall_Command (
        POA_CORBA::ComponentIR::FinderDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::FinderDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FinderDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::FinderDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FinderDef *> (servant);

  _repository_id_FinderDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::FinderDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::FinderDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FinderDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_FinderDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_FinderDef_Upcall_Command (
        POA_CORBA::ComponentIR::FinderDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::FinderDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::FinderDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::FinderDef * const impl =
    static_cast<POA_CORBA::ComponentIR::FinderDef *> (servant);

  _get_component_FinderDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::FinderDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/FinderDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/FinderDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::FinderDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::FinderDef *
POA_CORBA::ComponentIR::FinderDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::FinderDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_FinderDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_ComponentIR_HomeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ComponentIR_HomeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ComponentIR_HomeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101,   0,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101,   0,
     101,  45,  20,   0, 101, 101, 101,  15, 101, 101,
     101, 101, 101, 101, 101, 101, 101,   0,   0,  20,
     101,   0, 101,   5, 101, 101, 101, 101, 101, 101,
     101, 101,  35,  40, 101, 101, 101,   5,  10, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101,
#else
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
     101, 101, 101, 101, 101,   0, 101,   0, 101,  45,
      20,   0, 101, 101, 101,  15, 101, 101,   0,   0,
      20, 101,   0, 101,   5,  35,  40, 101, 101, 101,
       5,  10, 101, 101, 101, 101, 101, 101,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_ComponentIR_HomeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 55,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 100,
      HASH_VALUE_RANGE = 97,
      DUPLICATES = 14,
      WORDLIST_SIZE = 59
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ComponentIR::HomeDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ComponentIR::HomeDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ComponentIR::HomeDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::ComponentIR::HomeDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ComponentIR::HomeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ComponentIR::HomeDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ComponentIR::HomeDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ComponentIR::HomeDef::lookup_name_skel, 0},
      {"_get_base_home", &POA_CORBA::ComponentIR::HomeDef::_get_base_home_skel, 0},
      {"_set_base_home", &POA_CORBA::ComponentIR::HomeDef::_set_base_home_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ComponentIR::HomeDef::_get_absolute_name_skel, 0},
      {"is_a", &POA_CORBA::ComponentIR::HomeDef::is_a_skel, 0},
      {"_get_primary_key", &POA_CORBA::ComponentIR::HomeDef::_get_primary_key_skel, 0},
      {"_set_primary_key", &POA_CORBA::ComponentIR::HomeDef::_set_primary_key_skel, 0},
      {"_get_id", &POA_CORBA::ComponentIR::HomeDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ComponentIR::HomeDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ComponentIR::HomeDef::describe_skel, 0},
      {"_get_version", &POA_CORBA::ComponentIR::HomeDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ComponentIR::HomeDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ComponentIR::HomeDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::ComponentIR::HomeDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::ComponentIR::HomeDef::_get_defined_in_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ComponentIR::HomeDef::_get_containing_repository_skel, 0},
      {"destroy", &POA_CORBA::ComponentIR::HomeDef::destroy_skel, 0},
      {"describe_interface", &POA_CORBA::ComponentIR::HomeDef::describe_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ComponentIR::HomeDef::describe_ext_interface_skel, 0},
      {"_component", &POA_CORBA::ComponentIR::HomeDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ComponentIR::HomeDef::_non_existent_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ComponentIR::HomeDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ComponentIR::HomeDef::_set_base_interfaces_skel, 0},
      {"create_enum", &POA_CORBA::ComponentIR::HomeDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ComponentIR::HomeDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ComponentIR::HomeDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ComponentIR::HomeDef::create_native_skel, 0},
      {"_get_supported_interfaces", &POA_CORBA::ComponentIR::HomeDef::_get_supported_interfaces_skel, 0},
      {"_set_supported_interfaces", &POA_CORBA::ComponentIR::HomeDef::_set_supported_interfaces_skel, 0},
      {"create_interface", &POA_CORBA::ComponentIR::HomeDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ComponentIR::HomeDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ComponentIR::HomeDef::create_ext_value_skel, 0},
      {"_get_managed_component", &POA_CORBA::ComponentIR::HomeDef::_get_managed_component_skel, 0},
      {"_set_managed_component", &POA_CORBA::ComponentIR::HomeDef::_set_managed_component_skel, 0},
      {"create_finder", &POA_CORBA::ComponentIR::HomeDef::create_finder_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ComponentIR::HomeDef::create_ext_attribute_skel, 0},
      {"create_value_box", &POA_CORBA::ComponentIR::HomeDef::create_value_box_skel, 0},
      {"create_local_interface", &POA_CORBA::ComponentIR::HomeDef::create_local_interface_skel, 0},
      {"create_factory", &POA_CORBA::ComponentIR::HomeDef::create_factory_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ComponentIR::HomeDef::create_abstract_interface_skel, 0},
      {"describe_contents", &POA_CORBA::ComponentIR::HomeDef::describe_contents_skel, 0},
      {"create_union", &POA_CORBA::ComponentIR::HomeDef::create_union_skel, 0},
      {"create_exception", &POA_CORBA::ComponentIR::HomeDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ComponentIR::HomeDef::create_operation_skel, 0},
      {"contents", &POA_CORBA::ComponentIR::HomeDef::contents_skel, 0},
      {"create_alias", &POA_CORBA::ComponentIR::HomeDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::ComponentIR::HomeDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ComponentIR::HomeDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -1,   -1,    4,    5,    6,   -7,   -3, -102,   10,   11,  -12,   -2,
      -102,   -1,   -1,   -1,   14,   15,   -1,   -1,  -16,   -2,  -18,   -2, -104, -103,
        20,   -1,  -21,   -2, -102,   23,   24,   25,   26,   27,   28,   -1,  -32,   -2,
        29,   -1,  -36,   -2,  -38,   -2,  -40,   -3,   30,  -43,   -2,   31,   -1, -115,
        34,   35, -114,   -1, -114, -113, -111,   45,   -1,   46,   47,   48,   -1,   49,
        50,   -1,   51,   -1,   -1,   -1,   -1,   52,   -1,  -53,   -2, -102,   -1,   -1,
        -1,   -1,   -1,   -1,   55,   -1,   -1,   -1,   56,   -1,   -1,   -1,   -1,   -1,
        57,   -1,   58,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ComponentIR_HomeDef_Perfect_Hash_OpTable tao_CORBA_ComponentIR_HomeDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer =
    CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ComponentIR::HomeDef::HomeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ComponentIR_HomeDef_optable;
}

POA_CORBA::ComponentIR::HomeDef::HomeDef (const HomeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Container (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs),
    POA_CORBA::InterfaceDef (rhs),
    POA_CORBA::InterfaceAttrExtension (rhs),
    POA_CORBA::ExtInterfaceDef (rhs)
{
}

POA_CORBA::ComponentIR::HomeDef::~HomeDef (void)
{
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_base_home_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_base_home_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::HomeDef> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->base_home ();
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_get_base_home_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _get_base_home_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_base_home_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_base_home_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::HomeDef> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->base_home (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_set_base_home_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ComponentIR::HomeDef>::in_arg_val _tao_base_home;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_base_home
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _set_base_home_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_supported_interfaces_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_supported_interfaces_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDefSeq> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->supported_interfaces ();
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_get_supported_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _get_supported_interfaces_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_supported_interfaces_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_supported_interfaces_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->supported_interfaces (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_set_supported_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_supported_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_supported_interfaces
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _set_supported_interfaces_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_managed_component_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_managed_component_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::ComponentDef> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->managed_component ();
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_get_managed_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _get_managed_component_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_managed_component_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_managed_component_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ComponentIR::ComponentDef> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->managed_component (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_set_managed_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ComponentIR::ComponentDef>::in_arg_val _tao_managed_component;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_managed_component
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _set_managed_component_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_primary_key_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _get_primary_key_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ValueDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ValueDef> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_->primary_key ();
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_get_primary_key_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ValueDef>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _get_primary_key_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _set_primary_key_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline _set_primary_key_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ValueDef> (
            this->operation_details_,
            this->args_,
            1);

        this->servant_->primary_key (
          arg_1);
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::_set_primary_key_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_val _tao_primary_key;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_primary_key
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _set_primary_key_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_factory_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline create_factory_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::FactoryDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::FactoryDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ParDescriptionSeq> (
            this->operation_details_,
            this->args_,
            4);

        TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_5 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
            this->operation_details_,
            this->args_,
            5);

        retval =
          this->servant_->create_factory (
            arg_1
            , arg_2
            , arg_3
            , arg_4
            , arg_5);
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::create_factory_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::FactoryDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_val _tao_params;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_params,
      &_tao_exceptions
    };

  static size_t const nargs = 6;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  create_factory_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class create_finder_HomeDef
      : public TAO::Upcall_Command
    {
    public:
      inline create_finder_HomeDef (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::ComponentIR::FinderDef>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::ComponentIR::FinderDef> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
            this->operation_details_,
            this->args_,
            1);

        TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
            this->operation_details_,
            this->args_,
            2);

        TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
          TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
            this->operation_details_,
            this->args_,
            3);

        TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_type arg_4 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ParDescriptionSeq> (
            this->operation_details_,
            this->args_,
            4);

        TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_type arg_5 =
          TAO::Portable_Server::get_in_arg< ::CORBA::ExceptionDefSeq> (
            this->operation_details_,
            this->args_,
            5);

        retval =
          this->servant_->create_finder (
            arg_1
            , arg_2
            , arg_3
            , arg_4
            , arg_5);
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::ComponentIR::HomeDef::create_finder_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ComponentIR::FinderDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::ParDescriptionSeq>::in_arg_val _tao_params;
  TAO::SArg_Traits< ::CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_params,
      &_tao_exceptions
    };

  static size_t const nargs = 6;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  create_finder_HomeDef command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _is_a_HomeDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _is_a_HomeDef_Upcall_Command (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
          TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_,
            1);

        retval =
          this->servant_-> _is_a (
            arg_1);
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::HomeDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _is_a_HomeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _non_existent_HomeDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _non_existent_HomeDef_Upcall_Command (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _non_existent ();
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::HomeDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _non_existent_HomeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _repository_id_HomeDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _repository_id_HomeDef_Upcall_Command (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _repository_id ();
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::HomeDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _repository_id_HomeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::ComponentIR::HomeDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{
  namespace ComponentIR
  {


    // TAO_IDL - Generated from
    // be\be_visitor_operation/upcall_command_ss.cpp:127

    class _get_component_HomeDef_Upcall_Command
      : public TAO::Upcall_Command
    {
    public:
      inline _get_component_HomeDef_Upcall_Command (
        POA_CORBA::ComponentIR::HomeDef * servant,
        TAO_Operation_Details const * operation_details,
        TAO::Argument * const args[])
        : servant_ (servant)
          , operation_details_ (operation_details)
          , args_ (args)
      {
      }

      virtual void execute (void)
      {
        TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
          TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
            this->operation_details_,
            this->args_);

        retval =
          this->servant_-> _get_component ();
      }

    private:
      POA_CORBA::ComponentIR::HomeDef * const servant_;
      TAO_Operation_Details const * const operation_details_;
      TAO::Argument * const * const args_;
    };
  }

}


void POA_CORBA::ComponentIR::HomeDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::ComponentIR::HomeDef * const impl =
    static_cast<POA_CORBA::ComponentIR::HomeDef *> (servant);

  _get_component_HomeDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::ComponentIR::HomeDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ComponentIR/HomeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ComponentIR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ComponentIR/HomeDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::ComponentIR::HomeDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::ComponentIR::HomeDef *
POA_CORBA::ComponentIR::HomeDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::ComponentIR::HomeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA_ComponentIR__TAO_HomeDef_Proxy_Broker_Factory_function_pointer
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* ifndef */

