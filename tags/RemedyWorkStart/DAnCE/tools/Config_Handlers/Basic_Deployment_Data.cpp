/* $Id$
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please contact the current XSC maintainer:
 *             Will Otte <wotte@dre.vanderbilt.edu>
 */

// Fix for Borland compilers, which seem to have a broken
// <string> include.
#ifdef __BORLANDC__
# include <string.h>
#endif

#include "Basic_Deployment_Data.hpp"

namespace DAnCE
{
  namespace Config_Handlers
  {
    // IdRef
    //

    IdRef::
    IdRef ()
    :
    regulator__ ()
    {
    }

    IdRef::
    IdRef (IdRef const& s)
      : ::XSCRT::Type (),
    href_ (s.href_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.href_) : 0),
    idref_ (s.idref_.get () ? new ::XMLSchema::IDREF< ACE_TCHAR > (*s.idref_) : 0),
    regulator__ ()
    {
      if (href_.get ()) href_->container (this);
      if (idref_.get ()) idref_->container (this);
    }

    IdRef& IdRef::
    operator= (IdRef const& s)
    {
      if (s.href_.get ()) href (*(s.href_));
      else href_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      if (s.idref_.get ()) idref (*(s.idref_));
      else idref_ = ::std::auto_ptr< ::XMLSchema::IDREF< ACE_TCHAR > > (0);

      return *this;
    }


    // IdRef
    //
    bool IdRef::
    href_p () const
    {
      return href_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& IdRef::
    href () const
    {
      return *href_;
    }

    ::XMLSchema::string< ACE_TCHAR >& IdRef::
    href ()
    {
      return *href_;
    }

    void IdRef::
    href (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (href_.get ())
      {
        *href_ = e;
      }

      else
      {
        href_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        href_->container (this);
      }
    }

    // IdRef
    //
    bool IdRef::
    idref_p () const
    {
      return idref_.get () != 0;
    }

    ::XMLSchema::IDREF< ACE_TCHAR > const& IdRef::
    idref () const
    {
      return *idref_;
    }

    ::XMLSchema::IDREF< ACE_TCHAR >& IdRef::
    idref ()
    {
      return *idref_;
    }

    ::XSCRT::Type* IdRef::
    idref_ptr ()
    {
        std::basic_string<ACE_TCHAR> temp (idref().id());
      return this->get_idref(temp.c_str());
    }


    void IdRef::
    idref (::XMLSchema::IDREF< ACE_TCHAR > const& e)
    {
      if (idref_.get ())
      {
        *idref_ = e;
      }

      else
      {
        idref_ = ::std::auto_ptr< ::XMLSchema::IDREF< ACE_TCHAR > > (new ::XMLSchema::IDREF< ACE_TCHAR > (e));
        idref_->container (this);
      }
    }


    // TCKind
    //

    TCKind::Value TCKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::TCKind const& a, ::DAnCE::Config_Handlers::TCKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::TCKind const& a, ::DAnCE::Config_Handlers::TCKind const& b)
    {
      return a.v_ != b.v_;
    }

    TCKind::
    TCKind (TCKind::Value v)
    : v_ (v)
    {
    }

    // DataType
    //

    DataType::
    DataType (::DAnCE::Config_Handlers::TCKind const& kind__)
    :
    ::XSCRT::Type (),
    kind_ (new ::DAnCE::Config_Handlers::TCKind (kind__)),
    regulator__ ()
    {
      kind_->container (this);
    }

    DataType::
    DataType (DataType const& s)
    :
    ::XSCRT::Type (),
    kind_ (new ::DAnCE::Config_Handlers::TCKind (*s.kind_)),
    enum__ (s.enum__.get () ? new ::DAnCE::Config_Handlers::EnumType (*s.enum__) : 0),
    struct__ (s.struct__.get () ? new ::DAnCE::Config_Handlers::StructType (*s.struct__) : 0),
    value_ (s.value_.get () ? new ::DAnCE::Config_Handlers::ValueType (*s.value_) : 0),
    sequence_ (s.sequence_.get () ? new ::DAnCE::Config_Handlers::SequenceType (*s.sequence_) : 0),
    alias_ (s.alias_.get () ? new ::DAnCE::Config_Handlers::AliasType (*s.alias_) : 0),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      kind_->container (this);
      if (enum__.get ()) enum__->container (this);
      if (struct__.get ()) struct__->container (this);
      if (value_.get ()) value_->container (this);
      if (sequence_.get ()) sequence_->container (this);
      if (alias_.get ()) alias_->container (this);
      if (id_.get ()) id_->container (this);
    }

    DataType& DataType::
    operator= (DataType const& s)
    {
      kind (*s.kind_);

      if (s.enum__.get ())
        enum_ (*(s.enum__));
      else
        enum__.reset (0);

      if (s.struct__.get ())
        struct_ (*(s.struct__));
      else
        struct__.reset (0);

      if (s.value_.get ())
        value (*(s.value_));
      else
        value_.reset (0);

      if (s.sequence_.get ())
        sequence (*(s.sequence_));
      else
        sequence_.reset (0);

      if (s.alias_.get ())
        alias (*(s.alias_));
      else
        alias_.reset (0);

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // DataType
    //
    ::DAnCE::Config_Handlers::TCKind const& DataType::
    kind () const
    {
      return *kind_;
    }

    void DataType::
    kind (::DAnCE::Config_Handlers::TCKind const& e)
    {
      *kind_ = e;
    }

    // DataType
    //
    bool DataType::
    enum_p () const
    {
      return enum__.get () != 0;
    }

    ::DAnCE::Config_Handlers::EnumType const& DataType::
    enum_ () const
    {
      return *enum__;
    }

    void DataType::
    enum_ (::DAnCE::Config_Handlers::EnumType const& e)
    {
      if (enum__.get ())
      {
        *enum__ = e;
      }

      else
      {
        enum__ = ::std::auto_ptr< ::DAnCE::Config_Handlers::EnumType > (new ::DAnCE::Config_Handlers::EnumType (e));
        enum__->container (this);
      }
    }

    // DataType
    //
    bool DataType::
    struct_p () const
    {
      return struct__.get () != 0;
    }

    ::DAnCE::Config_Handlers::StructType const& DataType::
    struct_ () const
    {
      return *struct__;
    }

    void DataType::
    struct_ (::DAnCE::Config_Handlers::StructType const& e)
    {
      if (struct__.get ())
      {
        *struct__ = e;
      }

      else
      {
        struct__ = ::std::auto_ptr< ::DAnCE::Config_Handlers::StructType > (new ::DAnCE::Config_Handlers::StructType (e));
        struct__->container (this);
      }
    }

    // DataType
    //
    bool DataType::
    value_p () const
    {
      return value_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ValueType const& DataType::
    value () const
    {
      return *value_;
    }

    void DataType::
    value (::DAnCE::Config_Handlers::ValueType const& e)
    {
      if (value_.get ())
      {
        *value_ = e;
      }

      else
      {
        value_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::ValueType > (new ::DAnCE::Config_Handlers::ValueType (e));
        value_->container (this);
      }
    }

    // DataType
    //
    bool DataType::
    sequence_p () const
    {
      return sequence_.get () != 0;
    }

    ::DAnCE::Config_Handlers::SequenceType const& DataType::
    sequence () const
    {
      return *sequence_;
    }

    void DataType::
    sequence (::DAnCE::Config_Handlers::SequenceType const& e)
    {
      if (sequence_.get ())
      {
        *sequence_ = e;
      }

      else
      {
        sequence_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::SequenceType > (new ::DAnCE::Config_Handlers::SequenceType (e));
        sequence_->container (this);
      }
    }

    // DataType
    //
    bool DataType::
    alias_p () const
    {
      return alias_.get () != 0;
    }

    ::DAnCE::Config_Handlers::AliasType const& DataType::
    alias () const
    {
      return *alias_;
    }

    void DataType::
    alias (::DAnCE::Config_Handlers::AliasType const& e)
    {
      if (alias_.get ())
      {
        *alias_ = e;
      }

      else
      {
        alias_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::AliasType > (new ::DAnCE::Config_Handlers::AliasType (e));
        alias_->container (this);
      }
    }

    // DataType
    //
    bool DataType::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& DataType::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& DataType::
    id ()
    {
      return *id_;
    }

    void DataType::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // DataValue
    //

    DataValue::
    DataValue ()
    :
    regulator__ ()
    {
    }

    DataValue::
    DataValue (DataValue const& s)
    :
    ::XSCRT::Type (),
    short__ (s.short__),
    long__ (s.long__),
    ushort_ (s.ushort_),
    ulong_ (s.ulong_),
    float__ (s.float__),
    double__ (s.double__),
    boolean_ (s.boolean_),
    octet_ (s.octet_),
    enum__ (s.enum__),
    string_ (s.string_),
    longlong_ (s.longlong_),
    ulonglong_ (s.ulonglong_),
    longdouble_ (s.longdouble_),
    element_ (s.element_),
    member_ (s.member_),
    regulator__ ()
    {
    }

    DataValue& DataValue::
    operator= (DataValue const& s)
    {
      short__ = s.short__;

      long__ = s.long__;

      ushort_ = s.ushort_;

      ulong_ = s.ulong_;

      float__ = s.float__;

      double__ = s.double__;

      boolean_ = s.boolean_;

      octet_ = s.octet_;

      enum__ = s.enum__;

      string_ = s.string_;

      longlong_ = s.longlong_;

      ulonglong_ = s.ulonglong_;

      longdouble_ = s.longdouble_;

      element_ = s.element_;

      member_ = s.member_;

      return *this;
    }


    // DataValue
    //
    DataValue::short_iterator DataValue::
    begin_short ()
    {
      return short__.begin ();
    }

    DataValue::short_iterator DataValue::
    end_short ()
    {
      return short__.end ();
    }

    DataValue::short_const_iterator DataValue::
    begin_short () const
    {
      return short__.begin ();
    }

    DataValue::short_const_iterator DataValue::
    end_short () const
    {
      return short__.end ();
    }

    void DataValue::
    add_short (ACE_Refcounted_Auto_Ptr < ::XMLSchema::short_, ACE_Null_Mutex >  const& e)
    {
      short__.push_back (e);
    }

    size_t DataValue::
    count_short(void) const
    {
      return short__.size ();
    }

    // DataValue
    //
    DataValue::long_iterator DataValue::
    begin_long ()
    {
      return long__.begin ();
    }

    DataValue::long_iterator DataValue::
    end_long ()
    {
      return long__.end ();
    }

    DataValue::long_const_iterator DataValue::
    begin_long () const
    {
      return long__.begin ();
    }

    DataValue::long_const_iterator DataValue::
    end_long () const
    {
      return long__.end ();
    }

    void DataValue::
    add_long (ACE_Refcounted_Auto_Ptr < ::XMLSchema::int_, ACE_Null_Mutex >  const& e)
    {
      long__.push_back (e);
    }

    size_t DataValue::
    count_long(void) const
    {
      return long__.size ();
    }

    // DataValue
    //
    DataValue::ushort_iterator DataValue::
    begin_ushort ()
    {
      return ushort_.begin ();
    }

    DataValue::ushort_iterator DataValue::
    end_ushort ()
    {
      return ushort_.end ();
    }

    DataValue::ushort_const_iterator DataValue::
    begin_ushort () const
    {
      return ushort_.begin ();
    }

    DataValue::ushort_const_iterator DataValue::
    end_ushort () const
    {
      return ushort_.end ();
    }

    void DataValue::
    add_ushort (ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedShort, ACE_Null_Mutex >  const& e)
    {
      ushort_.push_back (e);
    }

    size_t DataValue::
    count_ushort(void) const
    {
      return ushort_.size ();
    }

    // DataValue
    //
    DataValue::ulong_iterator DataValue::
    begin_ulong ()
    {
      return ulong_.begin ();
    }

    DataValue::ulong_iterator DataValue::
    end_ulong ()
    {
      return ulong_.end ();
    }

    DataValue::ulong_const_iterator DataValue::
    begin_ulong () const
    {
      return ulong_.begin ();
    }

    DataValue::ulong_const_iterator DataValue::
    end_ulong () const
    {
      return ulong_.end ();
    }

    void DataValue::
    add_ulong (ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedInt, ACE_Null_Mutex >  const& e)
    {
      ulong_.push_back (e);
    }

    size_t DataValue::
    count_ulong(void) const
    {
      return ulong_.size ();
    }

    // DataValue
    //
    DataValue::float_iterator DataValue::
    begin_float ()
    {
      return float__.begin ();
    }

    DataValue::float_iterator DataValue::
    end_float ()
    {
      return float__.end ();
    }

    DataValue::float_const_iterator DataValue::
    begin_float () const
    {
      return float__.begin ();
    }

    DataValue::float_const_iterator DataValue::
    end_float () const
    {
      return float__.end ();
    }

    void DataValue::
    add_float (ACE_Refcounted_Auto_Ptr < ::XMLSchema::float_, ACE_Null_Mutex >  const& e)
    {
      float__.push_back (e);
    }

    size_t DataValue::
    count_float(void) const
    {
      return float__.size ();
    }

    // DataValue
    //
    DataValue::double_iterator DataValue::
    begin_double ()
    {
      return double__.begin ();
    }

    DataValue::double_iterator DataValue::
    end_double ()
    {
      return double__.end ();
    }

    DataValue::double_const_iterator DataValue::
    begin_double () const
    {
      return double__.begin ();
    }

    DataValue::double_const_iterator DataValue::
    end_double () const
    {
      return double__.end ();
    }

    void DataValue::
    add_double (ACE_Refcounted_Auto_Ptr < ::XMLSchema::double_, ACE_Null_Mutex >  const& e)
    {
      double__.push_back (e);
    }

    size_t DataValue::
    count_double(void) const
    {
      return double__.size ();
    }

    // DataValue
    //
    DataValue::boolean_iterator DataValue::
    begin_boolean ()
    {
      return boolean_.begin ();
    }

    DataValue::boolean_iterator DataValue::
    end_boolean ()
    {
      return boolean_.end ();
    }

    DataValue::boolean_const_iterator DataValue::
    begin_boolean () const
    {
      return boolean_.begin ();
    }

    DataValue::boolean_const_iterator DataValue::
    end_boolean () const
    {
      return boolean_.end ();
    }

    void DataValue::
    add_boolean (ACE_Refcounted_Auto_Ptr < ::XMLSchema::boolean, ACE_Null_Mutex >  const& e)
    {
      boolean_.push_back (e);
    }

    size_t DataValue::
    count_boolean(void) const
    {
      return boolean_.size ();
    }

    // DataValue
    //
    DataValue::octet_iterator DataValue::
    begin_octet ()
    {
      return octet_.begin ();
    }

    DataValue::octet_iterator DataValue::
    end_octet ()
    {
      return octet_.end ();
    }

    DataValue::octet_const_iterator DataValue::
    begin_octet () const
    {
      return octet_.begin ();
    }

    DataValue::octet_const_iterator DataValue::
    end_octet () const
    {
      return octet_.end ();
    }

    void DataValue::
    add_octet (ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedByte, ACE_Null_Mutex >  const& e)
    {
      octet_.push_back (e);
    }

    size_t DataValue::
    count_octet(void) const
    {
      return octet_.size ();
    }

    // DataValue
    //
    DataValue::enum_iterator DataValue::
    begin_enum ()
    {
      return enum__.begin ();
    }

    DataValue::enum_iterator DataValue::
    end_enum ()
    {
      return enum__.end ();
    }

    DataValue::enum_const_iterator DataValue::
    begin_enum () const
    {
      return enum__.begin ();
    }

    DataValue::enum_const_iterator DataValue::
    end_enum () const
    {
      return enum__.end ();
    }

    void DataValue::
    add_enum (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      enum__.push_back (e);
    }

    size_t DataValue::
    count_enum(void) const
    {
      return enum__.size ();
    }

    // DataValue
    //
    DataValue::string_iterator DataValue::
    begin_string ()
    {
      return string_.begin ();
    }

    DataValue::string_iterator DataValue::
    end_string ()
    {
      return string_.end ();
    }

    DataValue::string_const_iterator DataValue::
    begin_string () const
    {
      return string_.begin ();
    }

    DataValue::string_const_iterator DataValue::
    end_string () const
    {
      return string_.end ();
    }

    void DataValue::
    add_string (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      string_.push_back (e);
    }

    size_t DataValue::
    count_string(void) const
    {
      return string_.size ();
    }

    // DataValue
    //
    DataValue::longlong_iterator DataValue::
    begin_longlong ()
    {
      return longlong_.begin ();
    }

    DataValue::longlong_iterator DataValue::
    end_longlong ()
    {
      return longlong_.end ();
    }

    DataValue::longlong_const_iterator DataValue::
    begin_longlong () const
    {
      return longlong_.begin ();
    }

    DataValue::longlong_const_iterator DataValue::
    end_longlong () const
    {
      return longlong_.end ();
    }

    void DataValue::
    add_longlong (ACE_Refcounted_Auto_Ptr < ::XMLSchema::long_, ACE_Null_Mutex >  const& e)
    {
      longlong_.push_back (e);
    }

    size_t DataValue::
    count_longlong(void) const
    {
      return longlong_.size ();
    }

    // DataValue
    //
    DataValue::ulonglong_iterator DataValue::
    begin_ulonglong ()
    {
      return ulonglong_.begin ();
    }

    DataValue::ulonglong_iterator DataValue::
    end_ulonglong ()
    {
      return ulonglong_.end ();
    }

    DataValue::ulonglong_const_iterator DataValue::
    begin_ulonglong () const
    {
      return ulonglong_.begin ();
    }

    DataValue::ulonglong_const_iterator DataValue::
    end_ulonglong () const
    {
      return ulonglong_.end ();
    }

    void DataValue::
    add_ulonglong (ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedLong, ACE_Null_Mutex >  const& e)
    {
      ulonglong_.push_back (e);
    }

    size_t DataValue::
    count_ulonglong(void) const
    {
      return ulonglong_.size ();
    }

    // DataValue
    //
    DataValue::longdouble_iterator DataValue::
    begin_longdouble ()
    {
      return longdouble_.begin ();
    }

    DataValue::longdouble_iterator DataValue::
    end_longdouble ()
    {
      return longdouble_.end ();
    }

    DataValue::longdouble_const_iterator DataValue::
    begin_longdouble () const
    {
      return longdouble_.begin ();
    }

    DataValue::longdouble_const_iterator DataValue::
    end_longdouble () const
    {
      return longdouble_.end ();
    }

    void DataValue::
    add_longdouble (ACE_Refcounted_Auto_Ptr < ::XMLSchema::double_, ACE_Null_Mutex >  const& e)
    {
      longdouble_.push_back (e);
    }

    size_t DataValue::
    count_longdouble(void) const
    {
      return longdouble_.size ();
    }

    // DataValue
    //
    DataValue::element_iterator DataValue::
    begin_element ()
    {
      return element_.begin ();
    }

    DataValue::element_iterator DataValue::
    end_element ()
    {
      return element_.end ();
    }

    DataValue::element_const_iterator DataValue::
    begin_element () const
    {
      return element_.begin ();
    }

    DataValue::element_const_iterator DataValue::
    end_element () const
    {
      return element_.end ();
    }

    void DataValue::
    add_element (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::DataValue, ACE_Null_Mutex >  const& e)
    {
      element_.push_back (e);
    }

    size_t DataValue::
    count_element(void) const
    {
      return element_.size ();
    }

    // DataValue
    //
    DataValue::member_iterator DataValue::
    begin_member ()
    {
      return member_.begin ();
    }

    DataValue::member_iterator DataValue::
    end_member ()
    {
      return member_.end ();
    }

    DataValue::member_const_iterator DataValue::
    begin_member () const
    {
      return member_.begin ();
    }

    DataValue::member_const_iterator DataValue::
    end_member () const
    {
      return member_.end ();
    }

    void DataValue::
    add_member (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::NamedValue, ACE_Null_Mutex >  const& e)
    {
      member_.push_back (e);
    }

    size_t DataValue::
    count_member(void) const
    {
      return member_.size ();
    }


    // AliasType
    //

    AliasType::
    AliasType (::XMLSchema::string< ACE_TCHAR > const& name__,
               ::XMLSchema::string< ACE_TCHAR > const& typeId__,
               ::DAnCE::Config_Handlers::DataType const& elementType__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (typeId__)),
    elementType_ (new ::DAnCE::Config_Handlers::DataType (elementType__)),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
      elementType_->container (this);
    }

    AliasType::
    AliasType (AliasType const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (*s.typeId_)),
    elementType_ (new ::DAnCE::Config_Handlers::DataType (*s.elementType_)),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
      elementType_->container (this);
    }

    AliasType& AliasType::
    operator= (AliasType const& s)
    {
      name (*s.name_);

      typeId (*s.typeId_);

      elementType (*s.elementType_);

      return *this;
    }


    // AliasType
    //
    ::XMLSchema::string< ACE_TCHAR > const& AliasType::
    name () const
    {
      return *name_;
    }

    void AliasType::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // AliasType
    //
    ::XMLSchema::string< ACE_TCHAR > const& AliasType::
    typeId () const
    {
      return *typeId_;
    }

    void AliasType::
    typeId (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *typeId_ = e;
    }

    // AliasType
    //
    ::DAnCE::Config_Handlers::DataType const& AliasType::
    elementType () const
    {
      return *elementType_;
    }

    void AliasType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // EnumType
    //

    EnumType::
    EnumType (::XMLSchema::string< ACE_TCHAR > const& name__,
              ::XMLSchema::string< ACE_TCHAR > const& typeId__,
              ::std::list< ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex > > const& member__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (typeId__)),
    member_ (member__),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
    }

    EnumType::
    EnumType (EnumType const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (*s.typeId_)),
    member_ (s.member_),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
    }

    EnumType& EnumType::
    operator= (EnumType const& s)
    {
      name (*s.name_);

      typeId (*s.typeId_);

      member_ = s.member_;

      return *this;
    }


    // EnumType
    //
    ::XMLSchema::string< ACE_TCHAR > const& EnumType::
    name () const
    {
      return *name_;
    }

    void EnumType::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // EnumType
    //
    ::XMLSchema::string< ACE_TCHAR > const& EnumType::
    typeId () const
    {
      return *typeId_;
    }

    void EnumType::
    typeId (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *typeId_ = e;
    }

    // EnumType
    //
    EnumType::member_iterator EnumType::
    begin_member ()
    {
      return member_.begin ();
    }

    EnumType::member_iterator EnumType::
    end_member ()
    {
      return member_.end ();
    }

    EnumType::member_const_iterator EnumType::
    begin_member () const
    {
      return member_.begin ();
    }

    EnumType::member_const_iterator EnumType::
    end_member () const
    {
      return member_.end ();
    }

    void EnumType::
    add_member (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      member_.push_back (e);
    }

    size_t EnumType::
    count_member(void) const
    {
      return member_.size ();
    }


    // StructType
    //

    StructType::
    StructType (::XMLSchema::string< ACE_TCHAR > const& name__,
                ::XMLSchema::string< ACE_TCHAR > const& typeId__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (typeId__)),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
    }

    StructType::
    StructType (StructType const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (*s.typeId_)),
    member_ (s.member_),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
    }

    StructType& StructType::
    operator= (StructType const& s)
    {
      name (*s.name_);

      typeId (*s.typeId_);

      member_ = s.member_;

      return *this;
    }


    // StructType
    //
    ::XMLSchema::string< ACE_TCHAR > const& StructType::
    name () const
    {
      return *name_;
    }

    void StructType::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // StructType
    //
    ::XMLSchema::string< ACE_TCHAR > const& StructType::
    typeId () const
    {
      return *typeId_;
    }

    void StructType::
    typeId (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *typeId_ = e;
    }

    // StructType
    //
    StructType::member_iterator StructType::
    begin_member ()
    {
      return member_.begin ();
    }

    StructType::member_iterator StructType::
    end_member ()
    {
      return member_.end ();
    }

    StructType::member_const_iterator StructType::
    begin_member () const
    {
      return member_.begin ();
    }

    StructType::member_const_iterator StructType::
    end_member () const
    {
      return member_.end ();
    }

    void StructType::
    add_member (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::StructMemberType, ACE_Null_Mutex >  const& e)
    {
      member_.push_back (e);
    }

    size_t StructType::
    count_member(void) const
    {
      return member_.size ();
    }


    // StructMemberType
    //

    StructMemberType::
    StructMemberType (::XMLSchema::string< ACE_TCHAR > const& name__,
                      ::DAnCE::Config_Handlers::DataType const& type__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    type_ (new ::DAnCE::Config_Handlers::DataType (type__)),
    regulator__ ()
    {
      name_->container (this);
      type_->container (this);
    }

    StructMemberType::
    StructMemberType (StructMemberType const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_)),
    regulator__ ()
    {
      name_->container (this);
      type_->container (this);
    }

    StructMemberType& StructMemberType::
    operator= (StructMemberType const& s)
    {
      name (*s.name_);

      type (*s.type_);

      return *this;
    }


    // StructMemberType
    //
    ::XMLSchema::string< ACE_TCHAR > const& StructMemberType::
    name () const
    {
      return *name_;
    }

    void StructMemberType::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // StructMemberType
    //
    ::DAnCE::Config_Handlers::DataType const& StructMemberType::
    type () const
    {
      return *type_;
    }

    void StructMemberType::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // ValueType
    //

    ValueType::
    ValueType (::XMLSchema::string< ACE_TCHAR > const& name__,
               ::XMLSchema::string< ACE_TCHAR > const& typeId__,
               ::XMLSchema::string< ACE_TCHAR > const& modifier__,
               ::DAnCE::Config_Handlers::DataType const& baseType__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (typeId__)),
    modifier_ (new ::XMLSchema::string< ACE_TCHAR > (modifier__)),
    baseType_ (new ::DAnCE::Config_Handlers::DataType (baseType__)),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
      modifier_->container (this);
      baseType_->container (this);
    }

    ValueType::
    ValueType (ValueType const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    typeId_ (new ::XMLSchema::string< ACE_TCHAR > (*s.typeId_)),
    modifier_ (new ::XMLSchema::string< ACE_TCHAR > (*s.modifier_)),
    baseType_ (new ::DAnCE::Config_Handlers::DataType (*s.baseType_)),
    member_ (s.member_),
    regulator__ ()
    {
      name_->container (this);
      typeId_->container (this);
      modifier_->container (this);
      baseType_->container (this);
    }

    ValueType& ValueType::
    operator= (ValueType const& s)
    {
      name (*s.name_);

      typeId (*s.typeId_);

      modifier (*s.modifier_);

      baseType (*s.baseType_);

      member_ = s.member_;

      return *this;
    }


    // ValueType
    //
    ::XMLSchema::string< ACE_TCHAR > const& ValueType::
    name () const
    {
      return *name_;
    }

    void ValueType::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // ValueType
    //
    ::XMLSchema::string< ACE_TCHAR > const& ValueType::
    typeId () const
    {
      return *typeId_;
    }

    void ValueType::
    typeId (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *typeId_ = e;
    }

    // ValueType
    //
    ::XMLSchema::string< ACE_TCHAR > const& ValueType::
    modifier () const
    {
      return *modifier_;
    }

    void ValueType::
    modifier (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *modifier_ = e;
    }

    // ValueType
    //
    ::DAnCE::Config_Handlers::DataType const& ValueType::
    baseType () const
    {
      return *baseType_;
    }

    void ValueType::
    baseType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *baseType_ = e;
    }

    // ValueType
    //
    ValueType::member_iterator ValueType::
    begin_member ()
    {
      return member_.begin ();
    }

    ValueType::member_iterator ValueType::
    end_member ()
    {
      return member_.end ();
    }

    ValueType::member_const_iterator ValueType::
    begin_member () const
    {
      return member_.begin ();
    }

    ValueType::member_const_iterator ValueType::
    end_member () const
    {
      return member_.end ();
    }

    void ValueType::
    add_member (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ValueMemberType, ACE_Null_Mutex >  const& e)
    {
      member_.push_back (e);
    }

    size_t ValueType::
    count_member(void) const
    {
      return member_.size ();
    }


    // ValueMemberType
    //

    ValueMemberType::
    ValueMemberType (::XMLSchema::string< ACE_TCHAR > const& name__,
                     ::XMLSchema::string< ACE_TCHAR > const& visibility__,
                     ::DAnCE::Config_Handlers::DataType const& type__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    visibility_ (new ::XMLSchema::string< ACE_TCHAR > (visibility__)),
    type_ (new ::DAnCE::Config_Handlers::DataType (type__)),
    regulator__ ()
    {
      name_->container (this);
      visibility_->container (this);
      type_->container (this);
    }

    ValueMemberType::
    ValueMemberType (ValueMemberType const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    visibility_ (new ::XMLSchema::string< ACE_TCHAR > (*s.visibility_)),
    type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_)),
    regulator__ ()
    {
      name_->container (this);
      visibility_->container (this);
      type_->container (this);
    }

    ValueMemberType& ValueMemberType::
    operator= (ValueMemberType const& s)
    {
      name (*s.name_);

      visibility (*s.visibility_);

      type (*s.type_);

      return *this;
    }


    // ValueMemberType
    //
    ::XMLSchema::string< ACE_TCHAR > const& ValueMemberType::
    name () const
    {
      return *name_;
    }

    void ValueMemberType::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // ValueMemberType
    //
    ::XMLSchema::string< ACE_TCHAR > const& ValueMemberType::
    visibility () const
    {
      return *visibility_;
    }

    void ValueMemberType::
    visibility (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *visibility_ = e;
    }

    // ValueMemberType
    //
    ::DAnCE::Config_Handlers::DataType const& ValueMemberType::
    type () const
    {
      return *type_;
    }

    void ValueMemberType::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // NamedValue
    //

    NamedValue::
    NamedValue (::XMLSchema::string< ACE_TCHAR > const& name__,
                ::DAnCE::Config_Handlers::DataValue const& value__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    value_ (new ::DAnCE::Config_Handlers::DataValue (value__)),
    regulator__ ()
    {
      name_->container (this);
      value_->container (this);
    }

    NamedValue::
    NamedValue (NamedValue const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    value_ (new ::DAnCE::Config_Handlers::DataValue (*s.value_)),
    regulator__ ()
    {
      name_->container (this);
      value_->container (this);
    }

    NamedValue& NamedValue::
    operator= (NamedValue const& s)
    {
      name (*s.name_);

      value (*s.value_);

      return *this;
    }


    // NamedValue
    //
    ::XMLSchema::string< ACE_TCHAR > const& NamedValue::
    name () const
    {
      return *name_;
    }

    void NamedValue::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // NamedValue
    //
    ::DAnCE::Config_Handlers::DataValue const& NamedValue::
    value () const
    {
      return *value_;
    }

    void NamedValue::
    value (::DAnCE::Config_Handlers::DataValue const& e)
    {
      *value_ = e;
    }


    // SequenceType
    //

    SequenceType::
    SequenceType (::DAnCE::Config_Handlers::DataType const& elementType__)
    :
    elementType_ (new ::DAnCE::Config_Handlers::DataType (elementType__)),
    regulator__ ()
    {
      elementType_->container (this);
    }

    SequenceType::
    SequenceType (SequenceType const& s)
    :
    ::XSCRT::Type (),
    bound_ (s.bound_.get () ? new ::XMLSchema::unsignedInt (*s.bound_) : 0),
    elementType_ (new ::DAnCE::Config_Handlers::DataType (*s.elementType_)),
    regulator__ ()
    {
      if (bound_.get ()) bound_->container (this);
      elementType_->container (this);
    }

    SequenceType& SequenceType::
    operator= (SequenceType const& s)
    {
      if (s.bound_.get ())
        bound (*(s.bound_));
      else
        bound_.reset (0);

      elementType (*s.elementType_);

      return *this;
    }


    // SequenceType
    //
    bool SequenceType::
    bound_p () const
    {
      return bound_.get () != 0;
    }

    ::XMLSchema::unsignedInt const& SequenceType::
    bound () const
    {
      return *bound_;
    }

    void SequenceType::
    bound (::XMLSchema::unsignedInt const& e)
    {
      if (bound_.get ())
      {
        *bound_ = e;
      }

      else
      {
        bound_ = ::std::auto_ptr< ::XMLSchema::unsignedInt > (new ::XMLSchema::unsignedInt (e));
        bound_->container (this);
      }
    }

    // SequenceType
    //
    ::DAnCE::Config_Handlers::DataType const& SequenceType::
    elementType () const
    {
      return *elementType_;
    }

    void SequenceType::
    elementType (::DAnCE::Config_Handlers::DataType const& e)
    {
      *elementType_ = e;
    }


    // Any
    //

    Any::
    Any (::DAnCE::Config_Handlers::DataType const& type__,
         ::DAnCE::Config_Handlers::DataValue const& value__)
    :
    type_ (new ::DAnCE::Config_Handlers::DataType (type__)),
    value_ (new ::DAnCE::Config_Handlers::DataValue (value__)),
    regulator__ ()
    {
      type_->container (this);
      value_->container (this);
    }

    Any::
    Any (Any const& s)
    :
    ::XSCRT::Type (),
    type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_)),
    value_ (new ::DAnCE::Config_Handlers::DataValue (*s.value_)),
    regulator__ ()
    {
      type_->container (this);
      value_->container (this);
    }

    Any& Any::
    operator= (Any const& s)
    {
      type (*s.type_);

      value (*s.value_);

      return *this;
    }


    // Any
    //
    ::DAnCE::Config_Handlers::DataType const& Any::
    type () const
    {
      return *type_;
    }

    void Any::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }

    // Any
    //
    ::DAnCE::Config_Handlers::DataValue const& Any::
    value () const
    {
      return *value_;
    }

    void Any::
    value (::DAnCE::Config_Handlers::DataValue const& e)
    {
      *value_ = e;
    }


    // Property
    //

    Property::
    Property (::XMLSchema::string< ACE_TCHAR > const& name__,
              ::DAnCE::Config_Handlers::Any const& value__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    value_ (new ::DAnCE::Config_Handlers::Any (value__)),
    regulator__ ()
    {
      name_->container (this);
      value_->container (this);
    }

    Property::
    Property (Property const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    value_ (new ::DAnCE::Config_Handlers::Any (*s.value_)),
    regulator__ ()
    {
      name_->container (this);
      value_->container (this);
    }

    Property& Property::
    operator= (Property const& s)
    {
      name (*s.name_);

      value (*s.value_);

      return *this;
    }


    // Property
    //
    ::XMLSchema::string< ACE_TCHAR > const& Property::
    name () const
    {
      return *name_;
    }

    void Property::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Property
    //
    ::DAnCE::Config_Handlers::Any const& Property::
    value () const
    {
      return *value_;
    }

    void Property::
    value (::DAnCE::Config_Handlers::Any const& e)
    {
      *value_ = e;
    }


    // SatisfierPropertyKind
    //

    SatisfierPropertyKind::Value SatisfierPropertyKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::SatisfierPropertyKind const& a, ::DAnCE::Config_Handlers::SatisfierPropertyKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::SatisfierPropertyKind const& a, ::DAnCE::Config_Handlers::SatisfierPropertyKind const& b)
    {
      return a.v_ != b.v_;
    }

    SatisfierPropertyKind::
    SatisfierPropertyKind (SatisfierPropertyKind::Value v)
    : v_ (v)
    {
    }

    // SatisfierProperty
    //

    SatisfierProperty::
    SatisfierProperty (::XMLSchema::string< ACE_TCHAR > const& name__,
                       ::DAnCE::Config_Handlers::SatisfierPropertyKind const& kind__,
                       ::XMLSchema::boolean const& dynamic__,
                       ::DAnCE::Config_Handlers::Any const& value__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    kind_ (new ::DAnCE::Config_Handlers::SatisfierPropertyKind (kind__)),
    dynamic_ (new ::XMLSchema::boolean (dynamic__)),
    value_ (new ::DAnCE::Config_Handlers::Any (value__)),
    regulator__ ()
    {
      name_->container (this);
      kind_->container (this);
      dynamic_->container (this);
      value_->container (this);
    }

    SatisfierProperty::
    SatisfierProperty (SatisfierProperty const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    kind_ (new ::DAnCE::Config_Handlers::SatisfierPropertyKind (*s.kind_)),
    dynamic_ (new ::XMLSchema::boolean (*s.dynamic_)),
    value_ (new ::DAnCE::Config_Handlers::Any (*s.value_)),
    regulator__ ()
    {
      name_->container (this);
      kind_->container (this);
      dynamic_->container (this);
      value_->container (this);
    }

    SatisfierProperty& SatisfierProperty::
    operator= (SatisfierProperty const& s)
    {
      name (*s.name_);

      kind (*s.kind_);

      dynamic (*s.dynamic_);

      value (*s.value_);

      return *this;
    }


    // SatisfierProperty
    //
    ::XMLSchema::string< ACE_TCHAR > const& SatisfierProperty::
    name () const
    {
      return *name_;
    }

    void SatisfierProperty::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // SatisfierProperty
    //
    ::DAnCE::Config_Handlers::SatisfierPropertyKind const& SatisfierProperty::
    kind () const
    {
      return *kind_;
    }

    void SatisfierProperty::
    kind (::DAnCE::Config_Handlers::SatisfierPropertyKind const& e)
    {
      *kind_ = e;
    }

    // SatisfierProperty
    //
    ::XMLSchema::boolean const& SatisfierProperty::
    dynamic () const
    {
      return *dynamic_;
    }

    void SatisfierProperty::
    dynamic (::XMLSchema::boolean const& e)
    {
      *dynamic_ = e;
    }

    // SatisfierProperty
    //
    ::DAnCE::Config_Handlers::Any const& SatisfierProperty::
    value () const
    {
      return *value_;
    }

    void SatisfierProperty::
    value (::DAnCE::Config_Handlers::Any const& e)
    {
      *value_ = e;
    }


    // Resource
    //

    Resource::
    Resource (::XMLSchema::string< ACE_TCHAR > const& name__,
              ::std::list< ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex > > const& resourceType__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    resourceType_ (resourceType__),
    regulator__ ()
    {
      name_->container (this);
    }

    Resource::
    Resource (Resource const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    resourceType_ (s.resourceType_),
    property_ (s.property_),
    regulator__ ()
    {
      name_->container (this);
    }

    Resource& Resource::
    operator= (Resource const& s)
    {
      name (*s.name_);

      resourceType_ = s.resourceType_;

      property_ = s.property_;

      return *this;
    }


    // Resource
    //
    ::XMLSchema::string< ACE_TCHAR > const& Resource::
    name () const
    {
      return *name_;
    }

    void Resource::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Resource
    //
    Resource::resourceType_iterator Resource::
    begin_resourceType ()
    {
      return resourceType_.begin ();
    }

    Resource::resourceType_iterator Resource::
    end_resourceType ()
    {
      return resourceType_.end ();
    }

    Resource::resourceType_const_iterator Resource::
    begin_resourceType () const
    {
      return resourceType_.begin ();
    }

    Resource::resourceType_const_iterator Resource::
    end_resourceType () const
    {
      return resourceType_.end ();
    }

    void Resource::
    add_resourceType (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      resourceType_.push_back (e);
    }

    size_t Resource::
    count_resourceType(void) const
    {
      return resourceType_.size ();
    }

    // Resource
    //
    Resource::property_iterator Resource::
    begin_property ()
    {
      return property_.begin ();
    }

    Resource::property_iterator Resource::
    end_property ()
    {
      return property_.end ();
    }

    Resource::property_const_iterator Resource::
    begin_property () const
    {
      return property_.begin ();
    }

    Resource::property_const_iterator Resource::
    end_property () const
    {
      return property_.end ();
    }

    void Resource::
    add_property (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SatisfierProperty, ACE_Null_Mutex >  const& e)
    {
      property_.push_back (e);
    }

    size_t Resource::
    count_property(void) const
    {
      return property_.size ();
    }


    // Requirement
    //

    Requirement::
    Requirement (::XMLSchema::string< ACE_TCHAR > const& name__,
                 ::XMLSchema::string< ACE_TCHAR > const& resourceType__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (resourceType__)),
    regulator__ ()
    {
      name_->container (this);
      resourceType_->container (this);
    }

    Requirement::
    Requirement (Requirement const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (*s.resourceType_)),
    property_ (s.property_),
    regulator__ ()
    {
      name_->container (this);
      resourceType_->container (this);
    }

    Requirement& Requirement::
    operator= (Requirement const& s)
    {
      name (*s.name_);

      resourceType (*s.resourceType_);

      property_ = s.property_;

      return *this;
    }


    // Requirement
    //
    ::XMLSchema::string< ACE_TCHAR > const& Requirement::
    name () const
    {
      return *name_;
    }

    void Requirement::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Requirement
    //
    ::XMLSchema::string< ACE_TCHAR > const& Requirement::
    resourceType () const
    {
      return *resourceType_;
    }

    void Requirement::
    resourceType (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *resourceType_ = e;
    }

    // Requirement
    //
    Requirement::property_iterator Requirement::
    begin_property ()
    {
      return property_.begin ();
    }

    Requirement::property_iterator Requirement::
    end_property ()
    {
      return property_.end ();
    }

    Requirement::property_const_iterator Requirement::
    begin_property () const
    {
      return property_.begin ();
    }

    Requirement::property_const_iterator Requirement::
    end_property () const
    {
      return property_.end ();
    }

    void Requirement::
    add_property (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      property_.push_back (e);
    }

    size_t Requirement::
    count_property(void) const
    {
      return property_.size ();
    }


    // ResourceDeploymentDescription
    //

    ResourceDeploymentDescription::
    ResourceDeploymentDescription (::XMLSchema::string< ACE_TCHAR > const& requirementName__,
                                   ::XMLSchema::string< ACE_TCHAR > const& resourceName__)
    :
    requirementName_ (new ::XMLSchema::string< ACE_TCHAR > (requirementName__)),
    resourceName_ (new ::XMLSchema::string< ACE_TCHAR > (resourceName__)),
    regulator__ ()
    {
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ResourceDeploymentDescription::
    ResourceDeploymentDescription (ResourceDeploymentDescription const& s)
    :
    ::XSCRT::Type (),
    requirementName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.requirementName_)),
    resourceName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.resourceName_)),
    property_ (s.property_),
    regulator__ ()
    {
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ResourceDeploymentDescription& ResourceDeploymentDescription::
    operator= (ResourceDeploymentDescription const& s)
    {
      requirementName (*s.requirementName_);

      resourceName (*s.resourceName_);

      property_ = s.property_;

      return *this;
    }


    // ResourceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void ResourceDeploymentDescription::
    requirementName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *requirementName_ = e;
    }

    // ResourceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void ResourceDeploymentDescription::
    resourceName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *resourceName_ = e;
    }

    // ResourceDeploymentDescription
    //
    ResourceDeploymentDescription::property_iterator ResourceDeploymentDescription::
    begin_property ()
    {
      return property_.begin ();
    }

    ResourceDeploymentDescription::property_iterator ResourceDeploymentDescription::
    end_property ()
    {
      return property_.end ();
    }

    ResourceDeploymentDescription::property_const_iterator ResourceDeploymentDescription::
    begin_property () const
    {
      return property_.begin ();
    }

    ResourceDeploymentDescription::property_const_iterator ResourceDeploymentDescription::
    end_property () const
    {
      return property_.end ();
    }

    void ResourceDeploymentDescription::
    add_property (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      property_.push_back (e);
    }

    size_t ResourceDeploymentDescription::
    count_property(void) const
    {
      return property_.size ();
    }


    // ArtifactDeploymentDescription
    //

    ArtifactDeploymentDescription::
    ArtifactDeploymentDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                                   ::XMLSchema::string< ACE_TCHAR > const& node__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    node_ (new ::XMLSchema::string< ACE_TCHAR > (node__)),
    regulator__ ()
    {
      name_->container (this);
      node_->container (this);
    }

    ArtifactDeploymentDescription::
    ArtifactDeploymentDescription (ArtifactDeploymentDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    source_ (s.source_),
    node_ (new ::XMLSchema::string< ACE_TCHAR > (*s.node_)),
    location_ (s.location_),
    execParameter_ (s.execParameter_),
    deployRequirement_ (s.deployRequirement_),
    deployedResource_ (s.deployedResource_),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      name_->container (this);
      node_->container (this);
      if (id_.get ()) id_->container (this);
    }

    ArtifactDeploymentDescription& ArtifactDeploymentDescription::
    operator= (ArtifactDeploymentDescription const& s)
    {
      name (*s.name_);

      source_ = s.source_;

      node (*s.node_);

      location_ = s.location_;

      execParameter_ = s.execParameter_;

      deployRequirement_ = s.deployRequirement_;

      deployedResource_ = s.deployedResource_;

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // ArtifactDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ArtifactDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void ArtifactDeploymentDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // ArtifactDeploymentDescription
    //
    ArtifactDeploymentDescription::source_iterator ArtifactDeploymentDescription::
    begin_source ()
    {
      return source_.begin ();
    }

    ArtifactDeploymentDescription::source_iterator ArtifactDeploymentDescription::
    end_source ()
    {
      return source_.end ();
    }

    ArtifactDeploymentDescription::source_const_iterator ArtifactDeploymentDescription::
    begin_source () const
    {
      return source_.begin ();
    }

    ArtifactDeploymentDescription::source_const_iterator ArtifactDeploymentDescription::
    end_source () const
    {
      return source_.end ();
    }

    void ArtifactDeploymentDescription::
    add_source (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      source_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_source(void) const
    {
      return source_.size ();
    }

    // ArtifactDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ArtifactDeploymentDescription::
    node () const
    {
      return *node_;
    }

    void ArtifactDeploymentDescription::
    node (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *node_ = e;
    }

    // ArtifactDeploymentDescription
    //
    ArtifactDeploymentDescription::location_iterator ArtifactDeploymentDescription::
    begin_location ()
    {
      return location_.begin ();
    }

    ArtifactDeploymentDescription::location_iterator ArtifactDeploymentDescription::
    end_location ()
    {
      return location_.end ();
    }

    ArtifactDeploymentDescription::location_const_iterator ArtifactDeploymentDescription::
    begin_location () const
    {
      return location_.begin ();
    }

    ArtifactDeploymentDescription::location_const_iterator ArtifactDeploymentDescription::
    end_location () const
    {
      return location_.end ();
    }

    void ArtifactDeploymentDescription::
    add_location (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      location_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_location(void) const
    {
      return location_.size ();
    }

    // ArtifactDeploymentDescription
    //
    ArtifactDeploymentDescription::execParameter_iterator ArtifactDeploymentDescription::
    begin_execParameter ()
    {
      return execParameter_.begin ();
    }

    ArtifactDeploymentDescription::execParameter_iterator ArtifactDeploymentDescription::
    end_execParameter ()
    {
      return execParameter_.end ();
    }

    ArtifactDeploymentDescription::execParameter_const_iterator ArtifactDeploymentDescription::
    begin_execParameter () const
    {
      return execParameter_.begin ();
    }

    ArtifactDeploymentDescription::execParameter_const_iterator ArtifactDeploymentDescription::
    end_execParameter () const
    {
      return execParameter_.end ();
    }

    void ArtifactDeploymentDescription::
    add_execParameter (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      execParameter_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_execParameter(void) const
    {
      return execParameter_.size ();
    }

    // ArtifactDeploymentDescription
    //
    ArtifactDeploymentDescription::deployRequirement_iterator ArtifactDeploymentDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    ArtifactDeploymentDescription::deployRequirement_iterator ArtifactDeploymentDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    ArtifactDeploymentDescription::deployRequirement_const_iterator ArtifactDeploymentDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    ArtifactDeploymentDescription::deployRequirement_const_iterator ArtifactDeploymentDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void ArtifactDeploymentDescription::
    add_deployRequirement (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // ArtifactDeploymentDescription
    //
    ArtifactDeploymentDescription::deployedResource_iterator ArtifactDeploymentDescription::
    begin_deployedResource ()
    {
      return deployedResource_.begin ();
    }

    ArtifactDeploymentDescription::deployedResource_iterator ArtifactDeploymentDescription::
    end_deployedResource ()
    {
      return deployedResource_.end ();
    }

    ArtifactDeploymentDescription::deployedResource_const_iterator ArtifactDeploymentDescription::
    begin_deployedResource () const
    {
      return deployedResource_.begin ();
    }

    ArtifactDeploymentDescription::deployedResource_const_iterator ArtifactDeploymentDescription::
    end_deployedResource () const
    {
      return deployedResource_.end ();
    }

    void ArtifactDeploymentDescription::
    add_deployedResource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ResourceDeploymentDescription, ACE_Null_Mutex >  const& e)
    {
      deployedResource_.push_back (e);
    }

    size_t ArtifactDeploymentDescription::
    count_deployedResource(void) const
    {
      return deployedResource_.size ();
    }

    // ArtifactDeploymentDescription
    //
    bool ArtifactDeploymentDescription::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& ArtifactDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& ArtifactDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void ArtifactDeploymentDescription::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // MonolithicDeploymentDescription
    //

    MonolithicDeploymentDescription::
    MonolithicDeploymentDescription (::XMLSchema::string< ACE_TCHAR > const& name__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    MonolithicDeploymentDescription::
    MonolithicDeploymentDescription (MonolithicDeploymentDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    source_ (s.source_),
    artifact_ (s.artifact_),
    execParameter_ (s.execParameter_),
    deployRequirement_ (s.deployRequirement_),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      name_->container (this);
      if (id_.get ()) id_->container (this);
    }

    MonolithicDeploymentDescription& MonolithicDeploymentDescription::
    operator= (MonolithicDeploymentDescription const& s)
    {
      name (*s.name_);

      source_ = s.source_;

      artifact_ = s.artifact_;

      execParameter_ = s.execParameter_;

      deployRequirement_ = s.deployRequirement_;

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // MonolithicDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& MonolithicDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void MonolithicDeploymentDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // MonolithicDeploymentDescription
    //
    MonolithicDeploymentDescription::source_iterator MonolithicDeploymentDescription::
    begin_source ()
    {
      return source_.begin ();
    }

    MonolithicDeploymentDescription::source_iterator MonolithicDeploymentDescription::
    end_source ()
    {
      return source_.end ();
    }

    MonolithicDeploymentDescription::source_const_iterator MonolithicDeploymentDescription::
    begin_source () const
    {
      return source_.begin ();
    }

    MonolithicDeploymentDescription::source_const_iterator MonolithicDeploymentDescription::
    end_source () const
    {
      return source_.end ();
    }

    void MonolithicDeploymentDescription::
    add_source (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      source_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_source(void) const
    {
      return source_.size ();
    }

    // MonolithicDeploymentDescription
    //
    MonolithicDeploymentDescription::artifact_iterator MonolithicDeploymentDescription::
    begin_artifact ()
    {
      return artifact_.begin ();
    }

    MonolithicDeploymentDescription::artifact_iterator MonolithicDeploymentDescription::
    end_artifact ()
    {
      return artifact_.end ();
    }

    MonolithicDeploymentDescription::artifact_const_iterator MonolithicDeploymentDescription::
    begin_artifact () const
    {
      return artifact_.begin ();
    }

    MonolithicDeploymentDescription::artifact_const_iterator MonolithicDeploymentDescription::
    end_artifact () const
    {
      return artifact_.end ();
    }

    void MonolithicDeploymentDescription::
    add_artifact (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::IdRef, ACE_Null_Mutex >  const& e)
    {
      artifact_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_artifact(void) const
    {
      return artifact_.size ();
    }

    // MonolithicDeploymentDescription
    //
    MonolithicDeploymentDescription::execParameter_iterator MonolithicDeploymentDescription::
    begin_execParameter ()
    {
      return execParameter_.begin ();
    }

    MonolithicDeploymentDescription::execParameter_iterator MonolithicDeploymentDescription::
    end_execParameter ()
    {
      return execParameter_.end ();
    }

    MonolithicDeploymentDescription::execParameter_const_iterator MonolithicDeploymentDescription::
    begin_execParameter () const
    {
      return execParameter_.begin ();
    }

    MonolithicDeploymentDescription::execParameter_const_iterator MonolithicDeploymentDescription::
    end_execParameter () const
    {
      return execParameter_.end ();
    }

    void MonolithicDeploymentDescription::
    add_execParameter (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      execParameter_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_execParameter(void) const
    {
      return execParameter_.size ();
    }

    // MonolithicDeploymentDescription
    //
    MonolithicDeploymentDescription::deployRequirement_iterator MonolithicDeploymentDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    MonolithicDeploymentDescription::deployRequirement_iterator MonolithicDeploymentDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    MonolithicDeploymentDescription::deployRequirement_const_iterator MonolithicDeploymentDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    MonolithicDeploymentDescription::deployRequirement_const_iterator MonolithicDeploymentDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void MonolithicDeploymentDescription::
    add_deployRequirement (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t MonolithicDeploymentDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // MonolithicDeploymentDescription
    //
    bool MonolithicDeploymentDescription::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& MonolithicDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& MonolithicDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void MonolithicDeploymentDescription::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // ResourceUsageKind
    //

    ResourceUsageKind::Value ResourceUsageKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::ResourceUsageKind const& a, ::DAnCE::Config_Handlers::ResourceUsageKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::ResourceUsageKind const& a, ::DAnCE::Config_Handlers::ResourceUsageKind const& b)
    {
      return a.v_ != b.v_;
    }

    ResourceUsageKind::
    ResourceUsageKind (ResourceUsageKind::Value v)
    : v_ (v)
    {
    }

    // InstanceResourceDeploymentDescription
    //

    InstanceResourceDeploymentDescription::
    InstanceResourceDeploymentDescription (::DAnCE::Config_Handlers::ResourceUsageKind const& resourceUsage__,
                                           ::XMLSchema::string< ACE_TCHAR > const& requirementName__,
                                           ::XMLSchema::string< ACE_TCHAR > const& resourceName__)
    :
    resourceUsage_ (new ::DAnCE::Config_Handlers::ResourceUsageKind (resourceUsage__)),
    requirementName_ (new ::XMLSchema::string< ACE_TCHAR > (requirementName__)),
    resourceName_ (new ::XMLSchema::string< ACE_TCHAR > (resourceName__)),
    regulator__ ()
    {
      resourceUsage_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    InstanceResourceDeploymentDescription::
    InstanceResourceDeploymentDescription (InstanceResourceDeploymentDescription const& s)
    :
    ::XSCRT::Type (),
    resourceUsage_ (new ::DAnCE::Config_Handlers::ResourceUsageKind (*s.resourceUsage_)),
    requirementName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.requirementName_)),
    resourceName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.resourceName_)),
    property_ (s.property_),
    regulator__ ()
    {
      resourceUsage_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    InstanceResourceDeploymentDescription& InstanceResourceDeploymentDescription::
    operator= (InstanceResourceDeploymentDescription const& s)
    {
      resourceUsage (*s.resourceUsage_);

      requirementName (*s.requirementName_);

      resourceName (*s.resourceName_);

      property_ = s.property_;

      return *this;
    }


    // InstanceResourceDeploymentDescription
    //
    ::DAnCE::Config_Handlers::ResourceUsageKind const& InstanceResourceDeploymentDescription::
    resourceUsage () const
    {
      return *resourceUsage_;
    }

    void InstanceResourceDeploymentDescription::
    resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& e)
    {
      *resourceUsage_ = e;
    }

    // InstanceResourceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& InstanceResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void InstanceResourceDeploymentDescription::
    requirementName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *requirementName_ = e;
    }

    // InstanceResourceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& InstanceResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void InstanceResourceDeploymentDescription::
    resourceName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *resourceName_ = e;
    }

    // InstanceResourceDeploymentDescription
    //
    InstanceResourceDeploymentDescription::property_iterator InstanceResourceDeploymentDescription::
    begin_property ()
    {
      return property_.begin ();
    }

    InstanceResourceDeploymentDescription::property_iterator InstanceResourceDeploymentDescription::
    end_property ()
    {
      return property_.end ();
    }

    InstanceResourceDeploymentDescription::property_const_iterator InstanceResourceDeploymentDescription::
    begin_property () const
    {
      return property_.begin ();
    }

    InstanceResourceDeploymentDescription::property_const_iterator InstanceResourceDeploymentDescription::
    end_property () const
    {
      return property_.end ();
    }

    void InstanceResourceDeploymentDescription::
    add_property (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      property_.push_back (e);
    }

    size_t InstanceResourceDeploymentDescription::
    count_property(void) const
    {
      return property_.size ();
    }


    // InstanceDeploymentDescription
    //

    InstanceDeploymentDescription::
    InstanceDeploymentDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                                   ::XMLSchema::string< ACE_TCHAR > const& node__,
                                   ::XMLSchema::string< ACE_TCHAR > const& source__,
                                   ::DAnCE::Config_Handlers::IdRef const& implementation__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    node_ (new ::XMLSchema::string< ACE_TCHAR > (node__)),
    source_ (new ::XMLSchema::string< ACE_TCHAR > (source__)),
    implementation_ (new ::DAnCE::Config_Handlers::IdRef (implementation__)),
    regulator__ ()
    {
      name_->container (this);
      node_->container (this);
      source_->container (this);
      implementation_->container (this);
    }

    InstanceDeploymentDescription::
    InstanceDeploymentDescription (InstanceDeploymentDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    node_ (new ::XMLSchema::string< ACE_TCHAR > (*s.node_)),
    source_ (new ::XMLSchema::string< ACE_TCHAR > (*s.source_)),
    implementation_ (new ::DAnCE::Config_Handlers::IdRef (*s.implementation_)),
    configProperty_ (s.configProperty_),
    deployedResource_ (s.deployedResource_),
    deployedSharedResource_ (s.deployedSharedResource_.get () ? new ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription (*s.deployedSharedResource_) : 0),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      name_->container (this);
      node_->container (this);
      source_->container (this);
      implementation_->container (this);
      if (deployedSharedResource_.get ()) deployedSharedResource_->container (this);
      if (id_.get ()) id_->container (this);
    }

    InstanceDeploymentDescription& InstanceDeploymentDescription::
    operator= (InstanceDeploymentDescription const& s)
    {
      name (*s.name_);

      node (*s.node_);

      source (*s.source_);

      implementation (*s.implementation_);

      configProperty_ = s.configProperty_;

      deployedResource_ = s.deployedResource_;

      if (s.deployedSharedResource_.get ())
        deployedSharedResource (*(s.deployedSharedResource_));
      else
        deployedSharedResource_.reset (0);

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // InstanceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& InstanceDeploymentDescription::
    name () const
    {
      return *name_;
    }

    void InstanceDeploymentDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // InstanceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& InstanceDeploymentDescription::
    node () const
    {
      return *node_;
    }

    void InstanceDeploymentDescription::
    node (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *node_ = e;
    }

    // InstanceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& InstanceDeploymentDescription::
    source () const
    {
      return *source_;
    }

    void InstanceDeploymentDescription::
    source (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *source_ = e;
    }

    // InstanceDeploymentDescription
    //
    ::DAnCE::Config_Handlers::IdRef const& InstanceDeploymentDescription::
    implementation () const
    {
      return *implementation_;
    }

    void InstanceDeploymentDescription::
    implementation (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *implementation_ = e;
    }

    // InstanceDeploymentDescription
    //
    InstanceDeploymentDescription::configProperty_iterator InstanceDeploymentDescription::
    begin_configProperty ()
    {
      return configProperty_.begin ();
    }

    InstanceDeploymentDescription::configProperty_iterator InstanceDeploymentDescription::
    end_configProperty ()
    {
      return configProperty_.end ();
    }

    InstanceDeploymentDescription::configProperty_const_iterator InstanceDeploymentDescription::
    begin_configProperty () const
    {
      return configProperty_.begin ();
    }

    InstanceDeploymentDescription::configProperty_const_iterator InstanceDeploymentDescription::
    end_configProperty () const
    {
      return configProperty_.end ();
    }

    void InstanceDeploymentDescription::
    add_configProperty (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      configProperty_.push_back (e);
    }

    size_t InstanceDeploymentDescription::
    count_configProperty(void) const
    {
      return configProperty_.size ();
    }

    // InstanceDeploymentDescription
    //
    InstanceDeploymentDescription::deployedResource_iterator InstanceDeploymentDescription::
    begin_deployedResource ()
    {
      return deployedResource_.begin ();
    }

    InstanceDeploymentDescription::deployedResource_iterator InstanceDeploymentDescription::
    end_deployedResource ()
    {
      return deployedResource_.end ();
    }

    InstanceDeploymentDescription::deployedResource_const_iterator InstanceDeploymentDescription::
    begin_deployedResource () const
    {
      return deployedResource_.begin ();
    }

    InstanceDeploymentDescription::deployedResource_const_iterator InstanceDeploymentDescription::
    end_deployedResource () const
    {
      return deployedResource_.end ();
    }

    void InstanceDeploymentDescription::
    add_deployedResource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription, ACE_Null_Mutex >  const& e)
    {
      deployedResource_.push_back (e);
    }

    size_t InstanceDeploymentDescription::
    count_deployedResource(void) const
    {
      return deployedResource_.size ();
    }

    // InstanceDeploymentDescription
    //
    bool InstanceDeploymentDescription::
    deployedSharedResource_p () const
    {
      return deployedSharedResource_.get () != 0;
    }

    ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription const& InstanceDeploymentDescription::
    deployedSharedResource () const
    {
      return *deployedSharedResource_;
    }

    void InstanceDeploymentDescription::
    deployedSharedResource (::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription const& e)
    {
      if (deployedSharedResource_.get ())
      {
        *deployedSharedResource_ = e;
      }

      else
      {
        deployedSharedResource_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription > (new ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription (e));
        deployedSharedResource_->container (this);
      }
    }

    // InstanceDeploymentDescription
    //
    bool InstanceDeploymentDescription::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& InstanceDeploymentDescription::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& InstanceDeploymentDescription::
    id ()
    {
      return *id_;
    }

    void InstanceDeploymentDescription::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // CCMComponentPortKind
    //

    CCMComponentPortKind::Value CCMComponentPortKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::CCMComponentPortKind const& a, ::DAnCE::Config_Handlers::CCMComponentPortKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::CCMComponentPortKind const& a, ::DAnCE::Config_Handlers::CCMComponentPortKind const& b)
    {
      return a.v_ != b.v_;
    }

    CCMComponentPortKind::
    CCMComponentPortKind (CCMComponentPortKind::Value v)
    : v_ (v)
    {
    }

    // ComponentPortDescription
    //

    ComponentPortDescription::
    ComponentPortDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                              ::XMLSchema::boolean const& provider__,
                              ::XMLSchema::boolean const& exclusiveProvider__,
                              ::XMLSchema::boolean const& exclusiveUser__,
                              ::XMLSchema::boolean const& optional__,
                              ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    provider_ (new ::XMLSchema::boolean (provider__)),
    exclusiveProvider_ (new ::XMLSchema::boolean (exclusiveProvider__)),
    exclusiveUser_ (new ::XMLSchema::boolean (exclusiveUser__)),
    optional_ (new ::XMLSchema::boolean (optional__)),
    kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (kind__)),
    regulator__ ()
    {
      name_->container (this);
      provider_->container (this);
      exclusiveProvider_->container (this);
      exclusiveUser_->container (this);
      optional_->container (this);
      kind_->container (this);
    }

    ComponentPortDescription::
    ComponentPortDescription (ComponentPortDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    specificType_ (s.specificType_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.specificType_) : 0),
    supportedType_ (s.supportedType_),
    provider_ (new ::XMLSchema::boolean (*s.provider_)),
    exclusiveProvider_ (new ::XMLSchema::boolean (*s.exclusiveProvider_)),
    exclusiveUser_ (new ::XMLSchema::boolean (*s.exclusiveUser_)),
    optional_ (new ::XMLSchema::boolean (*s.optional_)),
    kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (*s.kind_)),
    templateParam_ (s.templateParam_),
    regulator__ ()
    {
      name_->container (this);
      if (specificType_.get ()) specificType_->container (this);
      provider_->container (this);
      exclusiveProvider_->container (this);
      exclusiveUser_->container (this);
      optional_->container (this);
      kind_->container (this);
    }

    ComponentPortDescription& ComponentPortDescription::
    operator= (ComponentPortDescription const& s)
    {
      name (*s.name_);

      if (s.specificType_.get ())
        specificType (*(s.specificType_));
      else
        specificType_.reset (0);

      supportedType_ = s.supportedType_;

      provider (*s.provider_);

      exclusiveProvider (*s.exclusiveProvider_);

      exclusiveUser (*s.exclusiveUser_);

      optional (*s.optional_);

      kind (*s.kind_);

      templateParam_ = s.templateParam_;

      return *this;
    }


    // ComponentPortDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ComponentPortDescription::
    name () const
    {
      return *name_;
    }

    void ComponentPortDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // ComponentPortDescription
    //
    bool ComponentPortDescription::
    specificType_p () const
    {
      return specificType_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& ComponentPortDescription::
    specificType () const
    {
      return *specificType_;
    }

    void ComponentPortDescription::
    specificType (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (specificType_.get ())
      {
        *specificType_ = e;
      }

      else
      {
        specificType_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        specificType_->container (this);
      }
    }

    // ComponentPortDescription
    //
    ComponentPortDescription::supportedType_iterator ComponentPortDescription::
    begin_supportedType ()
    {
      return supportedType_.begin ();
    }

    ComponentPortDescription::supportedType_iterator ComponentPortDescription::
    end_supportedType ()
    {
      return supportedType_.end ();
    }

    ComponentPortDescription::supportedType_const_iterator ComponentPortDescription::
    begin_supportedType () const
    {
      return supportedType_.begin ();
    }

    ComponentPortDescription::supportedType_const_iterator ComponentPortDescription::
    end_supportedType () const
    {
      return supportedType_.end ();
    }

    void ComponentPortDescription::
    add_supportedType (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      supportedType_.push_back (e);
    }

    size_t ComponentPortDescription::
    count_supportedType(void) const
    {
      return supportedType_.size ();
    }

    // ComponentPortDescription
    //
    ::XMLSchema::boolean const& ComponentPortDescription::
    provider () const
    {
      return *provider_;
    }

    void ComponentPortDescription::
    provider (::XMLSchema::boolean const& e)
    {
      *provider_ = e;
    }

    // ComponentPortDescription
    //
    ::XMLSchema::boolean const& ComponentPortDescription::
    exclusiveProvider () const
    {
      return *exclusiveProvider_;
    }

    void ComponentPortDescription::
    exclusiveProvider (::XMLSchema::boolean const& e)
    {
      *exclusiveProvider_ = e;
    }

    // ComponentPortDescription
    //
    ::XMLSchema::boolean const& ComponentPortDescription::
    exclusiveUser () const
    {
      return *exclusiveUser_;
    }

    void ComponentPortDescription::
    exclusiveUser (::XMLSchema::boolean const& e)
    {
      *exclusiveUser_ = e;
    }

    // ComponentPortDescription
    //
    ::XMLSchema::boolean const& ComponentPortDescription::
    optional () const
    {
      return *optional_;
    }

    void ComponentPortDescription::
    optional (::XMLSchema::boolean const& e)
    {
      *optional_ = e;
    }

    // ComponentPortDescription
    //
    ::DAnCE::Config_Handlers::CCMComponentPortKind const& ComponentPortDescription::
    kind () const
    {
      return *kind_;
    }

    void ComponentPortDescription::
    kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& e)
    {
      *kind_ = e;
    }

    // ComponentPortDescription
    //
    ComponentPortDescription::templateParam_iterator ComponentPortDescription::
    begin_templateParam ()
    {
      return templateParam_.begin ();
    }

    ComponentPortDescription::templateParam_iterator ComponentPortDescription::
    end_templateParam ()
    {
      return templateParam_.end ();
    }

    ComponentPortDescription::templateParam_const_iterator ComponentPortDescription::
    begin_templateParam () const
    {
      return templateParam_.begin ();
    }

    ComponentPortDescription::templateParam_const_iterator ComponentPortDescription::
    end_templateParam () const
    {
      return templateParam_.end ();
    }

    void ComponentPortDescription::
    add_templateParam (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      templateParam_.push_back (e);
    }

    size_t ComponentPortDescription::
    count_templateParam(void) const
    {
      return templateParam_.size ();
    }


    // ComponentPropertyDescription
    //

    ComponentPropertyDescription::
    ComponentPropertyDescription (::XMLSchema::string< ACE_TCHAR > const& name__,
                                  ::DAnCE::Config_Handlers::DataType const& type__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    type_ (new ::DAnCE::Config_Handlers::DataType (type__)),
    regulator__ ()
    {
      name_->container (this);
      type_->container (this);
    }

    ComponentPropertyDescription::
    ComponentPropertyDescription (ComponentPropertyDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    type_ (new ::DAnCE::Config_Handlers::DataType (*s.type_)),
    regulator__ ()
    {
      name_->container (this);
      type_->container (this);
    }

    ComponentPropertyDescription& ComponentPropertyDescription::
    operator= (ComponentPropertyDescription const& s)
    {
      name (*s.name_);

      type (*s.type_);

      return *this;
    }


    // ComponentPropertyDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ComponentPropertyDescription::
    name () const
    {
      return *name_;
    }

    void ComponentPropertyDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // ComponentPropertyDescription
    //
    ::DAnCE::Config_Handlers::DataType const& ComponentPropertyDescription::
    type () const
    {
      return *type_;
    }

    void ComponentPropertyDescription::
    type (::DAnCE::Config_Handlers::DataType const& e)
    {
      *type_ = e;
    }


    // ComponentExternalPortEndpoint
    //

    ComponentExternalPortEndpoint::
    ComponentExternalPortEndpoint (::XMLSchema::string< ACE_TCHAR > const& portName__)
    :
    portName_ (new ::XMLSchema::string< ACE_TCHAR > (portName__)),
    regulator__ ()
    {
      portName_->container (this);
    }

    ComponentExternalPortEndpoint::
    ComponentExternalPortEndpoint (ComponentExternalPortEndpoint const& s)
    :
    ::XSCRT::Type (),
    portName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.portName_)),
    regulator__ ()
    {
      portName_->container (this);
    }

    ComponentExternalPortEndpoint& ComponentExternalPortEndpoint::
    operator= (ComponentExternalPortEndpoint const& s)
    {
      portName (*s.portName_);

      return *this;
    }


    // ComponentExternalPortEndpoint
    //
    ::XMLSchema::string< ACE_TCHAR > const& ComponentExternalPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void ComponentExternalPortEndpoint::
    portName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *portName_ = e;
    }


    // PlanSubcomponentPortEndpoint
    //

    PlanSubcomponentPortEndpoint::
    PlanSubcomponentPortEndpoint (::XMLSchema::string< ACE_TCHAR > const& portName__,
                                  ::DAnCE::Config_Handlers::CCMComponentPortKind const& kind__,
                                  ::DAnCE::Config_Handlers::IdRef const& instance__)
    :
    portName_ (new ::XMLSchema::string< ACE_TCHAR > (portName__)),
    kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (kind__)),
    instance_ (new ::DAnCE::Config_Handlers::IdRef (instance__)),
    regulator__ ()
    {
      portName_->container (this);
      kind_->container (this);
      instance_->container (this);
    }

    PlanSubcomponentPortEndpoint::
    PlanSubcomponentPortEndpoint (PlanSubcomponentPortEndpoint const& s)
    :
    ::XSCRT::Type (),
    portName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.portName_)),
    provider_ (s.provider_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.provider_) : 0),
    kind_ (new ::DAnCE::Config_Handlers::CCMComponentPortKind (*s.kind_)),
    instance_ (new ::DAnCE::Config_Handlers::IdRef (*s.instance_)),
    regulator__ ()
    {
      portName_->container (this);
      if (provider_.get ()) provider_->container (this);
      kind_->container (this);
      instance_->container (this);
    }

    PlanSubcomponentPortEndpoint& PlanSubcomponentPortEndpoint::
    operator= (PlanSubcomponentPortEndpoint const& s)
    {
      portName (*s.portName_);

      if (s.provider_.get ())
        provider (*(s.provider_));
      else
        provider_.reset (0);

      kind (*s.kind_);

      instance (*s.instance_);

      return *this;
    }


    // PlanSubcomponentPortEndpoint
    //
    ::XMLSchema::string< ACE_TCHAR > const& PlanSubcomponentPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void PlanSubcomponentPortEndpoint::
    portName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *portName_ = e;
    }

    // PlanSubcomponentPortEndpoint
    //
    bool PlanSubcomponentPortEndpoint::
    provider_p () const
    {
      return provider_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& PlanSubcomponentPortEndpoint::
    provider () const
    {
      return *provider_;
    }

    void PlanSubcomponentPortEndpoint::
    provider (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (provider_.get ())
      {
        *provider_ = e;
      }

      else
      {
        provider_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        provider_->container (this);
      }
    }

    // PlanSubcomponentPortEndpoint
    //
    ::DAnCE::Config_Handlers::CCMComponentPortKind const& PlanSubcomponentPortEndpoint::
    kind () const
    {
      return *kind_;
    }

    void PlanSubcomponentPortEndpoint::
    kind (::DAnCE::Config_Handlers::CCMComponentPortKind const& e)
    {
      *kind_ = e;
    }

    // PlanSubcomponentPortEndpoint
    //
    ::DAnCE::Config_Handlers::IdRef const& PlanSubcomponentPortEndpoint::
    instance () const
    {
      return *instance_;
    }

    void PlanSubcomponentPortEndpoint::
    instance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *instance_ = e;
    }


    // ExternalReferenceEndpoint
    //

    ExternalReferenceEndpoint::
    ExternalReferenceEndpoint (::XMLSchema::string< ACE_TCHAR > const& location__,
                               ::XMLSchema::boolean const& provider__)
    :
    location_ (new ::XMLSchema::string< ACE_TCHAR > (location__)),
    provider_ (new ::XMLSchema::boolean (provider__)),
    regulator__ ()
    {
      location_->container (this);
      provider_->container (this);
    }

    ExternalReferenceEndpoint::
    ExternalReferenceEndpoint (ExternalReferenceEndpoint const& s)
    :
    ::XSCRT::Type (),
    location_ (new ::XMLSchema::string< ACE_TCHAR > (*s.location_)),
    provider_ (new ::XMLSchema::boolean (*s.provider_)),
    portName_ (s.portName_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.portName_) : 0),
    supportedType_ (s.supportedType_),
    regulator__ ()
    {
      location_->container (this);
      provider_->container (this);
      if (portName_.get ()) portName_->container (this);
    }

    ExternalReferenceEndpoint& ExternalReferenceEndpoint::
    operator= (ExternalReferenceEndpoint const& s)
    {
      location (*s.location_);

      provider (*s.provider_);

      if (s.portName_.get ())
        portName (*(s.portName_));
      else
        portName_.reset (0);

      supportedType_ = s.supportedType_;

      return *this;
    }


    // ExternalReferenceEndpoint
    //
    ::XMLSchema::string< ACE_TCHAR > const& ExternalReferenceEndpoint::
    location () const
    {
      return *location_;
    }

    void ExternalReferenceEndpoint::
    location (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *location_ = e;
    }

    // ExternalReferenceEndpoint
    //
    ::XMLSchema::boolean const& ExternalReferenceEndpoint::
    provider () const
    {
      return *provider_;
    }

    void ExternalReferenceEndpoint::
    provider (::XMLSchema::boolean const& e)
    {
      *provider_ = e;
    }

    // ExternalReferenceEndpoint
    //
    bool ExternalReferenceEndpoint::
    portName_p () const
    {
      return portName_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& ExternalReferenceEndpoint::
    portName () const
    {
      return *portName_;
    }

    void ExternalReferenceEndpoint::
    portName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (portName_.get ())
      {
        *portName_ = e;
      }

      else
      {
        portName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        portName_->container (this);
      }
    }

    // ExternalReferenceEndpoint
    //
    ExternalReferenceEndpoint::supportedType_iterator ExternalReferenceEndpoint::
    begin_supportedType ()
    {
      return supportedType_.begin ();
    }

    ExternalReferenceEndpoint::supportedType_iterator ExternalReferenceEndpoint::
    end_supportedType ()
    {
      return supportedType_.end ();
    }

    ExternalReferenceEndpoint::supportedType_const_iterator ExternalReferenceEndpoint::
    begin_supportedType () const
    {
      return supportedType_.begin ();
    }

    ExternalReferenceEndpoint::supportedType_const_iterator ExternalReferenceEndpoint::
    end_supportedType () const
    {
      return supportedType_.end ();
    }

    void ExternalReferenceEndpoint::
    add_supportedType (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      supportedType_.push_back (e);
    }

    size_t ExternalReferenceEndpoint::
    count_supportedType(void) const
    {
      return supportedType_.size ();
    }


    // ConnectionResourceDeploymentDescription
    //

    ConnectionResourceDeploymentDescription::
    ConnectionResourceDeploymentDescription (::XMLSchema::string< ACE_TCHAR > const& targetName__,
                                             ::XMLSchema::string< ACE_TCHAR > const& requirementName__,
                                             ::XMLSchema::string< ACE_TCHAR > const& resourceName__)
    :
    targetName_ (new ::XMLSchema::string< ACE_TCHAR > (targetName__)),
    requirementName_ (new ::XMLSchema::string< ACE_TCHAR > (requirementName__)),
    resourceName_ (new ::XMLSchema::string< ACE_TCHAR > (resourceName__)),
    regulator__ ()
    {
      targetName_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ConnectionResourceDeploymentDescription::
    ConnectionResourceDeploymentDescription (ConnectionResourceDeploymentDescription const& s)
    :
    ::XSCRT::Type (),
    targetName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.targetName_)),
    requirementName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.requirementName_)),
    resourceName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.resourceName_)),
    property_ (s.property_),
    regulator__ ()
    {
      targetName_->container (this);
      requirementName_->container (this);
      resourceName_->container (this);
    }

    ConnectionResourceDeploymentDescription& ConnectionResourceDeploymentDescription::
    operator= (ConnectionResourceDeploymentDescription const& s)
    {
      targetName (*s.targetName_);

      requirementName (*s.requirementName_);

      resourceName (*s.resourceName_);

      property_ = s.property_;

      return *this;
    }


    // ConnectionResourceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ConnectionResourceDeploymentDescription::
    targetName () const
    {
      return *targetName_;
    }

    void ConnectionResourceDeploymentDescription::
    targetName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *targetName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ConnectionResourceDeploymentDescription::
    requirementName () const
    {
      return *requirementName_;
    }

    void ConnectionResourceDeploymentDescription::
    requirementName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *requirementName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& ConnectionResourceDeploymentDescription::
    resourceName () const
    {
      return *resourceName_;
    }

    void ConnectionResourceDeploymentDescription::
    resourceName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *resourceName_ = e;
    }

    // ConnectionResourceDeploymentDescription
    //
    ConnectionResourceDeploymentDescription::property_iterator ConnectionResourceDeploymentDescription::
    begin_property ()
    {
      return property_.begin ();
    }

    ConnectionResourceDeploymentDescription::property_iterator ConnectionResourceDeploymentDescription::
    end_property ()
    {
      return property_.end ();
    }

    ConnectionResourceDeploymentDescription::property_const_iterator ConnectionResourceDeploymentDescription::
    begin_property () const
    {
      return property_.begin ();
    }

    ConnectionResourceDeploymentDescription::property_const_iterator ConnectionResourceDeploymentDescription::
    end_property () const
    {
      return property_.end ();
    }

    void ConnectionResourceDeploymentDescription::
    add_property (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      property_.push_back (e);
    }

    size_t ConnectionResourceDeploymentDescription::
    count_property(void) const
    {
      return property_.size ();
    }


    // PlanConnectionDescription
    //

    PlanConnectionDescription::
    PlanConnectionDescription (::XMLSchema::string< ACE_TCHAR > const& name__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    PlanConnectionDescription::
    PlanConnectionDescription (PlanConnectionDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    source_ (s.source_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.source_) : 0),
    deployRequirement_ (s.deployRequirement_),
    externalEndpoint_ (s.externalEndpoint_),
    internalEndpoint_ (s.internalEndpoint_),
    externalReference_ (s.externalReference_),
    deployedResource_ (s.deployedResource_),
    regulator__ ()
    {
      name_->container (this);
      if (source_.get ()) source_->container (this);
    }

    PlanConnectionDescription& PlanConnectionDescription::
    operator= (PlanConnectionDescription const& s)
    {
      name (*s.name_);

      if (s.source_.get ())
        source (*(s.source_));
      else
        source_.reset (0);

      deployRequirement_ = s.deployRequirement_;

      externalEndpoint_ = s.externalEndpoint_;

      internalEndpoint_ = s.internalEndpoint_;

      externalReference_ = s.externalReference_;

      deployedResource_ = s.deployedResource_;

      return *this;
    }


    // PlanConnectionDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& PlanConnectionDescription::
    name () const
    {
      return *name_;
    }

    void PlanConnectionDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // PlanConnectionDescription
    //
    bool PlanConnectionDescription::
    source_p () const
    {
      return source_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& PlanConnectionDescription::
    source () const
    {
      return *source_;
    }

    void PlanConnectionDescription::
    source (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (source_.get ())
      {
        *source_ = e;
      }

      else
      {
        source_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        source_->container (this);
      }
    }

    // PlanConnectionDescription
    //
    PlanConnectionDescription::deployRequirement_iterator PlanConnectionDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    PlanConnectionDescription::deployRequirement_iterator PlanConnectionDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    PlanConnectionDescription::deployRequirement_const_iterator PlanConnectionDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    PlanConnectionDescription::deployRequirement_const_iterator PlanConnectionDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void PlanConnectionDescription::
    add_deployRequirement (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // PlanConnectionDescription
    //
    PlanConnectionDescription::externalEndpoint_iterator PlanConnectionDescription::
    begin_externalEndpoint ()
    {
      return externalEndpoint_.begin ();
    }

    PlanConnectionDescription::externalEndpoint_iterator PlanConnectionDescription::
    end_externalEndpoint ()
    {
      return externalEndpoint_.end ();
    }

    PlanConnectionDescription::externalEndpoint_const_iterator PlanConnectionDescription::
    begin_externalEndpoint () const
    {
      return externalEndpoint_.begin ();
    }

    PlanConnectionDescription::externalEndpoint_const_iterator PlanConnectionDescription::
    end_externalEndpoint () const
    {
      return externalEndpoint_.end ();
    }

    void PlanConnectionDescription::
    add_externalEndpoint (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint, ACE_Null_Mutex >  const& e)
    {
      externalEndpoint_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_externalEndpoint(void) const
    {
      return externalEndpoint_.size ();
    }

    // PlanConnectionDescription
    //
    PlanConnectionDescription::internalEndpoint_iterator PlanConnectionDescription::
    begin_internalEndpoint ()
    {
      return internalEndpoint_.begin ();
    }

    PlanConnectionDescription::internalEndpoint_iterator PlanConnectionDescription::
    end_internalEndpoint ()
    {
      return internalEndpoint_.end ();
    }

    PlanConnectionDescription::internalEndpoint_const_iterator PlanConnectionDescription::
    begin_internalEndpoint () const
    {
      return internalEndpoint_.begin ();
    }

    PlanConnectionDescription::internalEndpoint_const_iterator PlanConnectionDescription::
    end_internalEndpoint () const
    {
      return internalEndpoint_.end ();
    }

    void PlanConnectionDescription::
    add_internalEndpoint (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::PlanSubcomponentPortEndpoint, ACE_Null_Mutex >  const& e)
    {
      internalEndpoint_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_internalEndpoint(void) const
    {
      return internalEndpoint_.size ();
    }

    // PlanConnectionDescription
    //
    PlanConnectionDescription::externalReference_iterator PlanConnectionDescription::
    begin_externalReference ()
    {
      return externalReference_.begin ();
    }

    PlanConnectionDescription::externalReference_iterator PlanConnectionDescription::
    end_externalReference ()
    {
      return externalReference_.end ();
    }

    PlanConnectionDescription::externalReference_const_iterator PlanConnectionDescription::
    begin_externalReference () const
    {
      return externalReference_.begin ();
    }

    PlanConnectionDescription::externalReference_const_iterator PlanConnectionDescription::
    end_externalReference () const
    {
      return externalReference_.end ();
    }

    void PlanConnectionDescription::
    add_externalReference (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ExternalReferenceEndpoint, ACE_Null_Mutex >  const& e)
    {
      externalReference_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_externalReference(void) const
    {
      return externalReference_.size ();
    }

    // PlanConnectionDescription
    //
    PlanConnectionDescription::deployedResource_iterator PlanConnectionDescription::
    begin_deployedResource ()
    {
      return deployedResource_.begin ();
    }

    PlanConnectionDescription::deployedResource_iterator PlanConnectionDescription::
    end_deployedResource ()
    {
      return deployedResource_.end ();
    }

    PlanConnectionDescription::deployedResource_const_iterator PlanConnectionDescription::
    begin_deployedResource () const
    {
      return deployedResource_.begin ();
    }

    PlanConnectionDescription::deployedResource_const_iterator PlanConnectionDescription::
    end_deployedResource () const
    {
      return deployedResource_.end ();
    }

    void PlanConnectionDescription::
    add_deployedResource (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription, ACE_Null_Mutex >  const& e)
    {
      deployedResource_.push_back (e);
    }

    size_t PlanConnectionDescription::
    count_deployedResource(void) const
    {
      return deployedResource_.size ();
    }


    // ImplementationDependency
    //

    ImplementationDependency::
    ImplementationDependency (::XMLSchema::string< ACE_TCHAR > const& requiredType__)
    :
    requiredType_ (new ::XMLSchema::string< ACE_TCHAR > (requiredType__)),
    regulator__ ()
    {
      requiredType_->container (this);
    }

    ImplementationDependency::
    ImplementationDependency (ImplementationDependency const& s)
    :
    ::XSCRT::Type (),
    requiredType_ (new ::XMLSchema::string< ACE_TCHAR > (*s.requiredType_)),
    regulator__ ()
    {
      requiredType_->container (this);
    }

    ImplementationDependency& ImplementationDependency::
    operator= (ImplementationDependency const& s)
    {
      requiredType (*s.requiredType_);

      return *this;
    }


    // ImplementationDependency
    //
    ::XMLSchema::string< ACE_TCHAR > const& ImplementationDependency::
    requiredType () const
    {
      return *requiredType_;
    }

    void ImplementationDependency::
    requiredType (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *requiredType_ = e;
    }


    // Capability
    //

    Capability::
    Capability (::XMLSchema::string< ACE_TCHAR > const& name__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    Capability::
    Capability (Capability const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    resourceType_ (s.resourceType_),
    property_ (s.property_),
    regulator__ ()
    {
      name_->container (this);
    }

    Capability& Capability::
    operator= (Capability const& s)
    {
      name (*s.name_);

      resourceType_ = s.resourceType_;

      property_ = s.property_;

      return *this;
    }


    // Capability
    //
    ::XMLSchema::string< ACE_TCHAR > const& Capability::
    name () const
    {
      return *name_;
    }

    void Capability::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Capability
    //
    Capability::resourceType_iterator Capability::
    begin_resourceType ()
    {
      return resourceType_.begin ();
    }

    Capability::resourceType_iterator Capability::
    end_resourceType ()
    {
      return resourceType_.end ();
    }

    Capability::resourceType_const_iterator Capability::
    begin_resourceType () const
    {
      return resourceType_.begin ();
    }

    Capability::resourceType_const_iterator Capability::
    end_resourceType () const
    {
      return resourceType_.end ();
    }

    void Capability::
    add_resourceType (ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  const& e)
    {
      resourceType_.push_back (e);
    }

    size_t Capability::
    count_resourceType(void) const
    {
      return resourceType_.size ();
    }

    // Capability
    //
    Capability::property_iterator Capability::
    begin_property ()
    {
      return property_.begin ();
    }

    Capability::property_iterator Capability::
    end_property ()
    {
      return property_.end ();
    }

    Capability::property_const_iterator Capability::
    begin_property () const
    {
      return property_.begin ();
    }

    Capability::property_const_iterator Capability::
    end_property () const
    {
      return property_.end ();
    }

    void Capability::
    add_property (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SatisfierProperty, ACE_Null_Mutex >  const& e)
    {
      property_.push_back (e);
    }

    size_t Capability::
    count_property(void) const
    {
      return property_.size ();
    }


    // ImplementationRequirement
    //

    ImplementationRequirement::
    ImplementationRequirement (::XMLSchema::string< ACE_TCHAR > const& resourceType__,
                               ::XMLSchema::string< ACE_TCHAR > const& name__)
    :
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (resourceType__)),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      resourceType_->container (this);
      name_->container (this);
    }

    ImplementationRequirement::
    ImplementationRequirement (ImplementationRequirement const& s)
    :
    ::XSCRT::Type (),
    resourceUsage_ (s.resourceUsage_.get () ? new ::DAnCE::Config_Handlers::ResourceUsageKind (*s.resourceUsage_) : 0),
    resourcePort_ (s.resourcePort_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.resourcePort_) : 0),
    componentPort_ (s.componentPort_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.componentPort_) : 0),
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (*s.resourceType_)),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    property_ (s.property_),
    regulator__ ()
    {
      if (resourceUsage_.get ()) resourceUsage_->container (this);
      if (resourcePort_.get ()) resourcePort_->container (this);
      if (componentPort_.get ()) componentPort_->container (this);
      resourceType_->container (this);
      name_->container (this);
    }

    ImplementationRequirement& ImplementationRequirement::
    operator= (ImplementationRequirement const& s)
    {
      if (s.resourceUsage_.get ())
        resourceUsage (*(s.resourceUsage_));
      else
        resourceUsage_.reset (0);

      if (s.resourcePort_.get ())
        resourcePort (*(s.resourcePort_));
      else
        resourcePort_.reset (0);

      if (s.componentPort_.get ())
        componentPort (*(s.componentPort_));
      else
        componentPort_.reset (0);

      resourceType (*s.resourceType_);

      name (*s.name_);

      property_ = s.property_;

      return *this;
    }


    // ImplementationRequirement
    //
    bool ImplementationRequirement::
    resourceUsage_p () const
    {
      return resourceUsage_.get () != 0;
    }

    ::DAnCE::Config_Handlers::ResourceUsageKind const& ImplementationRequirement::
    resourceUsage () const
    {
      return *resourceUsage_;
    }

    void ImplementationRequirement::
    resourceUsage (::DAnCE::Config_Handlers::ResourceUsageKind const& e)
    {
      if (resourceUsage_.get ())
      {
        *resourceUsage_ = e;
      }

      else
      {
        resourceUsage_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::ResourceUsageKind > (new ::DAnCE::Config_Handlers::ResourceUsageKind (e));
        resourceUsage_->container (this);
      }
    }

    // ImplementationRequirement
    //
    bool ImplementationRequirement::
    resourcePort_p () const
    {
      return resourcePort_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& ImplementationRequirement::
    resourcePort () const
    {
      return *resourcePort_;
    }

    void ImplementationRequirement::
    resourcePort (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (resourcePort_.get ())
      {
        *resourcePort_ = e;
      }

      else
      {
        resourcePort_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        resourcePort_->container (this);
      }
    }

    // ImplementationRequirement
    //
    bool ImplementationRequirement::
    componentPort_p () const
    {
      return componentPort_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& ImplementationRequirement::
    componentPort () const
    {
      return *componentPort_;
    }

    void ImplementationRequirement::
    componentPort (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (componentPort_.get ())
      {
        *componentPort_ = e;
      }

      else
      {
        componentPort_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        componentPort_->container (this);
      }
    }

    // ImplementationRequirement
    //
    ::XMLSchema::string< ACE_TCHAR > const& ImplementationRequirement::
    resourceType () const
    {
      return *resourceType_;
    }

    void ImplementationRequirement::
    resourceType (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *resourceType_ = e;
    }

    // ImplementationRequirement
    //
    ::XMLSchema::string< ACE_TCHAR > const& ImplementationRequirement::
    name () const
    {
      return *name_;
    }

    void ImplementationRequirement::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // ImplementationRequirement
    //
    ImplementationRequirement::property_iterator ImplementationRequirement::
    begin_property ()
    {
      return property_.begin ();
    }

    ImplementationRequirement::property_iterator ImplementationRequirement::
    end_property ()
    {
      return property_.end ();
    }

    ImplementationRequirement::property_const_iterator ImplementationRequirement::
    begin_property () const
    {
      return property_.begin ();
    }

    ImplementationRequirement::property_const_iterator ImplementationRequirement::
    end_property () const
    {
      return property_.end ();
    }

    void ImplementationRequirement::
    add_property (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  const& e)
    {
      property_.push_back (e);
    }

    size_t ImplementationRequirement::
    count_property(void) const
    {
      return property_.size ();
    }


    // SubcomponentPortEndpoint
    //

    SubcomponentPortEndpoint::
    SubcomponentPortEndpoint (::XMLSchema::string< ACE_TCHAR > const& portName__,
                              ::DAnCE::Config_Handlers::IdRef const& instance__)
    :
    portName_ (new ::XMLSchema::string< ACE_TCHAR > (portName__)),
    instance_ (new ::DAnCE::Config_Handlers::IdRef (instance__)),
    regulator__ ()
    {
      portName_->container (this);
      instance_->container (this);
    }

    SubcomponentPortEndpoint::
    SubcomponentPortEndpoint (SubcomponentPortEndpoint const& s)
    :
    ::XSCRT::Type (),
    portName_ (new ::XMLSchema::string< ACE_TCHAR > (*s.portName_)),
    instance_ (new ::DAnCE::Config_Handlers::IdRef (*s.instance_)),
    regulator__ ()
    {
      portName_->container (this);
      instance_->container (this);
    }

    SubcomponentPortEndpoint& SubcomponentPortEndpoint::
    operator= (SubcomponentPortEndpoint const& s)
    {
      portName (*s.portName_);

      instance (*s.instance_);

      return *this;
    }


    // SubcomponentPortEndpoint
    //
    ::XMLSchema::string< ACE_TCHAR > const& SubcomponentPortEndpoint::
    portName () const
    {
      return *portName_;
    }

    void SubcomponentPortEndpoint::
    portName (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *portName_ = e;
    }

    // SubcomponentPortEndpoint
    //
    ::DAnCE::Config_Handlers::IdRef const& SubcomponentPortEndpoint::
    instance () const
    {
      return *instance_;
    }

    void SubcomponentPortEndpoint::
    instance (::DAnCE::Config_Handlers::IdRef const& e)
    {
      *instance_ = e;
    }


    // AssemblyConnectionDescription
    //

    AssemblyConnectionDescription::
    AssemblyConnectionDescription (::XMLSchema::string< ACE_TCHAR > const& name__)
    :
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    AssemblyConnectionDescription::
    AssemblyConnectionDescription (AssemblyConnectionDescription const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    deployRequirement_ (s.deployRequirement_),
    internalEndpoint_ (s.internalEndpoint_),
    externalEndpoint_ (s.externalEndpoint_),
    externalReference_ (s.externalReference_),
    regulator__ ()
    {
      name_->container (this);
    }

    AssemblyConnectionDescription& AssemblyConnectionDescription::
    operator= (AssemblyConnectionDescription const& s)
    {
      name (*s.name_);

      deployRequirement_ = s.deployRequirement_;

      internalEndpoint_ = s.internalEndpoint_;

      externalEndpoint_ = s.externalEndpoint_;

      externalReference_ = s.externalReference_;

      return *this;
    }


    // AssemblyConnectionDescription
    //
    ::XMLSchema::string< ACE_TCHAR > const& AssemblyConnectionDescription::
    name () const
    {
      return *name_;
    }

    void AssemblyConnectionDescription::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // AssemblyConnectionDescription
    //
    AssemblyConnectionDescription::deployRequirement_iterator AssemblyConnectionDescription::
    begin_deployRequirement ()
    {
      return deployRequirement_.begin ();
    }

    AssemblyConnectionDescription::deployRequirement_iterator AssemblyConnectionDescription::
    end_deployRequirement ()
    {
      return deployRequirement_.end ();
    }

    AssemblyConnectionDescription::deployRequirement_const_iterator AssemblyConnectionDescription::
    begin_deployRequirement () const
    {
      return deployRequirement_.begin ();
    }

    AssemblyConnectionDescription::deployRequirement_const_iterator AssemblyConnectionDescription::
    end_deployRequirement () const
    {
      return deployRequirement_.end ();
    }

    void AssemblyConnectionDescription::
    add_deployRequirement (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  const& e)
    {
      deployRequirement_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_deployRequirement(void) const
    {
      return deployRequirement_.size ();
    }

    // AssemblyConnectionDescription
    //
    AssemblyConnectionDescription::internalEndpoint_iterator AssemblyConnectionDescription::
    begin_internalEndpoint ()
    {
      return internalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::internalEndpoint_iterator AssemblyConnectionDescription::
    end_internalEndpoint ()
    {
      return internalEndpoint_.end ();
    }

    AssemblyConnectionDescription::internalEndpoint_const_iterator AssemblyConnectionDescription::
    begin_internalEndpoint () const
    {
      return internalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::internalEndpoint_const_iterator AssemblyConnectionDescription::
    end_internalEndpoint () const
    {
      return internalEndpoint_.end ();
    }

    void AssemblyConnectionDescription::
    add_internalEndpoint (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SubcomponentPortEndpoint, ACE_Null_Mutex >  const& e)
    {
      internalEndpoint_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_internalEndpoint(void) const
    {
      return internalEndpoint_.size ();
    }

    // AssemblyConnectionDescription
    //
    AssemblyConnectionDescription::externalEndpoint_iterator AssemblyConnectionDescription::
    begin_externalEndpoint ()
    {
      return externalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::externalEndpoint_iterator AssemblyConnectionDescription::
    end_externalEndpoint ()
    {
      return externalEndpoint_.end ();
    }

    AssemblyConnectionDescription::externalEndpoint_const_iterator AssemblyConnectionDescription::
    begin_externalEndpoint () const
    {
      return externalEndpoint_.begin ();
    }

    AssemblyConnectionDescription::externalEndpoint_const_iterator AssemblyConnectionDescription::
    end_externalEndpoint () const
    {
      return externalEndpoint_.end ();
    }

    void AssemblyConnectionDescription::
    add_externalEndpoint (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint, ACE_Null_Mutex >  const& e)
    {
      externalEndpoint_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_externalEndpoint(void) const
    {
      return externalEndpoint_.size ();
    }

    // AssemblyConnectionDescription
    //
    AssemblyConnectionDescription::externalReference_iterator AssemblyConnectionDescription::
    begin_externalReference ()
    {
      return externalReference_.begin ();
    }

    AssemblyConnectionDescription::externalReference_iterator AssemblyConnectionDescription::
    end_externalReference ()
    {
      return externalReference_.end ();
    }

    AssemblyConnectionDescription::externalReference_const_iterator AssemblyConnectionDescription::
    begin_externalReference () const
    {
      return externalReference_.begin ();
    }

    AssemblyConnectionDescription::externalReference_const_iterator AssemblyConnectionDescription::
    end_externalReference () const
    {
      return externalReference_.end ();
    }

    void AssemblyConnectionDescription::
    add_externalReference (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ExternalReferenceEndpoint, ACE_Null_Mutex >  const& e)
    {
      externalReference_.push_back (e);
    }

    size_t AssemblyConnectionDescription::
    count_externalReference(void) const
    {
      return externalReference_.size ();
    }


    // PlanLocalityKind
    //

    PlanLocalityKind::Value PlanLocalityKind::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::DAnCE::Config_Handlers::PlanLocalityKind const& a, ::DAnCE::Config_Handlers::PlanLocalityKind const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::DAnCE::Config_Handlers::PlanLocalityKind const& a, ::DAnCE::Config_Handlers::PlanLocalityKind const& b)
    {
      return a.v_ != b.v_;
    }

    PlanLocalityKind::
    PlanLocalityKind (PlanLocalityKind::Value v)
    : v_ (v)
    {
    }

    // PlanLocality
    //

    PlanLocality::
    PlanLocality (::DAnCE::Config_Handlers::PlanLocalityKind const& constraint__,
                  ::std::list< ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::IdRef, ACE_Null_Mutex > > const& constrainedInstance__)
    :
    constraint_ (new ::DAnCE::Config_Handlers::PlanLocalityKind (constraint__)),
    constrainedInstance_ (constrainedInstance__),
    regulator__ ()
    {
      constraint_->container (this);
    }

    PlanLocality::
    PlanLocality (PlanLocality const& s)
    :
    ::XSCRT::Type (),
    constraint_ (new ::DAnCE::Config_Handlers::PlanLocalityKind (*s.constraint_)),
    constrainedInstance_ (s.constrainedInstance_),
    regulator__ ()
    {
      constraint_->container (this);
    }

    PlanLocality& PlanLocality::
    operator= (PlanLocality const& s)
    {
      constraint (*s.constraint_);

      constrainedInstance_ = s.constrainedInstance_;

      return *this;
    }


    // PlanLocality
    //
    ::DAnCE::Config_Handlers::PlanLocalityKind const& PlanLocality::
    constraint () const
    {
      return *constraint_;
    }

    void PlanLocality::
    constraint (::DAnCE::Config_Handlers::PlanLocalityKind const& e)
    {
      *constraint_ = e;
    }

    // PlanLocality
    //
    PlanLocality::constrainedInstance_iterator PlanLocality::
    begin_constrainedInstance ()
    {
      return constrainedInstance_.begin ();
    }

    PlanLocality::constrainedInstance_iterator PlanLocality::
    end_constrainedInstance ()
    {
      return constrainedInstance_.end ();
    }

    PlanLocality::constrainedInstance_const_iterator PlanLocality::
    begin_constrainedInstance () const
    {
      return constrainedInstance_.begin ();
    }

    PlanLocality::constrainedInstance_const_iterator PlanLocality::
    end_constrainedInstance () const
    {
      return constrainedInstance_.end ();
    }

    void PlanLocality::
    add_constrainedInstance (ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::IdRef, ACE_Null_Mutex >  const& e)
    {
      constrainedInstance_.push_back (e);
    }

    size_t PlanLocality::
    count_constrainedInstance(void) const
    {
      return constrainedInstance_.size ();
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    // IdRef
    //

    IdRef::
    IdRef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("href"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (a);
          href (t);
        }

        else if (n == ACE_TEXT ("idref"))
        {
          ::XMLSchema::IDREF< ACE_TCHAR > t (a);
          idref (t);
          std::basic_string<ACE_TCHAR> temp ((*idref_).id().c_str());

          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->
          add_idref(temp, dynamic_cast<XSCRT::Type*> (this));
        }

        else
        {
        }
      }
    }

    // TCKind
    //

    TCKind::
    TCKind (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == ACE_TEXT ("tk_null")) v_ = tk_null_l;
      else if (v == ACE_TEXT ("tk_void")) v_ = tk_void_l;
      else if (v == ACE_TEXT ("tk_short")) v_ = tk_short_l;
      else if (v == ACE_TEXT ("tk_long")) v_ = tk_long_l;
      else if (v == ACE_TEXT ("tk_ushort")) v_ = tk_ushort_l;
      else if (v == ACE_TEXT ("tk_ulong")) v_ = tk_ulong_l;
      else if (v == ACE_TEXT ("tk_float")) v_ = tk_float_l;
      else if (v == ACE_TEXT ("tk_double")) v_ = tk_double_l;
      else if (v == ACE_TEXT ("tk_boolean")) v_ = tk_boolean_l;
      else if (v == ACE_TEXT ("tk_char")) v_ = tk_char_l;
      else if (v == ACE_TEXT ("tk_octet")) v_ = tk_octet_l;
      else if (v == ACE_TEXT ("tk_any")) v_ = tk_any_l;
      else if (v == ACE_TEXT ("tk_TypeCode")) v_ = tk_TypeCode_l;
      else if (v == ACE_TEXT ("tk_Principal")) v_ = tk_Principal_l;
      else if (v == ACE_TEXT ("tk_objref")) v_ = tk_objref_l;
      else if (v == ACE_TEXT ("tk_struct")) v_ = tk_struct_l;
      else if (v == ACE_TEXT ("tk_union")) v_ = tk_union_l;
      else if (v == ACE_TEXT ("tk_enum")) v_ = tk_enum_l;
      else if (v == ACE_TEXT ("tk_string")) v_ = tk_string_l;
      else if (v == ACE_TEXT ("tk_sequence")) v_ = tk_sequence_l;
      else if (v == ACE_TEXT ("tk_array")) v_ = tk_array_l;
      else if (v == ACE_TEXT ("tk_alias")) v_ = tk_alias_l;
      else if (v == ACE_TEXT ("tk_except")) v_ = tk_except_l;
      else if (v == ACE_TEXT ("tk_longlong")) v_ = tk_longlong_l;
      else if (v == ACE_TEXT ("tk_ulonglong")) v_ = tk_ulonglong_l;
      else if (v == ACE_TEXT ("tk_longdouble")) v_ = tk_longdouble_l;
      else if (v == ACE_TEXT ("tk_wchar")) v_ = tk_wchar_l;
      else if (v == ACE_TEXT ("tk_wstring")) v_ = tk_wstring_l;
      else if (v == ACE_TEXT ("tk_fixed")) v_ = tk_fixed_l;
      else if (v == ACE_TEXT ("tk_value")) v_ = tk_value_l;
      else if (v == ACE_TEXT ("tk_value_box")) v_ = tk_value_box_l;
      else if (v == ACE_TEXT ("tk_native")) v_ = tk_native_l;
      else if (v == ACE_TEXT ("tk_abstract_interface")) v_ = tk_abstract_interface_l;
      else if (v == ACE_TEXT ("tk_local_interface")) v_ = tk_local_interface_l;
      else if (v == ACE_TEXT ("tk_component")) v_ = tk_component_l;
      else if (v == ACE_TEXT ("tk_home")) v_ = tk_home_l;
      else if (v == ACE_TEXT ("tk_event")) v_ = tk_event_l;
      else
      {
      }
    }

    TCKind::
    TCKind (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == ACE_TEXT ("tk_null")) v_ = tk_null_l;
      else if (v == ACE_TEXT ("tk_void")) v_ = tk_void_l;
      else if (v == ACE_TEXT ("tk_short")) v_ = tk_short_l;
      else if (v == ACE_TEXT ("tk_long")) v_ = tk_long_l;
      else if (v == ACE_TEXT ("tk_ushort")) v_ = tk_ushort_l;
      else if (v == ACE_TEXT ("tk_ulong")) v_ = tk_ulong_l;
      else if (v == ACE_TEXT ("tk_float")) v_ = tk_float_l;
      else if (v == ACE_TEXT ("tk_double")) v_ = tk_double_l;
      else if (v == ACE_TEXT ("tk_boolean")) v_ = tk_boolean_l;
      else if (v == ACE_TEXT ("tk_char")) v_ = tk_char_l;
      else if (v == ACE_TEXT ("tk_octet")) v_ = tk_octet_l;
      else if (v == ACE_TEXT ("tk_any")) v_ = tk_any_l;
      else if (v == ACE_TEXT ("tk_TypeCode")) v_ = tk_TypeCode_l;
      else if (v == ACE_TEXT ("tk_Principal")) v_ = tk_Principal_l;
      else if (v == ACE_TEXT ("tk_objref")) v_ = tk_objref_l;
      else if (v == ACE_TEXT ("tk_struct")) v_ = tk_struct_l;
      else if (v == ACE_TEXT ("tk_union")) v_ = tk_union_l;
      else if (v == ACE_TEXT ("tk_enum")) v_ = tk_enum_l;
      else if (v == ACE_TEXT ("tk_string")) v_ = tk_string_l;
      else if (v == ACE_TEXT ("tk_sequence")) v_ = tk_sequence_l;
      else if (v == ACE_TEXT ("tk_array")) v_ = tk_array_l;
      else if (v == ACE_TEXT ("tk_alias")) v_ = tk_alias_l;
      else if (v == ACE_TEXT ("tk_except")) v_ = tk_except_l;
      else if (v == ACE_TEXT ("tk_longlong")) v_ = tk_longlong_l;
      else if (v == ACE_TEXT ("tk_ulonglong")) v_ = tk_ulonglong_l;
      else if (v == ACE_TEXT ("tk_longdouble")) v_ = tk_longdouble_l;
      else if (v == ACE_TEXT ("tk_wchar")) v_ = tk_wchar_l;
      else if (v == ACE_TEXT ("tk_wstring")) v_ = tk_wstring_l;
      else if (v == ACE_TEXT ("tk_fixed")) v_ = tk_fixed_l;
      else if (v == ACE_TEXT ("tk_value")) v_ = tk_value_l;
      else if (v == ACE_TEXT ("tk_value_box")) v_ = tk_value_box_l;
      else if (v == ACE_TEXT ("tk_native")) v_ = tk_native_l;
      else if (v == ACE_TEXT ("tk_abstract_interface")) v_ = tk_abstract_interface_l;
      else if (v == ACE_TEXT ("tk_local_interface")) v_ = tk_local_interface_l;
      else if (v == ACE_TEXT ("tk_component")) v_ = tk_component_l;
      else if (v == ACE_TEXT ("tk_home")) v_ = tk_home_l;
      else if (v == ACE_TEXT ("tk_event")) v_ = tk_event_l;
      else
      {
      }
    }

    TCKind const TCKind::tk_null (TCKind::tk_null_l);
    TCKind const TCKind::tk_void (TCKind::tk_void_l);
    TCKind const TCKind::tk_short (TCKind::tk_short_l);
    TCKind const TCKind::tk_long (TCKind::tk_long_l);
    TCKind const TCKind::tk_ushort (TCKind::tk_ushort_l);
    TCKind const TCKind::tk_ulong (TCKind::tk_ulong_l);
    TCKind const TCKind::tk_float (TCKind::tk_float_l);
    TCKind const TCKind::tk_double (TCKind::tk_double_l);
    TCKind const TCKind::tk_boolean (TCKind::tk_boolean_l);
    TCKind const TCKind::tk_char (TCKind::tk_char_l);
    TCKind const TCKind::tk_octet (TCKind::tk_octet_l);
    TCKind const TCKind::tk_any (TCKind::tk_any_l);
    TCKind const TCKind::tk_TypeCode (TCKind::tk_TypeCode_l);
    TCKind const TCKind::tk_Principal (TCKind::tk_Principal_l);
    TCKind const TCKind::tk_objref (TCKind::tk_objref_l);
    TCKind const TCKind::tk_struct (TCKind::tk_struct_l);
    TCKind const TCKind::tk_union (TCKind::tk_union_l);
    TCKind const TCKind::tk_enum (TCKind::tk_enum_l);
    TCKind const TCKind::tk_string (TCKind::tk_string_l);
    TCKind const TCKind::tk_sequence (TCKind::tk_sequence_l);
    TCKind const TCKind::tk_array (TCKind::tk_array_l);
    TCKind const TCKind::tk_alias (TCKind::tk_alias_l);
    TCKind const TCKind::tk_except (TCKind::tk_except_l);
    TCKind const TCKind::tk_longlong (TCKind::tk_longlong_l);
    TCKind const TCKind::tk_ulonglong (TCKind::tk_ulonglong_l);
    TCKind const TCKind::tk_longdouble (TCKind::tk_longdouble_l);
    TCKind const TCKind::tk_wchar (TCKind::tk_wchar_l);
    TCKind const TCKind::tk_wstring (TCKind::tk_wstring_l);
    TCKind const TCKind::tk_fixed (TCKind::tk_fixed_l);
    TCKind const TCKind::tk_value (TCKind::tk_value_l);
    TCKind const TCKind::tk_value_box (TCKind::tk_value_box_l);
    TCKind const TCKind::tk_native (TCKind::tk_native_l);
    TCKind const TCKind::tk_abstract_interface (TCKind::tk_abstract_interface_l);
    TCKind const TCKind::tk_local_interface (TCKind::tk_local_interface_l);
    TCKind const TCKind::tk_component (TCKind::tk_component_l);
    TCKind const TCKind::tk_home (TCKind::tk_home_l);
    TCKind const TCKind::tk_event (TCKind::tk_event_l);

    // DataType
    //

    DataType::
    DataType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("kind"))
        {
          kind_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::TCKind > (new ::DAnCE::Config_Handlers::TCKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("enum"))
        {
          ::DAnCE::Config_Handlers::EnumType t (e);
          enum_ (t);
        }

        else if (n == ACE_TEXT("struct"))
        {
          ::DAnCE::Config_Handlers::StructType t (e);
          struct_ (t);
        }

        else if (n == ACE_TEXT("value"))
        {
          ::DAnCE::Config_Handlers::ValueType t (e);
          value (t);
        }

        else if (n == ACE_TEXT("sequence"))
        {
          ::DAnCE::Config_Handlers::SequenceType t (e);
          sequence (t);
        }

        else if (n == ACE_TEXT("alias"))
        {
          ::DAnCE::Config_Handlers::AliasType t (e);
          alias (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->
          add_id(temp, dynamic_cast<XSCRT::Type*> (this));
        }

        else
        {
        }
      }
    }

    // DataValue
    //

    DataValue::
    DataValue (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("short"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::short_, ACE_Null_Mutex >  t (new ::XMLSchema::short_ (e));
          add_short (t);
        }

        else if (n == ACE_TEXT("long"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::int_, ACE_Null_Mutex >  t (new ::XMLSchema::int_ (e));
          add_long (t);
        }

        else if (n == ACE_TEXT("ushort"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedShort, ACE_Null_Mutex >  t (new ::XMLSchema::unsignedShort (e));
          add_ushort (t);
        }

        else if (n == ACE_TEXT("ulong"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedInt, ACE_Null_Mutex >  t (new ::XMLSchema::unsignedInt (e));
          add_ulong (t);
        }

        else if (n == ACE_TEXT("float"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::float_, ACE_Null_Mutex >  t (new ::XMLSchema::float_ (e));
          add_float (t);
        }

        else if (n == ACE_TEXT("double"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::double_, ACE_Null_Mutex >  t (new ::XMLSchema::double_ (e));
          add_double (t);
        }

        else if (n == ACE_TEXT("boolean"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::boolean, ACE_Null_Mutex >  t (new ::XMLSchema::boolean (e));
          add_boolean (t);
        }

        else if (n == ACE_TEXT("octet"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedByte, ACE_Null_Mutex >  t (new ::XMLSchema::unsignedByte (e));
          add_octet (t);
        }

        else if (n == ACE_TEXT("enum"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_enum (t);
        }

        else if (n == ACE_TEXT("string"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_string (t);
        }

        else if (n == ACE_TEXT("longlong"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::long_, ACE_Null_Mutex >  t (new ::XMLSchema::long_ (e));
          add_longlong (t);
        }

        else if (n == ACE_TEXT("ulonglong"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::unsignedLong, ACE_Null_Mutex >  t (new ::XMLSchema::unsignedLong (e));
          add_ulonglong (t);
        }

        else if (n == ACE_TEXT("longdouble"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::double_, ACE_Null_Mutex >  t (new ::XMLSchema::double_ (e));
          add_longdouble (t);
        }

        else if (n == ACE_TEXT("element"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::DataValue, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::DataValue (e));
          add_element (t);
        }

        else if (n == ACE_TEXT("member"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::NamedValue, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::NamedValue (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // AliasType
    //

    AliasType::
    AliasType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("elementType"))
        {
          elementType_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataType > (new ::DAnCE::Config_Handlers::DataType (e));
          elementType_->container (this);
        }

        else
        {
        }
      }
    }

    // EnumType
    //

    EnumType::
    EnumType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("member"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // StructType
    //

    StructType::
    StructType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("member"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::StructMemberType, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::StructMemberType (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // StructMemberType
    //

    StructMemberType::
    StructMemberType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("type"))
        {
          type_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataType > (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else
        {
        }
      }
    }

    // ValueType
    //

    ValueType::
    ValueType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("typeId"))
        {
          typeId_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          typeId_->container (this);
        }

        else if (n == ACE_TEXT("modifier"))
        {
          modifier_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          modifier_->container (this);
        }

        else if (n == ACE_TEXT("baseType"))
        {
          baseType_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataType > (new ::DAnCE::Config_Handlers::DataType (e));
          baseType_->container (this);
        }

        else if (n == ACE_TEXT("member"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ValueMemberType, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::ValueMemberType (e));
          add_member (t);
        }

        else
        {
        }
      }
    }

    // ValueMemberType
    //

    ValueMemberType::
    ValueMemberType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("visibility"))
        {
          visibility_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          visibility_->container (this);
        }

        else if (n == ACE_TEXT("type"))
        {
          type_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataType > (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else
        {
        }
      }
    }

    // NamedValue
    //

    NamedValue::
    NamedValue (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataValue > (new ::DAnCE::Config_Handlers::DataValue (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // SequenceType
    //

    SequenceType::
    SequenceType (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("bound"))
        {
          ::XMLSchema::unsignedInt t (e);
          bound (t);
        }

        else if (n == ACE_TEXT("elementType"))
        {
          elementType_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataType > (new ::DAnCE::Config_Handlers::DataType (e));
          elementType_->container (this);
        }

        else
        {
        }
      }
    }

    // Any
    //

    Any::
    Any (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("type"))
        {
          type_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataType > (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataValue > (new ::DAnCE::Config_Handlers::DataValue (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // Property
    //

    Property::
    Property (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::Any > (new ::DAnCE::Config_Handlers::Any (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // SatisfierPropertyKind
    //

    SatisfierPropertyKind::
    SatisfierPropertyKind (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == ACE_TEXT ("Quantity")) v_ = Quantity_l;
      else if (v == ACE_TEXT ("Capacity")) v_ = Capacity_l;
      else if (v == ACE_TEXT ("Minimum")) v_ = Minimum_l;
      else if (v == ACE_TEXT ("Maximum")) v_ = Maximum_l;
      else if (v == ACE_TEXT ("Attribute")) v_ = Attribute_l;
      else if (v == ACE_TEXT ("Selection")) v_ = Selection_l;
      else
      {
      }
    }

    SatisfierPropertyKind::
    SatisfierPropertyKind (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == ACE_TEXT ("Quantity")) v_ = Quantity_l;
      else if (v == ACE_TEXT ("Capacity")) v_ = Capacity_l;
      else if (v == ACE_TEXT ("Minimum")) v_ = Minimum_l;
      else if (v == ACE_TEXT ("Maximum")) v_ = Maximum_l;
      else if (v == ACE_TEXT ("Attribute")) v_ = Attribute_l;
      else if (v == ACE_TEXT ("Selection")) v_ = Selection_l;
      else
      {
      }
    }

    SatisfierPropertyKind const SatisfierPropertyKind::Quantity (SatisfierPropertyKind::Quantity_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Capacity (SatisfierPropertyKind::Capacity_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Minimum (SatisfierPropertyKind::Minimum_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Maximum (SatisfierPropertyKind::Maximum_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Attribute (SatisfierPropertyKind::Attribute_l);
    SatisfierPropertyKind const SatisfierPropertyKind::Selection (SatisfierPropertyKind::Selection_l);

    // SatisfierProperty
    //

    SatisfierProperty::
    SatisfierProperty (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("kind"))
        {
          kind_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::SatisfierPropertyKind > (new ::DAnCE::Config_Handlers::SatisfierPropertyKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("dynamic"))
        {
          dynamic_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
          dynamic_->container (this);
        }

        else if (n == ACE_TEXT("value"))
        {
          value_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::Any > (new ::DAnCE::Config_Handlers::Any (e));
          value_->container (this);
        }

        else
        {
        }
      }
    }

    // Resource
    //

    Resource::
    Resource (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_resourceType (t);
        }

        else if (n == ACE_TEXT("property"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SatisfierProperty, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::SatisfierProperty (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // Requirement
    //

    Requirement::
    Requirement (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          resourceType_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // ResourceDeploymentDescription
    //

    ResourceDeploymentDescription::
    ResourceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("requirementName"))
        {
          requirementName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          requirementName_->container (this);
        }

        else if (n == ACE_TEXT("resourceName"))
        {
          resourceName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          resourceName_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // ArtifactDeploymentDescription
    //

    ArtifactDeploymentDescription::
    ArtifactDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_source (t);
        }

        else if (n == ACE_TEXT("node"))
        {
          node_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          node_->container (this);
        }

        else if (n == ACE_TEXT("location"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_location (t);
        }

        else if (n == ACE_TEXT("execParameter"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_execParameter (t);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else if (n == ACE_TEXT("deployedResource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ResourceDeploymentDescription, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::ResourceDeploymentDescription (e));
          add_deployedResource (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->
          add_id(temp, dynamic_cast<XSCRT::Type*> (this));
        }

        else
        {
        }
      }
    }

    // MonolithicDeploymentDescription
    //

    MonolithicDeploymentDescription::
    MonolithicDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_source (t);
        }

        else if (n == ACE_TEXT("artifact"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::IdRef, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::IdRef (e));
          add_artifact (t);
        }

        else if (n == ACE_TEXT("execParameter"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_execParameter (t);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->
          add_id(temp, dynamic_cast<XSCRT::Type*> (this));
        }

        else
        {
        }
      }
    }

    // ResourceUsageKind
    //

    ResourceUsageKind::
    ResourceUsageKind (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == ACE_TEXT ("None")) v_ = None_l;
      else if (v == ACE_TEXT ("InstanceUsesResource")) v_ = InstanceUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesInstance")) v_ = ResourceUsesInstance_l;
      else if (v == ACE_TEXT ("PortUsesResource")) v_ = PortUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesPort")) v_ = ResourceUsesPort_l;
      else
      {
      }
    }

    ResourceUsageKind::
    ResourceUsageKind (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == ACE_TEXT ("None")) v_ = None_l;
      else if (v == ACE_TEXT ("InstanceUsesResource")) v_ = InstanceUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesInstance")) v_ = ResourceUsesInstance_l;
      else if (v == ACE_TEXT ("PortUsesResource")) v_ = PortUsesResource_l;
      else if (v == ACE_TEXT ("ResourceUsesPort")) v_ = ResourceUsesPort_l;
      else
      {
      }
    }

    ResourceUsageKind const ResourceUsageKind::None (ResourceUsageKind::None_l);
    ResourceUsageKind const ResourceUsageKind::InstanceUsesResource (ResourceUsageKind::InstanceUsesResource_l);
    ResourceUsageKind const ResourceUsageKind::ResourceUsesInstance (ResourceUsageKind::ResourceUsesInstance_l);
    ResourceUsageKind const ResourceUsageKind::PortUsesResource (ResourceUsageKind::PortUsesResource_l);
    ResourceUsageKind const ResourceUsageKind::ResourceUsesPort (ResourceUsageKind::ResourceUsesPort_l);

    // InstanceResourceDeploymentDescription
    //

    InstanceResourceDeploymentDescription::
    InstanceResourceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("resourceUsage"))
        {
          resourceUsage_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::ResourceUsageKind > (new ::DAnCE::Config_Handlers::ResourceUsageKind (e));
          resourceUsage_->container (this);
        }

        else if (n == ACE_TEXT("requirementName"))
        {
          requirementName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          requirementName_->container (this);
        }

        else if (n == ACE_TEXT("resourceName"))
        {
          resourceName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          resourceName_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // InstanceDeploymentDescription
    //

    InstanceDeploymentDescription::
    InstanceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("node"))
        {
          node_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          node_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          source_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          source_->container (this);
        }

        else if (n == ACE_TEXT("implementation"))
        {
          implementation_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::IdRef > (new ::DAnCE::Config_Handlers::IdRef (e));
          implementation_->container (this);
        }

        else if (n == ACE_TEXT("configProperty"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_configProperty (t);
        }

        else if (n == ACE_TEXT("deployedResource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription (e));
          add_deployedResource (t);
        }

        else if (n == ACE_TEXT("deployedSharedResource"))
        {
          ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription t (e);
          deployedSharedResource (t);
        }

        else
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == ACE_TEXT ("id"))
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
          std::basic_string<ACE_TCHAR> temp ((*id_).c_str());
          (*ACE_Singleton<ID_Map::TSS_ID_Map, ACE_Null_Mutex>::instance())->
          add_id(temp, dynamic_cast<XSCRT::Type*> (this));
        }

        else
        {
        }
      }
    }

    // CCMComponentPortKind
    //

    CCMComponentPortKind::
    CCMComponentPortKind (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == ACE_TEXT ("Facet")) v_ = Facet_l;
      else if (v == ACE_TEXT ("SimplexReceptacle")) v_ = SimplexReceptacle_l;
      else if (v == ACE_TEXT ("MultiplexReceptacle")) v_ = MultiplexReceptacle_l;
      else if (v == ACE_TEXT ("EventEmitter")) v_ = EventEmitter_l;
      else if (v == ACE_TEXT ("EventPublisher")) v_ = EventPublisher_l;
      else if (v == ACE_TEXT ("EventConsumer")) v_ = EventConsumer_l;
      else if (v == ACE_TEXT ("ExtendedPort")) v_ = ExtendedPort_l;
      else if (v == ACE_TEXT ("MirrorPort")) v_ = MirrorPort_l;
      else
      {
      }
    }

    CCMComponentPortKind::
    CCMComponentPortKind (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == ACE_TEXT ("Facet")) v_ = Facet_l;
      else if (v == ACE_TEXT ("SimplexReceptacle")) v_ = SimplexReceptacle_l;
      else if (v == ACE_TEXT ("MultiplexReceptacle")) v_ = MultiplexReceptacle_l;
      else if (v == ACE_TEXT ("EventEmitter")) v_ = EventEmitter_l;
      else if (v == ACE_TEXT ("EventPublisher")) v_ = EventPublisher_l;
      else if (v == ACE_TEXT ("EventConsumer")) v_ = EventConsumer_l;
      else if (v == ACE_TEXT ("ExtendedPort")) v_ = ExtendedPort_l;
      else if (v == ACE_TEXT ("MirrorPort")) v_ = MirrorPort_l;
      else
      {
      }
    }

    CCMComponentPortKind const CCMComponentPortKind::Facet (CCMComponentPortKind::Facet_l);
    CCMComponentPortKind const CCMComponentPortKind::SimplexReceptacle (CCMComponentPortKind::SimplexReceptacle_l);
    CCMComponentPortKind const CCMComponentPortKind::MultiplexReceptacle (CCMComponentPortKind::MultiplexReceptacle_l);
    CCMComponentPortKind const CCMComponentPortKind::EventEmitter (CCMComponentPortKind::EventEmitter_l);
    CCMComponentPortKind const CCMComponentPortKind::EventPublisher (CCMComponentPortKind::EventPublisher_l);
    CCMComponentPortKind const CCMComponentPortKind::EventConsumer (CCMComponentPortKind::EventConsumer_l);
    CCMComponentPortKind const CCMComponentPortKind::ExtendedPort (CCMComponentPortKind::ExtendedPort_l);
    CCMComponentPortKind const CCMComponentPortKind::MirrorPort (CCMComponentPortKind::MirrorPort_l);

    // ComponentPortDescription
    //

    ComponentPortDescription::
    ComponentPortDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("specificType"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          specificType (t);
        }

        else if (n == ACE_TEXT("supportedType"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_supportedType (t);
        }

        else if (n == ACE_TEXT("provider"))
        {
          provider_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
          provider_->container (this);
        }

        else if (n == ACE_TEXT("exclusiveProvider"))
        {
          exclusiveProvider_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
          exclusiveProvider_->container (this);
        }

        else if (n == ACE_TEXT("exclusiveUser"))
        {
          exclusiveUser_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
          exclusiveUser_->container (this);
        }

        else if (n == ACE_TEXT("optional"))
        {
          optional_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
          optional_->container (this);
        }

        else if (n == ACE_TEXT("kind"))
        {
          kind_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::CCMComponentPortKind > (new ::DAnCE::Config_Handlers::CCMComponentPortKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("templateParam"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_templateParam (t);
        }

        else
        {
        }
      }
    }

    // ComponentPropertyDescription
    //

    ComponentPropertyDescription::
    ComponentPropertyDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("type"))
        {
          type_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::DataType > (new ::DAnCE::Config_Handlers::DataType (e));
          type_->container (this);
        }

        else
        {
        }
      }
    }

    // ComponentExternalPortEndpoint
    //

    ComponentExternalPortEndpoint::
    ComponentExternalPortEndpoint (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("portName"))
        {
          portName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          portName_->container (this);
        }

        else
        {
        }
      }
    }

    // PlanSubcomponentPortEndpoint
    //

    PlanSubcomponentPortEndpoint::
    PlanSubcomponentPortEndpoint (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("portName"))
        {
          portName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          portName_->container (this);
        }

        else if (n == ACE_TEXT("provider"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          provider (t);
        }

        else if (n == ACE_TEXT("kind"))
        {
          kind_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::CCMComponentPortKind > (new ::DAnCE::Config_Handlers::CCMComponentPortKind (e));
          kind_->container (this);
        }

        else if (n == ACE_TEXT("instance"))
        {
          instance_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::IdRef > (new ::DAnCE::Config_Handlers::IdRef (e));
          instance_->container (this);
        }

        else
        {
        }
      }
    }

    // ExternalReferenceEndpoint
    //

    ExternalReferenceEndpoint::
    ExternalReferenceEndpoint (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("location"))
        {
          location_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          location_->container (this);
        }

        else if (n == ACE_TEXT("provider"))
        {
          provider_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
          provider_->container (this);
        }

        else if (n == ACE_TEXT("portName"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          portName (t);
        }

        else if (n == ACE_TEXT("supportedType"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_supportedType (t);
        }

        else
        {
        }
      }
    }

    // ConnectionResourceDeploymentDescription
    //

    ConnectionResourceDeploymentDescription::
    ConnectionResourceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("targetName"))
        {
          targetName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          targetName_->container (this);
        }

        else if (n == ACE_TEXT("requirementName"))
        {
          requirementName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          requirementName_->container (this);
        }

        else if (n == ACE_TEXT("resourceName"))
        {
          resourceName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          resourceName_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // PlanConnectionDescription
    //

    PlanConnectionDescription::
    PlanConnectionDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("source"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          source (t);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else if (n == ACE_TEXT("externalEndpoint"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint (e));
          add_externalEndpoint (t);
        }

        else if (n == ACE_TEXT("internalEndpoint"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::PlanSubcomponentPortEndpoint, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::PlanSubcomponentPortEndpoint (e));
          add_internalEndpoint (t);
        }

        else if (n == ACE_TEXT("externalReference"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ExternalReferenceEndpoint, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::ExternalReferenceEndpoint (e));
          add_externalReference (t);
        }

        else if (n == ACE_TEXT("deployedResource"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription (e));
          add_deployedResource (t);
        }

        else
        {
        }
      }
    }

    // ImplementationDependency
    //

    ImplementationDependency::
    ImplementationDependency (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("requiredType"))
        {
          requiredType_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          requiredType_->container (this);
        }

        else
        {
        }
      }
    }

    // Capability
    //

    Capability::
    Capability (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          ACE_Refcounted_Auto_Ptr < ::XMLSchema::string< ACE_TCHAR >, ACE_Null_Mutex >  t (new ::XMLSchema::string< ACE_TCHAR > (e));
          add_resourceType (t);
        }

        else if (n == ACE_TEXT("property"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SatisfierProperty, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::SatisfierProperty (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // ImplementationRequirement
    //

    ImplementationRequirement::
    ImplementationRequirement (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("resourceUsage"))
        {
          ::DAnCE::Config_Handlers::ResourceUsageKind t (e);
          resourceUsage (t);
        }

        else if (n == ACE_TEXT("resourcePort"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          resourcePort (t);
        }

        else if (n == ACE_TEXT("componentPort"))
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          componentPort (t);
        }

        else if (n == ACE_TEXT("resourceType"))
        {
          resourceType_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          resourceType_->container (this);
        }

        else if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("property"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Property, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Property (e));
          add_property (t);
        }

        else
        {
        }
      }
    }

    // SubcomponentPortEndpoint
    //

    SubcomponentPortEndpoint::
    SubcomponentPortEndpoint (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("portName"))
        {
          portName_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          portName_->container (this);
        }

        else if (n == ACE_TEXT("instance"))
        {
          instance_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::IdRef > (new ::DAnCE::Config_Handlers::IdRef (e));
          instance_->container (this);
        }

        else
        {
        }
      }
    }

    // AssemblyConnectionDescription
    //

    AssemblyConnectionDescription::
    AssemblyConnectionDescription (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("name"))
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == ACE_TEXT("deployRequirement"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::Requirement, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::Requirement (e));
          add_deployRequirement (t);
        }

        else if (n == ACE_TEXT("internalEndpoint"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::SubcomponentPortEndpoint, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::SubcomponentPortEndpoint (e));
          add_internalEndpoint (t);
        }

        else if (n == ACE_TEXT("externalEndpoint"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::ComponentExternalPortEndpoint (e));
          add_externalEndpoint (t);
        }

        else if (n == ACE_TEXT("externalReference"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::ExternalReferenceEndpoint, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::ExternalReferenceEndpoint (e));
          add_externalReference (t);
        }

        else
        {
        }
      }
    }

    // PlanLocalityKind
    //

    PlanLocalityKind::
    PlanLocalityKind (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == ACE_TEXT ("SameProcess")) v_ = SameProcess_l;
      else if (v == ACE_TEXT ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v == ACE_TEXT ("NoConstraint")) v_ = NoConstraint_l;
      else
      {
      }
    }

    PlanLocalityKind::
    PlanLocalityKind (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == ACE_TEXT ("SameProcess")) v_ = SameProcess_l;
      else if (v == ACE_TEXT ("DifferentProcess")) v_ = DifferentProcess_l;
      else if (v == ACE_TEXT ("NoConstraint")) v_ = NoConstraint_l;
      else
      {
      }
    }

    PlanLocalityKind const PlanLocalityKind::SameProcess (PlanLocalityKind::SameProcess_l);
    PlanLocalityKind const PlanLocalityKind::DifferentProcess (PlanLocalityKind::DifferentProcess_l);
    PlanLocalityKind const PlanLocalityKind::NoConstraint (PlanLocalityKind::NoConstraint_l);

    // PlanLocality
    //

    PlanLocality::
    PlanLocality (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == ACE_TEXT("constraint"))
        {
          constraint_ = ::std::auto_ptr< ::DAnCE::Config_Handlers::PlanLocalityKind > (new ::DAnCE::Config_Handlers::PlanLocalityKind (e));
          constraint_->container (this);
        }

        else if (n == ACE_TEXT("constrainedInstance"))
        {
          ACE_Refcounted_Auto_Ptr < ::DAnCE::Config_Handlers::IdRef, ACE_Null_Mutex >  t (new ::DAnCE::Config_Handlers::IdRef (e));
          add_constrainedInstance (t);
        }

        else
        {
        }
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

#include "XMLSchema/TypeInfo.hpp"

namespace DAnCE
{
  namespace Config_Handlers
  {
    namespace
    {
      ::XMLSchema::TypeInfoInitializer < ACE_TCHAR > XMLSchemaTypeInfoInitializer_ (::XSCRT::extended_type_info_map ());

      struct IdRefTypeInfoInitializer
      {
        IdRefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::IdRef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      IdRefTypeInfoInitializer IdRefTypeInfoInitializer_;

      struct TCKindTypeInfoInitializer
      {
        TCKindTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (TCKind));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      TCKindTypeInfoInitializer TCKindTypeInfoInitializer_;

      struct DataTypeTypeInfoInitializer
      {
        DataTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::DataType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      DataTypeTypeInfoInitializer DataTypeTypeInfoInitializer_;

      struct DataValueTypeInfoInitializer
      {
        DataValueTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::DataValue));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      DataValueTypeInfoInitializer DataValueTypeInfoInitializer_;

      struct AliasTypeTypeInfoInitializer
      {
        AliasTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::AliasType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      AliasTypeTypeInfoInitializer AliasTypeTypeInfoInitializer_;

      struct EnumTypeTypeInfoInitializer
      {
        EnumTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::EnumType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      EnumTypeTypeInfoInitializer EnumTypeTypeInfoInitializer_;

      struct StructTypeTypeInfoInitializer
      {
        StructTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::StructType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      StructTypeTypeInfoInitializer StructTypeTypeInfoInitializer_;

      struct StructMemberTypeTypeInfoInitializer
      {
        StructMemberTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::StructMemberType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      StructMemberTypeTypeInfoInitializer StructMemberTypeTypeInfoInitializer_;

      struct ValueTypeTypeInfoInitializer
      {
        ValueTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ValueType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ValueTypeTypeInfoInitializer ValueTypeTypeInfoInitializer_;

      struct ValueMemberTypeTypeInfoInitializer
      {
        ValueMemberTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ValueMemberType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ValueMemberTypeTypeInfoInitializer ValueMemberTypeTypeInfoInitializer_;

      struct NamedValueTypeInfoInitializer
      {
        NamedValueTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::NamedValue));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      NamedValueTypeInfoInitializer NamedValueTypeInfoInitializer_;

      struct SequenceTypeTypeInfoInitializer
      {
        SequenceTypeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::SequenceType));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      SequenceTypeTypeInfoInitializer SequenceTypeTypeInfoInitializer_;

      struct AnyTypeInfoInitializer
      {
        AnyTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Any));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      AnyTypeInfoInitializer AnyTypeInfoInitializer_;

      struct PropertyTypeInfoInitializer
      {
        PropertyTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Property));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PropertyTypeInfoInitializer PropertyTypeInfoInitializer_;

      struct SatisfierPropertyKindTypeInfoInitializer
      {
        SatisfierPropertyKindTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (SatisfierPropertyKind));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      SatisfierPropertyKindTypeInfoInitializer SatisfierPropertyKindTypeInfoInitializer_;

      struct SatisfierPropertyTypeInfoInitializer
      {
        SatisfierPropertyTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::SatisfierProperty));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      SatisfierPropertyTypeInfoInitializer SatisfierPropertyTypeInfoInitializer_;

      struct ResourceTypeInfoInitializer
      {
        ResourceTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Resource));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ResourceTypeInfoInitializer ResourceTypeInfoInitializer_;

      struct RequirementTypeInfoInitializer
      {
        RequirementTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Requirement));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      RequirementTypeInfoInitializer RequirementTypeInfoInitializer_;

      struct ResourceDeploymentDescriptionTypeInfoInitializer
      {
        ResourceDeploymentDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ResourceDeploymentDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ResourceDeploymentDescriptionTypeInfoInitializer ResourceDeploymentDescriptionTypeInfoInitializer_;

      struct ArtifactDeploymentDescriptionTypeInfoInitializer
      {
        ArtifactDeploymentDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ArtifactDeploymentDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ArtifactDeploymentDescriptionTypeInfoInitializer ArtifactDeploymentDescriptionTypeInfoInitializer_;

      struct MonolithicDeploymentDescriptionTypeInfoInitializer
      {
        MonolithicDeploymentDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::MonolithicDeploymentDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      MonolithicDeploymentDescriptionTypeInfoInitializer MonolithicDeploymentDescriptionTypeInfoInitializer_;

      struct ResourceUsageKindTypeInfoInitializer
      {
        ResourceUsageKindTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ResourceUsageKind));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ResourceUsageKindTypeInfoInitializer ResourceUsageKindTypeInfoInitializer_;

      struct InstanceResourceDeploymentDescriptionTypeInfoInitializer
      {
        InstanceResourceDeploymentDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      InstanceResourceDeploymentDescriptionTypeInfoInitializer InstanceResourceDeploymentDescriptionTypeInfoInitializer_;

      struct InstanceDeploymentDescriptionTypeInfoInitializer
      {
        InstanceDeploymentDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::InstanceDeploymentDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      InstanceDeploymentDescriptionTypeInfoInitializer InstanceDeploymentDescriptionTypeInfoInitializer_;

      struct CCMComponentPortKindTypeInfoInitializer
      {
        CCMComponentPortKindTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (CCMComponentPortKind));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      CCMComponentPortKindTypeInfoInitializer CCMComponentPortKindTypeInfoInitializer_;

      struct ComponentPortDescriptionTypeInfoInitializer
      {
        ComponentPortDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ComponentPortDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ComponentPortDescriptionTypeInfoInitializer ComponentPortDescriptionTypeInfoInitializer_;

      struct ComponentPropertyDescriptionTypeInfoInitializer
      {
        ComponentPropertyDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ComponentPropertyDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ComponentPropertyDescriptionTypeInfoInitializer ComponentPropertyDescriptionTypeInfoInitializer_;

      struct ComponentExternalPortEndpointTypeInfoInitializer
      {
        ComponentExternalPortEndpointTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ComponentExternalPortEndpoint));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ComponentExternalPortEndpointTypeInfoInitializer ComponentExternalPortEndpointTypeInfoInitializer_;

      struct PlanSubcomponentPortEndpointTypeInfoInitializer
      {
        PlanSubcomponentPortEndpointTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::PlanSubcomponentPortEndpoint));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PlanSubcomponentPortEndpointTypeInfoInitializer PlanSubcomponentPortEndpointTypeInfoInitializer_;

      struct ExternalReferenceEndpointTypeInfoInitializer
      {
        ExternalReferenceEndpointTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ExternalReferenceEndpoint));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ExternalReferenceEndpointTypeInfoInitializer ExternalReferenceEndpointTypeInfoInitializer_;

      struct ConnectionResourceDeploymentDescriptionTypeInfoInitializer
      {
        ConnectionResourceDeploymentDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ConnectionResourceDeploymentDescriptionTypeInfoInitializer ConnectionResourceDeploymentDescriptionTypeInfoInitializer_;

      struct PlanConnectionDescriptionTypeInfoInitializer
      {
        PlanConnectionDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::PlanConnectionDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PlanConnectionDescriptionTypeInfoInitializer PlanConnectionDescriptionTypeInfoInitializer_;

      struct ImplementationDependencyTypeInfoInitializer
      {
        ImplementationDependencyTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ImplementationDependency));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ImplementationDependencyTypeInfoInitializer ImplementationDependencyTypeInfoInitializer_;

      struct CapabilityTypeInfoInitializer
      {
        CapabilityTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::Capability));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      CapabilityTypeInfoInitializer CapabilityTypeInfoInitializer_;

      struct ImplementationRequirementTypeInfoInitializer
      {
        ImplementationRequirementTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::ImplementationRequirement));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ImplementationRequirementTypeInfoInitializer ImplementationRequirementTypeInfoInitializer_;

      struct SubcomponentPortEndpointTypeInfoInitializer
      {
        SubcomponentPortEndpointTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::SubcomponentPortEndpoint));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      SubcomponentPortEndpointTypeInfoInitializer SubcomponentPortEndpointTypeInfoInitializer_;

      struct AssemblyConnectionDescriptionTypeInfoInitializer
      {
        AssemblyConnectionDescriptionTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::AssemblyConnectionDescription));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      AssemblyConnectionDescriptionTypeInfoInitializer AssemblyConnectionDescriptionTypeInfoInitializer_;

      struct PlanLocalityKindTypeInfoInitializer
      {
        PlanLocalityKindTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (PlanLocalityKind));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PlanLocalityKindTypeInfoInitializer PlanLocalityKindTypeInfoInitializer_;

      struct PlanLocalityTypeInfoInitializer
      {
        PlanLocalityTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (::DAnCE::Config_Handlers::PlanLocality));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PlanLocalityTypeInfoInitializer PlanLocalityTypeInfoInitializer_;
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    namespace Traversal
    {
      // IdRef
      //
      //

      void IdRef::
      traverse (Type& o)
      {
        pre (o);
        if (o.href_p ()) href (o);
        else href_none (o);
        if (o.idref_p ()) idref (o);
        else idref_none (o);
        post (o);
      }

      void IdRef::
      traverse (Type const& o)
      {
        pre (o);
        if (o.href_p ()) href (o);
        else href_none (o);
        if (o.idref_p ()) idref (o);
        else idref_none (o);
        post (o);
      }

      void IdRef::
      pre (Type&)
      {
      }

      void IdRef::
      pre (Type const&)
      {
      }

      void IdRef::
      href (Type& o)
      {
        dispatch (o.href ());
      }

      void IdRef::
      href (Type const& o)
      {
        dispatch (o.href ());
      }

      void IdRef::
      href_none (Type&)
      {
      }

      void IdRef::
      href_none (Type const&)
      {
      }

      void IdRef::
      idref (Type& o)
      {
        dispatch (o.idref ());
      }

      void IdRef::
      idref (Type const& o)
      {
        dispatch (o.idref ());
      }

      void IdRef::
      idref_none (Type&)
      {
      }

      void IdRef::
      idref_none (Type const&)
      {
      }

      void IdRef::
      post (Type&)
      {
      }

      void IdRef::
      post (Type const&)
      {
      }

      // DataType
      //
      //

      void DataType::
      traverse (Type& o)
      {
        pre (o);
        kind (o);
        if (o.enum_p ()) enum_ (o);
        else enum_none (o);
        if (o.struct_p ()) struct_ (o);
        else struct_none (o);
        if (o.value_p ()) value (o);
        else value_none (o);
        if (o.sequence_p ()) sequence (o);
        else sequence_none (o);
        if (o.alias_p ()) alias (o);
        else alias_none (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void DataType::
      traverse (Type const& o)
      {
        pre (o);
        kind (o);
        if (o.enum_p ()) enum_ (o);
        else enum_none (o);
        if (o.struct_p ()) struct_ (o);
        else struct_none (o);
        if (o.value_p ()) value (o);
        else value_none (o);
        if (o.sequence_p ()) sequence (o);
        else sequence_none (o);
        if (o.alias_p ()) alias (o);
        else alias_none (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void DataType::
      pre (Type&)
      {
      }

      void DataType::
      pre (Type const&)
      {
      }

      void DataType::
      kind (Type& o)
      {
        dispatch (o.kind ());
      }

      void DataType::
      kind (Type const& o)
      {
        dispatch (o.kind ());
      }

      void DataType::
      enum_ (Type& o)
      {
        dispatch (o.enum_ ());
      }

      void DataType::
      enum_ (Type const& o)
      {
        dispatch (o.enum_ ());
      }

      void DataType::
      enum_none (Type&)
      {
      }

      void DataType::
      enum_none (Type const&)
      {
      }

      void DataType::
      struct_ (Type& o)
      {
        dispatch (o.struct_ ());
      }

      void DataType::
      struct_ (Type const& o)
      {
        dispatch (o.struct_ ());
      }

      void DataType::
      struct_none (Type&)
      {
      }

      void DataType::
      struct_none (Type const&)
      {
      }

      void DataType::
      value (Type& o)
      {
        dispatch (o.value ());
      }

      void DataType::
      value (Type const& o)
      {
        dispatch (o.value ());
      }

      void DataType::
      value_none (Type&)
      {
      }

      void DataType::
      value_none (Type const&)
      {
      }

      void DataType::
      sequence (Type& o)
      {
        dispatch (o.sequence ());
      }

      void DataType::
      sequence (Type const& o)
      {
        dispatch (o.sequence ());
      }

      void DataType::
      sequence_none (Type&)
      {
      }

      void DataType::
      sequence_none (Type const&)
      {
      }

      void DataType::
      alias (Type& o)
      {
        dispatch (o.alias ());
      }

      void DataType::
      alias (Type const& o)
      {
        dispatch (o.alias ());
      }

      void DataType::
      alias_none (Type&)
      {
      }

      void DataType::
      alias_none (Type const&)
      {
      }

      void DataType::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void DataType::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void DataType::
      id_none (Type&)
      {
      }

      void DataType::
      id_none (Type const&)
      {
      }

      void DataType::
      post (Type&)
      {
      }

      void DataType::
      post (Type const&)
      {
      }

      // DataValue
      //
      //

      void DataValue::
      traverse (Type& o)
      {
        pre (o);
        short_ (o);
        long_ (o);
        ushort (o);
        ulong (o);
        float_ (o);
        double_ (o);
        boolean (o);
        octet (o);
        enum_ (o);
        string (o);
        longlong (o);
        ulonglong (o);
        longdouble (o);
        element (o);
        member (o);
        post (o);
      }

      void DataValue::
      traverse (Type const& o)
      {
        pre (o);
        short_ (o);
        long_ (o);
        ushort (o);
        ulong (o);
        float_ (o);
        double_ (o);
        boolean (o);
        octet (o);
        enum_ (o);
        string (o);
        longlong (o);
        ulonglong (o);
        longdouble (o);
        element (o);
        member (o);
        post (o);
      }

      void DataValue::
      pre (Type&)
      {
      }

      void DataValue::
      pre (Type const&)
      {
      }

      void DataValue::
      short_ (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::short_iterator b (o.begin_short()), e (o.end_short());

        if (b != e)
        {
          short_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) short_next (o);
          }

          short_post (o);
        }

        else short_none (o);
      }

      void DataValue::
      short_ (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::short_const_iterator b (o.begin_short()), e (o.end_short());

        if (b != e)
        {
          short_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) short_next (o);
          }

          short_post (o);
        }

        else short_none (o);
      }

      void DataValue::
      short_pre (Type&)
      {
      }

      void DataValue::
      short_pre (Type const&)
      {
      }

      void DataValue::
      short_next (Type&)
      {
      }

      void DataValue::
      short_next (Type const&)
      {
      }

      void DataValue::
      short_post (Type&)
      {
      }

      void DataValue::
      short_post (Type const&)
      {
      }

      void DataValue::
      short_none (Type&)
      {
      }

      void DataValue::
      short_none (Type const&)
      {
      }

      void DataValue::
      long_ (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::long_iterator b (o.begin_long()), e (o.end_long());

        if (b != e)
        {
          long_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) long_next (o);
          }

          long_post (o);
        }

        else long_none (o);
      }

      void DataValue::
      long_ (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::long_const_iterator b (o.begin_long()), e (o.end_long());

        if (b != e)
        {
          long_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) long_next (o);
          }

          long_post (o);
        }

        else long_none (o);
      }

      void DataValue::
      long_pre (Type&)
      {
      }

      void DataValue::
      long_pre (Type const&)
      {
      }

      void DataValue::
      long_next (Type&)
      {
      }

      void DataValue::
      long_next (Type const&)
      {
      }

      void DataValue::
      long_post (Type&)
      {
      }

      void DataValue::
      long_post (Type const&)
      {
      }

      void DataValue::
      long_none (Type&)
      {
      }

      void DataValue::
      long_none (Type const&)
      {
      }

      void DataValue::
      ushort (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::ushort_iterator b (o.begin_ushort()), e (o.end_ushort());

        if (b != e)
        {
          ushort_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) ushort_next (o);
          }

          ushort_post (o);
        }

        else ushort_none (o);
      }

      void DataValue::
      ushort (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::ushort_const_iterator b (o.begin_ushort()), e (o.end_ushort());

        if (b != e)
        {
          ushort_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) ushort_next (o);
          }

          ushort_post (o);
        }

        else ushort_none (o);
      }

      void DataValue::
      ushort_pre (Type&)
      {
      }

      void DataValue::
      ushort_pre (Type const&)
      {
      }

      void DataValue::
      ushort_next (Type&)
      {
      }

      void DataValue::
      ushort_next (Type const&)
      {
      }

      void DataValue::
      ushort_post (Type&)
      {
      }

      void DataValue::
      ushort_post (Type const&)
      {
      }

      void DataValue::
      ushort_none (Type&)
      {
      }

      void DataValue::
      ushort_none (Type const&)
      {
      }

      void DataValue::
      ulong (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::ulong_iterator b (o.begin_ulong()), e (o.end_ulong());

        if (b != e)
        {
          ulong_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) ulong_next (o);
          }

          ulong_post (o);
        }

        else ulong_none (o);
      }

      void DataValue::
      ulong (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::ulong_const_iterator b (o.begin_ulong()), e (o.end_ulong());

        if (b != e)
        {
          ulong_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) ulong_next (o);
          }

          ulong_post (o);
        }

        else ulong_none (o);
      }

      void DataValue::
      ulong_pre (Type&)
      {
      }

      void DataValue::
      ulong_pre (Type const&)
      {
      }

      void DataValue::
      ulong_next (Type&)
      {
      }

      void DataValue::
      ulong_next (Type const&)
      {
      }

      void DataValue::
      ulong_post (Type&)
      {
      }

      void DataValue::
      ulong_post (Type const&)
      {
      }

      void DataValue::
      ulong_none (Type&)
      {
      }

      void DataValue::
      ulong_none (Type const&)
      {
      }

      void DataValue::
      float_ (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::float_iterator b (o.begin_float()), e (o.end_float());

        if (b != e)
        {
          float_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) float_next (o);
          }

          float_post (o);
        }

        else float_none (o);
      }

      void DataValue::
      float_ (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::float_const_iterator b (o.begin_float()), e (o.end_float());

        if (b != e)
        {
          float_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) float_next (o);
          }

          float_post (o);
        }

        else float_none (o);
      }

      void DataValue::
      float_pre (Type&)
      {
      }

      void DataValue::
      float_pre (Type const&)
      {
      }

      void DataValue::
      float_next (Type&)
      {
      }

      void DataValue::
      float_next (Type const&)
      {
      }

      void DataValue::
      float_post (Type&)
      {
      }

      void DataValue::
      float_post (Type const&)
      {
      }

      void DataValue::
      float_none (Type&)
      {
      }

      void DataValue::
      float_none (Type const&)
      {
      }

      void DataValue::
      double_ (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::double_iterator b (o.begin_double()), e (o.end_double());

        if (b != e)
        {
          double_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) double_next (o);
          }

          double_post (o);
        }

        else double_none (o);
      }

      void DataValue::
      double_ (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::double_const_iterator b (o.begin_double()), e (o.end_double());

        if (b != e)
        {
          double_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) double_next (o);
          }

          double_post (o);
        }

        else double_none (o);
      }

      void DataValue::
      double_pre (Type&)
      {
      }

      void DataValue::
      double_pre (Type const&)
      {
      }

      void DataValue::
      double_next (Type&)
      {
      }

      void DataValue::
      double_next (Type const&)
      {
      }

      void DataValue::
      double_post (Type&)
      {
      }

      void DataValue::
      double_post (Type const&)
      {
      }

      void DataValue::
      double_none (Type&)
      {
      }

      void DataValue::
      double_none (Type const&)
      {
      }

      void DataValue::
      boolean (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::boolean_iterator b (o.begin_boolean()), e (o.end_boolean());

        if (b != e)
        {
          boolean_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) boolean_next (o);
          }

          boolean_post (o);
        }

        else boolean_none (o);
      }

      void DataValue::
      boolean (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::boolean_const_iterator b (o.begin_boolean()), e (o.end_boolean());

        if (b != e)
        {
          boolean_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) boolean_next (o);
          }

          boolean_post (o);
        }

        else boolean_none (o);
      }

      void DataValue::
      boolean_pre (Type&)
      {
      }

      void DataValue::
      boolean_pre (Type const&)
      {
      }

      void DataValue::
      boolean_next (Type&)
      {
      }

      void DataValue::
      boolean_next (Type const&)
      {
      }

      void DataValue::
      boolean_post (Type&)
      {
      }

      void DataValue::
      boolean_post (Type const&)
      {
      }

      void DataValue::
      boolean_none (Type&)
      {
      }

      void DataValue::
      boolean_none (Type const&)
      {
      }

      void DataValue::
      octet (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::octet_iterator b (o.begin_octet()), e (o.end_octet());

        if (b != e)
        {
          octet_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) octet_next (o);
          }

          octet_post (o);
        }

        else octet_none (o);
      }

      void DataValue::
      octet (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::octet_const_iterator b (o.begin_octet()), e (o.end_octet());

        if (b != e)
        {
          octet_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) octet_next (o);
          }

          octet_post (o);
        }

        else octet_none (o);
      }

      void DataValue::
      octet_pre (Type&)
      {
      }

      void DataValue::
      octet_pre (Type const&)
      {
      }

      void DataValue::
      octet_next (Type&)
      {
      }

      void DataValue::
      octet_next (Type const&)
      {
      }

      void DataValue::
      octet_post (Type&)
      {
      }

      void DataValue::
      octet_post (Type const&)
      {
      }

      void DataValue::
      octet_none (Type&)
      {
      }

      void DataValue::
      octet_none (Type const&)
      {
      }

      void DataValue::
      enum_ (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::enum_iterator b (o.begin_enum()), e (o.end_enum());

        if (b != e)
        {
          enum_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) enum_next (o);
          }

          enum_post (o);
        }

        else enum_none (o);
      }

      void DataValue::
      enum_ (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::enum_const_iterator b (o.begin_enum()), e (o.end_enum());

        if (b != e)
        {
          enum_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) enum_next (o);
          }

          enum_post (o);
        }

        else enum_none (o);
      }

      void DataValue::
      enum_pre (Type&)
      {
      }

      void DataValue::
      enum_pre (Type const&)
      {
      }

      void DataValue::
      enum_next (Type&)
      {
      }

      void DataValue::
      enum_next (Type const&)
      {
      }

      void DataValue::
      enum_post (Type&)
      {
      }

      void DataValue::
      enum_post (Type const&)
      {
      }

      void DataValue::
      enum_none (Type&)
      {
      }

      void DataValue::
      enum_none (Type const&)
      {
      }

      void DataValue::
      string (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::string_iterator b (o.begin_string()), e (o.end_string());

        if (b != e)
        {
          string_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) string_next (o);
          }

          string_post (o);
        }

        else string_none (o);
      }

      void DataValue::
      string (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::string_const_iterator b (o.begin_string()), e (o.end_string());

        if (b != e)
        {
          string_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) string_next (o);
          }

          string_post (o);
        }

        else string_none (o);
      }

      void DataValue::
      string_pre (Type&)
      {
      }

      void DataValue::
      string_pre (Type const&)
      {
      }

      void DataValue::
      string_next (Type&)
      {
      }

      void DataValue::
      string_next (Type const&)
      {
      }

      void DataValue::
      string_post (Type&)
      {
      }

      void DataValue::
      string_post (Type const&)
      {
      }

      void DataValue::
      string_none (Type&)
      {
      }

      void DataValue::
      string_none (Type const&)
      {
      }

      void DataValue::
      longlong (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::longlong_iterator b (o.begin_longlong()), e (o.end_longlong());

        if (b != e)
        {
          longlong_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) longlong_next (o);
          }

          longlong_post (o);
        }

        else longlong_none (o);
      }

      void DataValue::
      longlong (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::longlong_const_iterator b (o.begin_longlong()), e (o.end_longlong());

        if (b != e)
        {
          longlong_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) longlong_next (o);
          }

          longlong_post (o);
        }

        else longlong_none (o);
      }

      void DataValue::
      longlong_pre (Type&)
      {
      }

      void DataValue::
      longlong_pre (Type const&)
      {
      }

      void DataValue::
      longlong_next (Type&)
      {
      }

      void DataValue::
      longlong_next (Type const&)
      {
      }

      void DataValue::
      longlong_post (Type&)
      {
      }

      void DataValue::
      longlong_post (Type const&)
      {
      }

      void DataValue::
      longlong_none (Type&)
      {
      }

      void DataValue::
      longlong_none (Type const&)
      {
      }

      void DataValue::
      ulonglong (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::ulonglong_iterator b (o.begin_ulonglong()), e (o.end_ulonglong());

        if (b != e)
        {
          ulonglong_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) ulonglong_next (o);
          }

          ulonglong_post (o);
        }

        else ulonglong_none (o);
      }

      void DataValue::
      ulonglong (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::ulonglong_const_iterator b (o.begin_ulonglong()), e (o.end_ulonglong());

        if (b != e)
        {
          ulonglong_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) ulonglong_next (o);
          }

          ulonglong_post (o);
        }

        else ulonglong_none (o);
      }

      void DataValue::
      ulonglong_pre (Type&)
      {
      }

      void DataValue::
      ulonglong_pre (Type const&)
      {
      }

      void DataValue::
      ulonglong_next (Type&)
      {
      }

      void DataValue::
      ulonglong_next (Type const&)
      {
      }

      void DataValue::
      ulonglong_post (Type&)
      {
      }

      void DataValue::
      ulonglong_post (Type const&)
      {
      }

      void DataValue::
      ulonglong_none (Type&)
      {
      }

      void DataValue::
      ulonglong_none (Type const&)
      {
      }

      void DataValue::
      longdouble (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::longdouble_iterator b (o.begin_longdouble()), e (o.end_longdouble());

        if (b != e)
        {
          longdouble_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) longdouble_next (o);
          }

          longdouble_post (o);
        }

        else longdouble_none (o);
      }

      void DataValue::
      longdouble (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::longdouble_const_iterator b (o.begin_longdouble()), e (o.end_longdouble());

        if (b != e)
        {
          longdouble_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) longdouble_next (o);
          }

          longdouble_post (o);
        }

        else longdouble_none (o);
      }

      void DataValue::
      longdouble_pre (Type&)
      {
      }

      void DataValue::
      longdouble_pre (Type const&)
      {
      }

      void DataValue::
      longdouble_next (Type&)
      {
      }

      void DataValue::
      longdouble_next (Type const&)
      {
      }

      void DataValue::
      longdouble_post (Type&)
      {
      }

      void DataValue::
      longdouble_post (Type const&)
      {
      }

      void DataValue::
      longdouble_none (Type&)
      {
      }

      void DataValue::
      longdouble_none (Type const&)
      {
      }

      void DataValue::
      element (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::element_iterator b (o.begin_element()), e (o.end_element());

        if (b != e)
        {
          element_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) element_next (o);
          }

          element_post (o);
        }

        else element_none (o);
      }

      void DataValue::
      element (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::element_const_iterator b (o.begin_element()), e (o.end_element());

        if (b != e)
        {
          element_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) element_next (o);
          }

          element_post (o);
        }

        else element_none (o);
      }

      void DataValue::
      element_pre (Type&)
      {
      }

      void DataValue::
      element_pre (Type const&)
      {
      }

      void DataValue::
      element_next (Type&)
      {
      }

      void DataValue::
      element_next (Type const&)
      {
      }

      void DataValue::
      element_post (Type&)
      {
      }

      void DataValue::
      element_post (Type const&)
      {
      }

      void DataValue::
      element_none (Type&)
      {
      }

      void DataValue::
      element_none (Type const&)
      {
      }

      void DataValue::
      member (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::member_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }

        else member_none (o);
      }

      void DataValue::
      member (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::DataValue::member_const_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }

        else member_none (o);
      }

      void DataValue::
      member_pre (Type&)
      {
      }

      void DataValue::
      member_pre (Type const&)
      {
      }

      void DataValue::
      member_next (Type&)
      {
      }

      void DataValue::
      member_next (Type const&)
      {
      }

      void DataValue::
      member_post (Type&)
      {
      }

      void DataValue::
      member_post (Type const&)
      {
      }

      void DataValue::
      member_none (Type&)
      {
      }

      void DataValue::
      member_none (Type const&)
      {
      }

      void DataValue::
      post (Type&)
      {
      }

      void DataValue::
      post (Type const&)
      {
      }

      // AliasType
      //
      //

      void AliasType::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        typeId (o);
        elementType (o);
        post (o);
      }

      void AliasType::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        typeId (o);
        elementType (o);
        post (o);
      }

      void AliasType::
      pre (Type&)
      {
      }

      void AliasType::
      pre (Type const&)
      {
      }

      void AliasType::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void AliasType::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void AliasType::
      typeId (Type& o)
      {
        dispatch (o.typeId ());
      }

      void AliasType::
      typeId (Type const& o)
      {
        dispatch (o.typeId ());
      }

      void AliasType::
      elementType (Type& o)
      {
        dispatch (o.elementType ());
      }

      void AliasType::
      elementType (Type const& o)
      {
        dispatch (o.elementType ());
      }

      void AliasType::
      post (Type&)
      {
      }

      void AliasType::
      post (Type const&)
      {
      }

      // EnumType
      //
      //

      void EnumType::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        typeId (o);
        member (o);
        post (o);
      }

      void EnumType::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        typeId (o);
        member (o);
        post (o);
      }

      void EnumType::
      pre (Type&)
      {
      }

      void EnumType::
      pre (Type const&)
      {
      }

      void EnumType::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void EnumType::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void EnumType::
      typeId (Type& o)
      {
        dispatch (o.typeId ());
      }

      void EnumType::
      typeId (Type const& o)
      {
        dispatch (o.typeId ());
      }

      void EnumType::
      member (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::EnumType::member_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }
      }

      void EnumType::
      member (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::EnumType::member_const_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }
      }

      void EnumType::
      member_pre (Type&)
      {
      }

      void EnumType::
      member_pre (Type const&)
      {
      }

      void EnumType::
      member_next (Type&)
      {
      }

      void EnumType::
      member_next (Type const&)
      {
      }

      void EnumType::
      member_post (Type&)
      {
      }

      void EnumType::
      member_post (Type const&)
      {
      }

      void EnumType::
      post (Type&)
      {
      }

      void EnumType::
      post (Type const&)
      {
      }

      // StructType
      //
      //

      void StructType::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        typeId (o);
        member (o);
        post (o);
      }

      void StructType::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        typeId (o);
        member (o);
        post (o);
      }

      void StructType::
      pre (Type&)
      {
      }

      void StructType::
      pre (Type const&)
      {
      }

      void StructType::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void StructType::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void StructType::
      typeId (Type& o)
      {
        dispatch (o.typeId ());
      }

      void StructType::
      typeId (Type const& o)
      {
        dispatch (o.typeId ());
      }

      void StructType::
      member (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::StructType::member_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }

        else member_none (o);
      }

      void StructType::
      member (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::StructType::member_const_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }

        else member_none (o);
      }

      void StructType::
      member_pre (Type&)
      {
      }

      void StructType::
      member_pre (Type const&)
      {
      }

      void StructType::
      member_next (Type&)
      {
      }

      void StructType::
      member_next (Type const&)
      {
      }

      void StructType::
      member_post (Type&)
      {
      }

      void StructType::
      member_post (Type const&)
      {
      }

      void StructType::
      member_none (Type&)
      {
      }

      void StructType::
      member_none (Type const&)
      {
      }

      void StructType::
      post (Type&)
      {
      }

      void StructType::
      post (Type const&)
      {
      }

      // StructMemberType
      //
      //

      void StructMemberType::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        type (o);
        post (o);
      }

      void StructMemberType::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        type (o);
        post (o);
      }

      void StructMemberType::
      pre (Type&)
      {
      }

      void StructMemberType::
      pre (Type const&)
      {
      }

      void StructMemberType::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void StructMemberType::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void StructMemberType::
      type (Type& o)
      {
        dispatch (o.type ());
      }

      void StructMemberType::
      type (Type const& o)
      {
        dispatch (o.type ());
      }

      void StructMemberType::
      post (Type&)
      {
      }

      void StructMemberType::
      post (Type const&)
      {
      }

      // ValueType
      //
      //

      void ValueType::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        typeId (o);
        modifier (o);
        baseType (o);
        member (o);
        post (o);
      }

      void ValueType::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        typeId (o);
        modifier (o);
        baseType (o);
        member (o);
        post (o);
      }

      void ValueType::
      pre (Type&)
      {
      }

      void ValueType::
      pre (Type const&)
      {
      }

      void ValueType::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void ValueType::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void ValueType::
      typeId (Type& o)
      {
        dispatch (o.typeId ());
      }

      void ValueType::
      typeId (Type const& o)
      {
        dispatch (o.typeId ());
      }

      void ValueType::
      modifier (Type& o)
      {
        dispatch (o.modifier ());
      }

      void ValueType::
      modifier (Type const& o)
      {
        dispatch (o.modifier ());
      }

      void ValueType::
      baseType (Type& o)
      {
        dispatch (o.baseType ());
      }

      void ValueType::
      baseType (Type const& o)
      {
        dispatch (o.baseType ());
      }

      void ValueType::
      member (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ValueType::member_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }

        else member_none (o);
      }

      void ValueType::
      member (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ValueType::member_const_iterator b (o.begin_member()), e (o.end_member());

        if (b != e)
        {
          member_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) member_next (o);
          }

          member_post (o);
        }

        else member_none (o);
      }

      void ValueType::
      member_pre (Type&)
      {
      }

      void ValueType::
      member_pre (Type const&)
      {
      }

      void ValueType::
      member_next (Type&)
      {
      }

      void ValueType::
      member_next (Type const&)
      {
      }

      void ValueType::
      member_post (Type&)
      {
      }

      void ValueType::
      member_post (Type const&)
      {
      }

      void ValueType::
      member_none (Type&)
      {
      }

      void ValueType::
      member_none (Type const&)
      {
      }

      void ValueType::
      post (Type&)
      {
      }

      void ValueType::
      post (Type const&)
      {
      }

      // ValueMemberType
      //
      //

      void ValueMemberType::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        visibility (o);
        type (o);
        post (o);
      }

      void ValueMemberType::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        visibility (o);
        type (o);
        post (o);
      }

      void ValueMemberType::
      pre (Type&)
      {
      }

      void ValueMemberType::
      pre (Type const&)
      {
      }

      void ValueMemberType::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void ValueMemberType::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void ValueMemberType::
      visibility (Type& o)
      {
        dispatch (o.visibility ());
      }

      void ValueMemberType::
      visibility (Type const& o)
      {
        dispatch (o.visibility ());
      }

      void ValueMemberType::
      type (Type& o)
      {
        dispatch (o.type ());
      }

      void ValueMemberType::
      type (Type const& o)
      {
        dispatch (o.type ());
      }

      void ValueMemberType::
      post (Type&)
      {
      }

      void ValueMemberType::
      post (Type const&)
      {
      }

      // NamedValue
      //
      //

      void NamedValue::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        value (o);
        post (o);
      }

      void NamedValue::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        value (o);
        post (o);
      }

      void NamedValue::
      pre (Type&)
      {
      }

      void NamedValue::
      pre (Type const&)
      {
      }

      void NamedValue::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void NamedValue::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void NamedValue::
      value (Type& o)
      {
        dispatch (o.value ());
      }

      void NamedValue::
      value (Type const& o)
      {
        dispatch (o.value ());
      }

      void NamedValue::
      post (Type&)
      {
      }

      void NamedValue::
      post (Type const&)
      {
      }

      // SequenceType
      //
      //

      void SequenceType::
      traverse (Type& o)
      {
        pre (o);
        if (o.bound_p ()) bound (o);
        else bound_none (o);
        elementType (o);
        post (o);
      }

      void SequenceType::
      traverse (Type const& o)
      {
        pre (o);
        if (o.bound_p ()) bound (o);
        else bound_none (o);
        elementType (o);
        post (o);
      }

      void SequenceType::
      pre (Type&)
      {
      }

      void SequenceType::
      pre (Type const&)
      {
      }

      void SequenceType::
      bound (Type& o)
      {
        dispatch (o.bound ());
      }

      void SequenceType::
      bound (Type const& o)
      {
        dispatch (o.bound ());
      }

      void SequenceType::
      bound_none (Type&)
      {
      }

      void SequenceType::
      bound_none (Type const&)
      {
      }

      void SequenceType::
      elementType (Type& o)
      {
        dispatch (o.elementType ());
      }

      void SequenceType::
      elementType (Type const& o)
      {
        dispatch (o.elementType ());
      }

      void SequenceType::
      post (Type&)
      {
      }

      void SequenceType::
      post (Type const&)
      {
      }

      // Any
      //
      //

      void Any::
      traverse (Type& o)
      {
        pre (o);
        type (o);
        value (o);
        post (o);
      }

      void Any::
      traverse (Type const& o)
      {
        pre (o);
        type (o);
        value (o);
        post (o);
      }

      void Any::
      pre (Type&)
      {
      }

      void Any::
      pre (Type const&)
      {
      }

      void Any::
      type (Type& o)
      {
        dispatch (o.type ());
      }

      void Any::
      type (Type const& o)
      {
        dispatch (o.type ());
      }

      void Any::
      value (Type& o)
      {
        dispatch (o.value ());
      }

      void Any::
      value (Type const& o)
      {
        dispatch (o.value ());
      }

      void Any::
      post (Type&)
      {
      }

      void Any::
      post (Type const&)
      {
      }

      // Property
      //
      //

      void Property::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        value (o);
        post (o);
      }

      void Property::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        value (o);
        post (o);
      }

      void Property::
      pre (Type&)
      {
      }

      void Property::
      pre (Type const&)
      {
      }

      void Property::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Property::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Property::
      value (Type& o)
      {
        dispatch (o.value ());
      }

      void Property::
      value (Type const& o)
      {
        dispatch (o.value ());
      }

      void Property::
      post (Type&)
      {
      }

      void Property::
      post (Type const&)
      {
      }

      // SatisfierProperty
      //
      //

      void SatisfierProperty::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        kind (o);
        dynamic (o);
        value (o);
        post (o);
      }

      void SatisfierProperty::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        kind (o);
        dynamic (o);
        value (o);
        post (o);
      }

      void SatisfierProperty::
      pre (Type&)
      {
      }

      void SatisfierProperty::
      pre (Type const&)
      {
      }

      void SatisfierProperty::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void SatisfierProperty::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void SatisfierProperty::
      kind (Type& o)
      {
        dispatch (o.kind ());
      }

      void SatisfierProperty::
      kind (Type const& o)
      {
        dispatch (o.kind ());
      }

      void SatisfierProperty::
      dynamic (Type& o)
      {
        dispatch (o.dynamic ());
      }

      void SatisfierProperty::
      dynamic (Type const& o)
      {
        dispatch (o.dynamic ());
      }

      void SatisfierProperty::
      value (Type& o)
      {
        dispatch (o.value ());
      }

      void SatisfierProperty::
      value (Type const& o)
      {
        dispatch (o.value ());
      }

      void SatisfierProperty::
      post (Type&)
      {
      }

      void SatisfierProperty::
      post (Type const&)
      {
      }

      // Resource
      //
      //

      void Resource::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        property (o);
        post (o);
      }

      void Resource::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        property (o);
        post (o);
      }

      void Resource::
      pre (Type&)
      {
      }

      void Resource::
      pre (Type const&)
      {
      }

      void Resource::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Resource::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Resource::
      resourceType (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Resource::resourceType_iterator b (o.begin_resourceType()), e (o.end_resourceType());

        if (b != e)
        {
          resourceType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resourceType_next (o);
          }

          resourceType_post (o);
        }
      }

      void Resource::
      resourceType (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Resource::resourceType_const_iterator b (o.begin_resourceType()), e (o.end_resourceType());

        if (b != e)
        {
          resourceType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resourceType_next (o);
          }

          resourceType_post (o);
        }
      }

      void Resource::
      resourceType_pre (Type&)
      {
      }

      void Resource::
      resourceType_pre (Type const&)
      {
      }

      void Resource::
      resourceType_next (Type&)
      {
      }

      void Resource::
      resourceType_next (Type const&)
      {
      }

      void Resource::
      resourceType_post (Type&)
      {
      }

      void Resource::
      resourceType_post (Type const&)
      {
      }

      void Resource::
      property (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Resource::property_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void Resource::
      property (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Resource::property_const_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void Resource::
      property_pre (Type&)
      {
      }

      void Resource::
      property_pre (Type const&)
      {
      }

      void Resource::
      property_next (Type&)
      {
      }

      void Resource::
      property_next (Type const&)
      {
      }

      void Resource::
      property_post (Type&)
      {
      }

      void Resource::
      property_post (Type const&)
      {
      }

      void Resource::
      property_none (Type&)
      {
      }

      void Resource::
      property_none (Type const&)
      {
      }

      void Resource::
      post (Type&)
      {
      }

      void Resource::
      post (Type const&)
      {
      }

      // Requirement
      //
      //

      void Requirement::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        property (o);
        post (o);
      }

      void Requirement::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        property (o);
        post (o);
      }

      void Requirement::
      pre (Type&)
      {
      }

      void Requirement::
      pre (Type const&)
      {
      }

      void Requirement::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Requirement::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Requirement::
      resourceType (Type& o)
      {
        dispatch (o.resourceType ());
      }

      void Requirement::
      resourceType (Type const& o)
      {
        dispatch (o.resourceType ());
      }

      void Requirement::
      property (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Requirement::property_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void Requirement::
      property (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Requirement::property_const_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void Requirement::
      property_pre (Type&)
      {
      }

      void Requirement::
      property_pre (Type const&)
      {
      }

      void Requirement::
      property_next (Type&)
      {
      }

      void Requirement::
      property_next (Type const&)
      {
      }

      void Requirement::
      property_post (Type&)
      {
      }

      void Requirement::
      property_post (Type const&)
      {
      }

      void Requirement::
      property_none (Type&)
      {
      }

      void Requirement::
      property_none (Type const&)
      {
      }

      void Requirement::
      post (Type&)
      {
      }

      void Requirement::
      post (Type const&)
      {
      }

      // ResourceDeploymentDescription
      //
      //

      void ResourceDeploymentDescription::
      traverse (Type& o)
      {
        pre (o);
        requirementName (o);
        resourceName (o);
        property (o);
        post (o);
      }

      void ResourceDeploymentDescription::
      traverse (Type const& o)
      {
        pre (o);
        requirementName (o);
        resourceName (o);
        property (o);
        post (o);
      }

      void ResourceDeploymentDescription::
      pre (Type&)
      {
      }

      void ResourceDeploymentDescription::
      pre (Type const&)
      {
      }

      void ResourceDeploymentDescription::
      requirementName (Type& o)
      {
        dispatch (o.requirementName ());
      }

      void ResourceDeploymentDescription::
      requirementName (Type const& o)
      {
        dispatch (o.requirementName ());
      }

      void ResourceDeploymentDescription::
      resourceName (Type& o)
      {
        dispatch (o.resourceName ());
      }

      void ResourceDeploymentDescription::
      resourceName (Type const& o)
      {
        dispatch (o.resourceName ());
      }

      void ResourceDeploymentDescription::
      property (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ResourceDeploymentDescription::property_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void ResourceDeploymentDescription::
      property (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ResourceDeploymentDescription::property_const_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void ResourceDeploymentDescription::
      property_pre (Type&)
      {
      }

      void ResourceDeploymentDescription::
      property_pre (Type const&)
      {
      }

      void ResourceDeploymentDescription::
      property_next (Type&)
      {
      }

      void ResourceDeploymentDescription::
      property_next (Type const&)
      {
      }

      void ResourceDeploymentDescription::
      property_post (Type&)
      {
      }

      void ResourceDeploymentDescription::
      property_post (Type const&)
      {
      }

      void ResourceDeploymentDescription::
      property_none (Type&)
      {
      }

      void ResourceDeploymentDescription::
      property_none (Type const&)
      {
      }

      void ResourceDeploymentDescription::
      post (Type&)
      {
      }

      void ResourceDeploymentDescription::
      post (Type const&)
      {
      }

      // ArtifactDeploymentDescription
      //
      //

      void ArtifactDeploymentDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        source (o);
        node (o);
        location (o);
        execParameter (o);
        deployRequirement (o);
        deployedResource (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void ArtifactDeploymentDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        source (o);
        node (o);
        location (o);
        execParameter (o);
        deployRequirement (o);
        deployedResource (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void ArtifactDeploymentDescription::
      pre (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      pre (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void ArtifactDeploymentDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void ArtifactDeploymentDescription::
      source (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::source_iterator b (o.begin_source()), e (o.end_source());

        if (b != e)
        {
          source_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) source_next (o);
          }

          source_post (o);
        }

        else source_none (o);
      }

      void ArtifactDeploymentDescription::
      source (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::source_const_iterator b (o.begin_source()), e (o.end_source());

        if (b != e)
        {
          source_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) source_next (o);
          }

          source_post (o);
        }

        else source_none (o);
      }

      void ArtifactDeploymentDescription::
      source_pre (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      source_pre (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      source_next (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      source_next (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      source_post (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      source_post (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      source_none (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      source_none (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      node (Type& o)
      {
        dispatch (o.node ());
      }

      void ArtifactDeploymentDescription::
      node (Type const& o)
      {
        dispatch (o.node ());
      }

      void ArtifactDeploymentDescription::
      location (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::location_iterator b (o.begin_location()), e (o.end_location());

        if (b != e)
        {
          location_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) location_next (o);
          }

          location_post (o);
        }

        else location_none (o);
      }

      void ArtifactDeploymentDescription::
      location (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::location_const_iterator b (o.begin_location()), e (o.end_location());

        if (b != e)
        {
          location_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) location_next (o);
          }

          location_post (o);
        }

        else location_none (o);
      }

      void ArtifactDeploymentDescription::
      location_pre (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      location_pre (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      location_next (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      location_next (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      location_post (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      location_post (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      location_none (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      location_none (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::execParameter_iterator b (o.begin_execParameter()), e (o.end_execParameter());

        if (b != e)
        {
          execParameter_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) execParameter_next (o);
          }

          execParameter_post (o);
        }

        else execParameter_none (o);
      }

      void ArtifactDeploymentDescription::
      execParameter (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::execParameter_const_iterator b (o.begin_execParameter()), e (o.end_execParameter());

        if (b != e)
        {
          execParameter_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) execParameter_next (o);
          }

          execParameter_post (o);
        }

        else execParameter_none (o);
      }

      void ArtifactDeploymentDescription::
      execParameter_pre (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter_pre (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter_next (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter_next (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter_post (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter_post (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter_none (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      execParameter_none (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::deployRequirement_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void ArtifactDeploymentDescription::
      deployRequirement (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::deployRequirement_const_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void ArtifactDeploymentDescription::
      deployRequirement_pre (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement_pre (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement_next (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement_next (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement_post (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement_post (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement_none (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployRequirement_none (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::deployedResource_iterator b (o.begin_deployedResource()), e (o.end_deployedResource());

        if (b != e)
        {
          deployedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployedResource_next (o);
          }

          deployedResource_post (o);
        }

        else deployedResource_none (o);
      }

      void ArtifactDeploymentDescription::
      deployedResource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ArtifactDeploymentDescription::deployedResource_const_iterator b (o.begin_deployedResource()), e (o.end_deployedResource());

        if (b != e)
        {
          deployedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployedResource_next (o);
          }

          deployedResource_post (o);
        }

        else deployedResource_none (o);
      }

      void ArtifactDeploymentDescription::
      deployedResource_pre (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource_pre (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource_next (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource_next (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource_post (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource_post (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource_none (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      deployedResource_none (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void ArtifactDeploymentDescription::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void ArtifactDeploymentDescription::
      id_none (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      id_none (Type const&)
      {
      }

      void ArtifactDeploymentDescription::
      post (Type&)
      {
      }

      void ArtifactDeploymentDescription::
      post (Type const&)
      {
      }

      // MonolithicDeploymentDescription
      //
      //

      void MonolithicDeploymentDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        source (o);
        artifact (o);
        execParameter (o);
        deployRequirement (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void MonolithicDeploymentDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        source (o);
        artifact (o);
        execParameter (o);
        deployRequirement (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void MonolithicDeploymentDescription::
      pre (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      pre (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void MonolithicDeploymentDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void MonolithicDeploymentDescription::
      source (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::source_iterator b (o.begin_source()), e (o.end_source());

        if (b != e)
        {
          source_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) source_next (o);
          }

          source_post (o);
        }

        else source_none (o);
      }

      void MonolithicDeploymentDescription::
      source (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::source_const_iterator b (o.begin_source()), e (o.end_source());

        if (b != e)
        {
          source_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) source_next (o);
          }

          source_post (o);
        }

        else source_none (o);
      }

      void MonolithicDeploymentDescription::
      source_pre (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      source_pre (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      source_next (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      source_next (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      source_post (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      source_post (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      source_none (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      source_none (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::artifact_iterator b (o.begin_artifact()), e (o.end_artifact());

        if (b != e)
        {
          artifact_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) artifact_next (o);
          }

          artifact_post (o);
        }

        else artifact_none (o);
      }

      void MonolithicDeploymentDescription::
      artifact (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::artifact_const_iterator b (o.begin_artifact()), e (o.end_artifact());

        if (b != e)
        {
          artifact_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) artifact_next (o);
          }

          artifact_post (o);
        }

        else artifact_none (o);
      }

      void MonolithicDeploymentDescription::
      artifact_pre (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact_pre (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact_next (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact_next (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact_post (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact_post (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact_none (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      artifact_none (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::execParameter_iterator b (o.begin_execParameter()), e (o.end_execParameter());

        if (b != e)
        {
          execParameter_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) execParameter_next (o);
          }

          execParameter_post (o);
        }

        else execParameter_none (o);
      }

      void MonolithicDeploymentDescription::
      execParameter (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::execParameter_const_iterator b (o.begin_execParameter()), e (o.end_execParameter());

        if (b != e)
        {
          execParameter_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) execParameter_next (o);
          }

          execParameter_post (o);
        }

        else execParameter_none (o);
      }

      void MonolithicDeploymentDescription::
      execParameter_pre (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter_pre (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter_next (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter_next (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter_post (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter_post (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter_none (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      execParameter_none (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::deployRequirement_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void MonolithicDeploymentDescription::
      deployRequirement (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::MonolithicDeploymentDescription::deployRequirement_const_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void MonolithicDeploymentDescription::
      deployRequirement_pre (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement_pre (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement_next (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement_next (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement_post (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement_post (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement_none (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      deployRequirement_none (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void MonolithicDeploymentDescription::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void MonolithicDeploymentDescription::
      id_none (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      id_none (Type const&)
      {
      }

      void MonolithicDeploymentDescription::
      post (Type&)
      {
      }

      void MonolithicDeploymentDescription::
      post (Type const&)
      {
      }

      // InstanceResourceDeploymentDescription
      //
      //

      void InstanceResourceDeploymentDescription::
      traverse (Type& o)
      {
        pre (o);
        resourceUsage (o);
        requirementName (o);
        resourceName (o);
        property (o);
        post (o);
      }

      void InstanceResourceDeploymentDescription::
      traverse (Type const& o)
      {
        pre (o);
        resourceUsage (o);
        requirementName (o);
        resourceName (o);
        property (o);
        post (o);
      }

      void InstanceResourceDeploymentDescription::
      pre (Type&)
      {
      }

      void InstanceResourceDeploymentDescription::
      pre (Type const&)
      {
      }

      void InstanceResourceDeploymentDescription::
      resourceUsage (Type& o)
      {
        dispatch (o.resourceUsage ());
      }

      void InstanceResourceDeploymentDescription::
      resourceUsage (Type const& o)
      {
        dispatch (o.resourceUsage ());
      }

      void InstanceResourceDeploymentDescription::
      requirementName (Type& o)
      {
        dispatch (o.requirementName ());
      }

      void InstanceResourceDeploymentDescription::
      requirementName (Type const& o)
      {
        dispatch (o.requirementName ());
      }

      void InstanceResourceDeploymentDescription::
      resourceName (Type& o)
      {
        dispatch (o.resourceName ());
      }

      void InstanceResourceDeploymentDescription::
      resourceName (Type const& o)
      {
        dispatch (o.resourceName ());
      }

      void InstanceResourceDeploymentDescription::
      property (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription::property_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void InstanceResourceDeploymentDescription::
      property (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::InstanceResourceDeploymentDescription::property_const_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void InstanceResourceDeploymentDescription::
      property_pre (Type&)
      {
      }

      void InstanceResourceDeploymentDescription::
      property_pre (Type const&)
      {
      }

      void InstanceResourceDeploymentDescription::
      property_next (Type&)
      {
      }

      void InstanceResourceDeploymentDescription::
      property_next (Type const&)
      {
      }

      void InstanceResourceDeploymentDescription::
      property_post (Type&)
      {
      }

      void InstanceResourceDeploymentDescription::
      property_post (Type const&)
      {
      }

      void InstanceResourceDeploymentDescription::
      property_none (Type&)
      {
      }

      void InstanceResourceDeploymentDescription::
      property_none (Type const&)
      {
      }

      void InstanceResourceDeploymentDescription::
      post (Type&)
      {
      }

      void InstanceResourceDeploymentDescription::
      post (Type const&)
      {
      }

      // InstanceDeploymentDescription
      //
      //

      void InstanceDeploymentDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        node (o);
        source (o);
        implementation (o);
        configProperty (o);
        deployedResource (o);
        if (o.deployedSharedResource_p ()) deployedSharedResource (o);
        else deployedSharedResource_none (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void InstanceDeploymentDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        node (o);
        source (o);
        implementation (o);
        configProperty (o);
        deployedResource (o);
        if (o.deployedSharedResource_p ()) deployedSharedResource (o);
        else deployedSharedResource_none (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void InstanceDeploymentDescription::
      pre (Type&)
      {
      }

      void InstanceDeploymentDescription::
      pre (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void InstanceDeploymentDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void InstanceDeploymentDescription::
      node (Type& o)
      {
        dispatch (o.node ());
      }

      void InstanceDeploymentDescription::
      node (Type const& o)
      {
        dispatch (o.node ());
      }

      void InstanceDeploymentDescription::
      source (Type& o)
      {
        dispatch (o.source ());
      }

      void InstanceDeploymentDescription::
      source (Type const& o)
      {
        dispatch (o.source ());
      }

      void InstanceDeploymentDescription::
      implementation (Type& o)
      {
        dispatch (o.implementation ());
      }

      void InstanceDeploymentDescription::
      implementation (Type const& o)
      {
        dispatch (o.implementation ());
      }

      void InstanceDeploymentDescription::
      configProperty (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::InstanceDeploymentDescription::configProperty_iterator b (o.begin_configProperty()), e (o.end_configProperty());

        if (b != e)
        {
          configProperty_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) configProperty_next (o);
          }

          configProperty_post (o);
        }

        else configProperty_none (o);
      }

      void InstanceDeploymentDescription::
      configProperty (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::InstanceDeploymentDescription::configProperty_const_iterator b (o.begin_configProperty()), e (o.end_configProperty());

        if (b != e)
        {
          configProperty_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) configProperty_next (o);
          }

          configProperty_post (o);
        }

        else configProperty_none (o);
      }

      void InstanceDeploymentDescription::
      configProperty_pre (Type&)
      {
      }

      void InstanceDeploymentDescription::
      configProperty_pre (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      configProperty_next (Type&)
      {
      }

      void InstanceDeploymentDescription::
      configProperty_next (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      configProperty_post (Type&)
      {
      }

      void InstanceDeploymentDescription::
      configProperty_post (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      configProperty_none (Type&)
      {
      }

      void InstanceDeploymentDescription::
      configProperty_none (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::InstanceDeploymentDescription::deployedResource_iterator b (o.begin_deployedResource()), e (o.end_deployedResource());

        if (b != e)
        {
          deployedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployedResource_next (o);
          }

          deployedResource_post (o);
        }

        else deployedResource_none (o);
      }

      void InstanceDeploymentDescription::
      deployedResource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::InstanceDeploymentDescription::deployedResource_const_iterator b (o.begin_deployedResource()), e (o.end_deployedResource());

        if (b != e)
        {
          deployedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployedResource_next (o);
          }

          deployedResource_post (o);
        }

        else deployedResource_none (o);
      }

      void InstanceDeploymentDescription::
      deployedResource_pre (Type&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource_pre (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource_next (Type&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource_next (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource_post (Type&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource_post (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource_none (Type&)
      {
      }

      void InstanceDeploymentDescription::
      deployedResource_none (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      deployedSharedResource (Type& o)
      {
        dispatch (o.deployedSharedResource ());
      }

      void InstanceDeploymentDescription::
      deployedSharedResource (Type const& o)
      {
        dispatch (o.deployedSharedResource ());
      }

      void InstanceDeploymentDescription::
      deployedSharedResource_none (Type&)
      {
      }

      void InstanceDeploymentDescription::
      deployedSharedResource_none (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void InstanceDeploymentDescription::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void InstanceDeploymentDescription::
      id_none (Type&)
      {
      }

      void InstanceDeploymentDescription::
      id_none (Type const&)
      {
      }

      void InstanceDeploymentDescription::
      post (Type&)
      {
      }

      void InstanceDeploymentDescription::
      post (Type const&)
      {
      }

      // ComponentPortDescription
      //
      //

      void ComponentPortDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.specificType_p ()) specificType (o);
        else specificType_none (o);
        supportedType (o);
        provider (o);
        exclusiveProvider (o);
        exclusiveUser (o);
        optional (o);
        kind (o);
        templateParam (o);
        post (o);
      }

      void ComponentPortDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.specificType_p ()) specificType (o);
        else specificType_none (o);
        supportedType (o);
        provider (o);
        exclusiveProvider (o);
        exclusiveUser (o);
        optional (o);
        kind (o);
        templateParam (o);
        post (o);
      }

      void ComponentPortDescription::
      pre (Type&)
      {
      }

      void ComponentPortDescription::
      pre (Type const&)
      {
      }

      void ComponentPortDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void ComponentPortDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void ComponentPortDescription::
      specificType (Type& o)
      {
        dispatch (o.specificType ());
      }

      void ComponentPortDescription::
      specificType (Type const& o)
      {
        dispatch (o.specificType ());
      }

      void ComponentPortDescription::
      specificType_none (Type&)
      {
      }

      void ComponentPortDescription::
      specificType_none (Type const&)
      {
      }

      void ComponentPortDescription::
      supportedType (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ComponentPortDescription::supportedType_iterator b (o.begin_supportedType()), e (o.end_supportedType());

        if (b != e)
        {
          supportedType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) supportedType_next (o);
          }

          supportedType_post (o);
        }

        else supportedType_none (o);
      }

      void ComponentPortDescription::
      supportedType (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ComponentPortDescription::supportedType_const_iterator b (o.begin_supportedType()), e (o.end_supportedType());

        if (b != e)
        {
          supportedType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) supportedType_next (o);
          }

          supportedType_post (o);
        }

        else supportedType_none (o);
      }

      void ComponentPortDescription::
      supportedType_pre (Type&)
      {
      }

      void ComponentPortDescription::
      supportedType_pre (Type const&)
      {
      }

      void ComponentPortDescription::
      supportedType_next (Type&)
      {
      }

      void ComponentPortDescription::
      supportedType_next (Type const&)
      {
      }

      void ComponentPortDescription::
      supportedType_post (Type&)
      {
      }

      void ComponentPortDescription::
      supportedType_post (Type const&)
      {
      }

      void ComponentPortDescription::
      supportedType_none (Type&)
      {
      }

      void ComponentPortDescription::
      supportedType_none (Type const&)
      {
      }

      void ComponentPortDescription::
      provider (Type& o)
      {
        dispatch (o.provider ());
      }

      void ComponentPortDescription::
      provider (Type const& o)
      {
        dispatch (o.provider ());
      }

      void ComponentPortDescription::
      exclusiveProvider (Type& o)
      {
        dispatch (o.exclusiveProvider ());
      }

      void ComponentPortDescription::
      exclusiveProvider (Type const& o)
      {
        dispatch (o.exclusiveProvider ());
      }

      void ComponentPortDescription::
      exclusiveUser (Type& o)
      {
        dispatch (o.exclusiveUser ());
      }

      void ComponentPortDescription::
      exclusiveUser (Type const& o)
      {
        dispatch (o.exclusiveUser ());
      }

      void ComponentPortDescription::
      optional (Type& o)
      {
        dispatch (o.optional ());
      }

      void ComponentPortDescription::
      optional (Type const& o)
      {
        dispatch (o.optional ());
      }

      void ComponentPortDescription::
      kind (Type& o)
      {
        dispatch (o.kind ());
      }

      void ComponentPortDescription::
      kind (Type const& o)
      {
        dispatch (o.kind ());
      }

      void ComponentPortDescription::
      templateParam (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ComponentPortDescription::templateParam_iterator b (o.begin_templateParam()), e (o.end_templateParam());

        if (b != e)
        {
          templateParam_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) templateParam_next (o);
          }

          templateParam_post (o);
        }

        else templateParam_none (o);
      }

      void ComponentPortDescription::
      templateParam (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ComponentPortDescription::templateParam_const_iterator b (o.begin_templateParam()), e (o.end_templateParam());

        if (b != e)
        {
          templateParam_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) templateParam_next (o);
          }

          templateParam_post (o);
        }

        else templateParam_none (o);
      }

      void ComponentPortDescription::
      templateParam_pre (Type&)
      {
      }

      void ComponentPortDescription::
      templateParam_pre (Type const&)
      {
      }

      void ComponentPortDescription::
      templateParam_next (Type&)
      {
      }

      void ComponentPortDescription::
      templateParam_next (Type const&)
      {
      }

      void ComponentPortDescription::
      templateParam_post (Type&)
      {
      }

      void ComponentPortDescription::
      templateParam_post (Type const&)
      {
      }

      void ComponentPortDescription::
      templateParam_none (Type&)
      {
      }

      void ComponentPortDescription::
      templateParam_none (Type const&)
      {
      }

      void ComponentPortDescription::
      post (Type&)
      {
      }

      void ComponentPortDescription::
      post (Type const&)
      {
      }

      // ComponentPropertyDescription
      //
      //

      void ComponentPropertyDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        type (o);
        post (o);
      }

      void ComponentPropertyDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        type (o);
        post (o);
      }

      void ComponentPropertyDescription::
      pre (Type&)
      {
      }

      void ComponentPropertyDescription::
      pre (Type const&)
      {
      }

      void ComponentPropertyDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void ComponentPropertyDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void ComponentPropertyDescription::
      type (Type& o)
      {
        dispatch (o.type ());
      }

      void ComponentPropertyDescription::
      type (Type const& o)
      {
        dispatch (o.type ());
      }

      void ComponentPropertyDescription::
      post (Type&)
      {
      }

      void ComponentPropertyDescription::
      post (Type const&)
      {
      }

      // ComponentExternalPortEndpoint
      //
      //

      void ComponentExternalPortEndpoint::
      traverse (Type& o)
      {
        pre (o);
        portName (o);
        post (o);
      }

      void ComponentExternalPortEndpoint::
      traverse (Type const& o)
      {
        pre (o);
        portName (o);
        post (o);
      }

      void ComponentExternalPortEndpoint::
      pre (Type&)
      {
      }

      void ComponentExternalPortEndpoint::
      pre (Type const&)
      {
      }

      void ComponentExternalPortEndpoint::
      portName (Type& o)
      {
        dispatch (o.portName ());
      }

      void ComponentExternalPortEndpoint::
      portName (Type const& o)
      {
        dispatch (o.portName ());
      }

      void ComponentExternalPortEndpoint::
      post (Type&)
      {
      }

      void ComponentExternalPortEndpoint::
      post (Type const&)
      {
      }

      // PlanSubcomponentPortEndpoint
      //
      //

      void PlanSubcomponentPortEndpoint::
      traverse (Type& o)
      {
        pre (o);
        portName (o);
        if (o.provider_p ()) provider (o);
        else provider_none (o);
        kind (o);
        instance (o);
        post (o);
      }

      void PlanSubcomponentPortEndpoint::
      traverse (Type const& o)
      {
        pre (o);
        portName (o);
        if (o.provider_p ()) provider (o);
        else provider_none (o);
        kind (o);
        instance (o);
        post (o);
      }

      void PlanSubcomponentPortEndpoint::
      pre (Type&)
      {
      }

      void PlanSubcomponentPortEndpoint::
      pre (Type const&)
      {
      }

      void PlanSubcomponentPortEndpoint::
      portName (Type& o)
      {
        dispatch (o.portName ());
      }

      void PlanSubcomponentPortEndpoint::
      portName (Type const& o)
      {
        dispatch (o.portName ());
      }

      void PlanSubcomponentPortEndpoint::
      provider (Type& o)
      {
        dispatch (o.provider ());
      }

      void PlanSubcomponentPortEndpoint::
      provider (Type const& o)
      {
        dispatch (o.provider ());
      }

      void PlanSubcomponentPortEndpoint::
      provider_none (Type&)
      {
      }

      void PlanSubcomponentPortEndpoint::
      provider_none (Type const&)
      {
      }

      void PlanSubcomponentPortEndpoint::
      kind (Type& o)
      {
        dispatch (o.kind ());
      }

      void PlanSubcomponentPortEndpoint::
      kind (Type const& o)
      {
        dispatch (o.kind ());
      }

      void PlanSubcomponentPortEndpoint::
      instance (Type& o)
      {
        dispatch (o.instance ());
      }

      void PlanSubcomponentPortEndpoint::
      instance (Type const& o)
      {
        dispatch (o.instance ());
      }

      void PlanSubcomponentPortEndpoint::
      post (Type&)
      {
      }

      void PlanSubcomponentPortEndpoint::
      post (Type const&)
      {
      }

      // ExternalReferenceEndpoint
      //
      //

      void ExternalReferenceEndpoint::
      traverse (Type& o)
      {
        pre (o);
        location (o);
        provider (o);
        if (o.portName_p ()) portName (o);
        else portName_none (o);
        supportedType (o);
        post (o);
      }

      void ExternalReferenceEndpoint::
      traverse (Type const& o)
      {
        pre (o);
        location (o);
        provider (o);
        if (o.portName_p ()) portName (o);
        else portName_none (o);
        supportedType (o);
        post (o);
      }

      void ExternalReferenceEndpoint::
      pre (Type&)
      {
      }

      void ExternalReferenceEndpoint::
      pre (Type const&)
      {
      }

      void ExternalReferenceEndpoint::
      location (Type& o)
      {
        dispatch (o.location ());
      }

      void ExternalReferenceEndpoint::
      location (Type const& o)
      {
        dispatch (o.location ());
      }

      void ExternalReferenceEndpoint::
      provider (Type& o)
      {
        dispatch (o.provider ());
      }

      void ExternalReferenceEndpoint::
      provider (Type const& o)
      {
        dispatch (o.provider ());
      }

      void ExternalReferenceEndpoint::
      portName (Type& o)
      {
        dispatch (o.portName ());
      }

      void ExternalReferenceEndpoint::
      portName (Type const& o)
      {
        dispatch (o.portName ());
      }

      void ExternalReferenceEndpoint::
      portName_none (Type&)
      {
      }

      void ExternalReferenceEndpoint::
      portName_none (Type const&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ExternalReferenceEndpoint::supportedType_iterator b (o.begin_supportedType()), e (o.end_supportedType());

        if (b != e)
        {
          supportedType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) supportedType_next (o);
          }

          supportedType_post (o);
        }

        else supportedType_none (o);
      }

      void ExternalReferenceEndpoint::
      supportedType (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ExternalReferenceEndpoint::supportedType_const_iterator b (o.begin_supportedType()), e (o.end_supportedType());

        if (b != e)
        {
          supportedType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) supportedType_next (o);
          }

          supportedType_post (o);
        }

        else supportedType_none (o);
      }

      void ExternalReferenceEndpoint::
      supportedType_pre (Type&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType_pre (Type const&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType_next (Type&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType_next (Type const&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType_post (Type&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType_post (Type const&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType_none (Type&)
      {
      }

      void ExternalReferenceEndpoint::
      supportedType_none (Type const&)
      {
      }

      void ExternalReferenceEndpoint::
      post (Type&)
      {
      }

      void ExternalReferenceEndpoint::
      post (Type const&)
      {
      }

      // ConnectionResourceDeploymentDescription
      //
      //

      void ConnectionResourceDeploymentDescription::
      traverse (Type& o)
      {
        pre (o);
        targetName (o);
        requirementName (o);
        resourceName (o);
        property (o);
        post (o);
      }

      void ConnectionResourceDeploymentDescription::
      traverse (Type const& o)
      {
        pre (o);
        targetName (o);
        requirementName (o);
        resourceName (o);
        property (o);
        post (o);
      }

      void ConnectionResourceDeploymentDescription::
      pre (Type&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      pre (Type const&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      targetName (Type& o)
      {
        dispatch (o.targetName ());
      }

      void ConnectionResourceDeploymentDescription::
      targetName (Type const& o)
      {
        dispatch (o.targetName ());
      }

      void ConnectionResourceDeploymentDescription::
      requirementName (Type& o)
      {
        dispatch (o.requirementName ());
      }

      void ConnectionResourceDeploymentDescription::
      requirementName (Type const& o)
      {
        dispatch (o.requirementName ());
      }

      void ConnectionResourceDeploymentDescription::
      resourceName (Type& o)
      {
        dispatch (o.resourceName ());
      }

      void ConnectionResourceDeploymentDescription::
      resourceName (Type const& o)
      {
        dispatch (o.resourceName ());
      }

      void ConnectionResourceDeploymentDescription::
      property (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription::property_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void ConnectionResourceDeploymentDescription::
      property (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ConnectionResourceDeploymentDescription::property_const_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void ConnectionResourceDeploymentDescription::
      property_pre (Type&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      property_pre (Type const&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      property_next (Type&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      property_next (Type const&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      property_post (Type&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      property_post (Type const&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      property_none (Type&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      property_none (Type const&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      post (Type&)
      {
      }

      void ConnectionResourceDeploymentDescription::
      post (Type const&)
      {
      }

      // PlanConnectionDescription
      //
      //

      void PlanConnectionDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.source_p ()) source (o);
        else source_none (o);
        deployRequirement (o);
        externalEndpoint (o);
        internalEndpoint (o);
        externalReference (o);
        deployedResource (o);
        post (o);
      }

      void PlanConnectionDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.source_p ()) source (o);
        else source_none (o);
        deployRequirement (o);
        externalEndpoint (o);
        internalEndpoint (o);
        externalReference (o);
        deployedResource (o);
        post (o);
      }

      void PlanConnectionDescription::
      pre (Type&)
      {
      }

      void PlanConnectionDescription::
      pre (Type const&)
      {
      }

      void PlanConnectionDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void PlanConnectionDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void PlanConnectionDescription::
      source (Type& o)
      {
        dispatch (o.source ());
      }

      void PlanConnectionDescription::
      source (Type const& o)
      {
        dispatch (o.source ());
      }

      void PlanConnectionDescription::
      source_none (Type&)
      {
      }

      void PlanConnectionDescription::
      source_none (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::deployRequirement_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void PlanConnectionDescription::
      deployRequirement (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::deployRequirement_const_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void PlanConnectionDescription::
      deployRequirement_pre (Type&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement_pre (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement_next (Type&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement_next (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement_post (Type&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement_post (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement_none (Type&)
      {
      }

      void PlanConnectionDescription::
      deployRequirement_none (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::externalEndpoint_iterator b (o.begin_externalEndpoint()), e (o.end_externalEndpoint());

        if (b != e)
        {
          externalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalEndpoint_next (o);
          }

          externalEndpoint_post (o);
        }

        else externalEndpoint_none (o);
      }

      void PlanConnectionDescription::
      externalEndpoint (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::externalEndpoint_const_iterator b (o.begin_externalEndpoint()), e (o.end_externalEndpoint());

        if (b != e)
        {
          externalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalEndpoint_next (o);
          }

          externalEndpoint_post (o);
        }

        else externalEndpoint_none (o);
      }

      void PlanConnectionDescription::
      externalEndpoint_pre (Type&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint_pre (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint_next (Type&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint_next (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint_post (Type&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint_post (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint_none (Type&)
      {
      }

      void PlanConnectionDescription::
      externalEndpoint_none (Type const&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::internalEndpoint_iterator b (o.begin_internalEndpoint()), e (o.end_internalEndpoint());

        if (b != e)
        {
          internalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) internalEndpoint_next (o);
          }

          internalEndpoint_post (o);
        }

        else internalEndpoint_none (o);
      }

      void PlanConnectionDescription::
      internalEndpoint (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::internalEndpoint_const_iterator b (o.begin_internalEndpoint()), e (o.end_internalEndpoint());

        if (b != e)
        {
          internalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) internalEndpoint_next (o);
          }

          internalEndpoint_post (o);
        }

        else internalEndpoint_none (o);
      }

      void PlanConnectionDescription::
      internalEndpoint_pre (Type&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint_pre (Type const&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint_next (Type&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint_next (Type const&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint_post (Type&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint_post (Type const&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint_none (Type&)
      {
      }

      void PlanConnectionDescription::
      internalEndpoint_none (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalReference (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::externalReference_iterator b (o.begin_externalReference()), e (o.end_externalReference());

        if (b != e)
        {
          externalReference_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalReference_next (o);
          }

          externalReference_post (o);
        }

        else externalReference_none (o);
      }

      void PlanConnectionDescription::
      externalReference (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::externalReference_const_iterator b (o.begin_externalReference()), e (o.end_externalReference());

        if (b != e)
        {
          externalReference_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalReference_next (o);
          }

          externalReference_post (o);
        }

        else externalReference_none (o);
      }

      void PlanConnectionDescription::
      externalReference_pre (Type&)
      {
      }

      void PlanConnectionDescription::
      externalReference_pre (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalReference_next (Type&)
      {
      }

      void PlanConnectionDescription::
      externalReference_next (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalReference_post (Type&)
      {
      }

      void PlanConnectionDescription::
      externalReference_post (Type const&)
      {
      }

      void PlanConnectionDescription::
      externalReference_none (Type&)
      {
      }

      void PlanConnectionDescription::
      externalReference_none (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployedResource (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::deployedResource_iterator b (o.begin_deployedResource()), e (o.end_deployedResource());

        if (b != e)
        {
          deployedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployedResource_next (o);
          }

          deployedResource_post (o);
        }

        else deployedResource_none (o);
      }

      void PlanConnectionDescription::
      deployedResource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanConnectionDescription::deployedResource_const_iterator b (o.begin_deployedResource()), e (o.end_deployedResource());

        if (b != e)
        {
          deployedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployedResource_next (o);
          }

          deployedResource_post (o);
        }

        else deployedResource_none (o);
      }

      void PlanConnectionDescription::
      deployedResource_pre (Type&)
      {
      }

      void PlanConnectionDescription::
      deployedResource_pre (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployedResource_next (Type&)
      {
      }

      void PlanConnectionDescription::
      deployedResource_next (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployedResource_post (Type&)
      {
      }

      void PlanConnectionDescription::
      deployedResource_post (Type const&)
      {
      }

      void PlanConnectionDescription::
      deployedResource_none (Type&)
      {
      }

      void PlanConnectionDescription::
      deployedResource_none (Type const&)
      {
      }

      void PlanConnectionDescription::
      post (Type&)
      {
      }

      void PlanConnectionDescription::
      post (Type const&)
      {
      }

      // ImplementationDependency
      //
      //

      void ImplementationDependency::
      traverse (Type& o)
      {
        pre (o);
        requiredType (o);
        post (o);
      }

      void ImplementationDependency::
      traverse (Type const& o)
      {
        pre (o);
        requiredType (o);
        post (o);
      }

      void ImplementationDependency::
      pre (Type&)
      {
      }

      void ImplementationDependency::
      pre (Type const&)
      {
      }

      void ImplementationDependency::
      requiredType (Type& o)
      {
        dispatch (o.requiredType ());
      }

      void ImplementationDependency::
      requiredType (Type const& o)
      {
        dispatch (o.requiredType ());
      }

      void ImplementationDependency::
      post (Type&)
      {
      }

      void ImplementationDependency::
      post (Type const&)
      {
      }

      // Capability
      //
      //

      void Capability::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        property (o);
        post (o);
      }

      void Capability::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        property (o);
        post (o);
      }

      void Capability::
      pre (Type&)
      {
      }

      void Capability::
      pre (Type const&)
      {
      }

      void Capability::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Capability::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Capability::
      resourceType (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Capability::resourceType_iterator b (o.begin_resourceType()), e (o.end_resourceType());

        if (b != e)
        {
          resourceType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resourceType_next (o);
          }

          resourceType_post (o);
        }

        else resourceType_none (o);
      }

      void Capability::
      resourceType (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Capability::resourceType_const_iterator b (o.begin_resourceType()), e (o.end_resourceType());

        if (b != e)
        {
          resourceType_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) resourceType_next (o);
          }

          resourceType_post (o);
        }

        else resourceType_none (o);
      }

      void Capability::
      resourceType_pre (Type&)
      {
      }

      void Capability::
      resourceType_pre (Type const&)
      {
      }

      void Capability::
      resourceType_next (Type&)
      {
      }

      void Capability::
      resourceType_next (Type const&)
      {
      }

      void Capability::
      resourceType_post (Type&)
      {
      }

      void Capability::
      resourceType_post (Type const&)
      {
      }

      void Capability::
      resourceType_none (Type&)
      {
      }

      void Capability::
      resourceType_none (Type const&)
      {
      }

      void Capability::
      property (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Capability::property_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void Capability::
      property (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::Capability::property_const_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void Capability::
      property_pre (Type&)
      {
      }

      void Capability::
      property_pre (Type const&)
      {
      }

      void Capability::
      property_next (Type&)
      {
      }

      void Capability::
      property_next (Type const&)
      {
      }

      void Capability::
      property_post (Type&)
      {
      }

      void Capability::
      property_post (Type const&)
      {
      }

      void Capability::
      property_none (Type&)
      {
      }

      void Capability::
      property_none (Type const&)
      {
      }

      void Capability::
      post (Type&)
      {
      }

      void Capability::
      post (Type const&)
      {
      }

      // ImplementationRequirement
      //
      //

      void ImplementationRequirement::
      traverse (Type& o)
      {
        pre (o);
        if (o.resourceUsage_p ()) resourceUsage (o);
        else resourceUsage_none (o);
        if (o.resourcePort_p ()) resourcePort (o);
        else resourcePort_none (o);
        if (o.componentPort_p ()) componentPort (o);
        else componentPort_none (o);
        resourceType (o);
        name (o);
        property (o);
        post (o);
      }

      void ImplementationRequirement::
      traverse (Type const& o)
      {
        pre (o);
        if (o.resourceUsage_p ()) resourceUsage (o);
        else resourceUsage_none (o);
        if (o.resourcePort_p ()) resourcePort (o);
        else resourcePort_none (o);
        if (o.componentPort_p ()) componentPort (o);
        else componentPort_none (o);
        resourceType (o);
        name (o);
        property (o);
        post (o);
      }

      void ImplementationRequirement::
      pre (Type&)
      {
      }

      void ImplementationRequirement::
      pre (Type const&)
      {
      }

      void ImplementationRequirement::
      resourceUsage (Type& o)
      {
        dispatch (o.resourceUsage ());
      }

      void ImplementationRequirement::
      resourceUsage (Type const& o)
      {
        dispatch (o.resourceUsage ());
      }

      void ImplementationRequirement::
      resourceUsage_none (Type&)
      {
      }

      void ImplementationRequirement::
      resourceUsage_none (Type const&)
      {
      }

      void ImplementationRequirement::
      resourcePort (Type& o)
      {
        dispatch (o.resourcePort ());
      }

      void ImplementationRequirement::
      resourcePort (Type const& o)
      {
        dispatch (o.resourcePort ());
      }

      void ImplementationRequirement::
      resourcePort_none (Type&)
      {
      }

      void ImplementationRequirement::
      resourcePort_none (Type const&)
      {
      }

      void ImplementationRequirement::
      componentPort (Type& o)
      {
        dispatch (o.componentPort ());
      }

      void ImplementationRequirement::
      componentPort (Type const& o)
      {
        dispatch (o.componentPort ());
      }

      void ImplementationRequirement::
      componentPort_none (Type&)
      {
      }

      void ImplementationRequirement::
      componentPort_none (Type const&)
      {
      }

      void ImplementationRequirement::
      resourceType (Type& o)
      {
        dispatch (o.resourceType ());
      }

      void ImplementationRequirement::
      resourceType (Type const& o)
      {
        dispatch (o.resourceType ());
      }

      void ImplementationRequirement::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void ImplementationRequirement::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void ImplementationRequirement::
      property (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ImplementationRequirement::property_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void ImplementationRequirement::
      property (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::ImplementationRequirement::property_const_iterator b (o.begin_property()), e (o.end_property());

        if (b != e)
        {
          property_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) property_next (o);
          }

          property_post (o);
        }

        else property_none (o);
      }

      void ImplementationRequirement::
      property_pre (Type&)
      {
      }

      void ImplementationRequirement::
      property_pre (Type const&)
      {
      }

      void ImplementationRequirement::
      property_next (Type&)
      {
      }

      void ImplementationRequirement::
      property_next (Type const&)
      {
      }

      void ImplementationRequirement::
      property_post (Type&)
      {
      }

      void ImplementationRequirement::
      property_post (Type const&)
      {
      }

      void ImplementationRequirement::
      property_none (Type&)
      {
      }

      void ImplementationRequirement::
      property_none (Type const&)
      {
      }

      void ImplementationRequirement::
      post (Type&)
      {
      }

      void ImplementationRequirement::
      post (Type const&)
      {
      }

      // SubcomponentPortEndpoint
      //
      //

      void SubcomponentPortEndpoint::
      traverse (Type& o)
      {
        pre (o);
        portName (o);
        instance (o);
        post (o);
      }

      void SubcomponentPortEndpoint::
      traverse (Type const& o)
      {
        pre (o);
        portName (o);
        instance (o);
        post (o);
      }

      void SubcomponentPortEndpoint::
      pre (Type&)
      {
      }

      void SubcomponentPortEndpoint::
      pre (Type const&)
      {
      }

      void SubcomponentPortEndpoint::
      portName (Type& o)
      {
        dispatch (o.portName ());
      }

      void SubcomponentPortEndpoint::
      portName (Type const& o)
      {
        dispatch (o.portName ());
      }

      void SubcomponentPortEndpoint::
      instance (Type& o)
      {
        dispatch (o.instance ());
      }

      void SubcomponentPortEndpoint::
      instance (Type const& o)
      {
        dispatch (o.instance ());
      }

      void SubcomponentPortEndpoint::
      post (Type&)
      {
      }

      void SubcomponentPortEndpoint::
      post (Type const&)
      {
      }

      // AssemblyConnectionDescription
      //
      //

      void AssemblyConnectionDescription::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        deployRequirement (o);
        internalEndpoint (o);
        externalEndpoint (o);
        externalReference (o);
        post (o);
      }

      void AssemblyConnectionDescription::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        deployRequirement (o);
        internalEndpoint (o);
        externalEndpoint (o);
        externalReference (o);
        post (o);
      }

      void AssemblyConnectionDescription::
      pre (Type&)
      {
      }

      void AssemblyConnectionDescription::
      pre (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void AssemblyConnectionDescription::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void AssemblyConnectionDescription::
      deployRequirement (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::deployRequirement_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void AssemblyConnectionDescription::
      deployRequirement (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::deployRequirement_const_iterator b (o.begin_deployRequirement()), e (o.end_deployRequirement());

        if (b != e)
        {
          deployRequirement_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) deployRequirement_next (o);
          }

          deployRequirement_post (o);
        }

        else deployRequirement_none (o);
      }

      void AssemblyConnectionDescription::
      deployRequirement_pre (Type&)
      {
      }

      void AssemblyConnectionDescription::
      deployRequirement_pre (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      deployRequirement_next (Type&)
      {
      }

      void AssemblyConnectionDescription::
      deployRequirement_next (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      deployRequirement_post (Type&)
      {
      }

      void AssemblyConnectionDescription::
      deployRequirement_post (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      deployRequirement_none (Type&)
      {
      }

      void AssemblyConnectionDescription::
      deployRequirement_none (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::internalEndpoint_iterator b (o.begin_internalEndpoint()), e (o.end_internalEndpoint());

        if (b != e)
        {
          internalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) internalEndpoint_next (o);
          }

          internalEndpoint_post (o);
        }

        else internalEndpoint_none (o);
      }

      void AssemblyConnectionDescription::
      internalEndpoint (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::internalEndpoint_const_iterator b (o.begin_internalEndpoint()), e (o.end_internalEndpoint());

        if (b != e)
        {
          internalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) internalEndpoint_next (o);
          }

          internalEndpoint_post (o);
        }

        else internalEndpoint_none (o);
      }

      void AssemblyConnectionDescription::
      internalEndpoint_pre (Type&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint_pre (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint_next (Type&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint_next (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint_post (Type&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint_post (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint_none (Type&)
      {
      }

      void AssemblyConnectionDescription::
      internalEndpoint_none (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::externalEndpoint_iterator b (o.begin_externalEndpoint()), e (o.end_externalEndpoint());

        if (b != e)
        {
          externalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalEndpoint_next (o);
          }

          externalEndpoint_post (o);
        }

        else externalEndpoint_none (o);
      }

      void AssemblyConnectionDescription::
      externalEndpoint (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::externalEndpoint_const_iterator b (o.begin_externalEndpoint()), e (o.end_externalEndpoint());

        if (b != e)
        {
          externalEndpoint_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalEndpoint_next (o);
          }

          externalEndpoint_post (o);
        }

        else externalEndpoint_none (o);
      }

      void AssemblyConnectionDescription::
      externalEndpoint_pre (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint_pre (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint_next (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint_next (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint_post (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint_post (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint_none (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalEndpoint_none (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::externalReference_iterator b (o.begin_externalReference()), e (o.end_externalReference());

        if (b != e)
        {
          externalReference_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalReference_next (o);
          }

          externalReference_post (o);
        }

        else externalReference_none (o);
      }

      void AssemblyConnectionDescription::
      externalReference (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::AssemblyConnectionDescription::externalReference_const_iterator b (o.begin_externalReference()), e (o.end_externalReference());

        if (b != e)
        {
          externalReference_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) externalReference_next (o);
          }

          externalReference_post (o);
        }

        else externalReference_none (o);
      }

      void AssemblyConnectionDescription::
      externalReference_pre (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference_pre (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference_next (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference_next (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference_post (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference_post (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference_none (Type&)
      {
      }

      void AssemblyConnectionDescription::
      externalReference_none (Type const&)
      {
      }

      void AssemblyConnectionDescription::
      post (Type&)
      {
      }

      void AssemblyConnectionDescription::
      post (Type const&)
      {
      }

      // PlanLocality
      //
      //

      void PlanLocality::
      traverse (Type& o)
      {
        pre (o);
        constraint (o);
        constrainedInstance (o);
        post (o);
      }

      void PlanLocality::
      traverse (Type const& o)
      {
        pre (o);
        constraint (o);
        constrainedInstance (o);
        post (o);
      }

      void PlanLocality::
      pre (Type&)
      {
      }

      void PlanLocality::
      pre (Type const&)
      {
      }

      void PlanLocality::
      constraint (Type& o)
      {
        dispatch (o.constraint ());
      }

      void PlanLocality::
      constraint (Type const& o)
      {
        dispatch (o.constraint ());
      }

      void PlanLocality::
      constrainedInstance (Type& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanLocality::constrainedInstance_iterator b (o.begin_constrainedInstance()), e (o.end_constrainedInstance());

        if (b != e)
        {
          constrainedInstance_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) constrainedInstance_next (o);
          }

          constrainedInstance_post (o);
        }
      }

      void PlanLocality::
      constrainedInstance (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ::DAnCE::Config_Handlers::PlanLocality::constrainedInstance_const_iterator b (o.begin_constrainedInstance()), e (o.end_constrainedInstance());

        if (b != e)
        {
          constrainedInstance_pre (o);
          for (; b != e;)
          {
            dispatch (*(*b));
            if (++b != e) constrainedInstance_next (o);
          }

          constrainedInstance_post (o);
        }
      }

      void PlanLocality::
      constrainedInstance_pre (Type&)
      {
      }

      void PlanLocality::
      constrainedInstance_pre (Type const&)
      {
      }

      void PlanLocality::
      constrainedInstance_next (Type&)
      {
      }

      void PlanLocality::
      constrainedInstance_next (Type const&)
      {
      }

      void PlanLocality::
      constrainedInstance_post (Type&)
      {
      }

      void PlanLocality::
      constrainedInstance_post (Type const&)
      {
      }

      void PlanLocality::
      post (Type&)
      {
      }

      void PlanLocality::
      post (Type const&)
      {
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
    namespace Writer
    {
      // IdRef
      //
      //

      IdRef::
      IdRef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      IdRef::
      IdRef ()
      {
      }

      void IdRef::
      traverse (Type const& o)
      {
        Traversal::IdRef::traverse (o);
      }

      void IdRef::
      href (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (ACE_TEXT ("href"), ACE_TEXT (""), top_ ());
        attr_ (&a);
        Traversal::IdRef::href (o);
        attr_ (0);
      }

      void IdRef::
      idref (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (ACE_TEXT ("idref"), ACE_TEXT ("http://www.omg.org/Deployment"), ACE_TEXT (""), top_ ());
        attr_ (&a);
        Traversal::IdRef::idref (o);
        attr_ (0);
      }

      // TCKind
      //
      //

      TCKind::
      TCKind (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      TCKind::
      TCKind ()
      {
      }

      void TCKind::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::DAnCE::Config_Handlers::TCKind::tk_null) s = ACE_TEXT ("tk_null");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_void) s = ACE_TEXT ("tk_void");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_short) s = ACE_TEXT ("tk_short");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_long) s = ACE_TEXT ("tk_long");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_ushort) s = ACE_TEXT ("tk_ushort");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_ulong) s = ACE_TEXT ("tk_ulong");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_float) s = ACE_TEXT ("tk_float");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_double) s = ACE_TEXT ("tk_double");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_boolean) s = ACE_TEXT ("tk_boolean");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_char) s = ACE_TEXT ("tk_char");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_octet) s = ACE_TEXT ("tk_octet");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_any) s = ACE_TEXT ("tk_any");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_TypeCode) s = ACE_TEXT ("tk_TypeCode");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_Principal) s = ACE_TEXT ("tk_Principal");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_objref) s = ACE_TEXT ("tk_objref");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_struct) s = ACE_TEXT ("tk_struct");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_union) s = ACE_TEXT ("tk_union");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_enum) s = ACE_TEXT ("tk_enum");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_string) s = ACE_TEXT ("tk_string");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_sequence) s = ACE_TEXT ("tk_sequence");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_array) s = ACE_TEXT ("tk_array");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_alias) s = ACE_TEXT ("tk_alias");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_except) s = ACE_TEXT ("tk_except");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_longlong) s = ACE_TEXT ("tk_longlong");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_ulonglong) s = ACE_TEXT ("tk_ulonglong");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_longdouble) s = ACE_TEXT ("tk_longdouble");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_wchar) s = ACE_TEXT ("tk_wchar");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_wstring) s = ACE_TEXT ("tk_wstring");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_fixed) s = ACE_TEXT ("tk_fixed");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_value) s = ACE_TEXT ("tk_value");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_value_box) s = ACE_TEXT ("tk_value_box");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_native) s = ACE_TEXT ("tk_native");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_abstract_interface) s = ACE_TEXT ("tk_abstract_interface");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_local_interface) s = ACE_TEXT ("tk_local_interface");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_component) s = ACE_TEXT ("tk_component");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_home) s = ACE_TEXT ("tk_home");
        else if (o == ::DAnCE::Config_Handlers::TCKind::tk_event) s = ACE_TEXT ("tk_event");
        else
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // DataType
      //
      //

      DataType::
      DataType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      DataType::
      DataType ()
      {
      }

      void DataType::
      traverse (Type const& o)
      {
        Traversal::DataType::traverse (o);
      }

      void DataType::
      kind (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("kind"), top_ ()));
        Traversal::DataType::kind (o);
        pop_ ();
      }

      void DataType::
      enum_ (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("enum"), top_ ()));
        Traversal::DataType::enum_ (o);
        pop_ ();
      }

      void DataType::
      struct_ (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("struct"), top_ ()));
        Traversal::DataType::struct_ (o);
        pop_ ();
      }

      void DataType::
      value (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("value"), top_ ()));
        Traversal::DataType::value (o);
        pop_ ();
      }

      void DataType::
      sequence (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("sequence"), top_ ()));
        Traversal::DataType::sequence (o);
        pop_ ();
      }

      void DataType::
      alias (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("alias"), top_ ()));
        Traversal::DataType::alias (o);
        pop_ ();
      }

      void DataType::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (ACE_TEXT ("id"), ACE_TEXT ("http://www.omg.org/Deployment"), ACE_TEXT (""), top_ ());
        attr_ (&a);
        Traversal::DataType::id (o);
        attr_ (0);
      }

      // DataValue
      //
      //

      DataValue::
      DataValue (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      DataValue::
      DataValue ()
      {
      }

      void DataValue::
      traverse (Type const& o)
      {
        Traversal::DataValue::traverse (o);
      }

      void DataValue::
      short_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("short"), top_ ()));
      }

      void DataValue::
      short_next (Type const& o)
      {
        short_post (o);
        short_pre (o);
      }

      void DataValue::
      short_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      long_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("long"), top_ ()));
      }

      void DataValue::
      long_next (Type const& o)
      {
        long_post (o);
        long_pre (o);
      }

      void DataValue::
      long_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      ushort_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("ushort"), top_ ()));
      }

      void DataValue::
      ushort_next (Type const& o)
      {
        ushort_post (o);
        ushort_pre (o);
      }

      void DataValue::
      ushort_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      ulong_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("ulong"), top_ ()));
      }

      void DataValue::
      ulong_next (Type const& o)
      {
        ulong_post (o);
        ulong_pre (o);
      }

      void DataValue::
      ulong_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      float_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("float"), top_ ()));
      }

      void DataValue::
      float_next (Type const& o)
      {
        float_post (o);
        float_pre (o);
      }

      void DataValue::
      float_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      double_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("double"), top_ ()));
      }

      void DataValue::
      double_next (Type const& o)
      {
        double_post (o);
        double_pre (o);
      }

      void DataValue::
      double_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      boolean_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("boolean"), top_ ()));
      }

      void DataValue::
      boolean_next (Type const& o)
      {
        boolean_post (o);
        boolean_pre (o);
      }

      void DataValue::
      boolean_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      octet_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("octet"), top_ ()));
      }

      void DataValue::
      octet_next (Type const& o)
      {
        octet_post (o);
        octet_pre (o);
      }

      void DataValue::
      octet_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      enum_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("enum"), top_ ()));
      }

      void DataValue::
      enum_next (Type const& o)
      {
        enum_post (o);
        enum_pre (o);
      }

      void DataValue::
      enum_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      string_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("string"), top_ ()));
      }

      void DataValue::
      string_next (Type const& o)
      {
        string_post (o);
        string_pre (o);
      }

      void DataValue::
      string_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      longlong_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("longlong"), top_ ()));
      }

      void DataValue::
      longlong_next (Type const& o)
      {
        longlong_post (o);
        longlong_pre (o);
      }

      void DataValue::
      longlong_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      ulonglong_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("ulonglong"), top_ ()));
      }

      void DataValue::
      ulonglong_next (Type const& o)
      {
        ulonglong_post (o);
        ulonglong_pre (o);
      }

      void DataValue::
      ulonglong_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      longdouble_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("longdouble"), top_ ()));
      }

      void DataValue::
      longdouble_next (Type const& o)
      {
        longdouble_post (o);
        longdouble_pre (o);
      }

      void DataValue::
      longdouble_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      element_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("element"), top_ ()));
      }

      void DataValue::
      element_next (Type const& o)
      {
        element_post (o);
        element_pre (o);
      }

      void DataValue::
      element_post (Type const&)
      {
        pop_ ();
      }

      void DataValue::
      member_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("member"), top_ ()));
      }

      void DataValue::
      member_next (Type const& o)
      {
        member_post (o);
        member_pre (o);
      }

      void DataValue::
      member_post (Type const&)
      {
        pop_ ();
      }

      // AliasType
      //
      //

      AliasType::
      AliasType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      AliasType::
      AliasType ()
      {
      }

      void AliasType::
      traverse (Type const& o)
      {
        Traversal::AliasType::traverse (o);
      }

      void AliasType::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::AliasType::name (o);
        pop_ ();
      }

      void AliasType::
      typeId (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("typeId"), top_ ()));
        Traversal::AliasType::typeId (o);
        pop_ ();
      }

      void AliasType::
      elementType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("elementType"), top_ ()));
        Traversal::AliasType::elementType (o);
        pop_ ();
      }

      // EnumType
      //
      //

      EnumType::
      EnumType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      EnumType::
      EnumType ()
      {
      }

      void EnumType::
      traverse (Type const& o)
      {
        Traversal::EnumType::traverse (o);
      }

      void EnumType::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::EnumType::name (o);
        pop_ ();
      }

      void EnumType::
      typeId (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("typeId"), top_ ()));
        Traversal::EnumType::typeId (o);
        pop_ ();
      }

      void EnumType::
      member_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("member"), top_ ()));
      }

      void EnumType::
      member_next (Type const& o)
      {
        member_post (o);
        member_pre (o);
      }

      void EnumType::
      member_post (Type const&)
      {
        pop_ ();
      }

      // StructType
      //
      //

      StructType::
      StructType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      StructType::
      StructType ()
      {
      }

      void StructType::
      traverse (Type const& o)
      {
        Traversal::StructType::traverse (o);
      }

      void StructType::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::StructType::name (o);
        pop_ ();
      }

      void StructType::
      typeId (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("typeId"), top_ ()));
        Traversal::StructType::typeId (o);
        pop_ ();
      }

      void StructType::
      member_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("member"), top_ ()));
      }

      void StructType::
      member_next (Type const& o)
      {
        member_post (o);
        member_pre (o);
      }

      void StructType::
      member_post (Type const&)
      {
        pop_ ();
      }

      // StructMemberType
      //
      //

      StructMemberType::
      StructMemberType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      StructMemberType::
      StructMemberType ()
      {
      }

      void StructMemberType::
      traverse (Type const& o)
      {
        Traversal::StructMemberType::traverse (o);
      }

      void StructMemberType::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::StructMemberType::name (o);
        pop_ ();
      }

      void StructMemberType::
      type (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("type"), top_ ()));
        Traversal::StructMemberType::type (o);
        pop_ ();
      }

      // ValueType
      //
      //

      ValueType::
      ValueType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ValueType::
      ValueType ()
      {
      }

      void ValueType::
      traverse (Type const& o)
      {
        Traversal::ValueType::traverse (o);
      }

      void ValueType::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::ValueType::name (o);
        pop_ ();
      }

      void ValueType::
      typeId (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("typeId"), top_ ()));
        Traversal::ValueType::typeId (o);
        pop_ ();
      }

      void ValueType::
      modifier (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("modifier"), top_ ()));
        Traversal::ValueType::modifier (o);
        pop_ ();
      }

      void ValueType::
      baseType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("baseType"), top_ ()));
        Traversal::ValueType::baseType (o);
        pop_ ();
      }

      void ValueType::
      member_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("member"), top_ ()));
      }

      void ValueType::
      member_next (Type const& o)
      {
        member_post (o);
        member_pre (o);
      }

      void ValueType::
      member_post (Type const&)
      {
        pop_ ();
      }

      // ValueMemberType
      //
      //

      ValueMemberType::
      ValueMemberType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ValueMemberType::
      ValueMemberType ()
      {
      }

      void ValueMemberType::
      traverse (Type const& o)
      {
        Traversal::ValueMemberType::traverse (o);
      }

      void ValueMemberType::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::ValueMemberType::name (o);
        pop_ ();
      }

      void ValueMemberType::
      visibility (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("visibility"), top_ ()));
        Traversal::ValueMemberType::visibility (o);
        pop_ ();
      }

      void ValueMemberType::
      type (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("type"), top_ ()));
        Traversal::ValueMemberType::type (o);
        pop_ ();
      }

      // NamedValue
      //
      //

      NamedValue::
      NamedValue (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      NamedValue::
      NamedValue ()
      {
      }

      void NamedValue::
      traverse (Type const& o)
      {
        Traversal::NamedValue::traverse (o);
      }

      void NamedValue::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::NamedValue::name (o);
        pop_ ();
      }

      void NamedValue::
      value (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("value"), top_ ()));
        Traversal::NamedValue::value (o);
        pop_ ();
      }

      // SequenceType
      //
      //

      SequenceType::
      SequenceType (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      SequenceType::
      SequenceType ()
      {
      }

      void SequenceType::
      traverse (Type const& o)
      {
        Traversal::SequenceType::traverse (o);
      }

      void SequenceType::
      bound (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("bound"), top_ ()));
        Traversal::SequenceType::bound (o);
        pop_ ();
      }

      void SequenceType::
      elementType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("elementType"), top_ ()));
        Traversal::SequenceType::elementType (o);
        pop_ ();
      }

      // Any
      //
      //

      Any::
      Any (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Any::
      Any ()
      {
      }

      void Any::
      traverse (Type const& o)
      {
        Traversal::Any::traverse (o);
      }

      void Any::
      type (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("type"), top_ ()));
        Traversal::Any::type (o);
        pop_ ();
      }

      void Any::
      value (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("value"), top_ ()));
        Traversal::Any::value (o);
        pop_ ();
      }

      // Property
      //
      //

      Property::
      Property (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Property::
      Property ()
      {
      }

      void Property::
      traverse (Type const& o)
      {
        Traversal::Property::traverse (o);
      }

      void Property::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::Property::name (o);
        pop_ ();
      }

      void Property::
      value (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("value"), top_ ()));
        Traversal::Property::value (o);
        pop_ ();
      }

      // SatisfierPropertyKind
      //
      //

      SatisfierPropertyKind::
      SatisfierPropertyKind (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      SatisfierPropertyKind::
      SatisfierPropertyKind ()
      {
      }

      void SatisfierPropertyKind::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::DAnCE::Config_Handlers::SatisfierPropertyKind::Quantity) s = ACE_TEXT ("Quantity");
        else if (o == ::DAnCE::Config_Handlers::SatisfierPropertyKind::Capacity) s = ACE_TEXT ("Capacity");
        else if (o == ::DAnCE::Config_Handlers::SatisfierPropertyKind::Minimum) s = ACE_TEXT ("Minimum");
        else if (o == ::DAnCE::Config_Handlers::SatisfierPropertyKind::Maximum) s = ACE_TEXT ("Maximum");
        else if (o == ::DAnCE::Config_Handlers::SatisfierPropertyKind::Attribute) s = ACE_TEXT ("Attribute");
        else if (o == ::DAnCE::Config_Handlers::SatisfierPropertyKind::Selection) s = ACE_TEXT ("Selection");
        else
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // SatisfierProperty
      //
      //

      SatisfierProperty::
      SatisfierProperty (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      SatisfierProperty::
      SatisfierProperty ()
      {
      }

      void SatisfierProperty::
      traverse (Type const& o)
      {
        Traversal::SatisfierProperty::traverse (o);
      }

      void SatisfierProperty::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::SatisfierProperty::name (o);
        pop_ ();
      }

      void SatisfierProperty::
      kind (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("kind"), top_ ()));
        Traversal::SatisfierProperty::kind (o);
        pop_ ();
      }

      void SatisfierProperty::
      dynamic (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("dynamic"), top_ ()));
        Traversal::SatisfierProperty::dynamic (o);
        pop_ ();
      }

      void SatisfierProperty::
      value (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("value"), top_ ()));
        Traversal::SatisfierProperty::value (o);
        pop_ ();
      }

      // Resource
      //
      //

      Resource::
      Resource (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Resource::
      Resource ()
      {
      }

      void Resource::
      traverse (Type const& o)
      {
        Traversal::Resource::traverse (o);
      }

      void Resource::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::Resource::name (o);
        pop_ ();
      }

      void Resource::
      resourceType_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceType"), top_ ()));
      }

      void Resource::
      resourceType_next (Type const& o)
      {
        resourceType_post (o);
        resourceType_pre (o);
      }

      void Resource::
      resourceType_post (Type const&)
      {
        pop_ ();
      }

      void Resource::
      property_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
      }

      void Resource::
      property_next (Type const& o)
      {
        property_post (o);
        property_pre (o);
      }

      void Resource::
      property_post (Type const&)
      {
        pop_ ();
      }

      // Requirement
      //
      //

      Requirement::
      Requirement (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Requirement::
      Requirement ()
      {
      }

      void Requirement::
      traverse (Type const& o)
      {
        Traversal::Requirement::traverse (o);
      }

      void Requirement::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::Requirement::name (o);
        pop_ ();
      }

      void Requirement::
      resourceType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceType"), top_ ()));
        Traversal::Requirement::resourceType (o);
        pop_ ();
      }

      void Requirement::
      property_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
      }

      void Requirement::
      property_next (Type const& o)
      {
        property_post (o);
        property_pre (o);
      }

      void Requirement::
      property_post (Type const&)
      {
        pop_ ();
      }

      // ResourceDeploymentDescription
      //
      //

      ResourceDeploymentDescription::
      ResourceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ResourceDeploymentDescription::
      ResourceDeploymentDescription ()
      {
      }

      void ResourceDeploymentDescription::
      traverse (Type const& o)
      {
        Traversal::ResourceDeploymentDescription::traverse (o);
      }

      void ResourceDeploymentDescription::
      requirementName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("requirementName"), top_ ()));
        Traversal::ResourceDeploymentDescription::requirementName (o);
        pop_ ();
      }

      void ResourceDeploymentDescription::
      resourceName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceName"), top_ ()));
        Traversal::ResourceDeploymentDescription::resourceName (o);
        pop_ ();
      }

      void ResourceDeploymentDescription::
      property_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
      }

      void ResourceDeploymentDescription::
      property_next (Type const& o)
      {
        property_post (o);
        property_pre (o);
      }

      void ResourceDeploymentDescription::
      property_post (Type const&)
      {
        pop_ ();
      }

      // ArtifactDeploymentDescription
      //
      //

      ArtifactDeploymentDescription::
      ArtifactDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ArtifactDeploymentDescription::
      ArtifactDeploymentDescription ()
      {
      }

      void ArtifactDeploymentDescription::
      traverse (Type const& o)
      {
        Traversal::ArtifactDeploymentDescription::traverse (o);
      }

      void ArtifactDeploymentDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::ArtifactDeploymentDescription::name (o);
        pop_ ();
      }

      void ArtifactDeploymentDescription::
      source_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("source"), top_ ()));
      }

      void ArtifactDeploymentDescription::
      source_next (Type const& o)
      {
        source_post (o);
        source_pre (o);
      }

      void ArtifactDeploymentDescription::
      source_post (Type const&)
      {
        pop_ ();
      }

      void ArtifactDeploymentDescription::
      node (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("node"), top_ ()));
        Traversal::ArtifactDeploymentDescription::node (o);
        pop_ ();
      }

      void ArtifactDeploymentDescription::
      location_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("location"), top_ ()));
      }

      void ArtifactDeploymentDescription::
      location_next (Type const& o)
      {
        location_post (o);
        location_pre (o);
      }

      void ArtifactDeploymentDescription::
      location_post (Type const&)
      {
        pop_ ();
      }

      void ArtifactDeploymentDescription::
      execParameter_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("execParameter"), top_ ()));
      }

      void ArtifactDeploymentDescription::
      execParameter_next (Type const& o)
      {
        execParameter_post (o);
        execParameter_pre (o);
      }

      void ArtifactDeploymentDescription::
      execParameter_post (Type const&)
      {
        pop_ ();
      }

      void ArtifactDeploymentDescription::
      deployRequirement_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployRequirement"), top_ ()));
      }

      void ArtifactDeploymentDescription::
      deployRequirement_next (Type const& o)
      {
        deployRequirement_post (o);
        deployRequirement_pre (o);
      }

      void ArtifactDeploymentDescription::
      deployRequirement_post (Type const&)
      {
        pop_ ();
      }

      void ArtifactDeploymentDescription::
      deployedResource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployedResource"), top_ ()));
      }

      void ArtifactDeploymentDescription::
      deployedResource_next (Type const& o)
      {
        deployedResource_post (o);
        deployedResource_pre (o);
      }

      void ArtifactDeploymentDescription::
      deployedResource_post (Type const&)
      {
        pop_ ();
      }

      void ArtifactDeploymentDescription::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (ACE_TEXT ("id"), ACE_TEXT ("http://www.omg.org/Deployment"), ACE_TEXT (""), top_ ());
        attr_ (&a);
        Traversal::ArtifactDeploymentDescription::id (o);
        attr_ (0);
      }

      // MonolithicDeploymentDescription
      //
      //

      MonolithicDeploymentDescription::
      MonolithicDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      MonolithicDeploymentDescription::
      MonolithicDeploymentDescription ()
      {
      }

      void MonolithicDeploymentDescription::
      traverse (Type const& o)
      {
        Traversal::MonolithicDeploymentDescription::traverse (o);
      }

      void MonolithicDeploymentDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::MonolithicDeploymentDescription::name (o);
        pop_ ();
      }

      void MonolithicDeploymentDescription::
      source_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("source"), top_ ()));
      }

      void MonolithicDeploymentDescription::
      source_next (Type const& o)
      {
        source_post (o);
        source_pre (o);
      }

      void MonolithicDeploymentDescription::
      source_post (Type const&)
      {
        pop_ ();
      }

      void MonolithicDeploymentDescription::
      artifact_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("artifact"), top_ ()));
      }

      void MonolithicDeploymentDescription::
      artifact_next (Type const& o)
      {
        artifact_post (o);
        artifact_pre (o);
      }

      void MonolithicDeploymentDescription::
      artifact_post (Type const&)
      {
        pop_ ();
      }

      void MonolithicDeploymentDescription::
      execParameter_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("execParameter"), top_ ()));
      }

      void MonolithicDeploymentDescription::
      execParameter_next (Type const& o)
      {
        execParameter_post (o);
        execParameter_pre (o);
      }

      void MonolithicDeploymentDescription::
      execParameter_post (Type const&)
      {
        pop_ ();
      }

      void MonolithicDeploymentDescription::
      deployRequirement_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployRequirement"), top_ ()));
      }

      void MonolithicDeploymentDescription::
      deployRequirement_next (Type const& o)
      {
        deployRequirement_post (o);
        deployRequirement_pre (o);
      }

      void MonolithicDeploymentDescription::
      deployRequirement_post (Type const&)
      {
        pop_ ();
      }

      void MonolithicDeploymentDescription::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (ACE_TEXT ("id"), ACE_TEXT ("http://www.omg.org/Deployment"), ACE_TEXT (""), top_ ());
        attr_ (&a);
        Traversal::MonolithicDeploymentDescription::id (o);
        attr_ (0);
      }

      // ResourceUsageKind
      //
      //

      ResourceUsageKind::
      ResourceUsageKind (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ResourceUsageKind::
      ResourceUsageKind ()
      {
      }

      void ResourceUsageKind::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::DAnCE::Config_Handlers::ResourceUsageKind::None) s = ACE_TEXT ("None");
        else if (o == ::DAnCE::Config_Handlers::ResourceUsageKind::InstanceUsesResource) s = ACE_TEXT ("InstanceUsesResource");
        else if (o == ::DAnCE::Config_Handlers::ResourceUsageKind::ResourceUsesInstance) s = ACE_TEXT ("ResourceUsesInstance");
        else if (o == ::DAnCE::Config_Handlers::ResourceUsageKind::PortUsesResource) s = ACE_TEXT ("PortUsesResource");
        else if (o == ::DAnCE::Config_Handlers::ResourceUsageKind::ResourceUsesPort) s = ACE_TEXT ("ResourceUsesPort");
        else
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // InstanceResourceDeploymentDescription
      //
      //

      InstanceResourceDeploymentDescription::
      InstanceResourceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      InstanceResourceDeploymentDescription::
      InstanceResourceDeploymentDescription ()
      {
      }

      void InstanceResourceDeploymentDescription::
      traverse (Type const& o)
      {
        Traversal::InstanceResourceDeploymentDescription::traverse (o);
      }

      void InstanceResourceDeploymentDescription::
      resourceUsage (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceUsage"), top_ ()));
        Traversal::InstanceResourceDeploymentDescription::resourceUsage (o);
        pop_ ();
      }

      void InstanceResourceDeploymentDescription::
      requirementName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("requirementName"), top_ ()));
        Traversal::InstanceResourceDeploymentDescription::requirementName (o);
        pop_ ();
      }

      void InstanceResourceDeploymentDescription::
      resourceName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceName"), top_ ()));
        Traversal::InstanceResourceDeploymentDescription::resourceName (o);
        pop_ ();
      }

      void InstanceResourceDeploymentDescription::
      property_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
      }

      void InstanceResourceDeploymentDescription::
      property_next (Type const& o)
      {
        property_post (o);
        property_pre (o);
      }

      void InstanceResourceDeploymentDescription::
      property_post (Type const&)
      {
        pop_ ();
      }

      // InstanceDeploymentDescription
      //
      //

      InstanceDeploymentDescription::
      InstanceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      InstanceDeploymentDescription::
      InstanceDeploymentDescription ()
      {
      }

      void InstanceDeploymentDescription::
      traverse (Type const& o)
      {
        Traversal::InstanceDeploymentDescription::traverse (o);
      }

      void InstanceDeploymentDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::InstanceDeploymentDescription::name (o);
        pop_ ();
      }

      void InstanceDeploymentDescription::
      node (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("node"), top_ ()));
        Traversal::InstanceDeploymentDescription::node (o);
        pop_ ();
      }

      void InstanceDeploymentDescription::
      source (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("source"), top_ ()));
        Traversal::InstanceDeploymentDescription::source (o);
        pop_ ();
      }

      void InstanceDeploymentDescription::
      implementation (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("implementation"), top_ ()));
        Traversal::InstanceDeploymentDescription::implementation (o);
        pop_ ();
      }

      void InstanceDeploymentDescription::
      configProperty_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("configProperty"), top_ ()));
      }

      void InstanceDeploymentDescription::
      configProperty_next (Type const& o)
      {
        configProperty_post (o);
        configProperty_pre (o);
      }

      void InstanceDeploymentDescription::
      configProperty_post (Type const&)
      {
        pop_ ();
      }

      void InstanceDeploymentDescription::
      deployedResource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployedResource"), top_ ()));
      }

      void InstanceDeploymentDescription::
      deployedResource_next (Type const& o)
      {
        deployedResource_post (o);
        deployedResource_pre (o);
      }

      void InstanceDeploymentDescription::
      deployedResource_post (Type const&)
      {
        pop_ ();
      }

      void InstanceDeploymentDescription::
      deployedSharedResource (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployedSharedResource"), top_ ()));
        Traversal::InstanceDeploymentDescription::deployedSharedResource (o);
        pop_ ();
      }

      void InstanceDeploymentDescription::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (ACE_TEXT ("id"), ACE_TEXT ("http://www.omg.org/Deployment"), ACE_TEXT (""), top_ ());
        attr_ (&a);
        Traversal::InstanceDeploymentDescription::id (o);
        attr_ (0);
      }

      // CCMComponentPortKind
      //
      //

      CCMComponentPortKind::
      CCMComponentPortKind (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      CCMComponentPortKind::
      CCMComponentPortKind ()
      {
      }

      void CCMComponentPortKind::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::Facet) s = ACE_TEXT ("Facet");
        else if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::SimplexReceptacle) s = ACE_TEXT ("SimplexReceptacle");
        else if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::MultiplexReceptacle) s = ACE_TEXT ("MultiplexReceptacle");
        else if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::EventEmitter) s = ACE_TEXT ("EventEmitter");
        else if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::EventPublisher) s = ACE_TEXT ("EventPublisher");
        else if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::EventConsumer) s = ACE_TEXT ("EventConsumer");
        else if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::ExtendedPort) s = ACE_TEXT ("ExtendedPort");
        else if (o == ::DAnCE::Config_Handlers::CCMComponentPortKind::MirrorPort) s = ACE_TEXT ("MirrorPort");
        else
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // ComponentPortDescription
      //
      //

      ComponentPortDescription::
      ComponentPortDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ComponentPortDescription::
      ComponentPortDescription ()
      {
      }

      void ComponentPortDescription::
      traverse (Type const& o)
      {
        Traversal::ComponentPortDescription::traverse (o);
      }

      void ComponentPortDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::ComponentPortDescription::name (o);
        pop_ ();
      }

      void ComponentPortDescription::
      specificType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("specificType"), top_ ()));
        Traversal::ComponentPortDescription::specificType (o);
        pop_ ();
      }

      void ComponentPortDescription::
      supportedType_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("supportedType"), top_ ()));
      }

      void ComponentPortDescription::
      supportedType_next (Type const& o)
      {
        supportedType_post (o);
        supportedType_pre (o);
      }

      void ComponentPortDescription::
      supportedType_post (Type const&)
      {
        pop_ ();
      }

      void ComponentPortDescription::
      provider (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("provider"), top_ ()));
        Traversal::ComponentPortDescription::provider (o);
        pop_ ();
      }

      void ComponentPortDescription::
      exclusiveProvider (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("exclusiveProvider"), top_ ()));
        Traversal::ComponentPortDescription::exclusiveProvider (o);
        pop_ ();
      }

      void ComponentPortDescription::
      exclusiveUser (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("exclusiveUser"), top_ ()));
        Traversal::ComponentPortDescription::exclusiveUser (o);
        pop_ ();
      }

      void ComponentPortDescription::
      optional (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("optional"), top_ ()));
        Traversal::ComponentPortDescription::optional (o);
        pop_ ();
      }

      void ComponentPortDescription::
      kind (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("kind"), top_ ()));
        Traversal::ComponentPortDescription::kind (o);
        pop_ ();
      }

      void ComponentPortDescription::
      templateParam_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("templateParam"), top_ ()));
      }

      void ComponentPortDescription::
      templateParam_next (Type const& o)
      {
        templateParam_post (o);
        templateParam_pre (o);
      }

      void ComponentPortDescription::
      templateParam_post (Type const&)
      {
        pop_ ();
      }

      // ComponentPropertyDescription
      //
      //

      ComponentPropertyDescription::
      ComponentPropertyDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ComponentPropertyDescription::
      ComponentPropertyDescription ()
      {
      }

      void ComponentPropertyDescription::
      traverse (Type const& o)
      {
        Traversal::ComponentPropertyDescription::traverse (o);
      }

      void ComponentPropertyDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::ComponentPropertyDescription::name (o);
        pop_ ();
      }

      void ComponentPropertyDescription::
      type (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("type"), top_ ()));
        Traversal::ComponentPropertyDescription::type (o);
        pop_ ();
      }

      // ComponentExternalPortEndpoint
      //
      //

      ComponentExternalPortEndpoint::
      ComponentExternalPortEndpoint (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ComponentExternalPortEndpoint::
      ComponentExternalPortEndpoint ()
      {
      }

      void ComponentExternalPortEndpoint::
      traverse (Type const& o)
      {
        Traversal::ComponentExternalPortEndpoint::traverse (o);
      }

      void ComponentExternalPortEndpoint::
      portName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("portName"), top_ ()));
        Traversal::ComponentExternalPortEndpoint::portName (o);
        pop_ ();
      }

      // PlanSubcomponentPortEndpoint
      //
      //

      PlanSubcomponentPortEndpoint::
      PlanSubcomponentPortEndpoint (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PlanSubcomponentPortEndpoint::
      PlanSubcomponentPortEndpoint ()
      {
      }

      void PlanSubcomponentPortEndpoint::
      traverse (Type const& o)
      {
        Traversal::PlanSubcomponentPortEndpoint::traverse (o);
      }

      void PlanSubcomponentPortEndpoint::
      portName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("portName"), top_ ()));
        Traversal::PlanSubcomponentPortEndpoint::portName (o);
        pop_ ();
      }

      void PlanSubcomponentPortEndpoint::
      provider (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("provider"), top_ ()));
        Traversal::PlanSubcomponentPortEndpoint::provider (o);
        pop_ ();
      }

      void PlanSubcomponentPortEndpoint::
      kind (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("kind"), top_ ()));
        Traversal::PlanSubcomponentPortEndpoint::kind (o);
        pop_ ();
      }

      void PlanSubcomponentPortEndpoint::
      instance (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("instance"), top_ ()));
        Traversal::PlanSubcomponentPortEndpoint::instance (o);
        pop_ ();
      }

      // ExternalReferenceEndpoint
      //
      //

      ExternalReferenceEndpoint::
      ExternalReferenceEndpoint (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ExternalReferenceEndpoint::
      ExternalReferenceEndpoint ()
      {
      }

      void ExternalReferenceEndpoint::
      traverse (Type const& o)
      {
        Traversal::ExternalReferenceEndpoint::traverse (o);
      }

      void ExternalReferenceEndpoint::
      location (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("location"), top_ ()));
        Traversal::ExternalReferenceEndpoint::location (o);
        pop_ ();
      }

      void ExternalReferenceEndpoint::
      provider (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("provider"), top_ ()));
        Traversal::ExternalReferenceEndpoint::provider (o);
        pop_ ();
      }

      void ExternalReferenceEndpoint::
      portName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("portName"), top_ ()));
        Traversal::ExternalReferenceEndpoint::portName (o);
        pop_ ();
      }

      void ExternalReferenceEndpoint::
      supportedType_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("supportedType"), top_ ()));
      }

      void ExternalReferenceEndpoint::
      supportedType_next (Type const& o)
      {
        supportedType_post (o);
        supportedType_pre (o);
      }

      void ExternalReferenceEndpoint::
      supportedType_post (Type const&)
      {
        pop_ ();
      }

      // ConnectionResourceDeploymentDescription
      //
      //

      ConnectionResourceDeploymentDescription::
      ConnectionResourceDeploymentDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ConnectionResourceDeploymentDescription::
      ConnectionResourceDeploymentDescription ()
      {
      }

      void ConnectionResourceDeploymentDescription::
      traverse (Type const& o)
      {
        Traversal::ConnectionResourceDeploymentDescription::traverse (o);
      }

      void ConnectionResourceDeploymentDescription::
      targetName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("targetName"), top_ ()));
        Traversal::ConnectionResourceDeploymentDescription::targetName (o);
        pop_ ();
      }

      void ConnectionResourceDeploymentDescription::
      requirementName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("requirementName"), top_ ()));
        Traversal::ConnectionResourceDeploymentDescription::requirementName (o);
        pop_ ();
      }

      void ConnectionResourceDeploymentDescription::
      resourceName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceName"), top_ ()));
        Traversal::ConnectionResourceDeploymentDescription::resourceName (o);
        pop_ ();
      }

      void ConnectionResourceDeploymentDescription::
      property_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
      }

      void ConnectionResourceDeploymentDescription::
      property_next (Type const& o)
      {
        property_post (o);
        property_pre (o);
      }

      void ConnectionResourceDeploymentDescription::
      property_post (Type const&)
      {
        pop_ ();
      }

      // PlanConnectionDescription
      //
      //

      PlanConnectionDescription::
      PlanConnectionDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PlanConnectionDescription::
      PlanConnectionDescription ()
      {
      }

      void PlanConnectionDescription::
      traverse (Type const& o)
      {
        Traversal::PlanConnectionDescription::traverse (o);
      }

      void PlanConnectionDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::PlanConnectionDescription::name (o);
        pop_ ();
      }

      void PlanConnectionDescription::
      source (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("source"), top_ ()));
        Traversal::PlanConnectionDescription::source (o);
        pop_ ();
      }

      void PlanConnectionDescription::
      deployRequirement_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployRequirement"), top_ ()));
      }

      void PlanConnectionDescription::
      deployRequirement_next (Type const& o)
      {
        deployRequirement_post (o);
        deployRequirement_pre (o);
      }

      void PlanConnectionDescription::
      deployRequirement_post (Type const&)
      {
        pop_ ();
      }

      void PlanConnectionDescription::
      externalEndpoint_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("externalEndpoint"), top_ ()));
      }

      void PlanConnectionDescription::
      externalEndpoint_next (Type const& o)
      {
        externalEndpoint_post (o);
        externalEndpoint_pre (o);
      }

      void PlanConnectionDescription::
      externalEndpoint_post (Type const&)
      {
        pop_ ();
      }

      void PlanConnectionDescription::
      internalEndpoint_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("internalEndpoint"), top_ ()));
      }

      void PlanConnectionDescription::
      internalEndpoint_next (Type const& o)
      {
        internalEndpoint_post (o);
        internalEndpoint_pre (o);
      }

      void PlanConnectionDescription::
      internalEndpoint_post (Type const&)
      {
        pop_ ();
      }

      void PlanConnectionDescription::
      externalReference_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("externalReference"), top_ ()));
      }

      void PlanConnectionDescription::
      externalReference_next (Type const& o)
      {
        externalReference_post (o);
        externalReference_pre (o);
      }

      void PlanConnectionDescription::
      externalReference_post (Type const&)
      {
        pop_ ();
      }

      void PlanConnectionDescription::
      deployedResource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployedResource"), top_ ()));
      }

      void PlanConnectionDescription::
      deployedResource_next (Type const& o)
      {
        deployedResource_post (o);
        deployedResource_pre (o);
      }

      void PlanConnectionDescription::
      deployedResource_post (Type const&)
      {
        pop_ ();
      }

      // ImplementationDependency
      //
      //

      ImplementationDependency::
      ImplementationDependency (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ImplementationDependency::
      ImplementationDependency ()
      {
      }

      void ImplementationDependency::
      traverse (Type const& o)
      {
        Traversal::ImplementationDependency::traverse (o);
      }

      void ImplementationDependency::
      requiredType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("requiredType"), top_ ()));
        Traversal::ImplementationDependency::requiredType (o);
        pop_ ();
      }

      // Capability
      //
      //

      Capability::
      Capability (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Capability::
      Capability ()
      {
      }

      void Capability::
      traverse (Type const& o)
      {
        Traversal::Capability::traverse (o);
      }

      void Capability::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::Capability::name (o);
        pop_ ();
      }

      void Capability::
      resourceType_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceType"), top_ ()));
      }

      void Capability::
      resourceType_next (Type const& o)
      {
        resourceType_post (o);
        resourceType_pre (o);
      }

      void Capability::
      resourceType_post (Type const&)
      {
        pop_ ();
      }

      void Capability::
      property_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
      }

      void Capability::
      property_next (Type const& o)
      {
        property_post (o);
        property_pre (o);
      }

      void Capability::
      property_post (Type const&)
      {
        pop_ ();
      }

      // ImplementationRequirement
      //
      //

      ImplementationRequirement::
      ImplementationRequirement (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ImplementationRequirement::
      ImplementationRequirement ()
      {
      }

      void ImplementationRequirement::
      traverse (Type const& o)
      {
        Traversal::ImplementationRequirement::traverse (o);
      }

      void ImplementationRequirement::
      resourceUsage (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceUsage"), top_ ()));
        Traversal::ImplementationRequirement::resourceUsage (o);
        pop_ ();
      }

      void ImplementationRequirement::
      resourcePort (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourcePort"), top_ ()));
        Traversal::ImplementationRequirement::resourcePort (o);
        pop_ ();
      }

      void ImplementationRequirement::
      componentPort (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("componentPort"), top_ ()));
        Traversal::ImplementationRequirement::componentPort (o);
        pop_ ();
      }

      void ImplementationRequirement::
      resourceType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("resourceType"), top_ ()));
        Traversal::ImplementationRequirement::resourceType (o);
        pop_ ();
      }

      void ImplementationRequirement::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::ImplementationRequirement::name (o);
        pop_ ();
      }

      void ImplementationRequirement::
      property_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("property"), top_ ()));
      }

      void ImplementationRequirement::
      property_next (Type const& o)
      {
        property_post (o);
        property_pre (o);
      }

      void ImplementationRequirement::
      property_post (Type const&)
      {
        pop_ ();
      }

      // SubcomponentPortEndpoint
      //
      //

      SubcomponentPortEndpoint::
      SubcomponentPortEndpoint (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      SubcomponentPortEndpoint::
      SubcomponentPortEndpoint ()
      {
      }

      void SubcomponentPortEndpoint::
      traverse (Type const& o)
      {
        Traversal::SubcomponentPortEndpoint::traverse (o);
      }

      void SubcomponentPortEndpoint::
      portName (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("portName"), top_ ()));
        Traversal::SubcomponentPortEndpoint::portName (o);
        pop_ ();
      }

      void SubcomponentPortEndpoint::
      instance (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("instance"), top_ ()));
        Traversal::SubcomponentPortEndpoint::instance (o);
        pop_ ();
      }

      // AssemblyConnectionDescription
      //
      //

      AssemblyConnectionDescription::
      AssemblyConnectionDescription (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      AssemblyConnectionDescription::
      AssemblyConnectionDescription ()
      {
      }

      void AssemblyConnectionDescription::
      traverse (Type const& o)
      {
        Traversal::AssemblyConnectionDescription::traverse (o);
      }

      void AssemblyConnectionDescription::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("name"), top_ ()));
        Traversal::AssemblyConnectionDescription::name (o);
        pop_ ();
      }

      void AssemblyConnectionDescription::
      deployRequirement_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("deployRequirement"), top_ ()));
      }

      void AssemblyConnectionDescription::
      deployRequirement_next (Type const& o)
      {
        deployRequirement_post (o);
        deployRequirement_pre (o);
      }

      void AssemblyConnectionDescription::
      deployRequirement_post (Type const&)
      {
        pop_ ();
      }

      void AssemblyConnectionDescription::
      internalEndpoint_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("internalEndpoint"), top_ ()));
      }

      void AssemblyConnectionDescription::
      internalEndpoint_next (Type const& o)
      {
        internalEndpoint_post (o);
        internalEndpoint_pre (o);
      }

      void AssemblyConnectionDescription::
      internalEndpoint_post (Type const&)
      {
        pop_ ();
      }

      void AssemblyConnectionDescription::
      externalEndpoint_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("externalEndpoint"), top_ ()));
      }

      void AssemblyConnectionDescription::
      externalEndpoint_next (Type const& o)
      {
        externalEndpoint_post (o);
        externalEndpoint_pre (o);
      }

      void AssemblyConnectionDescription::
      externalEndpoint_post (Type const&)
      {
        pop_ ();
      }

      void AssemblyConnectionDescription::
      externalReference_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("externalReference"), top_ ()));
      }

      void AssemblyConnectionDescription::
      externalReference_next (Type const& o)
      {
        externalReference_post (o);
        externalReference_pre (o);
      }

      void AssemblyConnectionDescription::
      externalReference_post (Type const&)
      {
        pop_ ();
      }

      // PlanLocalityKind
      //
      //

      PlanLocalityKind::
      PlanLocalityKind (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PlanLocalityKind::
      PlanLocalityKind ()
      {
      }

      void PlanLocalityKind::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::DAnCE::Config_Handlers::PlanLocalityKind::SameProcess) s = ACE_TEXT ("SameProcess");
        else if (o == ::DAnCE::Config_Handlers::PlanLocalityKind::DifferentProcess) s = ACE_TEXT ("DifferentProcess");
        else if (o == ::DAnCE::Config_Handlers::PlanLocalityKind::NoConstraint) s = ACE_TEXT ("NoConstraint");
        else
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // PlanLocality
      //
      //

      PlanLocality::
      PlanLocality (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PlanLocality::
      PlanLocality ()
      {
      }

      void PlanLocality::
      traverse (Type const& o)
      {
        Traversal::PlanLocality::traverse (o);
      }

      void PlanLocality::
      constraint (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("constraint"), top_ ()));
        Traversal::PlanLocality::constraint (o);
        pop_ ();
      }

      void PlanLocality::
      constrainedInstance_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > (ACE_TEXT ("constrainedInstance"), top_ ()));
      }

      void PlanLocality::
      constrainedInstance_next (Type const& o)
      {
        constrainedInstance_post (o);
        constrainedInstance_pre (o);
      }

      void PlanLocality::
      constrainedInstance_post (Type const&)
      {
        pop_ ();
      }
    }
  }
}

namespace DAnCE
{
  namespace Config_Handlers
  {
  }
}

