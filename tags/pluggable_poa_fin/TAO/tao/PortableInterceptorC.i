/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#if (TAO_HAS_INTERCEPTORS == 1)
#if !defined (_PORTABLEINTERCEPTOR_OCTETSEQ_CI_)
#define _PORTABLEINTERCEPTOR_OCTETSEQ_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::OctetSeq_var
// *************************************************************

ACE_INLINE
PortableInterceptor::OctetSeq_var::OctetSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
PortableInterceptor::OctetSeq_var::OctetSeq_var (OctetSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
PortableInterceptor::OctetSeq_var::OctetSeq_var (const ::PortableInterceptor::OctetSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::PortableInterceptor::OctetSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

// fixed-size base types only
ACE_INLINE
PortableInterceptor::OctetSeq_var::OctetSeq_var (const ::PortableInterceptor::OctetSeq &p)
{
  ACE_NEW (this->ptr_, ::PortableInterceptor::OctetSeq (p));
}

ACE_INLINE
PortableInterceptor::OctetSeq_var::~OctetSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE PortableInterceptor::OctetSeq_var &
PortableInterceptor::OctetSeq_var::operator= (OctetSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::OctetSeq_var &
PortableInterceptor::OctetSeq_var::operator= (const ::PortableInterceptor::OctetSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::PortableInterceptor::OctetSeq (*p.ptr_), *this);
  }
  return *this;
}

// fixed-size types only
ACE_INLINE ::PortableInterceptor::OctetSeq_var &
PortableInterceptor::OctetSeq_var::operator= (const ::PortableInterceptor::OctetSeq &p)
{
  if (this->ptr_ != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::PortableInterceptor::OctetSeq (p), *this);
  }
  return *this;
}

ACE_INLINE const ::PortableInterceptor::OctetSeq *
PortableInterceptor::OctetSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::OctetSeq *
PortableInterceptor::OctetSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::OctetSeq_var::operator const ::PortableInterceptor::OctetSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
PortableInterceptor::OctetSeq_var::operator ::PortableInterceptor::OctetSeq &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
PortableInterceptor::OctetSeq_var::operator ::PortableInterceptor::OctetSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE CORBA::Octet &
PortableInterceptor::OctetSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::PortableInterceptor::OctetSeq &
PortableInterceptor::OctetSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::PortableInterceptor::OctetSeq &
PortableInterceptor::OctetSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size
ACE_INLINE ::PortableInterceptor::OctetSeq *&
PortableInterceptor::OctetSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::OctetSeq *
PortableInterceptor::OctetSeq_var::_retn (void)
{
  ::PortableInterceptor::OctetSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::PortableInterceptor::OctetSeq *
PortableInterceptor::OctetSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class PortableInterceptor::OctetSeq_out
// *************************************************************

ACE_INLINE
PortableInterceptor::OctetSeq_out::OctetSeq_out (OctetSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
PortableInterceptor::OctetSeq_out::OctetSeq_out (OctetSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
PortableInterceptor::OctetSeq_out::OctetSeq_out (const ::PortableInterceptor::OctetSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (OctetSeq_out&, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::OctetSeq_out &
PortableInterceptor::OctetSeq_out::operator= (const ::PortableInterceptor::OctetSeq_out &p)
{
  this->ptr_ = ACE_const_cast (OctetSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::PortableInterceptor::OctetSeq_out &
PortableInterceptor::OctetSeq_out::operator= (OctetSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::OctetSeq_out::operator ::PortableInterceptor::OctetSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::OctetSeq *&
PortableInterceptor::OctetSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::OctetSeq *
PortableInterceptor::OctetSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE CORBA::Octet &
PortableInterceptor::OctetSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_STRINGSEQ_CI_)
#define _PORTABLEINTERCEPTOR_STRINGSEQ_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::StringSeq_var
// *************************************************************

ACE_INLINE
PortableInterceptor::StringSeq_var::StringSeq_var (void) // default constructor
  : ptr_ (0)
{}

ACE_INLINE
PortableInterceptor::StringSeq_var::StringSeq_var (StringSeq *p)
  : ptr_ (p)
{}

ACE_INLINE
PortableInterceptor::StringSeq_var::StringSeq_var (const ::PortableInterceptor::StringSeq_var &p) // copy constructor
{
  if (p.ptr_)
    ACE_NEW (this->ptr_, ::PortableInterceptor::StringSeq (*p.ptr_));
  else
    this->ptr_ = 0;
}

ACE_INLINE
PortableInterceptor::StringSeq_var::~StringSeq_var (void) // destructor
{
  delete this->ptr_;
}

ACE_INLINE PortableInterceptor::StringSeq_var &
PortableInterceptor::StringSeq_var::operator= (StringSeq *p)
{
  delete this->ptr_;
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::StringSeq_var &
PortableInterceptor::StringSeq_var::operator= (const ::PortableInterceptor::StringSeq_var &p) // deep copy
{
  if (this != &p)
  {
    delete this->ptr_;
    ACE_NEW_RETURN (this->ptr_, ::PortableInterceptor::StringSeq (*p.ptr_), *this);
  }
  return *this;
}

ACE_INLINE const ::PortableInterceptor::StringSeq *
PortableInterceptor::StringSeq_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::StringSeq *
PortableInterceptor::StringSeq_var::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::StringSeq_var::operator const ::PortableInterceptor::StringSeq &() const // cast
{
  return *this->ptr_;
}

ACE_INLINE
PortableInterceptor::StringSeq_var::operator ::PortableInterceptor::StringSeq &() // cast
{
  return *this->ptr_;
}

ACE_INLINE
PortableInterceptor::StringSeq_var::operator ::PortableInterceptor::StringSeq &() const // cast
{
  return *this->ptr_;
}

// variable-size types only
ACE_INLINE
PortableInterceptor::StringSeq_var::operator ::PortableInterceptor::StringSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
PortableInterceptor::StringSeq_var::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}

ACE_INLINE const ::PortableInterceptor::StringSeq &
PortableInterceptor::StringSeq_var::in (void) const
{
  return *this->ptr_;
}

ACE_INLINE ::PortableInterceptor::StringSeq &
PortableInterceptor::StringSeq_var::inout (void)
{
  return *this->ptr_;
}

// mapping for variable size
ACE_INLINE ::PortableInterceptor::StringSeq *&
PortableInterceptor::StringSeq_var::out (void)
{
  delete this->ptr_;
  this->ptr_ = 0;
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::StringSeq *
PortableInterceptor::StringSeq_var::_retn (void)
{
  ::PortableInterceptor::StringSeq *tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

ACE_INLINE ::PortableInterceptor::StringSeq *
PortableInterceptor::StringSeq_var::ptr (void) const
{
  return this->ptr_;
}

// *************************************************************
// Inline operations for class PortableInterceptor::StringSeq_out
// *************************************************************

ACE_INLINE
PortableInterceptor::StringSeq_out::StringSeq_out (StringSeq *&p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

ACE_INLINE
PortableInterceptor::StringSeq_out::StringSeq_out (StringSeq_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  delete this->ptr_;
  this->ptr_ = 0;
}

ACE_INLINE
PortableInterceptor::StringSeq_out::StringSeq_out (const ::PortableInterceptor::StringSeq_out &p) // copy constructor
  : ptr_ (ACE_const_cast (StringSeq_out&, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::StringSeq_out &
PortableInterceptor::StringSeq_out::operator= (const ::PortableInterceptor::StringSeq_out &p)
{
  this->ptr_ = ACE_const_cast (StringSeq_out&, p).ptr_;
  return *this;
}

ACE_INLINE ::PortableInterceptor::StringSeq_out &
PortableInterceptor::StringSeq_out::operator= (StringSeq *p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::StringSeq_out::operator ::PortableInterceptor::StringSeq *&() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::StringSeq *&
PortableInterceptor::StringSeq_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::StringSeq *
PortableInterceptor::StringSeq_out::operator-> (void)
{
  return this->ptr_;
}

ACE_INLINE TAO_SeqElem_String_Manager
PortableInterceptor::StringSeq_out::operator[] (CORBA::ULong index)
{
  return this->ptr_->operator[] (index);
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_INTERCEPTOR___CI_)
#define _PORTABLEINTERCEPTOR_INTERCEPTOR___CI_

ACE_INLINE
PortableInterceptor::Interceptor::Interceptor (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_INTERCEPTOR___VAR_CI_)
#define _PORTABLEINTERCEPTOR_INTERCEPTOR___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::Interceptor_var
// *************************************************************

ACE_INLINE
PortableInterceptor::Interceptor_var::Interceptor_var (void) // default constructor
  : ptr_ (Interceptor::_nil ())
{}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr
PortableInterceptor::Interceptor_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::Interceptor_var::Interceptor_var (const ::PortableInterceptor::Interceptor_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Interceptor::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::Interceptor_var::~Interceptor_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::Interceptor_var &
PortableInterceptor::Interceptor_var::operator= (Interceptor_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::Interceptor_var &
PortableInterceptor::Interceptor_var::operator= (const ::PortableInterceptor::Interceptor_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::Interceptor::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::Interceptor_var::operator const ::PortableInterceptor::Interceptor_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::Interceptor_var::operator ::PortableInterceptor::Interceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr
PortableInterceptor::Interceptor_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr
PortableInterceptor::Interceptor_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr &
PortableInterceptor::Interceptor_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr &
PortableInterceptor::Interceptor_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::Interceptor::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr
PortableInterceptor::Interceptor_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::Interceptor_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::Interceptor::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_INTERCEPTOR___OUT_CI_)
#define _PORTABLEINTERCEPTOR_INTERCEPTOR___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::Interceptor_out
// *************************************************************

ACE_INLINE
PortableInterceptor::Interceptor_out::Interceptor_out (Interceptor_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::Interceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::Interceptor_out::Interceptor_out (Interceptor_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::Interceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::Interceptor_out::Interceptor_out (const ::PortableInterceptor::Interceptor_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Interceptor_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::Interceptor_out &
PortableInterceptor::Interceptor_out::operator= (const ::PortableInterceptor::Interceptor_out &p)
{
  this->ptr_ = ACE_const_cast (Interceptor_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::Interceptor_out &
PortableInterceptor::Interceptor_out::operator= (const ::PortableInterceptor::Interceptor_var &p)
{
  this->ptr_ = ::PortableInterceptor::Interceptor::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::Interceptor_out &
PortableInterceptor::Interceptor_out::operator= (Interceptor_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::Interceptor_out::operator ::PortableInterceptor::Interceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr &
PortableInterceptor::Interceptor_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Interceptor_ptr
PortableInterceptor::Interceptor_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception PortableInterceptor::ForwardRequest
// *************************************************************

// *************************************************************
// Inline operations for exception PortableInterceptor::InvalidSlot
// *************************************************************


#if !defined (_PORTABLEINTERCEPTOR_CURRENT___CI_)
#define _PORTABLEINTERCEPTOR_CURRENT___CI_

ACE_INLINE
PortableInterceptor::Current::Current (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CURRENT___VAR_CI_)
#define _PORTABLEINTERCEPTOR_CURRENT___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::Current_var
// *************************************************************

ACE_INLINE
PortableInterceptor::Current_var::Current_var (void) // default constructor
  : ptr_ (Current::_nil ())
{}

ACE_INLINE ::PortableInterceptor::Current_ptr
PortableInterceptor::Current_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::Current_var::Current_var (const ::PortableInterceptor::Current_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Current::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::Current_var::~Current_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::Current_var &
PortableInterceptor::Current_var::operator= (Current_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::Current_var &
PortableInterceptor::Current_var::operator= (const ::PortableInterceptor::Current_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::Current::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::Current_var::operator const ::PortableInterceptor::Current_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::Current_var::operator ::PortableInterceptor::Current_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Current_ptr
PortableInterceptor::Current_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Current_ptr
PortableInterceptor::Current_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Current_ptr &
PortableInterceptor::Current_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Current_ptr &
PortableInterceptor::Current_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::Current::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Current_ptr
PortableInterceptor::Current_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::Current_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::Current::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CURRENT___OUT_CI_)
#define _PORTABLEINTERCEPTOR_CURRENT___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::Current_out
// *************************************************************

ACE_INLINE
PortableInterceptor::Current_out::Current_out (Current_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::Current::_nil ();
}

ACE_INLINE
PortableInterceptor::Current_out::Current_out (Current_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::Current::_nil ();
}

ACE_INLINE
PortableInterceptor::Current_out::Current_out (const ::PortableInterceptor::Current_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Current_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::Current_out &
PortableInterceptor::Current_out::operator= (const ::PortableInterceptor::Current_out &p)
{
  this->ptr_ = ACE_const_cast (Current_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::Current_out &
PortableInterceptor::Current_out::operator= (const ::PortableInterceptor::Current_var &p)
{
  this->ptr_ = ::PortableInterceptor::Current::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::Current_out &
PortableInterceptor::Current_out::operator= (Current_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::Current_out::operator ::PortableInterceptor::Current_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Current_ptr &
PortableInterceptor::Current_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::Current_ptr
PortableInterceptor::Current_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_REQUESTINFO___CI_)
#define _PORTABLEINTERCEPTOR_REQUESTINFO___CI_

ACE_INLINE
PortableInterceptor::RequestInfo::RequestInfo (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_REQUESTINFO___VAR_CI_)
#define _PORTABLEINTERCEPTOR_REQUESTINFO___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::RequestInfo_var
// *************************************************************

ACE_INLINE
PortableInterceptor::RequestInfo_var::RequestInfo_var (void) // default constructor
  : ptr_ (RequestInfo::_nil ())
{}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr
PortableInterceptor::RequestInfo_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::RequestInfo_var::RequestInfo_var (const ::PortableInterceptor::RequestInfo_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (RequestInfo::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::RequestInfo_var::~RequestInfo_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::RequestInfo_var &
PortableInterceptor::RequestInfo_var::operator= (RequestInfo_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::RequestInfo_var &
PortableInterceptor::RequestInfo_var::operator= (const ::PortableInterceptor::RequestInfo_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::RequestInfo::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::RequestInfo_var::operator const ::PortableInterceptor::RequestInfo_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::RequestInfo_var::operator ::PortableInterceptor::RequestInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr
PortableInterceptor::RequestInfo_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr
PortableInterceptor::RequestInfo_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr &
PortableInterceptor::RequestInfo_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr &
PortableInterceptor::RequestInfo_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::RequestInfo::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr
PortableInterceptor::RequestInfo_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::RequestInfo_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::RequestInfo::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_REQUESTINFO___OUT_CI_)
#define _PORTABLEINTERCEPTOR_REQUESTINFO___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::RequestInfo_out
// *************************************************************

ACE_INLINE
PortableInterceptor::RequestInfo_out::RequestInfo_out (RequestInfo_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::RequestInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::RequestInfo_out::RequestInfo_out (RequestInfo_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::RequestInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::RequestInfo_out::RequestInfo_out (const ::PortableInterceptor::RequestInfo_out &p) // copy constructor
  : ptr_ (ACE_const_cast (RequestInfo_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::RequestInfo_out &
PortableInterceptor::RequestInfo_out::operator= (const ::PortableInterceptor::RequestInfo_out &p)
{
  this->ptr_ = ACE_const_cast (RequestInfo_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::RequestInfo_out &
PortableInterceptor::RequestInfo_out::operator= (const ::PortableInterceptor::RequestInfo_var &p)
{
  this->ptr_ = ::PortableInterceptor::RequestInfo::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::RequestInfo_out &
PortableInterceptor::RequestInfo_out::operator= (RequestInfo_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::RequestInfo_out::operator ::PortableInterceptor::RequestInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr &
PortableInterceptor::RequestInfo_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::RequestInfo_ptr
PortableInterceptor::RequestInfo_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CLIENTREQUESTINFO___CI_)
#define _PORTABLEINTERCEPTOR_CLIENTREQUESTINFO___CI_

ACE_INLINE
PortableInterceptor::ClientRequestInfo::ClientRequestInfo (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CLIENTREQUESTINFO___VAR_CI_)
#define _PORTABLEINTERCEPTOR_CLIENTREQUESTINFO___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ClientRequestInfo_var
// *************************************************************

ACE_INLINE
PortableInterceptor::ClientRequestInfo_var::ClientRequestInfo_var (void) // default constructor
  : ptr_ (ClientRequestInfo::_nil ())
{}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr
PortableInterceptor::ClientRequestInfo_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ClientRequestInfo_var::ClientRequestInfo_var (const ::PortableInterceptor::ClientRequestInfo_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ClientRequestInfo::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::ClientRequestInfo_var::~ClientRequestInfo_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::ClientRequestInfo_var &
PortableInterceptor::ClientRequestInfo_var::operator= (ClientRequestInfo_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::ClientRequestInfo_var &
PortableInterceptor::ClientRequestInfo_var::operator= (const ::PortableInterceptor::ClientRequestInfo_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::ClientRequestInfo::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::ClientRequestInfo_var::operator const ::PortableInterceptor::ClientRequestInfo_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ClientRequestInfo_var::operator ::PortableInterceptor::ClientRequestInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr
PortableInterceptor::ClientRequestInfo_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr
PortableInterceptor::ClientRequestInfo_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr &
PortableInterceptor::ClientRequestInfo_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr &
PortableInterceptor::ClientRequestInfo_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ClientRequestInfo::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr
PortableInterceptor::ClientRequestInfo_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::ClientRequestInfo_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::ClientRequestInfo::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CLIENTREQUESTINFO___OUT_CI_)
#define _PORTABLEINTERCEPTOR_CLIENTREQUESTINFO___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ClientRequestInfo_out
// *************************************************************

ACE_INLINE
PortableInterceptor::ClientRequestInfo_out::ClientRequestInfo_out (ClientRequestInfo_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::ClientRequestInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::ClientRequestInfo_out::ClientRequestInfo_out (ClientRequestInfo_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ClientRequestInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::ClientRequestInfo_out::ClientRequestInfo_out (const ::PortableInterceptor::ClientRequestInfo_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ClientRequestInfo_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_out &
PortableInterceptor::ClientRequestInfo_out::operator= (const ::PortableInterceptor::ClientRequestInfo_out &p)
{
  this->ptr_ = ACE_const_cast (ClientRequestInfo_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::ClientRequestInfo_out &
PortableInterceptor::ClientRequestInfo_out::operator= (const ::PortableInterceptor::ClientRequestInfo_var &p)
{
  this->ptr_ = ::PortableInterceptor::ClientRequestInfo::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::ClientRequestInfo_out &
PortableInterceptor::ClientRequestInfo_out::operator= (ClientRequestInfo_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::ClientRequestInfo_out::operator ::PortableInterceptor::ClientRequestInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr &
PortableInterceptor::ClientRequestInfo_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInfo_ptr
PortableInterceptor::ClientRequestInfo_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_SERVERREQUESTINFO___CI_)
#define _PORTABLEINTERCEPTOR_SERVERREQUESTINFO___CI_

ACE_INLINE
PortableInterceptor::ServerRequestInfo::ServerRequestInfo (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_SERVERREQUESTINFO___VAR_CI_)
#define _PORTABLEINTERCEPTOR_SERVERREQUESTINFO___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ServerRequestInfo_var
// *************************************************************

ACE_INLINE
PortableInterceptor::ServerRequestInfo_var::ServerRequestInfo_var (void) // default constructor
  : ptr_ (ServerRequestInfo::_nil ())
{}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr
PortableInterceptor::ServerRequestInfo_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ServerRequestInfo_var::ServerRequestInfo_var (const ::PortableInterceptor::ServerRequestInfo_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ServerRequestInfo::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::ServerRequestInfo_var::~ServerRequestInfo_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::ServerRequestInfo_var &
PortableInterceptor::ServerRequestInfo_var::operator= (ServerRequestInfo_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::ServerRequestInfo_var &
PortableInterceptor::ServerRequestInfo_var::operator= (const ::PortableInterceptor::ServerRequestInfo_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::ServerRequestInfo::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::ServerRequestInfo_var::operator const ::PortableInterceptor::ServerRequestInfo_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ServerRequestInfo_var::operator ::PortableInterceptor::ServerRequestInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr
PortableInterceptor::ServerRequestInfo_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr
PortableInterceptor::ServerRequestInfo_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr &
PortableInterceptor::ServerRequestInfo_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr &
PortableInterceptor::ServerRequestInfo_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ServerRequestInfo::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr
PortableInterceptor::ServerRequestInfo_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::ServerRequestInfo_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::ServerRequestInfo::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_SERVERREQUESTINFO___OUT_CI_)
#define _PORTABLEINTERCEPTOR_SERVERREQUESTINFO___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ServerRequestInfo_out
// *************************************************************

ACE_INLINE
PortableInterceptor::ServerRequestInfo_out::ServerRequestInfo_out (ServerRequestInfo_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::ServerRequestInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::ServerRequestInfo_out::ServerRequestInfo_out (ServerRequestInfo_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ServerRequestInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::ServerRequestInfo_out::ServerRequestInfo_out (const ::PortableInterceptor::ServerRequestInfo_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ServerRequestInfo_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_out &
PortableInterceptor::ServerRequestInfo_out::operator= (const ::PortableInterceptor::ServerRequestInfo_out &p)
{
  this->ptr_ = ACE_const_cast (ServerRequestInfo_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::ServerRequestInfo_out &
PortableInterceptor::ServerRequestInfo_out::operator= (const ::PortableInterceptor::ServerRequestInfo_var &p)
{
  this->ptr_ = ::PortableInterceptor::ServerRequestInfo::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::ServerRequestInfo_out &
PortableInterceptor::ServerRequestInfo_out::operator= (ServerRequestInfo_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::ServerRequestInfo_out::operator ::PortableInterceptor::ServerRequestInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr &
PortableInterceptor::ServerRequestInfo_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInfo_ptr
PortableInterceptor::ServerRequestInfo_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CLIENTREQUESTINTERCEPTOR___CI_)
#define _PORTABLEINTERCEPTOR_CLIENTREQUESTINTERCEPTOR___CI_

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor::ClientRequestInterceptor (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CLIENTREQUESTINTERCEPTOR___VAR_CI_)
#define _PORTABLEINTERCEPTOR_CLIENTREQUESTINTERCEPTOR___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ClientRequestInterceptor_var
// *************************************************************

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_var::ClientRequestInterceptor_var (void) // default constructor
  : ptr_ (ClientRequestInterceptor::_nil ())
{}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr
PortableInterceptor::ClientRequestInterceptor_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_var::ClientRequestInterceptor_var (const ::PortableInterceptor::ClientRequestInterceptor_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ClientRequestInterceptor::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_var::~ClientRequestInterceptor_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::ClientRequestInterceptor_var &
PortableInterceptor::ClientRequestInterceptor_var::operator= (ClientRequestInterceptor_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::ClientRequestInterceptor_var &
PortableInterceptor::ClientRequestInterceptor_var::operator= (const ::PortableInterceptor::ClientRequestInterceptor_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::ClientRequestInterceptor::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_var::operator const ::PortableInterceptor::ClientRequestInterceptor_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_var::operator ::PortableInterceptor::ClientRequestInterceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr
PortableInterceptor::ClientRequestInterceptor_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr
PortableInterceptor::ClientRequestInterceptor_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr &
PortableInterceptor::ClientRequestInterceptor_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr &
PortableInterceptor::ClientRequestInterceptor_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ClientRequestInterceptor::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr
PortableInterceptor::ClientRequestInterceptor_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::ClientRequestInterceptor_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::ClientRequestInterceptor::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_CLIENTREQUESTINTERCEPTOR___OUT_CI_)
#define _PORTABLEINTERCEPTOR_CLIENTREQUESTINTERCEPTOR___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ClientRequestInterceptor_out
// *************************************************************

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_out::ClientRequestInterceptor_out (ClientRequestInterceptor_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::ClientRequestInterceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_out::ClientRequestInterceptor_out (ClientRequestInterceptor_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ClientRequestInterceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_out::ClientRequestInterceptor_out (const ::PortableInterceptor::ClientRequestInterceptor_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ClientRequestInterceptor_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_out &
PortableInterceptor::ClientRequestInterceptor_out::operator= (const ::PortableInterceptor::ClientRequestInterceptor_out &p)
{
  this->ptr_ = ACE_const_cast (ClientRequestInterceptor_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::ClientRequestInterceptor_out &
PortableInterceptor::ClientRequestInterceptor_out::operator= (const ::PortableInterceptor::ClientRequestInterceptor_var &p)
{
  this->ptr_ = ::PortableInterceptor::ClientRequestInterceptor::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::ClientRequestInterceptor_out &
PortableInterceptor::ClientRequestInterceptor_out::operator= (ClientRequestInterceptor_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::ClientRequestInterceptor_out::operator ::PortableInterceptor::ClientRequestInterceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr &
PortableInterceptor::ClientRequestInterceptor_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ClientRequestInterceptor_ptr
PortableInterceptor::ClientRequestInterceptor_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_SERVERREQUESTINTERCEPTOR___CI_)
#define _PORTABLEINTERCEPTOR_SERVERREQUESTINTERCEPTOR___CI_

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor::ServerRequestInterceptor (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_SERVERREQUESTINTERCEPTOR___VAR_CI_)
#define _PORTABLEINTERCEPTOR_SERVERREQUESTINTERCEPTOR___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ServerRequestInterceptor_var
// *************************************************************

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_var::ServerRequestInterceptor_var (void) // default constructor
  : ptr_ (ServerRequestInterceptor::_nil ())
{}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr
PortableInterceptor::ServerRequestInterceptor_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_var::ServerRequestInterceptor_var (const ::PortableInterceptor::ServerRequestInterceptor_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ServerRequestInterceptor::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_var::~ServerRequestInterceptor_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::ServerRequestInterceptor_var &
PortableInterceptor::ServerRequestInterceptor_var::operator= (ServerRequestInterceptor_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::ServerRequestInterceptor_var &
PortableInterceptor::ServerRequestInterceptor_var::operator= (const ::PortableInterceptor::ServerRequestInterceptor_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::ServerRequestInterceptor::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_var::operator const ::PortableInterceptor::ServerRequestInterceptor_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_var::operator ::PortableInterceptor::ServerRequestInterceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr
PortableInterceptor::ServerRequestInterceptor_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr
PortableInterceptor::ServerRequestInterceptor_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr &
PortableInterceptor::ServerRequestInterceptor_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr &
PortableInterceptor::ServerRequestInterceptor_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ServerRequestInterceptor::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr
PortableInterceptor::ServerRequestInterceptor_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::ServerRequestInterceptor_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::ServerRequestInterceptor::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_SERVERREQUESTINTERCEPTOR___OUT_CI_)
#define _PORTABLEINTERCEPTOR_SERVERREQUESTINTERCEPTOR___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ServerRequestInterceptor_out
// *************************************************************

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_out::ServerRequestInterceptor_out (ServerRequestInterceptor_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::ServerRequestInterceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_out::ServerRequestInterceptor_out (ServerRequestInterceptor_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ServerRequestInterceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_out::ServerRequestInterceptor_out (const ::PortableInterceptor::ServerRequestInterceptor_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ServerRequestInterceptor_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_out &
PortableInterceptor::ServerRequestInterceptor_out::operator= (const ::PortableInterceptor::ServerRequestInterceptor_out &p)
{
  this->ptr_ = ACE_const_cast (ServerRequestInterceptor_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::ServerRequestInterceptor_out &
PortableInterceptor::ServerRequestInterceptor_out::operator= (const ::PortableInterceptor::ServerRequestInterceptor_var &p)
{
  this->ptr_ = ::PortableInterceptor::ServerRequestInterceptor::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::ServerRequestInterceptor_out &
PortableInterceptor::ServerRequestInterceptor_out::operator= (ServerRequestInterceptor_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::ServerRequestInterceptor_out::operator ::PortableInterceptor::ServerRequestInterceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr &
PortableInterceptor::ServerRequestInterceptor_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ServerRequestInterceptor_ptr
PortableInterceptor::ServerRequestInterceptor_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_IORINFO___CI_)
#define _PORTABLEINTERCEPTOR_IORINFO___CI_

ACE_INLINE
PortableInterceptor::IORInfo::IORInfo (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_IORINFO___VAR_CI_)
#define _PORTABLEINTERCEPTOR_IORINFO___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::IORInfo_var
// *************************************************************

ACE_INLINE
PortableInterceptor::IORInfo_var::IORInfo_var (void) // default constructor
  : ptr_ (IORInfo::_nil ())
{}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr
PortableInterceptor::IORInfo_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::IORInfo_var::IORInfo_var (const ::PortableInterceptor::IORInfo_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IORInfo::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::IORInfo_var::~IORInfo_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::IORInfo_var &
PortableInterceptor::IORInfo_var::operator= (IORInfo_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::IORInfo_var &
PortableInterceptor::IORInfo_var::operator= (const ::PortableInterceptor::IORInfo_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::IORInfo::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::IORInfo_var::operator const ::PortableInterceptor::IORInfo_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::IORInfo_var::operator ::PortableInterceptor::IORInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr
PortableInterceptor::IORInfo_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr
PortableInterceptor::IORInfo_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr &
PortableInterceptor::IORInfo_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr &
PortableInterceptor::IORInfo_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::IORInfo::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr
PortableInterceptor::IORInfo_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::IORInfo_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::IORInfo::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_IORINFO___OUT_CI_)
#define _PORTABLEINTERCEPTOR_IORINFO___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::IORInfo_out
// *************************************************************

ACE_INLINE
PortableInterceptor::IORInfo_out::IORInfo_out (IORInfo_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::IORInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::IORInfo_out::IORInfo_out (IORInfo_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::IORInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::IORInfo_out::IORInfo_out (const ::PortableInterceptor::IORInfo_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IORInfo_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::IORInfo_out &
PortableInterceptor::IORInfo_out::operator= (const ::PortableInterceptor::IORInfo_out &p)
{
  this->ptr_ = ACE_const_cast (IORInfo_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::IORInfo_out &
PortableInterceptor::IORInfo_out::operator= (const ::PortableInterceptor::IORInfo_var &p)
{
  this->ptr_ = ::PortableInterceptor::IORInfo::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::IORInfo_out &
PortableInterceptor::IORInfo_out::operator= (IORInfo_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::IORInfo_out::operator ::PortableInterceptor::IORInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr &
PortableInterceptor::IORInfo_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInfo_ptr
PortableInterceptor::IORInfo_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_IORINTERCEPTOR___CI_)
#define _PORTABLEINTERCEPTOR_IORINTERCEPTOR___CI_

ACE_INLINE
PortableInterceptor::IORInterceptor::IORInterceptor (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_IORINTERCEPTOR___VAR_CI_)
#define _PORTABLEINTERCEPTOR_IORINTERCEPTOR___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::IORInterceptor_var
// *************************************************************

ACE_INLINE
PortableInterceptor::IORInterceptor_var::IORInterceptor_var (void) // default constructor
  : ptr_ (IORInterceptor::_nil ())
{}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr
PortableInterceptor::IORInterceptor_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::IORInterceptor_var::IORInterceptor_var (const ::PortableInterceptor::IORInterceptor_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IORInterceptor::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::IORInterceptor_var::~IORInterceptor_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::IORInterceptor_var &
PortableInterceptor::IORInterceptor_var::operator= (IORInterceptor_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::IORInterceptor_var &
PortableInterceptor::IORInterceptor_var::operator= (const ::PortableInterceptor::IORInterceptor_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::IORInterceptor::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::IORInterceptor_var::operator const ::PortableInterceptor::IORInterceptor_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::IORInterceptor_var::operator ::PortableInterceptor::IORInterceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr
PortableInterceptor::IORInterceptor_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr
PortableInterceptor::IORInterceptor_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr &
PortableInterceptor::IORInterceptor_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr &
PortableInterceptor::IORInterceptor_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::IORInterceptor::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr
PortableInterceptor::IORInterceptor_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::IORInterceptor_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::IORInterceptor::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_IORINTERCEPTOR___OUT_CI_)
#define _PORTABLEINTERCEPTOR_IORINTERCEPTOR___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::IORInterceptor_out
// *************************************************************

ACE_INLINE
PortableInterceptor::IORInterceptor_out::IORInterceptor_out (IORInterceptor_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::IORInterceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::IORInterceptor_out::IORInterceptor_out (IORInterceptor_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::IORInterceptor::_nil ();
}

ACE_INLINE
PortableInterceptor::IORInterceptor_out::IORInterceptor_out (const ::PortableInterceptor::IORInterceptor_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IORInterceptor_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::IORInterceptor_out &
PortableInterceptor::IORInterceptor_out::operator= (const ::PortableInterceptor::IORInterceptor_out &p)
{
  this->ptr_ = ACE_const_cast (IORInterceptor_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::IORInterceptor_out &
PortableInterceptor::IORInterceptor_out::operator= (const ::PortableInterceptor::IORInterceptor_var &p)
{
  this->ptr_ = ::PortableInterceptor::IORInterceptor::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::IORInterceptor_out &
PortableInterceptor::IORInterceptor_out::operator= (IORInterceptor_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::IORInterceptor_out::operator ::PortableInterceptor::IORInterceptor_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr &
PortableInterceptor::IORInterceptor_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::IORInterceptor_ptr
PortableInterceptor::IORInterceptor_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_POLICYFACTORY___CI_)
#define _PORTABLEINTERCEPTOR_POLICYFACTORY___CI_

ACE_INLINE
PortableInterceptor::PolicyFactory::PolicyFactory (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_POLICYFACTORY___VAR_CI_)
#define _PORTABLEINTERCEPTOR_POLICYFACTORY___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::PolicyFactory_var
// *************************************************************

ACE_INLINE
PortableInterceptor::PolicyFactory_var::PolicyFactory_var (void) // default constructor
  : ptr_ (PolicyFactory::_nil ())
{}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr
PortableInterceptor::PolicyFactory_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::PolicyFactory_var::PolicyFactory_var (const ::PortableInterceptor::PolicyFactory_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (PolicyFactory::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::PolicyFactory_var::~PolicyFactory_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::PolicyFactory_var &
PortableInterceptor::PolicyFactory_var::operator= (PolicyFactory_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::PolicyFactory_var &
PortableInterceptor::PolicyFactory_var::operator= (const ::PortableInterceptor::PolicyFactory_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::PolicyFactory::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::PolicyFactory_var::operator const ::PortableInterceptor::PolicyFactory_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::PolicyFactory_var::operator ::PortableInterceptor::PolicyFactory_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr
PortableInterceptor::PolicyFactory_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr
PortableInterceptor::PolicyFactory_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr &
PortableInterceptor::PolicyFactory_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr &
PortableInterceptor::PolicyFactory_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::PolicyFactory::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr
PortableInterceptor::PolicyFactory_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::PolicyFactory_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::PolicyFactory::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_POLICYFACTORY___OUT_CI_)
#define _PORTABLEINTERCEPTOR_POLICYFACTORY___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::PolicyFactory_out
// *************************************************************

ACE_INLINE
PortableInterceptor::PolicyFactory_out::PolicyFactory_out (PolicyFactory_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::PolicyFactory::_nil ();
}

ACE_INLINE
PortableInterceptor::PolicyFactory_out::PolicyFactory_out (PolicyFactory_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::PolicyFactory::_nil ();
}

ACE_INLINE
PortableInterceptor::PolicyFactory_out::PolicyFactory_out (const ::PortableInterceptor::PolicyFactory_out &p) // copy constructor
  : ptr_ (ACE_const_cast (PolicyFactory_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::PolicyFactory_out &
PortableInterceptor::PolicyFactory_out::operator= (const ::PortableInterceptor::PolicyFactory_out &p)
{
  this->ptr_ = ACE_const_cast (PolicyFactory_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::PolicyFactory_out &
PortableInterceptor::PolicyFactory_out::operator= (const ::PortableInterceptor::PolicyFactory_var &p)
{
  this->ptr_ = ::PortableInterceptor::PolicyFactory::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::PolicyFactory_out &
PortableInterceptor::PolicyFactory_out::operator= (PolicyFactory_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::PolicyFactory_out::operator ::PortableInterceptor::PolicyFactory_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr &
PortableInterceptor::PolicyFactory_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::PolicyFactory_ptr
PortableInterceptor::PolicyFactory_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */

// *************************************************************
// Inline operations for exception PortableInterceptor::ORBInitInfo::DuplicateName
// *************************************************************

// *************************************************************
// Inline operations for exception PortableInterceptor::ORBInitInfo::InvalidName
// *************************************************************


#if !defined (_PORTABLEINTERCEPTOR_ORBINITINFO___CI_)
#define _PORTABLEINTERCEPTOR_ORBINITINFO___CI_

ACE_INLINE
PortableInterceptor::ORBInitInfo::ORBInitInfo (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_ORBINITINFO___VAR_CI_)
#define _PORTABLEINTERCEPTOR_ORBINITINFO___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ORBInitInfo_var
// *************************************************************

ACE_INLINE
PortableInterceptor::ORBInitInfo_var::ORBInitInfo_var (void) // default constructor
  : ptr_ (ORBInitInfo::_nil ())
{}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr
PortableInterceptor::ORBInitInfo_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ORBInitInfo_var::ORBInitInfo_var (const ::PortableInterceptor::ORBInitInfo_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ORBInitInfo::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::ORBInitInfo_var::~ORBInitInfo_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::ORBInitInfo_var &
PortableInterceptor::ORBInitInfo_var::operator= (ORBInitInfo_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::ORBInitInfo_var &
PortableInterceptor::ORBInitInfo_var::operator= (const ::PortableInterceptor::ORBInitInfo_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::ORBInitInfo::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::ORBInitInfo_var::operator const ::PortableInterceptor::ORBInitInfo_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ORBInitInfo_var::operator ::PortableInterceptor::ORBInitInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr
PortableInterceptor::ORBInitInfo_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr
PortableInterceptor::ORBInitInfo_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr &
PortableInterceptor::ORBInitInfo_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr &
PortableInterceptor::ORBInitInfo_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ORBInitInfo::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr
PortableInterceptor::ORBInitInfo_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::ORBInitInfo_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::ORBInitInfo::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_ORBINITINFO___OUT_CI_)
#define _PORTABLEINTERCEPTOR_ORBINITINFO___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ORBInitInfo_out
// *************************************************************

ACE_INLINE
PortableInterceptor::ORBInitInfo_out::ORBInitInfo_out (ORBInitInfo_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::ORBInitInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::ORBInitInfo_out::ORBInitInfo_out (ORBInitInfo_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ORBInitInfo::_nil ();
}

ACE_INLINE
PortableInterceptor::ORBInitInfo_out::ORBInitInfo_out (const ::PortableInterceptor::ORBInitInfo_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ORBInitInfo_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_out &
PortableInterceptor::ORBInitInfo_out::operator= (const ::PortableInterceptor::ORBInitInfo_out &p)
{
  this->ptr_ = ACE_const_cast (ORBInitInfo_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::ORBInitInfo_out &
PortableInterceptor::ORBInitInfo_out::operator= (const ::PortableInterceptor::ORBInitInfo_var &p)
{
  this->ptr_ = ::PortableInterceptor::ORBInitInfo::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::ORBInitInfo_out &
PortableInterceptor::ORBInitInfo_out::operator= (ORBInitInfo_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::ORBInitInfo_out::operator ::PortableInterceptor::ORBInitInfo_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr &
PortableInterceptor::ORBInitInfo_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitInfo_ptr
PortableInterceptor::ORBInitInfo_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_ORBINITIALIZER___CI_)
#define _PORTABLEINTERCEPTOR_ORBINITIALIZER___CI_

ACE_INLINE
PortableInterceptor::ORBInitializer::ORBInitializer (TAO_Stub *objref, CORBA::Boolean _tao_collocated) // constructor
  : CORBA_Object (objref, _tao_collocated)
{}

#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_ORBINITIALIZER___VAR_CI_)
#define _PORTABLEINTERCEPTOR_ORBINITIALIZER___VAR_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ORBInitializer_var
// *************************************************************

ACE_INLINE
PortableInterceptor::ORBInitializer_var::ORBInitializer_var (void) // default constructor
  : ptr_ (ORBInitializer::_nil ())
{}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr
PortableInterceptor::ORBInitializer_var::ptr (void) const
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ORBInitializer_var::ORBInitializer_var (const ::PortableInterceptor::ORBInitializer_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ORBInitializer::_duplicate (p.ptr ()))
{}

ACE_INLINE
PortableInterceptor::ORBInitializer_var::~ORBInitializer_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

ACE_INLINE PortableInterceptor::ORBInitializer_var &
PortableInterceptor::ORBInitializer_var::operator= (ORBInitializer_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

ACE_INLINE PortableInterceptor::ORBInitializer_var &
PortableInterceptor::ORBInitializer_var::operator= (const ::PortableInterceptor::ORBInitializer_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableInterceptor::ORBInitializer::_duplicate (p.ptr ());
  }
  return *this;
}

ACE_INLINE
PortableInterceptor::ORBInitializer_var::operator const ::PortableInterceptor::ORBInitializer_ptr &() const // cast
{
  return this->ptr_;
}

ACE_INLINE
PortableInterceptor::ORBInitializer_var::operator ::PortableInterceptor::ORBInitializer_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr
PortableInterceptor::ORBInitializer_var::operator-> (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr
PortableInterceptor::ORBInitializer_var::in (void) const
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr &
PortableInterceptor::ORBInitializer_var::inout (void)
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr &
PortableInterceptor::ORBInitializer_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ORBInitializer::_nil ();
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr
PortableInterceptor::ORBInitializer_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableInterceptor::ORBInitializer_ptr val = this->ptr_;
  this->ptr_ = ::PortableInterceptor::ORBInitializer::_nil ();
  return val;
}


#endif /* end #if !defined */


#if !defined (_PORTABLEINTERCEPTOR_ORBINITIALIZER___OUT_CI_)
#define _PORTABLEINTERCEPTOR_ORBINITIALIZER___OUT_CI_

// *************************************************************
// Inline operations for class PortableInterceptor::ORBInitializer_out
// *************************************************************

ACE_INLINE
PortableInterceptor::ORBInitializer_out::ORBInitializer_out (ORBInitializer_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableInterceptor::ORBInitializer::_nil ();
}

ACE_INLINE
PortableInterceptor::ORBInitializer_out::ORBInitializer_out (ORBInitializer_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableInterceptor::ORBInitializer::_nil ();
}

ACE_INLINE
PortableInterceptor::ORBInitializer_out::ORBInitializer_out (const ::PortableInterceptor::ORBInitializer_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ORBInitializer_out &, p).ptr_)
{}

ACE_INLINE ::PortableInterceptor::ORBInitializer_out &
PortableInterceptor::ORBInitializer_out::operator= (const ::PortableInterceptor::ORBInitializer_out &p)
{
  this->ptr_ = ACE_const_cast (ORBInitializer_out&, p).ptr_;
  return *this;
}

ACE_INLINE PortableInterceptor::ORBInitializer_out &
PortableInterceptor::ORBInitializer_out::operator= (const ::PortableInterceptor::ORBInitializer_var &p)
{
  this->ptr_ = ::PortableInterceptor::ORBInitializer::_duplicate (p.ptr ());
  return *this;
}

ACE_INLINE PortableInterceptor::ORBInitializer_out &
PortableInterceptor::ORBInitializer_out::operator= (ORBInitializer_ptr p)
{
  this->ptr_ = p;
  return *this;
}

ACE_INLINE
PortableInterceptor::ORBInitializer_out::operator ::PortableInterceptor::ORBInitializer_ptr &() // cast
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr &
PortableInterceptor::ORBInitializer_out::ptr (void) // ptr
{
  return this->ptr_;
}

ACE_INLINE ::PortableInterceptor::ORBInitializer_ptr
PortableInterceptor::ORBInitializer_out::operator-> (void)
{
  return this->ptr_;
}


#endif /* end #if !defined */


#if !defined _TAO_CDR_OP_PortableInterceptor_OctetSeq_I_
#define _TAO_CDR_OP_PortableInterceptor_OctetSeq_I_

CORBA::Boolean TAO_Export operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::OctetSeq &
  );
CORBA::Boolean TAO_Export operator>> (
    TAO_InputCDR &,
    PortableInterceptor::OctetSeq &
  );

#endif /* _TAO_CDR_OP_PortableInterceptor_OctetSeq_I_ */


#if !defined _TAO_CDR_OP_PortableInterceptor_StringSeq_I_
#define _TAO_CDR_OP_PortableInterceptor_StringSeq_I_

CORBA::Boolean TAO_Export operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::StringSeq &
  );
CORBA::Boolean TAO_Export operator>> (
    TAO_InputCDR &,
    PortableInterceptor::StringSeq &
  );

#endif /* _TAO_CDR_OP_PortableInterceptor_StringSeq_I_ */

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::Interceptor_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::Interceptor_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::Interceptor_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::Interceptor_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::Interceptor::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const PortableInterceptor::ForwardRequest &_tao_aggregate)
{
  // first marshal the repository ID
  if (strm << _tao_aggregate._id ())
  {
    // now marshal the members (if any)
    if (
      (strm << _tao_aggregate.forward.in ()) &&
      (strm << CORBA::Any::from_boolean (_tao_aggregate.permanent))
    )
      return 1;
    else
      return 0;
  }
  else
    return 0;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm,PortableInterceptor::ForwardRequest &_tao_aggregate)
{
  // now marshal the members
  if (
    (strm >> _tao_aggregate.forward.out ()) &&
    (strm >> CORBA::Any::to_boolean (_tao_aggregate.permanent))
  )
    return 1;
  else
    return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const PortableInterceptor::InvalidSlot &_tao_aggregate)
{
  // first marshal the repository ID
  if (strm << _tao_aggregate._id ())
    return 1;
  else
    return 0;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &,PortableInterceptor::InvalidSlot&)
{
  return 1;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::Current_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::Current_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::Current_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::Current_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::Current::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::RequestInfo_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::RequestInfo_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::RequestInfo_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::RequestInfo_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::RequestInfo::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::ClientRequestInfo_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::ClientRequestInfo_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ClientRequestInfo_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ClientRequestInfo_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::ClientRequestInfo::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::ServerRequestInfo_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::ServerRequestInfo_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ServerRequestInfo_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ServerRequestInfo_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::ServerRequestInfo::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::ClientRequestInterceptor_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::ClientRequestInterceptor_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ClientRequestInterceptor_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ClientRequestInterceptor_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::ClientRequestInterceptor::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::ServerRequestInterceptor_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::ServerRequestInterceptor_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ServerRequestInterceptor_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ServerRequestInterceptor_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::ServerRequestInterceptor::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::IORInfo_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::IORInfo_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::IORInfo_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::IORInfo_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::IORInfo::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::IORInterceptor_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::IORInterceptor_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::IORInterceptor_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::IORInterceptor_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::IORInterceptor::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::PolicyFactory_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::PolicyFactory_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::PolicyFactory_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::PolicyFactory_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::PolicyFactory::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::ORBInitInfo_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::ORBInitInfo_ptr &
  );

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const PortableInterceptor::ORBInitInfo::DuplicateName &_tao_aggregate)
{
  // first marshal the repository ID
  if (strm << _tao_aggregate._id ())
  {
    // now marshal the members (if any)
    if (
      (strm << _tao_aggregate.name.in ())
    )
      return 1;
    else
      return 0;
  }
  else
    return 0;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &strm,PortableInterceptor::ORBInitInfo::DuplicateName &_tao_aggregate)
{
  // now marshal the members
  if (
    (strm >> _tao_aggregate.name.out ())
  )
    return 1;
  else
    return 0;
}

ACE_INLINE CORBA::Boolean operator<< (TAO_OutputCDR &strm, const PortableInterceptor::ORBInitInfo::InvalidName &_tao_aggregate)
{
  // first marshal the repository ID
  if (strm << _tao_aggregate._id ())
    return 1;
  else
    return 0;
}

ACE_INLINE CORBA::Boolean operator>> (TAO_InputCDR &,PortableInterceptor::ORBInitInfo::InvalidName&)
{
  return 1;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ORBInitInfo_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ORBInitInfo_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::ORBInitInfo::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &,
    const PortableInterceptor::ORBInitializer_ptr
  );
ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &,
    PortableInterceptor::ORBInitializer_ptr &
  );

ACE_INLINE CORBA::Boolean
operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ORBInitializer_ptr _tao_objref
  )
{
  CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

ACE_INLINE CORBA::Boolean
operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ORBInitializer_ptr &_tao_objref
  )
{
  ACE_TRY_NEW_ENV
  {
    CORBA::Object_var obj;
    if ((strm >> obj.inout ()) == 0)
      return 0;
    // narrow to the right type
    _tao_objref =
      PortableInterceptor::ORBInitializer::_unchecked_narrow (
          obj.in (),
          ACE_TRY_ENV
        );
    ACE_TRY_CHECK;
    return 1;
  }
  ACE_CATCHANY
  {
    // do nothing
  }
  ACE_ENDTRY;
  return 0;
}

#endif /* TAO_HAS_INTERCEPTORS == 1 */
