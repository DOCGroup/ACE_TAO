/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "marshalS.h"

#if !defined (__ACE_INLINE__)
#include "marshalS.i"
#endif /* !defined INLINE */

class TAO_Marshal_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 14:06:51 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /export/kelvar/coryan/head/ACE_wrappers/build/Linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_Marshal_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_Marshal_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20,  0,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20,  0,
     20, 20, 20,  5, 20,  5, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20,  5,
     20, 20, 20,  0, 20, 20, 20, 20, 20, 20,
     20, 20, 20,  0, 20, 20, 20, 20,  0, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20,
#else
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
     20, 20, 20, 20, 20,  0, 20,  0, 20, 20,
     20,  5, 20,  5, 20, 20, 20, 20, 20, 20,
      5, 20, 20, 20,  0, 20,  0, 20, 20, 20,
     20,  0, 20, 20, 20, 20, 20, 20,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_Marshal_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 12,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 19,
      HASH_VALUE_RANGE = 15,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_Marshal::_is_a_skel},
      {"test_any", 	&POA_Marshal::test_any_skel},
      {"test_char", 	&POA_Marshal::test_char_skel},
      {"test_short", 	&POA_Marshal::test_short_skel},
      {"test_octet", 	&POA_Marshal::test_octet_skel},
      {"test_struct", 	&POA_Marshal::test_struct_skel},
      {"_non_existent",  &POA_Marshal::_non_existent_skel},
      {"test_long", 	&POA_Marshal::test_long_skel},
      {"test_union", 	&POA_Marshal::test_union_skel},
      {"test_double", 	&POA_Marshal::test_double_skel},
      {"test_sequence", 	&POA_Marshal::test_sequence_skel},
      {"test_recursive", 	&POA_Marshal::test_recursive_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -8,  -2,   6,   7, -23,  10,  -1,  11, 
       12,  13,  14,  -1,  15,  16, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 14:06:51 */
static TAO_Marshal_Perfect_Hash_OpTable tao_Marshal_optable;

Marshal_ptr _TAO_collocation_POA_Marshal_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      Marshal_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          _tao_thru_poa_collocated_Marshal (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_Marshal_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_Marshal_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_Marshal_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_Marshal_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_Marshal_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_Marshal_Stub_Factory_Initializer));

// skeleton constructor
POA_Marshal::POA_Marshal (void)
{
  this->optable_ = &tao_Marshal_optable;
}

// copy ctor
POA_Marshal::POA_Marshal (const POA_Marshal& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_Marshal::~POA_Marshal (void)
{
}

void POA_Marshal::test_short_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  CORBA::Short s1;
  CORBA::Short s2;
  if (!(
    (_tao_in >> s1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_short",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_short (
        s1,
        s2
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_short",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_short",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << s2)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_long_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  CORBA::Long l1;
  CORBA::Long l2;
  if (!(
    (_tao_in >> l1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_long",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_long (
        l1,
        l2
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_long",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_long",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << l2)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_octet_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  CORBA::Octet o1;
  CORBA::Octet o2;
  if (!(
    (_tao_in >> CORBA::Any::to_octet (o1))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_octet",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_octet (
        o1,
        o2
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_octet",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_octet",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_octet (o2))
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_char_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  CORBA::Char c1;
  CORBA::Char c2;
  if (!(
    (_tao_in >> CORBA::Any::to_char (c1))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_char",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_char (
        c1,
        c2
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_char",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_char",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_char (c2))
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_double_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  CORBA::Double d1;
  CORBA::Double d2;
  if (!(
    (_tao_in >> d1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_double",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_double (
        d1,
        d2
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_double",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_double",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << d2)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_struct_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  Marshal::Marshal_Struct ms1;
  Marshal::Marshal_Struct ms2;
  if (!(
    (_tao_in >> ms1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_struct",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_struct (
        ms1,
        ms2
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_struct",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_struct",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << ms2)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_union_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  Marshal::Marshal_Union u1;
  Marshal::Marshal_Union u2;
  if (!(
    (_tao_in >> u1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_union",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_union (
        u1,
        u2
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_union",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_union",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << u2)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_any_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  CORBA::Any a1;
  CORBA::Any_var a2;
  if (!(
    (_tao_in >> a1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_any",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_any (
        a1,
        a2.out ()
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_any",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_any",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << a2.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_sequence_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  Marshal::AnySeq as1;
  Marshal::AnySeq_var as2;
    if (!(
    (_tao_in >> as1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_sequence",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_sequence (
        as1,
        as2.out ()
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_sequence",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_sequence",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << as2.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::test_recursive_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *)_tao_object_reference;

  Marshal::Marshal_Recursive mr1;
  Marshal::Marshal_Recursive_var mr2;
  if (!(
    (_tao_in >> mr1)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_recursive",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->test_recursive (
        mr1,
        mr2.out ()
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_recursive",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "test_recursive",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << mr2.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_Marshal::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_Marshal *_tao_impl = (POA_Marshal *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_Marshal::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_Marshal *_tao_impl = (POA_Marshal *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_Marshal::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Marshal:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_Marshal::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:Marshal:1.0") == 0)
    return ACE_static_cast (POA_Marshal_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_Marshal::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_Marshal::_interface_repository_id (void) const
{
  return "IDL:Marshal:1.0";
}

Marshal*
POA_Marshal::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::Marshal_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              _tao_thru_poa_collocated_Marshal (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::Marshal::_unchecked_narrow (obj.in ());
    }
}

_tao_thru_poa_collocated_Marshal::_tao_thru_poa_collocated_Marshal (
  TAO_Stub *stub
)
  :  CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean _tao_thru_poa_collocated_Marshal::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean _tao_thru_poa_collocated_Marshal::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


void _tao_thru_poa_collocated_Marshal::test_short  (
    CORBA::Short s1,
    CORBA::Short_out s2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_short"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_short (
      s1,
      s2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_long  (
    CORBA::Long l1,
    CORBA::Long_out l2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_long"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_long (
      l1,
      l2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_octet  (
    CORBA::Octet o1,
    CORBA::Octet_out o2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_octet"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_octet (
      o1,
      o2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_char  (
    CORBA::Char c1,
    CORBA::Char_out c2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_char"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_char (
      c1,
      c2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_double  (
    CORBA::Double d1,
    CORBA::Double_out d2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_double"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_double (
      d1,
      d2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_struct  (
    const Marshal::Marshal_Struct & ms1,
    Marshal::Marshal_Struct_out ms2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_struct"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_struct (
      ms1,
      ms2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_union  (
    const Marshal::Marshal_Union & u1,
    Marshal::Marshal_Union_out u2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_union"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_union (
      u1,
      u2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_any  (
    const CORBA::Any & a1,
    CORBA::Any_out a2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_any"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_any (
      a1,
      a2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_sequence  (
    const Marshal::AnySeq & as1,
    Marshal::AnySeq_out as2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_sequence"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_sequence (
      as1,
      as2
    );
  return;
}

void _tao_thru_poa_collocated_Marshal::test_recursive  (
    const Marshal::Marshal_Recursive & mr1,
    Marshal::Marshal_Recursive_out mr2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "test_recursive"
    );
  ACE_reinterpret_cast (
      POA_Marshal_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:Marshal:1.0"
        )
    )->test_recursive (
      mr1,
      mr2
    );
  return;
}



