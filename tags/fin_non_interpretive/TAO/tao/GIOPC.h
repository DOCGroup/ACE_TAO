/* -*- C++ -*- $Id$ */

// ================================================================
//
// = LIBRARY
//   TAO
//
// = FILENAME
//   GIOPC.h
//
// = DESCRIPTION
//   Generated from GIOP1_2.pidl, that contains a part of the new data
//   type definitions for GIOP1.2 module.
//   The code was generated by the IDL compiler and then hand-crafted
//   to reduce the includes interdependencies.
//   hand crafted by Balachandran Natarajan <bala@cs.wustl.edu>
// ================================================================
// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

// Readers Note:
// This file is named GIOPC.h intentionally. Shortly the file GIOP.h
// in $TAO_ROOT/ta would dissappear giving way to new files once the
// pluggable messaging stuff is done. So I would assume that there
// should be no such name clashes.

#ifndef _TAO_IDL_GIOPC_H_
#define _TAO_IDL_GIOPC_H_

#include "tao/corbafwd.h"
#include "tao/IOPC.h"
#include "tao/Union.h"

#if defined (ACE_HAS_MINIMUM_IOSTREAMH_INCLUSION)
#include "ace/streams.h"
#endif /* ACE_HAS_MINIMUM_IOSTREAMH_INCLUSION */

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

TAO_NAMESPACE  GIOP
{
  typedef CORBA::Short AddressingDisposition;
  typedef CORBA::Short_out AddressingDisposition_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_AddressingDisposition;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short KeyAddr;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ProfileAddr;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ReferenceAddr;

  struct IORAddressingInfo;
  class IORAddressingInfo_var;
  typedef IORAddressingInfo* IORAddressingInfo_ptr;
  
  struct TAO_Export IORAddressingInfo
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef IORAddressingInfo_ptr _ptr_type;
    typedef IORAddressingInfo_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    static void _tao_any_destructor (void*);

    CORBA::ULong selected_profile_index;
    IOP::IOR ior;
  };

  class TAO_Export IORAddressingInfo_var
  {
  public:
    IORAddressingInfo_var (void); // default constructor
    IORAddressingInfo_var (IORAddressingInfo *);
    IORAddressingInfo_var (const IORAddressingInfo_var &); // copy constructor
    ~IORAddressingInfo_var (void); // destructor
    
    IORAddressingInfo_var &operator= (IORAddressingInfo *);
    IORAddressingInfo_var &operator= (const IORAddressingInfo_var &);
    IORAddressingInfo *operator-> (void);
    const IORAddressingInfo *operator-> (void) const;
    
    operator const IORAddressingInfo &() const;
    operator IORAddressingInfo &();
    operator IORAddressingInfo &() const;
    // in, inout, out, _retn 
    const IORAddressingInfo &in (void) const;
    IORAddressingInfo &inout (void);
    IORAddressingInfo *&out (void);
    IORAddressingInfo *_retn (void);
    IORAddressingInfo *ptr (void) const;

  private:
    IORAddressingInfo *ptr_;
  };

  class TAO_Export IORAddressingInfo_out
  {
  public:
    IORAddressingInfo_out (IORAddressingInfo *&);
    IORAddressingInfo_out (IORAddressingInfo_var &);
    IORAddressingInfo_out (const IORAddressingInfo_out &);
    IORAddressingInfo_out &operator= (const IORAddressingInfo_out &);
    IORAddressingInfo_out &operator= (IORAddressingInfo *);
    operator IORAddressingInfo *&();
    IORAddressingInfo *&ptr (void);
    IORAddressingInfo *operator-> (void);
    
  private:
    IORAddressingInfo *&ptr_;
    // assignment from T_var not allowed
    void operator= (const IORAddressingInfo_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_IORAddressingInfo;


#if !defined (_GIOP_TARGETADDRESS_CH_)
#define _GIOP_TARGETADDRESS_CH_

  class TargetAddress;
  class TargetAddress_var;
  typedef TargetAddress* TargetAddress_ptr;
  
  class TAO_Export TargetAddress: public TAO_Base_Union 
  {
  public:
    TargetAddress (void); // default constructor
    TargetAddress (const TargetAddress &); // copy constructor
    ~TargetAddress (void); // destructor
    TargetAddress &operator= (const TargetAddress &); // copy constructor

    void _d (CORBA::Short);
    CORBA::Short _d (void) const;

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TargetAddress_ptr _ptr_type;
    typedef TargetAddress_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */
    static void _tao_any_destructor (void*);

#if !defined (_GIOP_TARGETADDRESS__TAO_SEQ_OCTET_CH_)
#define _GIOP_TARGETADDRESS__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;
    typedef _tao_seq_Octet* _tao_seq_Octet_ptr;
    
    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************
    
    class TAO_Export _tao_seq_Octet : public 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max, 
        CORBA::ULong length, 
        CORBA::Octet *buffer, 
        CORBA::Boolean release=0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void); // dtor

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_ptr _ptr_type;
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    
#if defined(TAO_NO_COPY_OCTET_SEQUENCES)
    _tao_seq_Octet (
        CORBA::ULong length,
        const ACE_Message_Block* mb
      )
      : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE */

  };
  
#endif /* end #if !defined */


#if !defined (_GIOP_TARGETADDRESS__TAO_SEQ_OCTET___VAR_CH_)
#define _GIOP_TARGETADDRESS__TAO_SEQ_OCTET___VAR_CH_

  // *************************************************************
  // class GIOP::TargetAddress::_tao_seq_Octet_var
  // *************************************************************

  class TAO_Export _tao_seq_Octet_var
  {
  public:
    _tao_seq_Octet_var (void); // default constructor
    _tao_seq_Octet_var (_tao_seq_Octet *);
    _tao_seq_Octet_var (const _tao_seq_Octet_var &); // copy constructor
    ~_tao_seq_Octet_var (void); // destructor
    
    _tao_seq_Octet_var &operator= (_tao_seq_Octet *);
    _tao_seq_Octet_var &operator= (const _tao_seq_Octet_var &);
    _tao_seq_Octet *operator-> (void);
    const _tao_seq_Octet *operator-> (void) const;
    
    operator const _tao_seq_Octet &() const;
    operator _tao_seq_Octet &();
    operator _tao_seq_Octet &() const;
    CORBA::Octet &operator[] (CORBA::ULong index);
    // in, inout, out, _retn 
    const _tao_seq_Octet &in (void) const;
    _tao_seq_Octet &inout (void);
    _tao_seq_Octet *&out (void);
    _tao_seq_Octet *_retn (void);
    _tao_seq_Octet *ptr (void) const;

  private:
    _tao_seq_Octet *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_GIOP_TARGETADDRESS__TAO_SEQ_OCTET___OUT_CH_)
#define _GIOP_TARGETADDRESS__TAO_SEQ_OCTET___OUT_CH_

  class TAO_Export _tao_seq_Octet_out
  {
  public:
    _tao_seq_Octet_out (_tao_seq_Octet *&);
    _tao_seq_Octet_out (_tao_seq_Octet_var &);
    _tao_seq_Octet_out (const _tao_seq_Octet_out &);
    _tao_seq_Octet_out &operator= (const _tao_seq_Octet_out &);
    _tao_seq_Octet_out &operator= (_tao_seq_Octet *);
    operator _tao_seq_Octet *&();
    _tao_seq_Octet *&ptr (void);
    _tao_seq_Octet *operator-> (void);
    CORBA::Octet &operator[] (CORBA::ULong index);
    
  private:
    _tao_seq_Octet *&ptr_;
    // assignment from T_var not allowed
    void operator= (const _tao_seq_Octet_var &);
  };


#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef _tao_seq_Octet _object_key_seq;
#endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

    void object_key (const _tao_seq_Octet &);// set
  const _tao_seq_Octet &object_key (void) const; // get method (read only)
  _tao_seq_Octet &object_key (void); // get method (read/write only)

  void profile (const IOP::TaggedProfile &);// set
  const IOP::TaggedProfile &profile (void) const; // get method (read only)
  IOP::TaggedProfile &profile (void); // get method (read/write only)

  void ior (const ACE_NESTED_CLASS (GIOP, IORAddressingInfo) &);// set
  const ACE_NESTED_CLASS (GIOP, IORAddressingInfo) &ior (void) const; // get method (read only)
  ACE_NESTED_CLASS (GIOP, IORAddressingInfo) &ior (void); // get method (read/write only)

  void _default ();
private:
  CORBA::Short disc_;
  union
  {
    _tao_seq_Octet *object_key_;
    IOP::TaggedProfile *profile_;
    ACE_NESTED_CLASS (GIOP, IORAddressingInfo) *ior_;
  } u_; // end of union
  // TAO extensions
  void _reset (CORBA::Short, CORBA::Boolean);
  // Frees any allocated storage
  
  virtual void *_discriminant (void);
  // returns pointer to the discriminant
  
  virtual void _reset (void);
  // calls the above reset with finalize=1
  
  virtual void *_access (CORBA::Boolean flag);
  // accesses the right data member. Also will allocate on TRUE flag
  
}; // GIOP::TargetAddress

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TargetAddress;


#endif /* end #if !defined */


#if !defined (_GIOP_TARGETADDRESS___VAR_CH_)
#define _GIOP_TARGETADDRESS___VAR_CH_

class TAO_Export TargetAddress_var
{
public:
  TargetAddress_var (void); // default constructor
  TargetAddress_var (TargetAddress *);
  TargetAddress_var (const TargetAddress_var &); // copy constructor
  ~TargetAddress_var (void); // destructor
  
  TargetAddress_var &operator= (TargetAddress *);
  TargetAddress_var &operator= (const TargetAddress_var &);
  TargetAddress *operator-> (void);
  const TargetAddress *operator-> (void) const;
  
  operator const TargetAddress &() const;
  operator TargetAddress &();
  operator TargetAddress &() const;
  // in, inout, out, _retn 
  const TargetAddress &in (void) const;
  TargetAddress &inout (void);
  TargetAddress *&out (void);
  TargetAddress *_retn (void);
  TargetAddress *ptr(void) const;

private:
  TargetAddress *ptr_;
};


#endif /* end #if !defined */


#if !defined (_GIOP_TARGETADDRESS___OUT_CH_)
#define _GIOP_TARGETADDRESS___OUT_CH_

class TAO_Export TargetAddress_out
{
public:
  TargetAddress_out (TargetAddress *&);
  TargetAddress_out (TargetAddress_var &);
  TargetAddress_out (const TargetAddress_out &);
  TargetAddress_out &operator= (const TargetAddress_out &);
  TargetAddress_out &operator= (TargetAddress *);
  operator TargetAddress *&();
  TargetAddress *&ptr (void);
  TargetAddress *operator-> (void);
  
private:
  TargetAddress *&ptr_;
  // assignment from T_var not allowed
  void operator= (const TargetAddress_var &);
};


#endif /* end #if !defined */


}
TAO_NAMESPACE_CLOSE // module GIOP

TAO_Export void operator<<= (CORBA::Any &, 
                             const GIOP::IORAddressingInfo &); // copying version
TAO_Export void operator<<= (CORBA::Any &, 
                             GIOP::IORAddressingInfo*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, 
                                       GIOP::IORAddressingInfo *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, 
                                       const GIOP::IORAddressingInfo *&);
TAO_Export void operator<<= (CORBA::Any &, 
                             const GIOP::TargetAddress &); // copying version
TAO_Export void operator<<= (CORBA::Any &, 
                             GIOP::TargetAddress*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, 
                                       GIOP::TargetAddress *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, 
                                       const GIOP::TargetAddress *&);

#ifndef __ACE_INLINE__

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const GIOP::IORAddressingInfo &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, GIOP::IORAddressingInfo &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const GIOP::TargetAddress &); // 
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, GIOP::TargetAddress &);

#if !defined _TAO_CDR_OP_GIOP_TargetAddress__tao_seq_Octet_H_
#define _TAO_CDR_OP_GIOP_TargetAddress__tao_seq_Octet_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const GIOP::TargetAddress::_tao_seq_Octet &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    GIOP::TargetAddress::_tao_seq_Octet &
  );

#endif /* _TAO_CDR_OP_GIOP_TargetAddress__tao_seq_Octet_H_ */


#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "GIOPC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#endif /* ifndef */
