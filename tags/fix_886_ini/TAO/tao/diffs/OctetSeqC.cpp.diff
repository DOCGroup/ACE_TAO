--- OctetSeqC.cpp	Thu May  3 11:29:05 2001
+++ OctetSeqC.cpp.mod	Wed May  2 23:32:41 2001
@@ -1,6 +1,6 @@
 // -*- C++ -*-
 //
-// $Id$
+// $Id$
 
 // ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
 // TAO and the TAO IDL Compiler have been developed by:
@@ -21,13 +21,6 @@
 
 #include "OctetSeqC.h"
 
-#include "tao/Stub.h"
-#include "tao/Invocation.h"
-#include "tao/ClientRequestInfo.h"
-#if TAO_HAS_INTERCEPTORS == 1
-#include "tao/RequestInfo_Util.h"
-#endif  /* TAO_HAS_INTERCEPTORS == 1 */
-
 #if defined (__BORLANDC__)
 #pragma option -w-rvl -w-rch -w-ccc -w-aus
 #endif /* __BORLANDC__ */
@@ -36,6 +29,10 @@
 #include "OctetSeqC.i"
 #endif /* !defined INLINE */
 
+#include "Any.h"
+#include "CDR.h"
+#include "Typecode.h"
+#include "ORB_Core.h"
 
 #if !defined (_CORBA_OCTETSEQ_CS_)
 #define _CORBA_OCTETSEQ_CS_
@@ -44,9 +41,9 @@
 // CORBA::OctetSeq
 // *************************************************************
 
-CORBA::OctetSeq::OctetSeq (void)
+CORBA_OctetSeq::CORBA_OctetSeq (void)
 {}
-CORBA::OctetSeq::OctetSeq (CORBA::ULong max) // uses max size
+CORBA_OctetSeq::CORBA_OctetSeq (CORBA::ULong max) // uses max size
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   TAO_Unbounded_Sequence<CORBA::Octet>
@@ -55,7 +52,7 @@
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max)
 {}
-CORBA::OctetSeq::OctetSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
+CORBA_OctetSeq::CORBA_OctetSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   TAO_Unbounded_Sequence<CORBA::Octet>
@@ -64,7 +61,7 @@
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (max, length, buffer, release)
 {}
-CORBA::OctetSeq::OctetSeq (const OctetSeq &seq) // copy ctor
+CORBA_OctetSeq::CORBA_OctetSeq (const CORBA_OctetSeq &seq) // copy ctor
   : 
 #if !defined (TAO_USE_SEQUENCE_TEMPLATES)
   TAO_Unbounded_Sequence<CORBA::Octet>
@@ -73,11 +70,11 @@
 #endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
  (seq)
 {}
-CORBA::OctetSeq::~OctetSeq (void) // dtor
+CORBA_OctetSeq::~CORBA_OctetSeq (void) // dtor
 {}
-void CORBA::OctetSeq::_tao_any_destructor (void *x)
+void CORBA_OctetSeq::_tao_any_destructor (void *x)
 {
-  OctetSeq *tmp = ACE_static_cast (OctetSeq*,x);
+  CORBA_OctetSeq *tmp = ACE_static_cast (CORBA_OctetSeq*,x);
   delete tmp;
 }
 
@@ -87,19 +84,8 @@
 static const CORBA::Long _oc_CORBA_OctetSeq[] =
 {
   TAO_ENCAP_BYTE_ORDER, // byte order
-  31,
-  ACE_NTOHL (0x49444c3a), 
-  ACE_NTOHL (0x6f6d672e), 
-  ACE_NTOHL (0x6f72672f), 
-  ACE_NTOHL (0x434f5242), 
-  ACE_NTOHL (0x412f4f63), 
-  ACE_NTOHL (0x74657453), 
-  ACE_NTOHL (0x65713a31), 
-  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
-  9,
-  ACE_NTOHL (0x4f637465), 
-  ACE_NTOHL (0x74536571), 
-  ACE_NTOHL (0x0),  // name = OctetSeq
+  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f63), ACE_NTOHL (0x74657453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
+  9, ACE_NTOHL (0x4f637465), ACE_NTOHL (0x74536571), ACE_NTOHL (0x0),  // name = OctetSeq
   CORBA::tk_sequence, // typecode kind
   12, // encapsulation length
     TAO_ENCAP_BYTE_ORDER, // byte order
@@ -108,15 +94,7 @@
     0U,
 
 };
-
-static CORBA::TypeCode _tc_TAO_tc_CORBA_OctetSeq (
-    CORBA::tk_alias,
-    sizeof (_oc_CORBA_OctetSeq),
-    (char *) &_oc_CORBA_OctetSeq,
-    0,
-    sizeof (CORBA::OctetSeq)
-  );
-
+static CORBA::TypeCode _tc_TAO_tc_CORBA_OctetSeq (CORBA::tk_alias, sizeof (_oc_CORBA_OctetSeq), (char *) &_oc_CORBA_OctetSeq, 0, sizeof (CORBA_OctetSeq));
 TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
 TAO_NAMESPACE_BEGIN (CORBA)
 TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OctetSeq, &_tc_TAO_tc_CORBA_OctetSeq)
@@ -124,7 +102,7 @@
 
 void operator<<= (
     CORBA::Any &_tao_any,
-    const CORBA::OctetSeq &_tao_elem
+    const CORBA_OctetSeq &_tao_elem
   ) // copying
 {
   TAO_OutputCDR stream;
@@ -138,7 +116,7 @@
   }
 }
 
-void operator<<= (CORBA::Any &_tao_any, CORBA::OctetSeq *_tao_elem) // non copying
+void operator<<= (CORBA::Any &_tao_any, CORBA_OctetSeq *_tao_elem) // non copying
 {
   TAO_OutputCDR stream;
   stream << *_tao_elem;
@@ -148,43 +126,45 @@
       stream.begin (),
       1,
       _tao_elem,
-      CORBA::OctetSeq::_tao_any_destructor
+      CORBA_OctetSeq::_tao_any_destructor
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OctetSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_OctetSeq *&_tao_elem)
 {
   return _tao_any >>= ACE_const_cast(
-      const CORBA::OctetSeq*&,
+      const CORBA_OctetSeq*&,
       _tao_elem
     );
 }
 
-CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::OctetSeq *&_tao_elem)
+CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA_OctetSeq *&_tao_elem)
 {
   _tao_elem = 0;
   ACE_TRY_NEW_ENV
   {
     CORBA::TypeCode_var type = _tao_any.type ();
-    
-    CORBA::Boolean result = type->equivalent (CORBA::_tc_OctetSeq, ACE_TRY_ENV);
+    CORBA::Boolean result =
+      type->equivalent (CORBA::_tc_OctetSeq, ACE_TRY_ENV);
     ACE_TRY_CHECK;
     
     if (!result)
-      return 0; // not equivalent
+      {
+        return 0;
+      }
     
     if (_tao_any.any_owns_data ())
     {
       _tao_elem = ACE_static_cast(
-          const CORBA::OctetSeq*,
+          const CORBA_OctetSeq*,
           _tao_any.value ()
         );
       return 1;
     }
     else
     {
-      CORBA::OctetSeq *tmp;
-      ACE_NEW_RETURN (tmp, CORBA::OctetSeq, 0);
+      CORBA_OctetSeq *tmp;
+      ACE_NEW_RETURN (tmp, CORBA_OctetSeq, 0);
       TAO_InputCDR stream (
           _tao_any._tao_get_cdr (),
           _tao_any._tao_byte_order ()
@@ -195,7 +175,7 @@
             CORBA::_tc_OctetSeq,
             1,
             ACE_static_cast (void *, tmp),
-            CORBA::OctetSeq::_tao_any_destructor
+            CORBA_OctetSeq::_tao_any_destructor
           );
         _tao_elem = tmp;
         return 1;
@@ -215,7 +195,7 @@
 
 CORBA::Boolean operator<< (
     TAO_OutputCDR &strm,
-    const CORBA::OctetSeq &_tao_sequence
+    const CORBA_OctetSeq &_tao_sequence
   )
 {
   if (strm << _tao_sequence.length ())
@@ -225,7 +205,7 @@
 #if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
     {
       TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
-        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (CORBA::OctetSeq *)&_tao_sequence);
+        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (CORBA_OctetSeq *)&_tao_sequence);
       if (oseq->mb ())
         return strm.write_octet_array_mb (oseq->mb ());
       else
@@ -242,7 +222,7 @@
 
 CORBA::Boolean operator>> (
     TAO_InputCDR &strm,
-    CORBA::OctetSeq &_tao_sequence
+    CORBA_OctetSeq &_tao_sequence
   )
 {
   CORBA::ULong _tao_seq_len;
@@ -253,11 +233,6 @@
     // If length is 0 we return true.
     if (0 >= _tao_seq_len) 
       return 1;
-    // Add a check to the length of the sequence
-    // to make sure it does not exceed the length
-    // of the stream. (See bug 58.)
-    if (_tao_seq_len > strm.length())
-      return 0;
     // retrieve all the elements
     
 #if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
@@ -265,6 +240,7 @@
     ACE_Message_Block::DONT_DELETE))
     {
       TAO_ORB_Core* orb_core = strm.orb_core ();
+
       if (orb_core != 0 &&
       strm.orb_core ()->resource_factory ()->
       input_cdr_allocator_type_locked () == 1)
@@ -277,7 +253,9 @@
         return 1;
       }
     }
+
     return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
+
 #else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
     return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
   
@@ -285,4 +263,3 @@
   }
   return 0; // error
 }
-
