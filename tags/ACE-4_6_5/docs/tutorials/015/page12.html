<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="James CE Johnson">
   <TITLE>ACE Tutorial 015</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000FFF" VLINK="#FF0F0F">

<CENTER><B><FONT SIZE=+2>ACE Tutorial 015</FONT></B></CENTER>

<CENTER><B><FONT SIZE=+2>Building a protocol stream</FONT></B></CENTER>

<P>
<HR WIDTH="100%">
And now the implementation of the Protocol_Stream.  There are more
lines of code here than we've seen so far but it still isn't
complicated.  The basic idea is to construct the ACE_Stream with our
set of protocol objects that will manipulate the data.  Our primary
concern in this file is to get everything in the correct order!
<HR>
<PRE>

<font color=red>// $Id$</font>

<font color=blue>#ifndef</font> <font color=purple>PROTOCOL_TASK_H</font>
<font color=blue>#define</font> <font color=purple>PROTOCOL_TASK_H</font>

<font color=blue>#include</font> "<font color=green>ace/Task.h</font>"

<font color=blue>#if !defined</font> (<font color=purple>ACE_LACKS_PRAGMA_ONCE</font>)
# pragma once
<font color=blue>#endif</font> <font color=red>/* ACE_LACKS_PRAGMA_ONCE */</font>

<font color=red>/* A typical ACE_Task&lt;> derivative that adds a few things appropriate
   to protocol stacks.
*/</font>
class Protocol_Task : public ACE_Task&lt;ACE_MT_SYNCH>
{
public:

    typedef ACE_Task&lt;ACE_MT_SYNCH> inherited;

        <font color=red>// A choice of concurrency strategies is offered by the</font>
        <font color=red>// constructor.  In most cases it makes sense to set this to</font>
        <font color=red>// zero and let things proceed serially.  You might have a</font>
        <font color=red>// need, however, for some of your tasks to have their own thread.</font>
    Protocol_Task( int _thr_count );

    ~Protocol_Task(void);

        <font color=red>// open() is invoked when the task is inserted into the stream.</font>
    virtual int open(void *arg);

        <font color=red>// close() is invoked when the stream is closed (flags will be</font>
        <font color=red>// set to '1') and when the svc() method exits (flags will be</font>
        <font color=red>// '0').</font>
    virtual int close(u_long flags);

        <font color=red>// As data travels through the stream, the put() method of</font>
        <font color=red>// each task is invoked to keep the data moving along.</font>
    virtual int put(ACE_Message_Block *message,
                    ACE_Time_Value *timeout);

        <font color=red>// If you choose to activate the task then this method will be</font>
        <font color=red>// doing all of the work.</font>
    virtual int svc(void);

protected:

        <font color=red>// Called by put() or svc() as necessary to process a block of</font>
        <font color=red>// data.</font>
    int process(ACE_Message_Block * message, ACE_Time_Value *timeout);

        <font color=red>// Just let us know if we're active or not.</font>
    int is_active(void)
        {
            return this->thr_count() != 0;
        }

        <font color=red>// Tasks on the writter (downstream) side of the stream</font>
        <font color=red>// are called upon to send() data that will ultimately go to</font>
        <font color=red>// the peer.</font>
    virtual int send(ACE_Message_Block *message,
                     ACE_Time_Value *timeout);

        <font color=red>// Tasks on the reader (upstream) side will be receiving data</font>
        <font color=red>// that came from the peer.</font>
    virtual int recv(ACE_Message_Block * message,
                     ACE_Time_Value *timeout);

private:
    int desired_thr_count_;
};

<font color=blue>#endif</font> <font color=red>// PROTOCOL_TASK_H</font>
</PRE>
<P><HR WIDTH="100%">
<CENTER>[<A HREF="../online-tutorials.html">Tutorial Index</A>] [<A HREF="page13.html">Continue This Tutorial</A>]</CENTER>
