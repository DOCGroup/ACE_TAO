// -*- C++ -*-
// $Id$
// FUZZ: disable check_for_ace_log_categories

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.1.4
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:1673

#include "Demo_i.h"
#include "ace/Log_Msg.h"

// Implementation skeleton constructor
ATC_Test_i::ATC_Test_i (void)
{
}

// Implementation skeleton destructor
ATC_Test_i::~ATC_Test_i (void)
{
}

char *
ATC_Test_i::do_union (const ::CORBA::Any & a)
{
  Demo::NestedUnion *any_union;
  const char *result = "do_union called";
  if (a >>= any_union)
    {
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("%P: a >>= any_union went well\n")));
      ACE_DEBUG ((LM_DEBUG,
                  ACE_TEXT ("%P: The discriminator is %d\n"),
                  any_union->_d ()));
      switch ( any_union->_d ())
        {
        case 1:
          {
            Demo::BaseUnion bar1 = any_union->bar1 ();
            if (bar1._d () == 1)
              {
                result = bar1.str ();
                ACE_DEBUG ((LM_DEBUG,
                            ACE_TEXT ("%P: bar1 has str = %s\n"),
                            result));
              }
          }
          break;
        case 2:
          {
            Demo::BaseUnion bar2 = any_union->bar2 ();
            if (bar2._d () == 2)
              {
                CORBA::Long l = bar2.l ();
                ACE_DEBUG ((LM_DEBUG,
                            ACE_TEXT ("%P: bar1 has l = %d\n"),
                            l));
                result = "bar2 has l";
              }
          }
          break;
        default:
          {
            Demo::BaseUnion defaultBar = any_union->defaultBar ();
            if (defaultBar._d () != 1 && defaultBar._d () != 2)
              {
                CORBA::Short s = defaultBar.s ();
                ACE_DEBUG ((LM_DEBUG,
                            ACE_TEXT ("%P: bar1 has s = %d\n"),
                            s));
                result = "defaultBar has s";
              }
          }
          break;
        }
    }
  else
    {
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("%P: a >>= any_union failed\n")));
    }
  return CORBA::string_dup (result);
}

char *
ATC_Test_i::do_struct (const ::CORBA::Any & a)
{
  Demo::NestedStruct *bar;
  const char *result = "do_struct called";
  if (a >>= bar)
    {
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("%P: a >>= any_struct went well\n")));
      Demo::BaseStruct foo1 = bar->foo1;
      Demo::BaseStruct foo2 = bar->foo2;
      Demo::BaseStruct foo3 = bar->foo3;
      Demo::NestedSeq bars = bar->bars;
      if (bars.length () > 0)
        {
          ACE_DEBUG ((LM_DEBUG,
                      ACE_TEXT ("%P: bars[0].foo1.str = %s\n"),
                      bars[0].foo1.str.in()));
        }
      ACE_DEBUG ((LM_DEBUG,
                  ACE_TEXT ("%P: foo1.str = %s, foo2.str = %s, ")
                  ACE_TEXT ("foo3.str = %s, bars.length() = %d\n"),
                  foo1.str.in (), foo2.str.in (), foo3.str.in (), bars.length ()));

      if (bars.length() > 0)
        {
          ACE_DEBUG ((LM_DEBUG,
                      ACE_TEXT ("%P: returning %s\n"),
                      bars[bars.length() - 1].foo3.str.in ()));
          return CORBA::string_dup(bars[bars.length() - 1].foo3.str);
        }
      else
        {
          ACE_DEBUG ((LM_DEBUG,
                      ACE_TEXT ("%P: bars.length = 0, returning %s\n"),
                      foo3.str.in()));
          return CORBA::string_dup(foo3.str);
        }
    }
  else
    {
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("%P: a >>= any_struct failed\n")));
    }
  return CORBA::string_dup (result);
}

char *
ATC_Test_i::do_value (const ::CORBA::Any & a)
{
  Demo::NestedValue *bar;
  const char *result = "do_value called";
  if (a >>= bar)
    {
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("%P: a >>= any_value went well\n")));
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("%P: returning %s\n"),
                                      bar->foo2()->str() ));
      return CORBA::string_dup(bar->foo2()->str());
    }
  else
    {
      ACE_DEBUG ((LM_DEBUG, ACE_TEXT ("%P: a >>= any_value failed\n")));
    }
  return CORBA::string_dup (result);
}

void
ATC_Test_i::shutdown (void)
{
  int argc = 0;
  ACE_TCHAR **argv = 0;

  CORBA::ORB_var def_orb = CORBA::ORB_init (argc, argv);
  def_orb->shutdown (false);
  ACE_DEBUG ((LM_DEBUG,
              ACE_TEXT ("%P: shutdown called \n")));
}
