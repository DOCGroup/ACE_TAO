--- bison_gen\ETCL_l.cpp	2005-07-19 10:09:28.523824100 -0700
+++ ETCL_l.cpp	2005-07-19 09:47:22.138585300 -0700
@@ -1,15 +1,14 @@
+
 /* A lexical scanner generated by flex */

 /* Scanner skeleton version:
- * $Header$
+ * $Id$
  */

 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5

-#include <stdio.h>
-

 /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
 #ifdef c_plusplus
@@ -21,8 +20,7 @@

 #ifdef __cplusplus

-#include <stdlib.h>
-#include <unistd.h>
+#include "ace/OS_NS_unistd.h"
+#include "ace/OS_NS_stdio.h"

 /* Use prototypes in function declarations. */
 #define YY_USE_PROTOS
@@ -262,8 +260,8 @@
 #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)


-#define yywrap() 1
-#define YY_SKIP_YYWRAP
+//#define yywrap() 1
+//#define YY_SKIP_YYWRAP
 typedef unsigned char YY_CHAR;
 FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
 typedef int yy_state_type;
@@ -444,15 +442,15 @@
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
 char *yytext;
-#line 1 "ETCL.ll"
+//#line 1 "ETCL/ETCL.ll"
 #define INITIAL 0
-#line 4 "ETCL.ll"
+//#line 4 "ETCL/ETCL.ll"
 // $Id$
 // ========================================================================
 //
 // = LIBRARY
 //   orbsvcs/ECTL
-//
+//
 // = FILENAME
 //   ETCL.ll
 //
@@ -462,12 +460,12 @@
 //
 // ========================================================================

-#include "ace/OS.h"
-
+#include "ETCL_Interpreter.h"
 #include "ETCL_Constraint.h"
 #include "ETCL_y.h"

-static const char * extract_string(char*);
+static const char* extract_string(char*);
+//static const char * extract_string(char*);

 #define TAO_YY_LEX_DEBUG

@@ -475,12 +473,11 @@
 #define TAO_YY_LEX_DEBUG TAO_OS::fprintf(stderr, "%s\n", yytext)
 #endif /* TAO_CONSTRAINT_DEBUG */

-#define YY_DECL int TAO_ETCL_yylex (TAO_ETCL_YYSTYPE *lvalp, void* state)
+//#define YY_DECL int TAO_ETCL_yylex (TAO_ETCL_YYSTYPE *lvalp, void* state)

 #define YY_BREAK
 #define YY_NO_UNPUT

-#line 484 "lex.yy.c"

 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -494,10 +491,6 @@
 #endif
 #endif

-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
 #ifndef yytext_ptr
 static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
 #endif
@@ -556,11 +549,11 @@

 /* Copy whatever the last rule matched to the standard output. */

-#ifndef ECHO
+#ifndef TAO_ETCL_ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define TAO_ETCL_ECHO (void) fwrite( yytext, yyleng, 1, yyout )
 #endif

 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -628,13 +621,11 @@
 YY_DECL
 	{
 	ACE_REGISTER yy_state_type yy_current_state;
-	ACE_REGISTER char *yy_cp, *yy_bp;
+	ACE_REGISTER char *yy_cp = 0;
+  ACE_REGISTER char *yy_bp = 0;
 	ACE_REGISTER int yy_act;

-#line 50 "ETCL.ll"
-
-
-#line 638 "lex.yy.c"
+//#line 50 "ETCL/ETCL.ll"

 	if ( yy_init )
 		{
@@ -719,240 +710,239 @@

 case 1:
 YY_RULE_SETUP
-#line 52 "ETCL.ll"
+//#line 52 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_MIN; }
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 53 "ETCL.ll"
+//#line 53 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_MAX; }
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 54 "ETCL.ll"
+//#line 54 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_FIRST; }
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 55 "ETCL.ll"
+//#line 55 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_RANDOM; }
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 56 "ETCL.ll"
+//#line 56 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_WITH; }
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 57 "ETCL.ll"
+//#line 57 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_EXIST; }
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 58 "ETCL.ll"
+//#line 58 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_NOT; }
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 59 "ETCL.ll"
+//#line 59 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_AND; }
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 60 "ETCL.ll"
+//#line 60 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_OR; }
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 61 "ETCL.ll"
+//#line 61 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_IN; }
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 62 "ETCL.ll"
+//#line 62 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_TWIDDLE; }
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 63 "ETCL.ll"
+//#line 63 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_PLUS; }
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 64 "ETCL.ll"
+//#line 64 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_MINUS; }
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 65 "ETCL.ll"
+//#line 65 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_MULT; }
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 66 "ETCL.ll"
+//#line 66 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_DIV; }
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 67 "ETCL.ll"
+//#line 67 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_LT; }
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 68 "ETCL.ll"
+//#line 68 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_LE; }
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 69 "ETCL.ll"
+//#line 69 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_GT; }
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 70 "ETCL.ll"
+//#line 70 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_GE; }
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 71 "ETCL.ll"
+//#line 71 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_EQ; }
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 72 "ETCL.ll"
+//#line 72 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_NE; }
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 73 "ETCL.ll"
+//#line 73 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_LPAREN; }
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 74 "ETCL.ll"
+//#line 74 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_RPAREN; }
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 75 "ETCL.ll"
+//#line 75 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_DOLLAR; }
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 76 "ETCL.ll"
+//#line 76 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_DOT; }
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 77 "ETCL.ll"
+//#line 77 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_DEFAULT; }
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 78 "ETCL.ll"
+//#line 78 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_DISCRIMINANT; }
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 79 "ETCL.ll"
+//#line 79 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_TYPE_ID; }
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 80 "ETCL.ll"
+//#line 80 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_REPOS_ID; }
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 81 "ETCL.ll"
+//#line 81 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_LENGTH; }
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 82 "ETCL.ll"
+//#line 82 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_LBRA; }
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 83 "ETCL.ll"
+//#line 83 "ETCL/ETCL.ll"
 { TAO_YY_LEX_DEBUG; return TAO_ETCL_RBRA; }
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 84 "ETCL.ll"
-{
-		  lvalp->constraint =
+//#line 84 "ETCL/ETCL.ll"
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint ((CORBA::Boolean) 1);
 		  TAO_YY_LEX_DEBUG; return TAO_ETCL_BOOLEAN;
 		}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 89 "ETCL.ll"
-{
-		  lvalp->constraint =
+//#line 89 "ETCL/ETCL.ll"
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint ((CORBA::Boolean) 0);
 		  TAO_YY_LEX_DEBUG; return TAO_ETCL_BOOLEAN;
 		}
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 94 "ETCL.ll"
-{
-		  lvalp->constraint =
+//#line 94 "ETCL/ETCL.ll"
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint (ACE_OS::atoi (yytext));
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_INTEGER;
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_INTEGER;
 		}
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 99 "ETCL.ll"
+//#line 99 "ETCL/ETCL.ll"
 {
 		  double v;
-		  sscanf (yytext, "%lf", &v);
-		  lvalp->constraint =
+		  sscanf (yytext, "%lf", &v);
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint (v);
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_FLOAT;
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_FLOAT;
 		}
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 106 "ETCL.ll"
-{
-		  lvalp->constraint =
-		    new TAO_ETCL_Literal_Constraint (extract_string (yytext));
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_STRING;
+//#line 106 "ETCL/ETCL.ll"
+{
+		  yylval.constraint =
+		    new TAO_ETCL_Literal_Constraint (extract_string(yytext));
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_STRING;
 		}
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 111 "ETCL.ll"
-{
-		  lvalp->constraint =
+//#line 111 "ETCL/ETCL.ll"
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Identifier (yytext);
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_IDENT;
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_IDENT;
 		}
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 116 "ETCL.ll"
-{
+//#line 116 "ETCL/ETCL.ll"
+{
                   TAO_YY_LEX_DEBUG; break; // Ignore
                 }
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
-#line 119 "ETCL.ll"
-{
+//#line 119 "ETCL/ETCL.ll"
+{
                   TAO_YY_LEX_DEBUG; break; // @@ TODO
                 }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 122 "ETCL.ll"
-ECHO;
+//#line 122 "ETCL/ETCL.ll"
+TAO_ETCL_ECHO;
 	YY_BREAK
-#line 956 "lex.yy.c"
 case YY_STATE_EOF(INITIAL):
 	yyterminate();

@@ -1288,7 +1278,7 @@
 	return yy_is_jam ? 0 : yy_current_state;
 	}

-
+#if 0
 #ifndef YY_NO_UNPUT
 #ifdef YY_USE_PROTOS
 static void yyunput( int c, ACE_REGISTER char *yy_bp )
@@ -1332,7 +1322,7 @@
 	yy_c_buf_p = yy_cp;
 	}
 #endif	/* ifndef YY_NO_UNPUT */
-
+#endif /* 0 */

 #ifdef __cplusplus
 static int yyinput()
@@ -1406,6 +1396,11 @@
 	return c;
 	}

+void yyflush_current_buffer (void)
+{
+	YY_FLUSH_BUFFER;
+}
+

 #ifdef YY_USE_PROTOS
 void yyrestart( FILE *input_file )
@@ -1516,11 +1511,6 @@
 	}


-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif

 #ifdef YY_USE_PROTOS
 void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
@@ -1537,15 +1527,18 @@
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;

-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
+#if defined (ACE_HAS_WINCE)
+    // Mimic the behavior as WinCE does not have isatty().
+    if ((file != 0) && (file == ACE_OS::fileno(file))) {
+        b->yy_is_interactive = 1;
+    }
+    else {
+        b->yy_is_interactive = 0;
+    }
 #else
        b->yy_is_interactive = file ? (ACE_OS::isatty( ACE_OS::fileno(file) ) > 0) : 0;
-#endif
-#endif
+#endif  // ACE_HAS_WINCE
+
 	}


@@ -1838,7 +1831,7 @@
 	return 0;
 	}
 #endif
-#line 122 "ETCL.ll"
+//#line 122 "ETCL/ETCL.ll"


 const char*
