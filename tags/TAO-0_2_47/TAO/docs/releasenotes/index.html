<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; SunOS 5.5.1 sun4u) [Netscape]">
   <TITLE>TAO Release Information and TODO List</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">
<!-- $Id$ -->
<CENTER>
<HR></CENTER>

<CENTER>
<H3>
Release Information for The ACE ORB (TAO)</H3></CENTER>
Information is available on the following topics related to the <A HREF="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/VERSION">current
release</A> of <A HREF="http://www.cs.wustl.edu/~schmidt/TAO.html">TAO</A>:
<UL>
<LI>
<A HREF="orbcore.html">ORB Core</A></LI>

<LI>
<A HREF="#idl">IDL Compiler</A></LI>

<LI>
<A HREF="#poa">Portable Object Adapter</A></LI>

<LI>
<A HREF="#implrepo">Implementation Repository</A></LI>

<LI>
<A HREF="#nservices">CORBA Naming Service</A></LI>

<LI>
<A HREF="#tservices">CORBA Trading Service</A></LI>

<LI>
<A HREF="#pservices">CORBA Property Service</A></LI>

<LI>
<A HREF="#cservices">CORBA Concurrency Service</A></LI>

<LI>
<A HREF="#av">CORBA Audio/Video Control Service</A></LI>

<LI>
<A HREF="#ts">CORBA Time Service</A></LI>

<LI>
<A HREF="#ec">CORBA Event Service</A></LI>

<LI>
<A HREF="ec.html">TAO's Real-time Event Service</A></LI>

<LI>
<A HREF="#scheduling">TAO's Scheduling Service</A></LI>

<LI>
<A HREF="#logging">TAO's Logging Service</A></LI>

<LI>
<A HREF="#apps">Test &amp; Performance Tests</A></LI>

<LI>
<A HREF="#ace">ORB-related ACE Changes</A></LI>

<LI>
<A HREF="#dove">The DOVE Demo</A></LI>

<LI>
<A HREF="#forwarding">Location Forwarding</A></LI>

<LI>
<A HREF="#leader">Global Resources and Leader-Follower Model</A></LI>

<LI>
<A HREF="#locate">Locate requests</A></LI>
<LI>

<A HREF="TODO.html">Our TODO list</A></LI>
</UL>

A complete list of all modifications to TAO is available in the <A HREF="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/ChangeLog">ChangeLog</A>.<P>

<HR><!--#include virtual="orbcore.html" -->
<HR>
<H3>
<A NAME="idl"></A>IDL Compiler</H3>
Point of contact: <A HREF="mailto:gokhale@research.bell-labs.com">Aniruddha Gokhale</A>

<P>Current status: (As of Jan 03, 1999.)
<UL>
        <LI>
        Generated code closely follows the C++ Mapping specified in
        the latest C++ mapping for CORBA 2.3 (Document ptc/98-09-03).
        </LI>

     <LI>
     Struct members of type strings and arrays of strings now use the
     managed type instead of the _var type. This change was necessary
     to conform to the IDL->C++ mapping.
     </LI>

     <LI>
     Fixed a large number of problems with anonymous arrays and
     sequences inside structs and unions. The name of anonymous
     sequence needs to be fixed as per latest C++ mapping spec.
     </LI>

     <LI>
     Compile problems with sequence of forward declared interfaces is
     fixed. In addition, problems with sequence of CORBA::Objects is
     fixed. In this specific case, we were not generating the
     _downcast and _upcast methods.
     </LI>

     <LI>
     Some more problems with the front-end have been fixed. In
     particular, oneway operations with a "raises" clause or having an
     "inout", "out", or "return" mode is flagged as an error.
     </LI>

     <LI>
     For platforms that support namespaces, we now allow reopening
     modules.
     </LI>

     <LI>
     Support for generating compiled marshaling code is added. Use the
     -Gc option. However, this needs thorough testing before we can
     claim success. Unions are still a problme with compiled
     marshaling.
     </LI>

     <LI> The problem of "#include"ing the relative path of the header
         files rather than the paths of their corresponding IDL files
         has been fixed. tao_idl now generates #include path names
         that are derived from the IDL files that are #include'd in
         the main idl file.

      <LI>Added options to IDL compiler to specify file name endings
          for the IDL-generated stubs, skeletons and the various
          header files. Please refer to the <A
          HREF="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/docs/compiler.html">IDL compiler options</A> for details.
      </LI>

      <LI>Added partial native C++ exception support:
	<UL>
	  <LI>The ORB can be configured to catch native C++ exceptions
	    thrown on the server side and transmit them to the client
	    side.
	    On the client side exceptions received from the wire are
	    thrown using native C++ exceptions also.
	  </LI>
	  <LI>To facilitate portability between the standard and
	    alternative C++ mapping the
	    <CODE>CORBA::Environment</CODE> has a default value.
	    The IDL compiler generates code using that default value
	    and the TAO library methods also have the default.
	  </LI>
	  <LI>Some macros are provided to facilitate portability
	    between platforms with and without macros.
	  </LI>
	</UL>
	There is still some work to do, mainly provide complete
	support for the standard mapping, i.e. remove the
	<CODE>CORBA::Environment</CODE> argument completely.
      </LI>

      <LI>Verified support for the "long long" and "unsigned long long"
	datatypes. On platforms that do not support 64 bit longs we
	provided <EM>partial</EM> emulation through ACE_U_LongLong.
      </LI>

<LI>
Perfect Hashed Operation Lookup Strategy has been added to the IDL Compiler.
-P flag to the&nbsp;<tao_idl>enables the perfect hased lookup strategy.
This strategy uses <A HREF="http://www.cs.wustl.edu/~schmidt/gperf.ps.gz">GPERF</A>,
the GNU's Perfect Hash Function Generator written by Dr.Douglas C. Schmidt.
Right now, GPERF works only on Solaris. Any work on porting GPERF to other
platforms will be highly appreciated.&nbsp;</L1></LI>

<LI>
Significantly improved the support for unions. The default case is yet
to be handled.</LI>

<LI>
Added support for TIE classes. If the interfaces are defined inside modules,
then the TIE class and its code gets generated inside a conditional macro.
For platforms that support namespaces, this macro will allow these TIE
classes else they get commented out. The reason to do this is because nested
templates have problems on most compilers.</LI>

<LI>
The &lt;&lt;= and >>= operators for user-defined types are now generated.</LI>

<LI>
Completely redesigned the IDL compiler using the Visitor patterns. Many
incomplete issues have been resolved. These include support for "sequence
of typecodes", passing object references as in, inout, and out parameters.
Code generation for sequences is also properly handled i.e., for a named
sequence such as "typedef sequence&nbsp;<char>CharSeq;", we now generate
a new class (and hence a type) called "class CharSeq". Arrays are still
being worked out and will be done soon. An important difference in the
generated code is that the skeletons now use a table driven approach very
similar to the stubs.</LI>

<LI>
Support for the "native" keyword added.</LI>

<LI>
The problem of incorrect code generation for typedefs defined in an imported
file is resolved.</LI>

<LI>
Problems when interfaces use single or multiple inheritance solved. The
problem was with the demultiplexing code, the generated operation tables,
and the dispatching mechanism. We are currently testing this with the Event
Channel code.</LI>

<LI>
The problems arising due to public virtual inheritance when casting from
an interface class to CORBA::Object_ptr has been solved. We do this casting
inside the stubs/skeletons rather than first converting an interface class
pointer to a void*, storing it in an Any, and casting it to CORBA::Object_ptr
in the encode/decode methods. The casting inside the stubs/skeletons work
because the compiler has knowledge of both types.</LI>

<LI>
Include files are handled properly. So are the definitions used inside
the include files that are used in the currently parsed files.</LI>

<LI>
Generates C++ stubs and skeletons that use TAO's <A HREF="http://www.cs.wustl.edu/~schmidt/HICSS-97.ps.gz">interpretive
IIOP protocol engine</A>.</LI>

<LI>
Support dynamic libraries on NT, i.e., marking classes for DLL export was
added. Two backend options control the name of the export macro, and the
name of an extra include file were the macro is defined; the options are
<TT>-Wp,export_macro=MACRO_NAME</TT> <TT>-Wp,export_include=INCLUDE_NAME</TT>.</LI>

<LI>
The IDL compiler generates now source code for sequences. The user has
now the option to use these generated sequence classes or to use, as up
to now, the template instatiation. If TAO_LACKS_TEMPLATE_SPECIALIZATION
is defined, then template instantiation will be used, else not. The reason
for this was, that some C++ compilers did not support template instantiation
properly and sequences were based on templates. The generated source code
is mainly contained in the generated header file directly in the class
declaration.</LI>
</UL>

Known bugs/unimplemented constructs:
<UL>
<LI>
Generation of Managed types must somehow be moved to the ORB Core</LI>

<LI>
We need support for ``TIEs'' (i.e., the object form of the Adapter pattern).</LI>

<LI>
TypeCode generation for recursive types not implemented yet. </LI>

<LI>
Unions with default cases yet to be handled</LI>

<LI>
IDL is case-insensitive. However, it looks like our front-end is case-sensitive.
Thanks to Anil Gopinath (anil@ittc.ukans.edu) for pointing this out.</LI>

</UL>

Future work:
<UL>
<LI>
Need to relocate the various libraries used by the IDL compiler out of
the ACE directory. Having them here can cause problems when working with
multiple versions of TAO and a single version of ACE.</LI>

<LI>
Fix bugs in the SunSoft IDL front-end we've uncovered. These primarily
include support for Unions.</LI>

<LI>
Use <A HREF="http://www.cs.utah.edu/projects/flux/flick/">Flick</A> (from
the University of Utah) to generate compiled stubs.</LI>

<P>Goal is to measure the code size of the interpretive stubs generated
by TAO IDL compiler <I>vs</I> code size of compiled stubs. Then compare
the performance of each. We want to prove the thesis that TAO IDL compiler
generated interpretive stubs have a small code size, yet are comparable
in performance (or slightly less) than compiled stubs. Hence, it will be
useful for small distributed equipment such as handsets, PDAs, etc.

<P>In doing the above, improvements to the IIOP protocol engine in terms
of size/performance/determinism will be made.
<LI>
Tweak the IDL compiler to generate code that's more easily integrated back
into the ORB Core, e.g., POA, etc. This will depend largely on our ability
to generalize the changes necessary to generated code.</LI>
</UL>

<LI>
The generated sequence classes should not be generated per sequence, but
per type and parent scope. Which means, that the overhead of having the
source code generated serveral times should be reduced. To do this, an
extra pass over the internal representation of the IDL file has to be done.&nbsp;
<HR></LI>

<H3>
<A NAME="poa"></A>Portable Object Adapter</H3>
Point of contact: <A HREF="mailto:irfan@cs.wustl.edu">Irfan Pyarali</A>

<P>Current Status:
<UL>
<LI>
TAO fully supports the POA spec. This section will carry updates as available.</LI>
</UL>
Known issues:
<UL>
<LI>
None.</LI>
</UL>
Critical work:
<UL>
<LI>
None.</LI>
</UL>
Future work:
<UL>
<LI>
Determine the degree to which we will support the full semantics of remote
objects on a collocated object. The spec mandates that collocated object
should behave <I>exactly</I> like remote objects, but that means that request
will have to be queued rather than calling a method directly, and this
could be hazardous to our quest for real-time ORB status. <p>
</LI>

<LI>
Provide extensions of the specification to ensure real-time delivery of
messages.</LI>
</UL>

Recently completed work:
<UL>
<LI>
Support for collocation should be much better now because the POA can
tell if we created the object reference. <p>
</LI>
<LI>
The POA now supports active demultiplexing of servants in the
SYSTEM_ID policy.  This should make the POA faster and more
predictable since there is no hashing involved and the index of the
slot where the servant is registered is in the Object Key.
</LI>
</UL>

<HR>
<H3>
<A NAME="implrepo"></A>Implementation Repository</H3>
Point of contact: <A HREF="mailto:brunsch@cs.wustl.edu">Darrell Brunsch</A>

<P>Current status (as of November 17, 1998)

<P>Here is a brief list of my goals (and the dates completed). For more
information, please see the <A HREF="../implrepo.html">Implementation Repository
documentation</A>.</P>

Immediate goals:

<UL>
  <LI>[7/17] Create the base test client and server programs </LI>
  <LI>[7/23] Add an IR that forwards server requests </LI>
  <LI>[7/23] Persistence</LI>
  <LI>[8/10] Have the server register its IOR with the IR</LI>
  <LI>[8/14] Have the server exit after every call, so it is restarted each time</LI>
  <LI>[9/10] Make the IR forward any request</LI>
  <LI>[9/10] Add the ping object to the server</LI>
  <LI>[9/10] Add in shutdown calls to test ping objects</LI>
  <LI>[9/15] Implement the full IDL Interface for the IR</LI>
  <LI>Add another test server</LI>
</UL>

Longer term goals:

<UL>
  <LI>Change IOR format</LI>
  <LI>Add in support for virtual server names</LI>
  <LI>Integration with POA and ORB</LI>
</UL>

Other goals:

<UL>
  <LI>Multiple Profiles</LI>
  <LI>POA extension</LI>
</UL>

Future Goals (might or might not happen):

<UL>
  <LI>TAO client-side optimization with restarted servers</LI>
  <LI>Server security (checksums)</LI>
  <LI>Helper Application</LI>
  <LI>Federation of IRs</LI>
  <LI>DLLs</LI>
</UL>

<HR>
<H3>
<A NAME="nservices"></A>CORBA Naming Service</H3>
Point of contact: <A HREF="mailto:marina@cs.wustl.edu">Marina
Spivak</A>

<P>Current status (as of Sep 28):
<UL>
<LI>
Implementation of the Naming Service is complete.
</LI>
</UL>

Recently completed work:
<UL>
<LI>
The implementation of the Naming Service has been upgraded to use TAO's exception macros,
which allow it to work both with C++ exceptions and without.
<LI>
Destroy method has been updated.
<LI>
More test examples have been added to TAO/orbsvcs/tests/Simple_Naming.
</UL>

Future work:
<UL>
<LI>
Currently the bindings are stored as a table in memory. Future work will
include a persistent database to store the bindings.</LI>
<LI>
Replication of the bindings to other Naming Service's currently running.
It will probably be modeled after the LDAP Multi-Master Replication Protocol.
For more information on this replication protocol please read <A HREF="ftp://ds.internic.net/internet-drafts/draft-ietf-asid-ldap-mult-mast-rep-02.txt">LDAP
Multi-Master Replication Protocol</A></LI>
</UL>
For general documentation on the Naming Service please read <A HREF="ftp://www.omg.org/pub/docs/formal/97-07-12.pdf">The
Naming Service Specification</A>.

<P>
<HR>
<H3>
<A NAME="tservices"></A>CORBA Trading Service</H3>
Point of contact: <A HREF="mailto:sbw1@cs.wustl.edu">Seth Widoff</A>

<P>The TAO Trading Service is a transient implementation of the COS Trading
Service speficiation that meets the Linked Trader conformance criteria
--- it implements the <TT>Lookup</TT>, <TT>Register</TT>, <TT>Admin</TT>,
and <TT>Link</TT> interfaces, but not the <TT>Proxy</TT> interface. Notably,
the TAO trader supports the following features:
<UL>
<LI>
Multithreaded operation;</LI>

<LI>
Trader federations and distributed queries;</LI>

<LI>
Dynamic properties;</LI>

<LI>
Modifiable properties;</LI>

<LI>
All policies described in the specification;</LI>

<LI>
Preference sorting;</LI>

<LI>
Service type inheritance hierarchies and subtype searching.</LI>
</UL>
<A HREF="trader.html">Trading Service documentation</A> is also available.

<P>Future Work:
<UL>
<LI>
The Proxy Interface.</LI>

<LI>
Persistent storage of service types and offers.</LI>
</UL>
For general documentation of the Trading Service, please read <A HREF="http://www.omg.org/corba/sectrans.htm#trader">The
Trading Service Specification.</A>

<P>
<HR>
<H3>
<A NAME="pservices"></A>CORBA Property Service</H3>
Point of contact: <A HREF="mailto:alex@cs.wustl.edu">Alexander Babu Arulanthu</A>

<P>Current status (as of May&nbsp; 02, 1998)
<BR>&nbsp;
<BR>All the interfaces of this service have been implemented.&nbsp; Please
go through the&nbsp; test examples at&nbsp; $TAO/orbsvcs/tests/CosPropertyService.&nbsp;
Property Service is&nbsp; now used by the AVStreams that is currently being
developed for TAO. More testing is being done.

<P>For general documentation of the Property Service, please read <A HREF="http://www.omg.org/corba/sectrans.htm#prop">The
Property Service Specification.</A>

<P>
<HR>
<H3>
<A NAME="cservices"></A>CORBA Concurrency Service</H3>
Point of contact: <A HREF="mailto:tworm@cs.wustl.edu">Torben Worm</A>

<P>Current status (as of May 3rd):
<UL>
<LI>
A simple version of the concurrency service has been implemented, i.e.
a version without transactions. It is currently being tested.</LI>
</UL>
Future Work:
<UL>
<LI>
Implementation of the Concurrency Service with transactions</LI>
</UL>
For general documentation of the Concurrency Service, please read
<A HREF="http://www.omg.org/corba/sectrans.htm#concur">The Concurrency
Service Specification.</A>

<HR WIDTH="100%">
<H3>
<A NAME="av"></A>CORBA Audio/Video Control Service</H3>
Point of contact: <A HREF="mailto:naga@cs.wustl.edu">Nagarajan Surendran</A>

<P>This is an implementation of the OMG spec addressing the <A HREF="http://www.cs.wustl.edu/~sumedh/research/corbaav.pdf">Control
and Management of Audio/Video Streams</A>.

<P>The audio/video streaming service has been implemented in the light
profile. An MPEG-1 application which streams mpeg-1 video and mpeg-1 audio
separately has been developed using the service. This application currently
works only for Unix platforms.

<P>Work in progress:
<UL>
<LI>
Implementing the SFP protocol</LI>

<LI>
Integrating the mpeg-1 streaming application with the trading service.</LI>
</UL>

<HR>
<P><A NAME="ts"></A><B>CORBA Time Service</B>
<P>Point of contact: <A HREF="mailto:vishal@cs.wustl.edu">Vishal Kachroo</A>
<P>TAO's Time Service allows clients to connect to Time Service
Clerks running on their machines and obtain globally synchronized
time.  This time is calculated from the time obtained from one or more
Time Servers running on multiple machines in the network.
<P>Current status (as of 1st Jan 1999):
<UL>
<LI>
Implementation of a Distributed CORBA Time Service without using the Implementation
Repository is complete.</LI>
</UL>
Work in progress
<UL>
<LI>
Integrating the Implementation Repository with the Time Service. This
allows the Time Servers and Clerks to be activated on-demand.</LI>
<LI>
Adding tests for the various options in the service.</LI>
</UL>
Future work:
<UL>
<LI>
Currently the average of the time obtained from the various servers is
considered the global notion of time. A better distributed time
synchronization algorithm can be used in the future.</LI>
<LI>
Implementation of the Timer Event Service.</LI>
</UL>
For OMG's documentation on the Time Service please read&nbsp; <A HREF="ftp://ftp.omg.org/pub/docs/formal/97-02-22.pdf">The
Time Service Specification.</A>

<P><HR WIDTH="100%"><P>
<H3><A NAME="ec">CORBA Event Service</A></H3>

<H4>
<!-- @@ Pradeep: can you find an URL that points to the OMG website? -->
<!-- IMHO it will look more official like that. -->
Last Updated: Sat Jan&nbsp; 2 01:17:33 CST 1999</H4>
Point of contact: <A HREF="mailto:pradeep@cs.wustl.edu">Pradeep Gore</A>
<P>The COS compliant Event Service implements the <A HREF="http://siesta.cs.wustl.edu/~coryan/Docs/formal/97-12-11.pdf">Event
Service Specification</A>
<BR>This implementation is based on the Real Time Event service.
<H3>
Features in this release:</H3>

<UL>
<LI>
The Event Channel (<TT>$TAO_ROOT/orbsvcs/orbsvcs/CosEvent</TT>) supports
the <TT>push </TT>style event communication.</LI>

<LI>
A simple test (<TT>$TAO_ROOT/orbsvcs/tests/CosEC_Basic</TT>) demonstrates
how to create and use the event channel.</LI>
</UL>

<H3>
Current Work:</H3>

<UL>
<LI>
<TT>Event Service</TT>: The Event Service will create an event channel
and register it with the naming service, Push style consumers and
producers</LI> 

<BR>can then connect to the service and send /receive events.
<LI>
<TT>CosEC_Multiple</TT>:&nbsp; This test demonstrates how multiple CosEC's
connect to one RtEC and how multiple consumers and producers exchange
events in this configuration.</LI>

</UL>

<P><HR><!--#include virtual="ec.html" -->
<P>
<HR><P>
<H3><A NAME="scheduling"></A>TAO's Scheduling Service</H3>
Point of contact:&nbsp; <A HREF="mailto:cdgill@cs.wustl.edu">Chris Gill</A>
and <A HREF="mailto:levine@cs.wustl.edu">David Levine</A>

<P>Currently Implemented Features:
<UL>
<LI>
The scheduling service can be built to use either a null 
implementation or a strategized implementation of the configuration scheduler.
</LI>
<LI>
The null scheduler implementation, which is built by default, allows the 
configuration scheduler to be used with applications that require a scheduling
service interface, but do not (at least in the current stage of their 
development, in certain configurations, etc.) make use of the real-time 
scheduling features it provides.
</LI>
<LI>
The strategized scheduler implementation can be built by #defining
TAO_USES_STRATEGY_SCHEDULER, and the appropriate scheduling strategy macro
(TAO_USES_RMS_SCHEDULING, TAO_USES_EDF_SCHEDULING, TAO_USES_MUF_SCHEDULING,
or TAO_USES_MUF_SCHEDULING) in $ACE_ROOT/ace/config.h. This allows the 
configuration scheduler to be used with applications that require a specific
scheduling strategy.  Each scheduling strategy will produce a set of static
scheduling priorities, which it will assign to operations based on their
RT_Infos.  For each static priority, a strategy will also determine the
run-time (dynamic) scheduling strategy to use for that priority level.
</LI>
</UL>
Future work:
<UL>
<LI>
&nbsp;Implement heap-based dispatching queues.</LI>
<LI>
&nbsp;Add support for additional configurability, especially in the type
of dispatching strategy (list vs. heap) that will be used to dispatch 
operations at a given static priority level.</LI>
<LI>
&nbsp;Benchmark the various alternative strategies to obtain performance
profiles across different operation loads and OS platforms.</LI>
<LI>
&nbsp;Add increased functionality. Requests and suggestions are welcome.</LI>
</UL><P>

<HR>
<H3><A NAME="logging"></A>TAO's Logging Service</H3>
Point of contact:&nbsp; <A HREF="mailto:mjb2@cs.wustl.edu">Matt Braun</A>

<P>Current status (as of August 4'th):
<UL>
<LI>
The basic logging service has been implemented. It can log basic messages
from multiple clients. It is currently in the testing stage.</LI>
</UL>
Future work:
<UL>
<LI>
&nbsp;Add increased functionality. Requests and suggestions are welcome.</LI>
</UL>
&nbsp;&nbsp;&nbsp;&nbsp;

<HR>
<H3>
<A NAME="apps"></A>Test &amp; Performance Tests</H3>
Point of contact: <A HREF="mailto:naga@cs.wustl.edu">Nagarajan Surendran</A>

<P>Current Status:

<P>The TAO IDL_Cubit test application makes use of the Naming Service and
the server holds a TAO_Naming_Server component.Just running server and
client is enough to test the application.

<P>The various tests in the tests/POA test the different features of
the Portable Object Adapter interface like Explicit Activation, On
Demand Activation,etc..

<P>MT_Cubit:

<P>Current status:

<P>The TAO MT_Cubit test application is meant to serve as a starting point
for real-time tests on the TAO system. It comprises the following parts:
<UL>
<LI>
<I>Server.</I> The server creates multiple CORBA objects (servants), each
with different real-time priorities. This priority is implemented by using
real-time thread support provided by the operating system. Thus, requests
sent to a high-priority servant are handled by a high-priority real-time
thread, and those sent to a lower priority servant are handled by correspondingly
lower priority threads.</LI>

<LI>
<I>Client.</I> The client component binds to the servants, and sends a
stream of CORBA requests to the servants. It measures the response time,
i.e. the time taken for the request to complete successfully. In particular,
it measures the time taken for requests sent to the high priority servant
to complete. The volume of lower priority requests is configurable. The
client is thus able to measure the performance of the high-priority servant
in the presence of competition from several lower-priority servants.</LI>
</UL>
Clearly, if the ORB endsystem handles the priorities of the various requests
correctly, increasing the volume of lower priority requests should not
affect the performance seen by the higher priority requests. The application
thus serves as a tool to measure and confirm this behavior.

<P>Future work:
<UL>
<LI>
Study the impacts of scheduling &amp; concurrency strategies on performance.</LI>

<LI>
Evolve into a testbed for discovering sources of performance non-determinism
&amp; priority inversion.</LI>
</UL>

<HR>

<H3>
<A NAME="ace"></A>ORB-related ACE Changes</H3>
Points of contact: <A HREF="mailto:nanbor@cs.wustl.edu">Nanbor Wang</A>
and <A HREF="mailto:irfan@cs.wustl.edu">Irfan Pyrarli</A>

<P>Recently Completed Work:
<UL>
<LI>
Added special declaration to OS.h for <TT>inet_ntoa</TT> and other functions
because VxWorks doesn't provide full argument prototypes for these library
functions.</LI>

<LI>
The current caching connector behaves properly in the face of a non-blocking
connect request. The "fix" is simply to not support non-blocking connects
through the cache. When the <TT>connect()</TT> fails with <TT>EWOULDBLOCK</TT>,
morph the error to -1 and clean up the request.</LI>

<LI>
Service handlers obtained from the caching connector are now cleaned up.
The application needs to be able to signal that it's not using it any longer,
and, when the application encounters an error, needs to effectively close
down that connection for good so that a new connection can be initiated.</LI>

<BR>Added the ability for a Svc_Handler to recycle itself. idle() can be
called when the Svc_Handler is done serving a particular connection and
can how be recycled. The Svc_Handler now also has a pointer to a recycler
that is responsible for managing the connections. The recycler is usually
a Cached_Connector.
<BR>Added new class ACE_Recycling_Strategy. It defines the interface (and
default implementation) for specifying a recycling strategy for a Svc_Handler.
This strategy acts as a consular to the Svc_Handler, preparing it for the
tough times ahead when the Svc_Handler will be recycled.
<BR>Added new class ACE_NOOP_Concurrency_Strategy. It implements a no-op
activation strategy in order to avoid calling open on a recycled svc_handler
multiple times.
<BR>ACE_Cached_Connect_Strategy now implements the ACE_Connection_Recycling_Strategy
interface. This allows Svc_Handlers to cache themselves with ACE_Cached_Connect_Strategy
when they become idle. It also allows them to purge themselves from the
connection cache when the Svc_Handlers close down.
<BR>Also added ~ACE_Cached_Connect_Strategy that will cleanup up the connection
cache.</UL>
Future work:
<BLOCKQUOTE><I>None currently scheduled.</I></BLOCKQUOTE>

<HR>
<H3>
<A NAME="dove"></A>The DOVE Demo</H3>
Points of contact: <A HREF="mailto:mk1@cs.wustl.edu">Michael
Kircher</A> and <A HREF="mailto:cdgill@cs.wustl.edu">Chris Gill</A>.

<P><A HREF="http://www.cs.wustl.edu/~schmidt/dove.html">DOVE</A> is
documented in detail <A
HREF="http://www.cs.wustl.edu/~schmidt/DOVE_and_LifeCycleService.ps.gz">online</A>.
This discussion focuses on the following goals:<P>

<UL>
<LI>
Have a DOVE Browser running using Java Beans as vizualization components.</LI>

<LI>
Have the Event Channel as DOVE Agent running with an Event Consumer in
the DOVE Browser.</LI>

<LI>
Having a DOVE Management Information Base (MIB), which dumps all events
transfered on the Event Channel into a file on persistent storage for later
reuse.</LI>
</UL>
The DOVE Browser uses independent visualization components (Java Beans)
and the Event Channel as DOVE Agent. Connections can be established between
monitored metrics and the visualization components.

<P>We have three major components: Observables (monitored metrics),
Observers (a Java Bean for displaying the metric) and a DataHandler
(for demultiplexing the monitored metrics to the appropriate
Observables). Each component inherits from a base class, so that a
certain behavior of the components can be assured for each
component. Relationships between components are based on these base
classes.

<P>The used Java Beans are required to conform to some standards, as
they have to support a function called "getProperty" which allows the
DOVE Browser to determine if the vizualization capabilities of a
specific Java Bean are sufficient to display the metric. A JavaBean is
for example a Java Panel which shows a Graph of the delivered
doubles. So all metrics can be displayed by this visualization
component which can be expressed by a single double.

<P>The DataHandler is connected to the Event Push Consumer (PUSH,
because we use the push concept of the Event Service). The Event Push
Consumer does not know what kind of data is transported. The only
component knowing all the details about the dependencies of the
metrics is the DataHandler.  This separation allows easy extension and
change of the demo.

<P><A HREF="http://students.cec.wustl.edu/~mk1/dove.html">Object Diagrams</A>
are available about this new concept.

<P>Event Service events are used as communication between DOVE
Applications and the DOVE Browser. The DOVE MIB analyses the event
data field of all events and stores this information into a file. The
event data filed is of type CORBA::Any and the DOVE MIB has no notion
of what is conveyed in this field. So the DOVE MIB has to discover the
content via the embedded type code information. Future work includes:

<UL>
<LI>
Enhancing MIB functionality</LI>

<LI>
Monitoring the AV Streaming Service</LI>
</UL>

<P>For more information on the DOVE demo, please refer to:
        $TAO_ROOT/orbsvcs/tests/Simulator/README

<HR>
<H3>
<A NAME="forwarding"></A>Location Forwarding</H3>
Point of contact: <A HREF="mailto:irfan@cs.wustl.edu">Irfan Pyarali</A>,
<A HREF="mailto:mk1@mk1.wustl.edu">Michael Kircher</A>.

<P>For more information see <A HREF="../forwarding.html">Location forwarding</A><P>
<HR>
<H3>
<A NAME="leader"></A>Global Resources and Leader-Follower Model</H3>
Point of contact: <A HREF="mailto:irfan@cs.wustl.edu">Irfan Pyarali</A>,
<A HREF="mailto:mk1@mk1.wustl.edu">Michael Kircher</A>.

<P>For more information see <A HREF="../leader_follower.html">Leader-follower
model</A><P>
<HR>
<H3>
<A NAME="locate"></A>Implementation of locate request</H3>
Point of contact: <A HREF="mailto:irfan@cs.wustl.edu">Irfan Pyarali</A>,
<A HREF="mailto:mk1@mk1.wustl.edu">Michael Kircher</A>.

<P>For more information see <A HREF="../locate_request.html">Locate request</A><P>
<HR>

<P>Back to the TAO <A HREF="../index.html">documentation index</A>.&nbsp;<!--#include virtual="/~schmidt/cgi-sig.html" -->
</BODY>
</HTML>
