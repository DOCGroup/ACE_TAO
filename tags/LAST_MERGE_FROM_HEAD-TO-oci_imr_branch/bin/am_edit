#!/usr/bin/perl

## $Id$

## Expands the specilised TAO tags in Makefile.in to (hopefully) valid
## make syntax.
##
## This script has been modified from the original am_edit script that
## the KDE development team uses for the KDE.  This modified script
## searches a Makefile.in file for IDL sources (ending in `.idl'), and
## adds appropriate targets for the C++ sources generated by the TAO
## IDL compiler.  For example, for the IDL file `CosNaming.idl' this script
## would add all relevant targets for the following files:
##
##     CosNaming.idl  --> CosNamingC.h
##                        CosNamingC.i
##                        CosNamingC.cpp
##                        CosNamingS.h
##                        CosNamingS.i
##                        CosNamingS.cpp
##
##   Ossama Othman <ossama@debian.org> 


# Expands the specilised KDE tags in Makefile.in to (hopefully) valid
# make syntax.
# When called without file parameters, we work recursively on all Makefile.in
# in and below the current subdirectory. When called with file parameters,
# only those Makefile.in are changed.
# The currently supported tags are
#
# {program}_METASOURCES
# where you have a choice of two styles
#   {program}_METASOURCES = name1.moc name2.moc ... [\]
#   {program}_METASOURCES = AUTO
#       The second style requires other tags as well.
#
# and more new tags TBD!
#
# The concept (and base code) for this peogram came from automoc,
# supplied by the following
#
# Matthias Ettrich <ettrich\@kde.org>      (The originator)
# Kalle Dalheimer <kalle\@kde.org>      (The original implementator)
# Harri Porten  <porten@tu-harburg.de>
# Alex Zepeda  <garbanzo@hooked.net>
# David Faure <faure@kde.org>
# Stephan Kulow <coolo@kde.org>
#
# I've puddled around with automoc and produced something different
# 1999-02-01 John Birch <jb.nz@writeme.com>
#       * Rewritten automoc to cater for more than just moc file expansion
#         Version 0.01 does the same as automoc at this stage.
# 1999-02-18 jb
#       * We must always write a Makefile.in file out even if we fail
#         because we need the "perl autokmake" in the AUTOMAKE so that a
#         "make" will regenerate the Makefile.in correctly.
#         Reworked moc file checking so that missing includes in cpp
#         will work and includes in cpp when using use_automoc will also
#         work.
# 1999-02-23 jb
#       * Added POFILE processing and changed the USE_AUTOMOC tag to
#         AUTO instead.
# 1999-11-07 Ossama Othman <ossama@debian.org> 
#       * Modified IDL source file related code to specifically
#       * generated targets for TAO IDL generated sources.


use Cwd;
use File::Find;
use File::Basename;

# Prototype the functions
sub initialise ();
sub processMakefile ($);
sub updateMakefile ();
sub restoreMakefile ();

sub removeLine ($$);
sub appendLines ($);
sub substituteLine ($$);

sub findMocCandidates ();
sub pruneMocCandidates ($);
sub checkMocCandidates ();
sub addMocRules ();

sub tag_AUTOMAKE ();
sub tag_META_INCLUDES ();
sub tag_METASOURCES ();
sub tag_POFILES ();
sub tag_DOCFILES ();
sub tag_LOCALINSTALL();
sub tag_IDLFILES();
sub tag_TOPLEVEL();
sub tag_SUBDIRS();
sub tag_ICON();

# Some global globals...
$verbose    = 0;        # a debug flag
$thisProg   = "$0";     # This programs name
$topdir     = cwd();    # The current directory
@makefiles  = ();       # Contains all the files we'll process
$start      = (times)[0]; # some stats for testing - comment out for release
$version    = "v0.2";
$errorflag  = 0;
$cppExt     = "*.cpp *.cc *.cxx *.C *.c++";           # used by grep
$hExt       = "*.h *.H *.hh *.hxx *.h++";             # used by grep
$progId     = "TAO tags expanded automatically by " . basename($thisProg);
$automkCall = "\n";
$printname  = "";  # used to display the directory the Makefile is in
$use_final  = 1;        # create code for --enable-final
$cleantarget = "clean";
$locolor_install = 0;

while (defined ($ARGV[0]))
{
    $_ = shift;
    if (/^--version$/)
    {
        print STDOUT "\n";
        print STDOUT basename($thisProg), " $version\n",
                "This is really free software, unencumbered by the GPL.\n",
                "You can do anything you like with it except sueing me.\n",
                "Copyright 1998 Kalle Dalheimer <kalle\@kde.org>\n",
                "Concept, design and unnecessary questions about perl\n",
                "       by Matthias Ettrich <ettrich\@kde.org>\n\n",
                "Making it useful by Stephan Kulow <coolo\@kde.org> and\n",
                "Harri Porten <porten\@kde.org>\n",
                "Updated (Feb-1999), John Birch <jb.nz\@writeme.com>\n\n";
        exit 0;
    }
    elsif (/^--verbose$|^-v$/)
    {
        $verbose = 1;       # Oh is there a problem...?
    }
    elsif (/^-p(.+)$|^--path=(.+)$/)
    {
        $thisProg = "$1/".basename($thisProg);
        warn ("$thisProg doesn't exist\n")      if (!(-f $thisProg));
    }
    elsif (/^--help$|^-h$/)
    {
        print STDOUT "Usage $thisProg [OPTION] ... [dir/Makefile.in]...\n",
                "\n",
                "Patches dir/Makefile.in generated from automake\n",
                "(where dir can be a full or relative directory name)",
                "\n",
                "  -v, --verbose      verbosely list files processed\n",
                "  -h, --help         print this help, then exit\n",
                "  --version          print version number, then exit\n",
                "  -p, --path=        use the path to automoc if the path\n",
	        "  --no-final         don't patch for --enable-final\n",
                "                     called from is not the one to be used\n";
	
        exit 0;
    }
    elsif (/^--no-final$/)
    {
	$use_final = 0;
	$locolor_install = 1;
    }
    else
    {
        # user selects what input files to check
        # add full path if relative path is given
        $_ = cwd()."/".$_   if (! /^\//);
        print "User wants $_\n" if ($verbose);
        push (@makefiles, $_);
    }
}

# Only scan for files when the user hasn't entered data
if (!@makefiles)
{
    print STDOUT "Scanning for Makefile.in\n"       if ($verbose);
    find (\&add_makefile, cwd());
    #chdir('$topdir');
} else {
    print STDOUT "Using user enter input files\n"   if ($verbose);
}

foreach $makefile (@makefiles)
{
    processMakefile ($makefile);
    last            if ($errorflag);
}

# Just some debug statistics - comment out for release as it uses printf.
printf STDOUT "Time %.2f CPU sec\n", (times)[0] - $start     if ($verbose);

exit $errorflag;        # causes make to fail if errorflag is set

#-----------------------------------------------------------------------------

# In conjunction with the "find" call, this builds the list of input files
sub add_makefile ()
{
    push (@makefiles, $File::Find::name)  if (/Makefile.in$/);
}

#-----------------------------------------------------------------------------

# Processes a single make file
# The parameter contains the full path name of the Makefile.in to use
sub processMakefile ($)
{
    # some useful globals for the subroutines called here
    local ($makefile)       = @_;
    local @headerdirs       = ('.');
    local $haveAutomocTag   = 0;
    local $MakefileData     = "";

    local $cxxsuffix  = "TAO";

    local @programs = ();  # lists the names of programs and libraries
    local $program = "";

    local %realObjs = ();  # lists the objects compiled into $program
    local %sources = ();   # lists the sources used for $program
    local %finalObjs = (); # lists the objects compiled when final
    local %idlfiles = ();  # lists the idl files used for $program
    local $idl_output = "";# lists all idl generated files for cleantarget

    local %depedmocs = ();

    local $metasourceTags = 0;
    local $dep_files = "";
    local %target_adds = (); # the targets to add
    local $kdelang    = "";

    $makefileDir = dirname($makefile);
    chdir ($makefileDir);
    $printname = $makefile;
    $printname =~ s/^\Q$topdir\E\///;
    $makefile = basename($makefile);

    print STDOUT "Processing makefile $printname\n"   if ($verbose);

    # Setup and see if we need to do this.
    return      if (!initialise());

    tag_AUTOMAKE ();            # Allows a "make" to redo the Makefile.in
    tag_META_INCLUDES ();       # Supplies directories for src locations

    foreach $program (@programs) {
	tag_METASOURCES ();         # Sorts out the moc rules
	tag_IDLFILES();             # Sorts out idl rules
    }

    if ($idl_output) {
      appendLines ("$cleantarget-idl:\n\t-rm -f $idl_output\n");
      $target_adds{"$cleantarget-am"} .= "$cleantarget-idl ";
    }

    if ($MakefileData =~ /\nKDE_LANG\s*=\s*(\S*)\n/) {
      $kdelang = '$(KDE_LANG)'
    } else {
      $kdelang = '';
    }

    tag_POFILES ();             # language rules for po directory
    tag_DOCFILES ();            # language rules for doc directories
    tag_TOPLEVEL ();            # language rules for po toplevel
    tag_LOCALINSTALL();         # add $(DESTDIR) before all kde_ dirs
    tag_ICON();

    my $tmp = "force-reedit:\n";
    $tmp   .= "\t$automkCall\n\tcd \$(top_srcdir) && perl $thisProg $printname\n\n";
    appendLines($tmp);

    tag_FINAL() if ($use_final);

    my $final_lines = "final:\n\t\$(MAKE) ";

    foreach $program (@programs) {

      my $lookup = "$program\_OBJECTS.*=[^\n]*";

      my $new = "";

      my @list = split(/[\034\s]+/, $realObjs{$program});

      if ($use_final && @list > 1 && $finalObjs{$program}) {
	
	$new  = "\@KDE_USE_FINAL_FALSE\@$program\_OBJECTS = " . $realObjs{$program};
	$new .= "\n\@KDE_USE_FINAL_TRUE\@$program\_OBJECTS = " . $finalObjs{$program};
	$new .= "\n$program\_final\_OBJECTS = " . $finalObjs{$program};

	$final_lines .= "$program\_OBJECTS=\"\$($program\_final_OBJECTS)\" ";

      } else {
	$new = "$program\_OBJECTS = " . $realObjs{$program};
      }

      substituteLine ($lookup, $new);
    }
    appendLines($final_lines . "all-am");

    my $lookup = 'DEP_FILES\s*=(.*)\n';
    if ($MakefileData =~ /\n$lookup/) {
      $lines = "DEP_FILES = $dep_files";
      $lines .= " \034";
      $lines .= $1;
      $lines .= "\n";

      substituteLine($lookup, $lines);
    }

    foreach $add (keys %target_adds) {
      my $lookup = "$add:\s*(.*)";
      if ($MakefileData =~ /\n$lookup\n/) {
	substituteLine($lookup, "$add: " . $target_adds{$add} . $1);
      }
    }

    my $cvs_lines = "cvs-clean:\n";
    $cvs_lines .= "\t\$(MAKE) -f \$(top_srcdir)/admin/Makefile.common cvs-clean\n";
    appendLines($cvs_lines);

    # Always update the Makefile.in
    updateMakefile ();
    return;
}

#-----------------------------------------------------------------------------

# Check to see whether we should process this make file.
# This is where we look for tags that we need to process.
# A small amount of initialising on the tags is also done here.
# And of course we open and/or create the needed make files.
sub initialise ()
{
    if (! -r "Makefile.am") {
	print STDOUT "found Makefile.in without Makefile.am\n" if ($verbose);
	return;
    }

    # Checking for files to process...
    open (FILEIN, $makefile)
      || die "Could not open $makefileDir/$makefile: $!\n";
    # Read the file
    while ( <FILEIN> )
    {
        $MakefileData .= $_;
    }
    close FILEIN;

    # Remove the line continuations, but keep them marked
    # Note: we lose the trailing spaces but that's ok.
    $MakefileData =~ s/\\\s*\n/\034/g;

    # If we've processed the file before...
    restoreMakefile ()      if ($MakefileData =~ /$progId/);

    # Look for the tags than mean we should process this file.
    $metasourceTags = 0;
    $metasourceTags++    while ($MakefileData =~ /\n[^=#]*METASOURCES\s*=/g);

    my $pofileTag = 0;
    $pofileTag++    while ($MakefileData =~ /\nPOFILES\s*=/g);
    if ($pofileTag > 1)
    {
        print STDERR "Error: Only one POFILES tag allowed\n";
        $errorflag = 1;
    }

    while ($MakefileData =~ /\n\.SUFFIXES:([^\n]+)\n/g) {
	my @list=split(' ', $1);
	my $extions = " " . $cppExt . " ";
	foreach $ext (@list) {
	    if ($extions =~ / \*\Q$ext\E /) {
		$cxxsuffix = $ext;
		$cxxsuffix =~ s/\.//g;
		print STDOUT "will use suffix $cxxsuffix\n" if ($verbose);
		last;
	    }
	}
    }

    while ($MakefileData =~ /\n(\S*)_OBJECTS\s*=\s*([^(\n]*)\n/g) {
      my $program = $1;
      my $objs = $2; # safe them
      $program =~ s/^am_// if ($program =~ /^am_/);

      print STDOUT "found program $program\n" if ($verbose);
      push(@programs, $program);

      $realObjs{$program} = $objs;

      if ($MakefileData =~ /\n$program\_SOURCES\s*=\s*(.*)\n/) {
	$sources{$program} = $1;
      } else {
	$sources{$program} = "";
	print STDERR "found program with no _SOURCES: $program\n";
      }
    }

    my $localTag = 0;
    $localTag++ if ($MakefileData =~ /\ninstall-\S+-local:/);

    return (!$errorflag);
}

#-----------------------------------------------------------------------------

# Gets the list of user defined directories - relative to $srcdir - where
# header files could be located.
sub tag_META_INCLUDES ()
{
    my $lookup = '[^=\n]*META_INCLUDES\s*=\s*(.*)';
    return 1    if ($MakefileData !~ /($lookup)\n/);
    print STDOUT "META_INCLUDE processing <$1>\n"       if ($verbose);

    my $headerStr = $2;
    removeLine ($lookup, $1);

    $headerStr =~ tr/\034/ /;
    my @headerlist = split(' ', $headerStr);

    foreach $dir (@headerlist)
    {
        $dir =~ s#\$\(srcdir\)#.#;
        if (! -d $dir)
        {
            print STDERR "Warning: $dir can't be found. ",
                            "Must be a relative path to \$(srcdir)\n";
        }
        else
        {
            push (@headerdirs, $dir);
        }
    }

    return 0;
}

#-----------------------------------------------------------------------------

sub tag_FINAL()
{
  my @final_names = ();

  foreach $program (@programs) {

    if ($sources{$program} =~ /\(/) {
      print STDERR "found ( in $program\_SOURCES. skipping\n" if ($verbose);
      next;
    }

    my @list = split(/[\s\034]+/, $realObjs{$program});
    # we're not making anything faster for one object file
    next if (@list == 1);

    my $mocsources = "";

    my @progsources = split(/[\s\034]+/, $sources{$program});
    my %sourcelist = ();

    foreach $source (@progsources) {
      my $suffix = $source;
      $suffix =~ s/^.*\.([^\.]+)$/$1/;

      if (defined($sourcelist{$suffix})) {
	$sourcelist{$suffix} .= " " . $source;
      } else {
	$sourcelist{$suffix} .= $source;
      }
    }

    foreach $suffix (keys %sourcelist) {

      # See if this file contains c++ code. (ie Just check the files suffix against
      my $suffix_is_cxx = 0;
      foreach $cxx_suffix (split(' ', $cppExt)) {
       $cxx_suffix =~ s/^\*\.//;
       $cxx_suffix = quotemeta($cxx_suffix);
       if ($suffix =~ $cxx_suffix) {
         $suffix_is_cxx = 1;
         last;
       }
      }

      my $mocfiles_in = ($suffix eq $cxxsuffix) &&
	defined($depedmocs{$program});

      my @sourcelist = split(/[\s\034]+/, $sourcelist{$suffix});

      if ((@sourcelist == 1 && !$mocfiles_in) || $suffix_is_cxx != 1 ) {

	# we support IDL on our own
	if ($suffix =~ /^idl$/ || $suffix =~ /^h$/) {
	  next;
	}
	
	foreach $file (@sourcelist) {

	  $file =~ s/\Q$suffix\E$//;
	
	  $finalObjs{$program} .= $file;
	  if ($program =~ /_la$/) {
	    $finalObjs{$program} .= "lo ";
	  } else {
	    $finalObjs{$program} .= "o ";
	  }
	}
	next; # suffix
      }

      my $source_deps = "";
      foreach $source (@sourcelist) {
	if (-f $source) {
	  $source_deps .= "\$(srcdir)/$source ";
	} else {
	  $source_deps .= "$source ";
	}
      }

      $handling = "$program.all_$suffix.$suffix: \$(srcdir)/Makefile.in " . $source_deps . " ";

      if ($mocfiles_in) {
	$handling .= $depedmocs{$program};
	foreach $mocfile (split(' ', $depedmocs{$program})) {
	  if ($mocfile =~ m/\.$suffix$/) {
	    $mocsources .= " " . $mocfile;
	  }
	}
      }

      $handling .= "\n";
      $handling .= "\t\@echo 'creating $program.all_$suffix.$suffix ...'; \\\n";
      $handling .= "\trm -f $program.all_$suffix.files $program.all_$suffix.final; \\\n";
      $handling .= "\techo \"#define KDE_USE_FINAL 1\" >> $program.all_$suffix.final; \\\n";
      $handling .= "\tfor file in " . $sourcelist{$suffix} . " $mocsources; do \\\n";
      $handling .= "\t  echo \"#include \\\"\$\$file\\\"\" >> $program.all_$suffix.files; \\\n";
      $handling .= "\t  test ! -f \$\(srcdir\)/\$\$file || egrep '^#pragma +implementation' \$\(srcdir\)/\$\$file >> $program.all_$suffix.final; \\\n";
      $handling .= "\tdone; \\\n";
      $handling .= "\tcat $program.all_$suffix.final $program.all_$suffix.files  > $program.all_$suffix.$suffix; \\\n";
      $handling .= "\trm -f $program.all_$suffix.final $program.all_$suffix.files\n";

      appendLines($handling);
	
      push(@final_names, "$program.all_$suffix.$suffix");
      $finalObjs{$program} .= "$program.all_$suffix.";
      if ($program =~ /_la$/) {
	$finalObjs{$program} .= "lo ";
      } else {
	$finalObjs{$program} .= "o ";
      }
    }
  }

  if ($use_final && @final_names >= 1) {
    # add clean-final target
    my $lines = "$cleantarget-final:\n";
    $lines .= "\t-rm -f " . join(' ', @final_names) . "\n" if (@final_names);
    appendLines($lines);
    $target_adds{"$cleantarget-am"} .= "$cleantarget-final ";

    foreach $finalfile (@final_names) {
      $finalfile =~ s/\.[^.]*$/.P/;
      $dep_files .= " .deps/$finalfile";
    }
  }
}

# Organises the list of headers that we'll use to produce moc files
# from.
sub tag_METASOURCES ()
{
    local @newObs           = ();  # here we add to create object files
    local @deped            = ();  # here we add to create moc files
    local $mocExt           = ".moc";
    local %mocFiles         = ();

    my $line = "";
    my $postEqual = "";

    my $lookup;
    my $found = "";

    if ($metasourceTags > 1) {
	$lookup = $program . '_METASOURCES\s*=\s*(.*)';
	return 1    if ($MakefileData !~ /\n($lookup)\n/);
	$found = $1;
    } else {
	$lookup = $program . '_METASOURCES\s*=\s*(.*)';
	if ($MakefileData !~ /\n($lookup)\n/) {
	    $lookup = 'METASOURCES\s*=\s*(.*)';
	    return 1    if ($MakefileData !~ /\n($lookup)\n/);
	    $found = $1;
	    $metasourceTags = 0; # we can use the general target only once
	} else {
	  $found = $1;
      }
    }
    print STDOUT "METASOURCE processing <$found>)\n"      if ($verbose);

    $postEqual = $found;
    $postEqual =~ s/[^=]*=//;

    removeLine ($lookup, $found);

    # Always find the header files that could be used to "moc"
    return 1    if (findMocCandidates ());

    if ($postEqual =~ /AUTO\s*(\S*)|USE_AUTOMOC\s*(\S*)/)
    {
	print STDERR "$printname: the argument for AUTO|USE_AUTOMOC is obsolete" if ($+);
	$mocExt = ".moc.$cxxsuffix";
	$haveAutomocTag = 1;
    }
    else
    {
        # Not automoc so read the list of files supplied which
        # should be .moc files.

        $postEqual =~ tr/\034/ /;

        # prune out extra headers - This also checks to make sure that
        # the list is valid.
        pruneMocCandidates ($postEqual);
    }

    checkMocCandidates ();

    if (@newObs) {
      my $ext =  ($program =~ /_la$/) ? ".moc.lo " : ".moc.o ";
      $realObjs{$program} .= "\034" . join ($ext, @newObs) . $ext;
      $depedmocs{$program} = join (".moc.$cxxsuffix " , @newObs) . ".moc.$cxxsuffix";
      foreach $file (@newObs) {
	$dep_files .= " .deps/$file.moc.P";
      }
    }
    if (@deped) {
      $depedmocs{$program} .= " ";
      $depedmocs{$program} .= join('.moc ', @deped) . ".moc";
      $depedmocs{$program} .= " ";
    }
    addMocRules ();
}

#-----------------------------------------------------------------------------

# Returns 0 if the line was processed - 1 otherwise.
# Errors are logged in the global $errorflags
sub tag_AUTOMAKE ()
{
    my $lookup = '.*cd \$\(top_srcdir\)\s+&&\s+\$\(AUTOMAKE\)(.*)';
    return 1    if ($MakefileData !~ /($lookup)/);
    print STDOUT "AUTOMAKE processing <$1>\n"        if ($verbose);

    my $newLine = $1."\n\tcd \$(top_srcdir) && perl $thisProg $printname";
    substituteLine ($lookup, $newLine);
    $automkCall = $1;
    return 0;
}

#-----------------------------------------------------------------------------

sub tag_TOPLEVEL()
{
  my $lookup = 'TOPLEVEL_LANG\s*=\s*(\S+)';
  return 1 if ($MakefileData !~ /\n$lookup\n/);
  my $lang = $1;

  if (tag_SUBDIRS()) {
    print STDERR "Error: TOPLEVEL_LANG without SUBDIRS = \$(AUTODIRS) in $printname\n";
    $errorflag = 1;
    return 1;
  }

  my $pofiles = "";
  my @restfiles = ();
  opendir (THISDIR, ".");
  foreach $entry (readdir(THISDIR)) {
    next if (-d $entry);

    next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^#.*#$/ || $entry =~ /.gmo$/);

    if ($entry =~ /\.po$/) {
      $pofiles .= "$entry ";
      next;
    }
    push(@restfiles, $entry);
  }
  closedir (THISDIR);

  print STDOUT "pofiles found = $pofiles\n"   if ($verbose);
  handle_POFILES($pofiles, '$(TOPLEVEL_LANG)') if ($pofiles);

  if (@restfiles) {
    $target_adds{"install-data-am"} .= "install-nls-files ";
    $lines = "install-nls-files:\n";
    $lines .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_locale)/$lang\n";
    for $file (@restfiles) {
      $lines .= "\t\$(INSTALL_DATA) \$\(srcdir\)/$file \$(DESTDIR)\$(kde_locale)/$lang/$file\n";
    }
    appendLines($lines);
  }

  return 0;
}

#-----------------------------------------------------------------------------

sub tag_SUBDIRS ()
{
  if ($MakefileData !~ /\nSUBDIRS\s*=\s*\$\(AUTODIRS\)\s*\n/) {
    return 1;
  }

  my $subdirs;

  opendir (THISDIR, ".");
  foreach $entry (readdir(THISDIR)) {
    next if ($entry eq "CVS" || $entry =~ /^\./);
    if (-d $entry && -f $entry . "/Makefile.in") {
      $subdirs .= " $entry";
      next;
    }
  }
  closedir (THISDIR);

  my $lines = "SUBDIRS =$subdirs\n";
  substituteLine('SUBDIRS\s*=.*', $lines);
  return 0;
}

sub tag_IDLFILES ()
{
  my @psources = split(/[\034\s]+/, $sources{$program});
  my $dep_lines = "";

  foreach $source (@psources) {
    if ($source =~ m/\.idl$/) {
      print STDERR "adding IDL file $source\n" if ($verbose);

      $source =~ s/\.idl$//;

      my $sourcedir = '';
      if (-f "$makefileDir/$source.idl") {
	$sourcedir = '$(srcdir)/';
      } else {
	if ($MakefileData =~ /\n$source\_IDLDIR\s*=\s*(\S+)\n/) {#
	  $sourcedir = $1;
	  $sourcedir .= "/" if ($sourcedir !~ /\/$/);
	}
      }

      $dep_lines .= "${source}C.h: $sourcedir${source}.idl\n";
      $dep_lines .= "\t\$(IDL) \$(IDL_FLAGS) ${source}.idl\n";
      $dep_lines .= "${source}S.h: ${source}C.h\n";
      $dep_lines .= "${source}C.i: ${source}C.h\n";
      $dep_lines .= "${source}S.i: ${source}C.h\n";
      $dep_lines .= "${source}C.cpp: ${source}C.h\n";
      $dep_lines .= "${source}S.cpp: ${source}C.h\n";

      $idlfiles{$program} .= $source . " ";
#      $realObjs{$program} .= " $source";
      if ($program =~ /_la$/) {
	$realObjs{$program} .= " ${source}C.lo";
	$realObjs{$program} .= " ${source}S.lo";
      } else {
	$realObjs{$program} .= " ${source}C.o";
	$realObjs{$program} .= " ${source}S.o";
      }
      $sources{$program} .= " ${source}C.cpp";
      $sources{$program} .= " ${source}S.cpp";
      $idl_output .= " ${source}C.cpp ${source}S.cpp ${source}C.h ${source}S.h ${source}C.i ${source}S.i";
    }
  }
  if ($dep_lines) {
    appendLines($dep_lines);
    my $lookup = "($program)";
    $lookup =~ s/\_/./g;
    $lookup .= ":(.*)\\\$\\\($program\_OBJECTS\\\)(.*)";
    if ($MakefileData =~ /\n$lookup/) {

      my $line = "$1:$2";
      foreach $file (split(' ', $idlfiles{$program})) {
	$line .= "$file.h ";
      }
      $line .= "\$($program\_OBJECTS)$3\n";
      substituteLine($lookup, $line);
    } else {
      print STDERR "no built dependency found $lookup\n";
    }
  }

}

sub tag_ICON()
{
  my $lookup = 'KDE_ICON\s*=\s*([^\n]*)';
  return 1    if ($MakefileData !~ /\n$lookup/);
  my @appnames = split(" ", $1);
  print STDOUT "KDE_ICON processing <@appnames>\n"   if ($verbose);

  my @files = ();
  opendir (THISDIR, ".");
  foreach $entry (readdir(THISDIR)) {
    next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^\#.*\#$/);
    next if (! -f $entry);
    next if ($entry !~ /\.xpm$/ && $entry !~ /\.png/);
    foreach $appname (@appnames) {
      if ($entry =~ /^mini-$appname\./ || $entry =~ /^$appname\./ || $entry =~ /^lo-$appname\./) {
	push(@files, $entry);
      }
    }
  }
  closedir (THISDIR);
  $target_adds{"install-data-am"} .= "install-kde-icons ";
  $target_adds{"uninstall-am"} .= "uninstall-kde-icons ";

  $install = "install-kde-icons:\n";
  $uninstall = "uninstall-kde-icons:\n";

  my %directories = ();

  foreach $file (@files)
    {
      my $newfile = $file;

      if ($file =~ /^mini-/) {
	if (!defined $directories{"mini"}) {
	  $install .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_icondir)/mini\n";
	  $directories{"mini"} = 1;
	}
	$newfile =~ s/^mini-//;
	$install .= "\t\$(INSTALL_DATA) \$(srcdir)/$file \$(DESTDIR)\$(kde_icondir)/mini/$newfile\n";
	$uninstall .= "\t-rm -f \$(DESTDIR)\$(kde_icondir)/mini/$newfile\n";
	next;
      }

      if ($file =~ /^lo-/) {
	my $dir;
	if ($locolor_install) {
	  $dir = "\$(DESTDIR)\$(kde_icondir)/locolor"
	} else {
	  $dir = "\$(DESTDIR)\$(kde_icondir)"
	}

	if (!defined $directories{"locolor"}) {
	  $install .= "\t\$(mkinstalldirs) $dir\n";
	  $directories{"locolor"} = 1;
	}
	$newfile =~ s/^lo-//;
	$install .= "\t\$(INSTALL_DATA) \$(srcdir)/$file $dir/$newfile\n";
	$uninstall .= "\t-rm -f $dir/$newfile\n";
	next;
      }

      if (!defined $directories{"icon"}) {
	$install .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_icondir)\n";
	$directories{"icon"} = 1;
      }
      $install .= "\t\$(INSTALL_DATA) \$(srcdir)/$file \$(DESTDIR)\$(kde_icondir)/$newfile\n";
      $uninstall .= "\t-rm -f \$(DESTDIR)\$(kde_icondir)/$newfile\n";

    }

  appendLines($install . "\n" . $uninstall);

}

sub handle_POFILES($$)
{
  my @pofiles = split(" ", $_[0]);
  my $lang = $_[1];

  # Build rules for creating the gmo files
  my $tmp = "";
  my $allgmofiles     = "";
  my $pofileLine   = "POFILES =";
  foreach $pofile (@pofiles)
    {
        $pofile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
        $tmp .= "$1.gmo: $pofile\n";
        $tmp .= "\trm -f $1.gmo; \$(GMSGFMT) -o $1.gmo \$(srcdir)/$pofile\n";
        $allgmofiles .= " $1.gmo";
        $pofileLine  .= " $1.po";
    }
  appendLines ($tmp);
  my $lookup = 'POFILES\s*=([^\n]*)';
  if ($MakefileData !~ /\n$lookup/) {
    appendLines("$pofileLine\nGMOFILES =$allgmofiles");
  } else {
    substituteLine ($lookup, "$pofileLine\nGMOFILES =$allgmofiles");
  }

    if ($allgmofiles) {

        # Add the "clean" rule so that the maintainer-clean does something
        appendLines ("clean-nls:\n\t-rm -f $allgmofiles\n");

	$target_adds{"maintainer-clean"} .= "clean-nls ";

	$lookup = 'DISTFILES\s*=\s*(.*)';
	if ($MakefileData =~ /\n$lookup\n/) {
	  $tmp = "DISTFILES = \$(GMOFILES) \$(POFILES) $1";
	  substituteLine ($lookup, $tmp);
	}
    }

  $target_adds{"install-data-am"} .= "install-nls-\@USE_NLS\@ ";

  $tmp = "install-nls-no:\n";
  $tmp .= "install-nls-yes:\n";
  if ($lang) {
    $tmp  .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES\n";
  }
  $tmp .= "\t\@for base in ";
  foreach $pofile (@pofiles)
    {
      $pofile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
      $tmp .= "$1 ";
    }

  $tmp .= "; do \\\n";
  if ($lang) {
    $tmp .= "\t  echo \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES/\$\$base.mo ;\\\n";
    $tmp .= "\t  test ! -f \$\$base.gmo || \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES/\$\$base.mo ;\\\n"
  } else {
    $tmp .= "\t  echo \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/\$\$base/LC_MESSAGES/\$(PACKAGE).mo ;\\\n";
    $tmp .= "\t  \$(mkinstalldirs) \$(DESTDIR)\$(kde_locale)/\$\$base/LC_MESSAGES ; \\\n";
    $tmp .= "\t  test ! -f \$\$base.gmo || \$(INSTALL_DATA) \$\$base.gmo \$(DESTDIR)\$(kde_locale)/\$\$base/LC_MESSAGES/\$(PACKAGE).mo ;\\\n";
  }
  $tmp .= "\tdone\n\n";
  appendLines ($tmp);

  $target_adds{"uninstall"} .= "uninstall-nls ";

  $tmp = "uninstall-nls:\n";
  foreach $pofile (@pofiles)
    {
      $pofile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
      if ($lang) {
	$tmp .= "\trm -f \$(DESTDIR)\$(kde_locale)/$lang/LC_MESSAGES/$1.mo\n";
      } else {
	$tmp .= "\trm -f \$(DESTDIR)\$(kde_locale)/$1/LC_MESSAGES/\$(PACKAGE).mo\n";
      }
    }
  appendLines($tmp);

  $target_adds{"all"} .= "all-nls-\@USE_NLS\@ ";

  $tmp = "all-nls-no:\n";
  $tmp .= "all-nls-yes: \$(GMOFILES)\n";

  appendLines($tmp);

  $target_adds{"distdir"} .= "distdir-nls ";

  $tmp = "distdir-nls:\$(GMOFILES)\n";
  $tmp .= "\tfor file in \$(POFILES); do \\\n";
  $tmp .= "\t  cp \$(srcdir)/\$\$file \$(distdir); \\\n";
  $tmp .= "\tdone\n";
  $tmp .= "\ttest -z \"\$(GMOFILES)\" || cp \$(GMOFILES) \$(distdir)\n";

  appendLines ($tmp);

}

#-----------------------------------------------------------------------------

# Returns 0 if the line was processed - 1 otherwise.
# Errors are logged in the global $errorflags
sub tag_POFILES ()
{
    my $lookup = 'POFILES\s*=([^\n]*)';
    return 1    if ($MakefileData !~ /\n$lookup/);
    print STDOUT "POFILES processing <$1>\n"   if ($verbose);

    my $tmp = $1;

    # make sure these are all gone.
    if ($MakefileData =~ /\n\.po\.gmo:\n/)
    {
        print STDERR "Warning: Found old .po.gmo rules in $printname. New po rules not added\n";
        return 1;
    }

    # Either find the pofiles in the directory (AUTO) or use
    # only the specified po files.
    my $pofiles = "";
    if ($tmp =~ /^\s*AUTO\s*$/)
    {
        opendir (THISDIR, ".");
	next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^#.*#$/);
	$pofiles =  join(" ", grep(/\.po$/, readdir(THISDIR)));
        closedir (THISDIR);
        print STDOUT "pofiles found = $pofiles\n"   if ($verbose);
    }
    else
    {
        $tmp =~ s/\034/ /g;
        $pofiles = $tmp;
    }
    return 1    if (!$pofiles);        # Nothing to do

    handle_POFILES($pofiles, $kdelang);

    return 0;
}

sub helper_LOCALINSTALL($)
{
  my $lookup = "\n" . $_[0] . ":";
  if ($MakefileData =~ /($lookup)/) {

    my $install = $MakefileData;
    $install =~ s/\n/\035/g;
    $install =~ s/.*\035$_[0]:[^\035]*\035//;
    my $emptyline = 0;
    while (! $emptyline) {
      if ($install =~ /([^\035]*)\035(.*)/) {
	local $line = $1;
	$install = $2;
	if ($line =~ /^\s*$/ || $line !~ /^\t/) {
	  $emptyline = 1;
	} else {
	  replaceDestDir($line);
	}
      } else {
	$emptyline = 1;
      }
    }
  }

}

sub tag_LOCALINSTALL ()
{
  helper_LOCALINSTALL('install-exec-local');
  helper_LOCALINSTALL('install-data-local');
  helper_LOCALINSTALL('uninstall-local');

  return 0;
}

sub replaceDestDir($) {
  local $line = $_[0];

  if ($line =~ /^\s*\$\(mkinstalldirs\)/ || $line =~ /^\s*\$\(INSTALL\S*\)/
      || $line =~ /^\s*(-?rm.*) \S*$/)
  {
    $line =~ s/^(.*) ([^\s]*)\s*$/$1 \$(DESTDIR)$2/;
  }

  if ($line ne $_[0]) {
    $_[0] = quotemeta $_[0];
    substituteLine($_[0], $line);
  }
}
#-----------------------------------------------------------------------------

# Returns 0 if the line was processed - 1 otherwise.
# Errors are logged in the global $errorflags
sub tag_DOCFILES ()
{
    my $lookup = 'KDE_DOCS\s*=\s*([^\n]*)';
    return 1    if ($MakefileData !~ /\n$lookup/);
    print STDOUT "KDE_DOCS processing <$1>\n"   if ($verbose);

    tag_SUBDIRS();

    my $tmp = $1;

    # Either find the files in the directory (AUTO) or use
    # only the specified po files.
    my $files = "";
    my $appname = $tmp;
    $appname =~ s/^(\S*)\s*.*$/$1/;
    if ($appname =~ /AUTO/) {
      $appname = basename($makefileDir);
    }

    if ($tmp !~ / - /)
    {
        opendir (THISDIR, ".");
	foreach $entry (readdir(THISDIR)) {
	  next if ($entry eq "CVS" || $entry =~ /^\./  || $entry =~ /^Makefile/ || $entry =~ /~$/ || $entry =~ /^#.*#$/);
	  next if (! -f $entry);
	  $files .= "$entry ";
	}
        closedir (THISDIR);
        print STDOUT "docfiles found = $files\n"   if ($verbose);
    }
    else
    {
        $tmp =~ s/\034/ /g;
	$tmp =~ s/^\S*\s*-\s*//;
        $files = $tmp;
    }
    return 1    if (!$files);        # Nothing to do

    $target_adds{"install-data-am"} .= "install-nls-\@USE_NLS\@ ";
    $target_adds{"uninstall"} .= "uninstall-nls ";

    $tmp = "install-nls-no:\n";
    $tmp .= "install-nls-yes:\n";
    $tmp .= "\t\$(mkinstalldirs) \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname\n";
    $tmp .= "\t\@for base in $files; do \\\n";
    $tmp .= "\t  echo \$(INSTALL_DATA) \$\$base \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$base ;\\\n";
    $tmp .= "\t  \$(INSTALL_DATA) \$(srcdir)/\$\$base \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$base ;\\\n";
    $tmp .= "\tdone\n";
    $tmp .= "\n";
    $tmp .= "uninstall-nls:\n";
    $tmp .= "\tfor base in $files; do \\\n";
    $tmp .= "\t  rm -f \$(DESTDIR)\$(kde_htmldir)/$kdelang/$appname/\$\$base ;\\\n";
    $tmp .= "\tdone\n\n";
    appendLines ($tmp);

    $target_adds{"distdir"} .= "distdir-nls ";

    $tmp = "distdir-nls:\n";
    $tmp .= "\tfor file in $files; do \\\n";
    $tmp .= "\t  cp \$(srcdir)/\$\$file \$(distdir); \\\n";
    $tmp .= "\tdone\n";

    appendLines ($tmp);

    return 0;
}

sub tag_LOCALINSTALL ()
{
  helper_LOCALINSTALL('install-exec-local');
  helper_LOCALINSTALL('install-data-local');
  helper_LOCALINSTALL('uninstall-local');

  return 0;
}

#-----------------------------------------------------------------------------
# Find headers in any of the source directories specified previously, that
# are candidates for "moc-ing".
sub findMocCandidates ()
{
    my @list = ();
    foreach $dir (@headerdirs)
    {
        chdir ($dir);
        @list = `grep -l '^.*Q_OBJECT' $hExt 2> /dev/null`;
        chdir ($makefileDir);

        # The assoc array of root of headerfile and header filename
        foreach $hFile (@list)
        {
            chomp ($hFile);
            $hFile =~ /(.*)\.[^\.]*$/;          # Find name minus extension
            if ($mocFiles{$1})
            {
                print STDERR "Warning: Multiple header files found for $1\n";
                next;                           # Use the first one
            }
            $mocFiles{$1} = "$dir\035$hFile";   # Add relative dir
        }
    }

    if (!%mocFiles)
    {
        print STDERR "Error: No moc-able header's found but METASOURCES in $printname \n";
        $errorflag = 1;
        return 1;
    }

    return 0;
}

#-----------------------------------------------------------------------------

# The programmer has specified a moc list. Prune out the moc candidates
# list that we found based on looking at the header files. This generates
# a warning if the programmer gets the list wrong, but this doesn't have
# to be fatal here.
sub pruneMocCandidates ($)
{
    my %prunedMoc = ();
    local @mocList = split(' ', $_[0]);

    foreach $mocname (@mocList)
    {
        $mocname =~ s/\.moc$//;
        if ($mocFiles{$mocname})
        {
            $prunedMoc{$mocname} = $mocFiles{$mocname};
        }
        else
        {
            my $print = $makefileDir;
            $print =~ s/^\Q$topdir\E\\//;
            # They specified a moc file but we can't find a header that
            # will generate this moc file. That's possible fatal!
            print STDERR "Warning: No moc-able header file for $print/$mocname\n";
        }
    }

    undef %mocFiles;
    %mocFiles = %prunedMoc;
}

#-----------------------------------------------------------------------------

# Finds the cpp files (If they exist).
# The cpp files get appended to the header file separated by \035
sub checkMocCandidates ()
{
    my @cppFiles = ();

    foreach $mocFile (keys (%mocFiles))
    {
        # Find corresponding c++ files that includes the moc file
        @cppFiles =
            `grep -l "^#include[ ]*.$mocFile\.moc." $cppExt 2> /dev/null`;

        if (@cppFiles == 1)
        {
            chomp $cppFiles[0];
            $mocFiles{$mocFile} .= "\035" . $cppFiles[0];
	    push(@deped, $mocFile);
            next;
        }

        if (@cppFiles == 0)
        {
            push (@newObs, $mocFile);           # Produce new object file
            next    if ($haveAutomocTag);       # This is expected...
            # But this is an error we can deal with - let them know
            print STDERR
                "Warning: No c++ file that includes $mocFile.moc\n";
            next;
        }
        else
        {
            # We can't decide which file to use, so it's fatal. Although as a
            # guess we could use the mocFile.cpp file if it's in the list???
            print STDERR
                "Error: Multiple c++ files that include $mocFile.moc\n";
            print STDERR "\t",join ("\t", @cppFiles),"\n";
            $errorflag = 1;
            delete $mocFiles{$mocFile};
            # Let's continue and see what happens - They have been told!
        }
    }
}

#-----------------------------------------------------------------------------

# Add the rules for generating moc source from header files
# For Automoc output *.moc.cpp but normally we'll output *.moc
# (We must compile *.moc.cpp separately. *.moc files are included
# in the appropriate *.cpp file by the programmer)
sub addMocRules ()
{
    my $cppFile;
    my $hFile;
    my $cleanMoc = "";

    foreach $mocFile (keys (%mocFiles))
    {
        undef $cppFile;
        ($dir, $hFile, $cppFile) =  split ("\035", $mocFiles{$mocFile}, 3);
        $dir =~ s#^\.#\$(srcdir)#;
        if (defined ($cppFile))
        {
            appendLines ("\$(srcdir)/$cppFile: $mocFile.moc\n$mocFile.moc: $dir/$hFile\n\t\$(MOC) $dir/$hFile -o $mocFile.moc\n");
            $cleanMoc .= " $mocFile.moc";
        }
        else
        {
            appendLines ("$mocFile$mocExt: $dir/$hFile\n\t\$(MOC) $dir/$hFile -o $mocFile$mocExt\n");
            $cleanMoc .= " $mocFile$mocExt";
        }
    }
	
    if ($cleanMoc) {
      # Always add dist clean tag
      # Add extra *.moc.cpp files created for USE_AUTOMOC because they
      # aren't included in the normal *.moc clean rules.
      appendLines ("$cleantarget-metasources:\n\t-rm -f $cleanMoc\n");
      $target_adds{"$cleantarget-am"} .= "$cleantarget-metasources ";
    }
  }

#-----------------------------------------------------------------------------

sub updateMakefile ()
{
    open (FILEOUT, "> $makefile")
                        || die "Could not create $makefile: $!\n";

    print FILEOUT "\# $progId - " . '$Revision$ '  . "\n";
    $MakefileData =~ s/\034/\\\n/g;    # Restore continuation lines
    print FILEOUT $MakefileData;
    close FILEOUT;
}

#-----------------------------------------------------------------------------

# The given line needs to be removed from the makefile
# Do this by adding the special "removed line" comment at the line start.
sub removeLine ($$)
{
    my ($lookup, $old) = @_;

    $old =~ s/\034/\\\n#>- /g;          # Fix continuation lines
    $MakefileData =~ s/\n$lookup/\n#>\- $old/;
}

#-----------------------------------------------------------------------------

# Replaces the old line with the new line
# old line(s) are retained but tagged as removed. The new line(s) have the
# "added" tag placed before it.
sub substituteLine ($$)
{
    my ($lookup, $new) = @_;

    if ($MakefileData =~ /\n($lookup)/) {
      $old = $1;
      $old =~ s/\034/\\\n#>\- /g;         # Fix continuation lines
      $new =~ s/\034/\\\n/g;
      my $newCount = 1;
      $newCount++  while ($new =~ /\n/g);

      $MakefileData =~ s/\n$lookup/\n#>- $old\n#>\+ $newCount\n$new/;
    } else {
      print STDERR "Warning: substitution of \"$lookup\" in $printname failed\n";
    }
}

#-----------------------------------------------------------------------------

# Slap new lines on the back of the file.
sub appendLines ($)
{
    my ($new) = @_;

    $new =~ s/\034/\\\n/g;        # Fix continuation lines
    my $newCount = 1;
    $newCount++  while ($new =~ /\n/g);

    $MakefileData .= "\n#>\+ $newCount\n$new";
}

#-----------------------------------------------------------------------------

# Restore the Makefile.in to the state it was before we fiddled with it
sub restoreMakefile ()
{
    $MakefileData =~ s/# $progId[^\n\034]*[\n\034]*//g;
    # Restore removed lines
    $MakefileData =~ s/([\n\034])#>\- /$1/g;
    # Remove added lines
    while ($MakefileData =~ /[\n\034]#>\+ ([^\n\034]*)/)
    {
        my $newCount = $1;
        my $removeLines = "";
        while ($newCount--) {
            $removeLines .= "[^\n\034]*([\n\034]|)";
        }
        $MakefileData =~ s/[\n\034]#>\+.*[\n\034]$removeLines/\n/;
    }
}

#-----------------------------------------------------------------------------
