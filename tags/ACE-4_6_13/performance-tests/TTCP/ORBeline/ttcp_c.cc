/* This file is automatically generated by Orbeline.         */
/* Do not modify this file.                                  */
/* Orbeline (c) is copyrighted by PostModern Computing, Inc. */

#include <ttcp_c.hh>

const CORBA::TypeInfo ttcp_sequence::_class_info("ttcp_sequence",
		&ttcp_sequence::_reader,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *ttcp_sequence::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *ttcp_sequence::_type_info() const
{
	return &_class_info;
}
void *ttcp_sequence::_safe_narrow(const CORBA::TypeInfo *info) const
{
	if (&_class_info == info)
		return (void *) this;
	void *ret = NULL;
	return ret;
}
ttcp_sequence *ttcp_sequence::_narrow(const CORBA::Object *obj)
{
	void *ptr = obj->_safe_narrow(&_class_info);
	return (ttcp_sequence *) ptr;
}
ttcp_sequence *ttcp_sequence::_bind(CORBA::Environment &_env, const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *opt)
{
	_env.clear_exception();
	ttcp_sequence *_impl;
	CORBA::Object *_obj = _implementation("ttcp_sequence", _object_name);
	if (!_obj) {
		_impl = new ttcp_sequence(_object_name);
#if defined(_MSC_BUG)
		_impl->Object::_bind("ttcp_sequence", _env, _object_name, _host_name, opt);
#else
		_impl->CORBA::Object::_bind("ttcp_sequence", _env, _object_name, _host_name, opt);
#endif
		if (_env.check_exception()) {
			delete _impl;
			return NULL;
		}
	}
	else
		_impl = ttcp_sequence::_narrow(_obj);
	return _impl;
}

#if !defined(_IMPLEMENT_SEQUENCE_CORBA__Char_ttcp_sequence__) && defined(_DECLARE_SEQUENCE_CORBA__Char_ttcp_sequence___ttcp_idl)
#define _IMPLEMENT_SEQUENCE_CORBA__Char_ttcp_sequence__
IMPLEMENT_PRIMITIVE_SEQUENCE(CORBA__Char,CORBA::Char,ttcp_sequence::)
#endif





void ttcp_sequence::send(const ttcp_sequence::my_sequence& ttcp_rec, CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		send(ttcp_rec);
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_sequence", _ttcp_sequence_M_send,_env);
	if (_env.check_exception())
		return;
	_strm->putSequence(ttcp_rec, CORBA::MarshalStream::ARG_IN);
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			send(ttcp_rec, _env);
		return;
	}
	_strm->flush(_env);
	return;
}




void ttcp_sequence::send_hack(const CORBA::String& ttcp_string, CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		send_hack(ttcp_string);
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_sequence", _ttcp_sequence_M_send_hack,_env);
	if (_env.check_exception())
		return;
	_strm->putString(ttcp_string, CORBA::MarshalStream::ARG_IN);
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			send_hack(ttcp_string, _env);
		return;
	}
	_strm->flush(_env);
	return;
}




void ttcp_sequence::start_timer(CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		start_timer();
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_sequence", _ttcp_sequence_M_start_timer,_env);
	if (_env.check_exception())
		return;
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			start_timer(_env);
		return;
	}
	_strm->flush(_env);
	return;
}




void ttcp_sequence::stop_timer(CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		stop_timer();
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_sequence", _ttcp_sequence_M_stop_timer,_env);
	if (_env.check_exception())
		return;
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			stop_timer(_env);
		return;
	}
	_strm->flush(_env);
	return;
}

const CORBA::TypeInfo ttcp_string::_class_info("ttcp_string",
		&ttcp_string::_reader,
		CORBA::Object::_desc(),
		0);
const CORBA::TypeInfo *ttcp_string::_desc()
{
	return &_class_info;
}
const CORBA::TypeInfo *ttcp_string::_type_info() const
{
	return &_class_info;
}
void *ttcp_string::_safe_narrow(const CORBA::TypeInfo *info) const
{
	if (&_class_info == info)
		return (void *) this;
	void *ret = NULL;
	return ret;
}
ttcp_string *ttcp_string::_narrow(const CORBA::Object *obj)
{
	void *ptr = obj->_safe_narrow(&_class_info);
	return (ttcp_string *) ptr;
}
ttcp_string *ttcp_string::_bind(CORBA::Environment &_env, const char *_object_name,
		const char *_host_name, const CORBA::BindOptions *opt)
{
	_env.clear_exception();
	ttcp_string *_impl;
	CORBA::Object *_obj = _implementation("ttcp_string", _object_name);
	if (!_obj) {
		_impl = new ttcp_string(_object_name);
#if defined(_MSC_BUG)
		_impl->Object::_bind("ttcp_string", _env, _object_name, _host_name, opt);
#else
		_impl->CORBA::Object::_bind("ttcp_string", _env, _object_name, _host_name, opt);
#endif
		if (_env.check_exception()) {
			delete _impl;
			return NULL;
		}
	}
	else
		_impl = ttcp_string::_narrow(_obj);
	return _impl;
}



void ttcp_string::send(const CORBA::String& ttcp_string, CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		send(ttcp_string);
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_string", _ttcp_string_M_send,_env);
	if (_env.check_exception())
		return;
	_strm->putString(ttcp_string, CORBA::MarshalStream::ARG_IN);
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			send(ttcp_string, _env);
		return;
	}
	_strm->flush(_env);
	return;
}




void ttcp_string::send_hack(const CORBA::String& ttcp_string, CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		send_hack(ttcp_string);
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_string", _ttcp_string_M_send_hack,_env);
	if (_env.check_exception())
		return;
	_strm->putString(ttcp_string, CORBA::MarshalStream::ARG_IN);
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			send_hack(ttcp_string, _env);
		return;
	}
	_strm->flush(_env);
	return;
}




void ttcp_string::start_timer(CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		start_timer();
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_string", _ttcp_string_M_start_timer,_env);
	if (_env.check_exception())
		return;
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			start_timer(_env);
		return;
	}
	_strm->flush(_env);
	return;
}




void ttcp_string::stop_timer(CORBA::Environment& _env) 
{
	_env.clear_exception();
	if (_is_local()) {
		stop_timer();
		return;
	}
	CORBA::MarshalStream *_strm = _create_oneway_request(
			"ttcp_string", _ttcp_string_M_stop_timer,_env);
	if (_env.check_exception())
		return;
	_send_oneway(_env);
	if (_env.check_exception()) {
		if (CORBA::StExcep::TRANSIENT::_cast(_env.exception_value()) != NULL)
			stop_timer(_env);
		return;
	}
	_strm->flush(_env);
	return;
}


