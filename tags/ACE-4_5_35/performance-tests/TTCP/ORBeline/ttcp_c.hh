#ifndef _ttcp_c_hh
#define _ttcp_c_hh

/* This file is automatically generated by Orbeline.         */
/* Do not modify this file.                                  */
/* Orbeline (c) is copyrighted by PostModern Computing, Inc. */

#include <corba.h>
#include <arrmac.h>
#include <seqmac.h>



class ttcp_sequence: public virtual CORBA::Object
{
    private:
	static const CORBA::TypeInfo _class_info;
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo *) const;
	static CORBA::Object *_reader(NCistream& strm) {
		return new ttcp_sequence(strm);
	}
    protected:
#if defined(_MSC_BUG)
	ttcp_sequence(const char *obj_name = NULL) :Object(obj_name) {}
	ttcp_sequence(NCistream& strm) :Object(strm) {}
#else
	ttcp_sequence(const char *obj_name = NULL) :CORBA::Object(obj_name) {}
	ttcp_sequence(NCistream& strm) :CORBA::Object(strm) {}
#endif
	virtual ~ttcp_sequence() {}
    public:
	enum _ttcp_sequence_Methods {
		_ttcp_sequence_M_send = 0,
		_ttcp_sequence_M_send_hack,
		_ttcp_sequence_M_start_timer,
		_ttcp_sequence_M_stop_timer
	};
	static ttcp_sequence *_narrow(const CORBA::Object *obj);
	static ttcp_sequence *_bind(CORBA::Environment &_env, const char *object_name = NULL,
		const char *host_name = NULL, const CORBA::BindOptions* opt = NULL);
	static ttcp_sequence *_bind(const char *object_name = NULL,
		const char *host_name = NULL, const CORBA::BindOptions* opt = NULL) {
		CORBA::Environment env;
		return _bind(env, object_name, host_name, opt);
	}
	virtual const char *_interface_name() const { return "ttcp_sequence"; }

#ifndef _DECLARE_SEQUENCE_CORBA__Char_ttcp_sequence__
#define _DECLARE_SEQUENCE_CORBA__Char_ttcp_sequence__
#define _DECLARE_SEQUENCE_CORBA__Char_ttcp_sequence___ttcp_idl
DECLARE_PRIMITIVE_SEQUENCE(CORBA__Char,CORBA::Char);
#endif

	typedef ttcp_sequence::IDLSequence(CORBA__Char) my_sequence;
	
	
	
	
	void send(const ttcp_sequence::my_sequence& ttcp_rec, CORBA::Environment& _env);
	
	virtual void send(const ttcp_sequence::my_sequence& ttcp_rec) {
		send(ttcp_rec, _environment());
	}
	
	
	
	
	void send_hack(const CORBA::String& ttcp_string, CORBA::Environment& _env);
	
	virtual void send_hack(const CORBA::String& ttcp_string) {
		send_hack(ttcp_string, _environment());
	}
	
	
	
	
	void start_timer(CORBA::Environment& _env);
	
	virtual void start_timer() {
		start_timer(_environment());
	}
	
	
	
	
	void stop_timer(CORBA::Environment& _env);
	
	virtual void stop_timer() {
		stop_timer(_environment());
	}
	
	
};
typedef ttcp_sequence* ttcp_sequenceRef;




class ttcp_string: public virtual CORBA::Object
{
    private:
	static const CORBA::TypeInfo _class_info;
    public:
	static const CORBA::TypeInfo *_desc();
	virtual const CORBA::TypeInfo *_type_info() const;
	virtual void *_safe_narrow(const CORBA::TypeInfo *) const;
	static CORBA::Object *_reader(NCistream& strm) {
		return new ttcp_string(strm);
	}
    protected:
#if defined(_MSC_BUG)
	ttcp_string(const char *obj_name = NULL) :Object(obj_name) {}
	ttcp_string(NCistream& strm) :Object(strm) {}
#else
	ttcp_string(const char *obj_name = NULL) :CORBA::Object(obj_name) {}
	ttcp_string(NCistream& strm) :CORBA::Object(strm) {}
#endif
	virtual ~ttcp_string() {}
    public:
	enum _ttcp_string_Methods {
		_ttcp_string_M_send = 0,
		_ttcp_string_M_send_hack,
		_ttcp_string_M_start_timer,
		_ttcp_string_M_stop_timer
	};
	static ttcp_string *_narrow(const CORBA::Object *obj);
	static ttcp_string *_bind(CORBA::Environment &_env, const char *object_name = NULL,
		const char *host_name = NULL, const CORBA::BindOptions* opt = NULL);
	static ttcp_string *_bind(const char *object_name = NULL,
		const char *host_name = NULL, const CORBA::BindOptions* opt = NULL) {
		CORBA::Environment env;
		return _bind(env, object_name, host_name, opt);
	}
	virtual const char *_interface_name() const { return "ttcp_string"; }

	
	
	void send(const CORBA::String& ttcp_string, CORBA::Environment& _env);
	
	virtual void send(const CORBA::String& ttcp_string) {
		send(ttcp_string, _environment());
	}
	
	
	
	
	void send_hack(const CORBA::String& ttcp_string, CORBA::Environment& _env);
	
	virtual void send_hack(const CORBA::String& ttcp_string) {
		send_hack(ttcp_string, _environment());
	}
	
	
	
	
	void start_timer(CORBA::Environment& _env);
	
	virtual void start_timer() {
		start_timer(_environment());
	}
	
	
	
	
	void stop_timer(CORBA::Environment& _env);
	
	virtual void stop_timer() {
		stop_timer(_environment());
	}
	
	
};
typedef ttcp_string* ttcp_stringRef;



#endif

