	 
1.	#include "ace/Acceptor.h"
2.	#include "ace/SOCK_Acceptor.h"
3.	#include "ace/Reactor.h"
4.	#include "ace/Thread.h"
	
	
5.	ACE_Reactor * g_reactor;
	
6.	static sig_atomic_t finished = 0;
		
	
7.	extern "C" void handler (int) { finished = 1; }
8.	static void *thread_run(void *);
	// ----------------------------------------
	
9.	class Logging_Handler : public ACE_Svc_Handler<ACE_SOCK_STREAM, ACE_NULL_SYNCH>
	{
	
	public:
	
10.	  Logging_Handler (void)
		{
11.		  thread_reactor = NULL;
		}
	
12.	  ~Logging_Handler (void)
		{
13.		  cout << "in destructor" <<endl;
14.		  delete thread_reactor;
		}
	
15.	   virtual void destroy (void)
		{ 
16.		  cout << " in destroy" <<endl;
17.		  g_reactor->cancel_timer (this);
18.		  this->peer ().close ();
19.		  delete this;
		}
	
20.	  static void *run_thread(Logging_Handler *this_)
	  	{
21.	      	  cout << "run_thread in " << getpid() << endl;
	
22.		  this_->thread_reactor = new ACE_Reactor;
		
23.		  if (this_->thread_reactor->register_handler(this_, ACE_Event_Handler::READ_MASK) == -1)
24.			  ACE_ERROR_RETURN ((LM_ERROR,"can'(%P|%t) t register with reactor\n"), -1);
25.		  else if (this_->thread_reactor->schedule_timer (this_, (const void *)this_, ACE_Time_Value (2), ACE_Time_Value (2)) == -1)
26.			  ACE_ERROR_RETURN ((LM_ERROR, "can'(%P|%t) t register with reactor\n"), -1);
27.		  else
28.		      	  ACE_DEBUG ((LM_DEBUG, "(%P|%t) connected with client \n"));
		
29.		  while(!finished)
30.		  	this_->thread_reactor->handle_events();
		  	
		} 
	
31.	 virtual int open (void *)
		{
32.	          ACE_Thread::spawn(&Logging_Handler::run_thread,this);
33.		  return 0;
		}
	
34.	  virtual int close (u_long)
		{
	
35.	          if (this->thread_reactor->remove_handler(this,ACE_Event_Handler::READ_MASK | ACE_Event_Handler::DONT_CALL) == -1)
36.		         ACE_ERROR_RETURN ((LM_ERROR, "can'(%P|%t) t remove service from reactor\n"), -1);
37.		  this->destroy ();
38.		  return 0;
		}
	
	protected:
	
39.	  virtual int handle_input (ACE_HANDLE)
	        {
40.	          char buf[128];
41.	          memset(buf,0,sizeof(buf));
	        
42.		  cout << "handle_input in " << getpid() << endl;
43.	          switch( this->peer().recv(buf,sizeof buf) )
	          {
44.	          case -1:
45.	            ACE_ERROR_RETURN ((LM_ERROR, "(%P|%t) %p bad read\n", "client logger"), -1);
46.	          case 0:
47.	            ACE_ERROR_RETURN ((LM_ERROR, "(%P|%t) closing log daemon (fd = %d)\n", this->get_handle ()), -1);
48.	          default:
49.		    cout << "Data from client " << buf << endl;
	            // ACE_DEBUG ((LM_DEBUG, "(%P|%t) from client: %s",buf));
	          }
	          
50.	          return 0;
	        }
	
51.	  virtual int handle_timeout (const ACE_Time_Value &tv, const void *arg)
		{
52.		  ACE_ASSERT (arg == this);
		  // ACE_DEBUG ((LM_DEBUG, "(%P|%t) handling timeout from this = %u\n", this));
53.		  cout << "Timout in " << getpid() << endl;
54.		  return 0;
		}
	
	private:
55.	  ACE_Reactor *thread_reactor;
56.	  char peer_name_[MAXHOSTNAMELEN + 1];
	  
	};
	
	
57.	typedef ACE_Acceptor <Logging_Handler, ACE_SOCK_ACCEPTOR> Logging_Acceptor;
	
	
58.	static const u_short PORT = ACE_DEFAULT_SERVER_PORT;
	
59.	int main (int argc, char *argv[])
	{
60.	  g_reactor = new ACE_Reactor;
	
61.	  cout << "main is " << getpid() << endl;
	
	  // Acceptor factory.
62.	  Logging_Acceptor peer_acceptor;
	
63.	  if (peer_acceptor.open (ACE_INET_Addr (PORT)) == -1)
64.	    ACE_ERROR_RETURN ((LM_ERROR, "%p\n", "open"), -1);
	
65.	  else if (g_reactor->register_handler (&peer_acceptor, ACE_Event_Handler::READ_MASK) == -1)
66.	    ACE_ERROR_RETURN ((LM_ERROR, "registering service with ACE_Reactor\n"), -1);
	
67.	  ACE_Sig_Action sa ((ACE_SignalHandler) handler, SIGINT);
	
	  // Run forever, performing logging service.
	
68.	  ACE_DEBUG ((LM_DEBUG, "(%P|%t) starting up server logging daemon\n"));
	
	  // Perform logging service until QUIT_HANDLER receives SIGINT.
69.	  while ( !finished )
70.	    g_reactor->handle_events ();
	
71.	  ACE_DEBUG ((LM_DEBUG, "(%P|%t) shutting down server logging daemon\n"));
	
72.	  return 0;
	}
