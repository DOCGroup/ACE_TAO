/* -*- C++ -*- */
// $Id$

// ============================================================================
//
// = LIBRARY
//    TAO
//
// = FILENAME
//   POA_CORBA.h
//
//   This file is created by merging the PolicyS.h,
//   DomainS.h and InterfaceS.h files which
//   have been removed.
//
// = AUTHOR
//
// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html
//
//
// Modified by Aniruddha Gokhale.
//
// ============================================================================

#ifndef TAO_IDL_POA_CORBA_H
#define TAO_IDL_POA_CORBA_H
#include "ace/pre.h"

#include "tao/corbafwd.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "Servant_Base.h"
#include "ThruPOA_Object_Proxy_Impl.h"
#include "Direct_Object_Proxy_Impl.h"
#include "tao/ORB_Core.h"
#include "tao/PolicyC.h"
#include "tao/DomainC.h"
#if (TAO_HAS_INTERFACE_REPOSITORY == 1)
#include "tao/InterfaceC.h"
#endif /* TAO_HAS_INTERFACE_REPOSITORY == 1 */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

class IR_InterfaceDef;
class POA_CORBA_DomainManager;
class POA_CORBA_ConstructionPolicy;

class TAO_PortableServer_Export  POA_CORBA
{
public:

  // ****************************************************************

  class Policy;
  typedef Policy *Policy_ptr;
  class TAO_PortableServer_Export Policy :  public virtual PortableServer::ServantBase
  {
  protected:
    Policy (void);

  public:
    Policy (const Policy& rhs);
    virtual ~Policy (void);


    virtual CORBA::Boolean _is_a (
                                  const char* logical_type_id,
                                  CORBA::Environment &ACE_TRY_ENV =
                                  TAO_default_environment ()
                                  );

    virtual void* _downcast (
                             const char* logical_type_id
                             );

    static void _is_a_skel (
                            TAO_ServerRequest &req,
                            void *obj,
                            void *context,
                            CORBA::Environment &ACE_TRY_ENV =
                            TAO_default_environment ()
                            );

    static void _non_existent_skel (
                                    TAO_ServerRequest &req,
                                    void *obj,
                                    void *context,
                                    CORBA::Environment &ACE_TRY_ENV =
                                    TAO_default_environment ()
                                    );

    virtual void _dispatch (
                            TAO_ServerRequest &_tao_req,
                            void *_tao_context,
                            CORBA::Environment &ACE_TRY_ENV =
                            TAO_default_environment ()
                            );

    ::CORBA_Policy *_this (
                           CORBA::Environment &ACE_TRY_ENV =
                           TAO_default_environment ()
                           );

    virtual const char* _interface_repository_id (void) const;

    virtual CORBA::PolicyType policy_type (
                                           CORBA::Environment &ACE_TRY_ENV =
                                           TAO_default_environment ()
                                           )
      ACE_THROW_SPEC ((
                       CORBA::SystemException
                       )) = 0;

    static void _get_policy_type_skel (
                                       TAO_ServerRequest &_tao_req,
                                       void *_tao_obj,
                                       void *_tao_context,
                                       CORBA::Environment &ACE_TRY_ENV =
                                       TAO_default_environment ()
                                       );

    virtual CORBA_Policy_ptr copy (
                                   CORBA::Environment &ACE_TRY_ENV =
                                   TAO_default_environment ()
                                   )
      ACE_THROW_SPEC ((
                       CORBA::SystemException
                       )) = 0;

    static void copy_skel (
                           TAO_ServerRequest &_tao_req,
                           void *_tao_obj,
                           void *_tao_context,
                           CORBA::Environment &ACE_TRY_ENV =
                           TAO_default_environment ()
                           );

    virtual void destroy (
                          CORBA::Environment &ACE_TRY_ENV =
                          TAO_default_environment ()
                          )
      ACE_THROW_SPEC ((
                       CORBA::SystemException
                       )) = 0;

    static void destroy_skel (
                              TAO_ServerRequest &_tao_req,
                              void *_tao_obj,
                              void *_tao_context,
                              CORBA::Environment &ACE_TRY_ENV =
                              TAO_default_environment ()
                              );


  };


  class TAO_PortableServer_Export _tao_thru_poa_collocated_Policy   : public virtual ::CORBA_Policy
  {
  public:
    _tao_thru_poa_collocated_Policy (
                                           TAO_Stub *stub
                                           );
    virtual CORBA::Boolean _is_a(
                                 const CORBA::Char *logical_type_id,
                                 CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                                 );

    virtual CORBA::Boolean _non_existent(
                                         CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
                                         );

    virtual CORBA::PolicyType policy_type (
                                           CORBA::Environment &ACE_TRY_ENV =
                                           TAO_default_environment ()
                                           )
      ACE_THROW_SPEC ((
                       CORBA::SystemException
                       ));

    virtual CORBA_Policy_ptr copy (
                                   CORBA::Environment &ACE_TRY_ENV =
                                   TAO_default_environment ()
                                   )
      ACE_THROW_SPEC ((
                       CORBA::SystemException
                       ));

    virtual void destroy (
                          CORBA::Environment &ACE_TRY_ENV =
                          TAO_default_environment ()
                          )
      ACE_THROW_SPEC ((
                       CORBA::SystemException
                       ));

  };

  // ****************************************************************

  typedef POA_CORBA_DomainManager DomainManager;
  typedef POA_CORBA_ConstructionPolicy ConstructionPolicy;

  // ****************************************************************

#if (TAO_HAS_INTERFACE_REPOSITORY == 1)

  class IRObject;
  typedef IRObject *IRObject_ptr;
  // Forward Classes Declaration
  class _TAO_IRObject_ThruPOA_Proxy_Impl;
  class _TAO_IRObject_Strategized_Proxy_Broker;
  
  class IRObject : public virtual PortableServer::ServantBase
  {
  protected:
    IRObject (void);

  public:
    IRObject (const IRObject& rhs);
    virtual ~IRObject (void);

    virtual CORBA::Boolean _is_a (
        const char* logical_type_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    virtual void* _downcast (
        const char* logical_type_id
      );

    static void _is_a_skel (
        TAO_ServerRequest &req,
        void *obj,
        void *context,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    static void _non_existent_skel (
        TAO_ServerRequest &req,
        void *obj,
        void *context,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    virtual void _dispatch (
        TAO_ServerRequest &_tao_req,
        void *_tao_context,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    ::CORBA::IRObject *_this (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    virtual const char* _interface_repository_id (void) const;

    virtual IR::DefinitionKind def_kind (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    static void _get_def_kind_skel (
        TAO_ServerRequest &_tao_req,
        void *_tao_obj,
        void *_tao_context,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );

    virtual void destroy (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    static void destroy_skel (
        TAO_ServerRequest &_tao_req,
        void *_tao_obj,
        void *_tao_context,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
  };

  ///////////////////////////////////////////////////////////////////////
  //               Strategized Proxy Broker Declaration 
  //

  class _TAO_IRObject_Strategized_Proxy_Broker 
    : public virtual _TAO_IRObject_Proxy_Broker
  {
  public: 
    _TAO_IRObject_Strategized_Proxy_Broker (void);
  
    virtual ~_TAO_IRObject_Strategized_Proxy_Broker (void);
  
    virtual _TAO_IRObject_Proxy_Impl &select_proxy (
      CORBA_IRObject *object,
      CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
    );

  private:

  // Helper methods that takes care to create the proxy
  // as soon as their use is necessary.
    void create_proxy (
      TAO_ORB_Core::TAO_Collocation_Strategies strategy,
      CORBA::Environment &ACE_TRY_ENV
    );

  private:
  
    // Caches the proxy implementations. The proxy implementation
    // are totally stateless, and those can be shared by all the
    // instances of a given IDL interface type.
    _TAO_IRObject_Proxy_Impl *proxy_cache_[TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM];
  
    ACE_SYNCH_MUTEX mutex_;
  // This funxtion is used to get an handle to the unique instance
  // of the Strategized Proxy Broker that is available for a given
  // interface.

  public:
    static _TAO_IRObject_Strategized_Proxy_Broker *the_TAO_IRObject_Strategized_Proxy_Broker (void);
  };


  //
  //            End Strategized Proxy Broker Declaration 
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                    ThruPOA  Impl. Declaration
  //

  class _TAO_IRObject_ThruPOA_Proxy_Impl 
    : public virtual _TAO_IRObject_Proxy_Impl,
      public virtual TAO_ThruPOA_Object_Proxy_Impl
  {
  public:
    _TAO_IRObject_ThruPOA_Proxy_Impl (void);
  
    virtual ~_TAO_IRObject_ThruPOA_Proxy_Impl (void);
  
      virtual IR::DefinitionKind def_kind (
        CORBA_Object *_collocated_tao_target_,
        CORBA::Environment &ACE_TRY_ENV
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void destroy (
        CORBA_Object *_collocated_tao_target_,
        CORBA::Environment &ACE_TRY_ENV
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

  };


  //
  //                ThruPOA  Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

#endif /* TAO_HAS_INTERFACE_REPOSITORY == 1 */
};

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#include "ace/post.h"
#endif /* TAO_IDL_POA_CORBA_H */
