/* -*- C++ -*- */
//$Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/InterfaceC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"

#if (TAO_HAS_INTERFACE_REPOSITORY == 1)

#if !defined (__ACE_INLINE__)
#include "tao/InterfaceC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_CORBA_Identifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Identifier (CORBA::tk_alias, sizeof (_oc_CORBA_Identifier), (char *) &_oc_CORBA_Identifier, 0, sizeof (CORBA::Identifier));


static const CORBA::Long _oc_CORBA_ScopedName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5363), ACE_NTOHL (0x6f706564), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ScopedName:1.0
  11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ScopedName (CORBA::tk_alias, sizeof (_oc_CORBA_ScopedName), (char *) &_oc_CORBA_ScopedName, 0, sizeof (CORBA::ScopedName));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_CORBA_ScopedName)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_RepositoryId (CORBA::tk_alias, sizeof (_oc_CORBA_RepositoryId), (char *) &_oc_CORBA_RepositoryId, 0, sizeof (CORBA::RepositoryId));

static const CORBA::Long _oc_CORBA_DefinitionKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
  15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
  24, // member count
  8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
  7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
  13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
  12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
  13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
  13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
  10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
  13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
  11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
  9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
  8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
  13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
  12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
  14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
  11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
  9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
  9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
  12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
  15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
  10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_DefinitionKind (CORBA::tk_enum, sizeof (_oc_CORBA_DefinitionKind), (char *) &_oc_CORBA_DefinitionKind, 0, sizeof (CORBA::DefinitionKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_DefinitionKind, &_tc_TAO_tc_CORBA_DefinitionKind)
TAO_NAMESPACE_END
CORBA_IRObject_ptr CORBA_IRObject::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_IRObject::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IRObject:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_IRObject::_nil ());
  if (is_a == 0)
    return CORBA_IRObject::_nil ();
  return CORBA_IRObject::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_IRObject_ptr CORBA_IRObject::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_IRObject::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer != 0)
    {
      CORBA_IRObject_ptr retv = _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_IRObject_ptr retval = CORBA_IRObject::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_IRObject (stub),
                  CORBA_IRObject::_nil ());

  return retval;
}

CORBA_IRObject_ptr
CORBA_IRObject::_duplicate (CORBA_IRObject_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::DefinitionKind CORBA_IRObject::def_kind (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

 CORBA::DefinitionKind _tao_retval = (CORBA::DefinitionKind)0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""def_kind",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_IRObject::destroy (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      7,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_IRObject::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

static const CORBA::Long _oc_CORBA_IRObject[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4952), ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/IRObject:1.0
  9, ACE_NTOHL (0x49524f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = IRObject
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_IRObject (CORBA::tk_objref, sizeof (_oc_CORBA_IRObject), (char *) &_oc_CORBA_IRObject, 0, sizeof (CORBA_IRObject));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IRObject, &_tc_TAO_tc_CORBA_IRObject)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_VersionSpec[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
  12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_VersionSpec (CORBA::tk_alias, sizeof (_oc_CORBA_VersionSpec), (char *) &_oc_CORBA_VersionSpec, 0, sizeof (CORBA::VersionSpec));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_VersionSpec, &_tc_TAO_tc_CORBA_VersionSpec)
TAO_NAMESPACE_END
CORBA_Contained_ptr CORBA_Contained::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Contained::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Contained:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_Contained::_nil ());
  if (is_a == 0)
    return CORBA_Contained::_nil ();
  return CORBA_Contained::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_Contained_ptr CORBA_Contained::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Contained::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer != 0)
    {
      CORBA_Contained_ptr retv = _TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_Contained_ptr retval = CORBA_Contained::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_Contained (stub),
                  CORBA_Contained::_nil ());

  return retval;
}

CORBA_Contained_ptr
CORBA_Contained::_duplicate (CORBA_Contained_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

char * CORBA_Contained::id (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  char* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""id",
      7,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_Contained::id (
    const char * id,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""id",
      7,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

char * CORBA_Contained::name (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  char* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""name",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_Contained::name (
    const char * name,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""name",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << name)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

char * CORBA_Contained::version (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  char* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""version",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_Contained::version (
    const char * version,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""version",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << version)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_Container_ptr CORBA_Contained::defined_in (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Container_ptr _tao_retval = CORBA_Container::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""defined_in",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

char * CORBA_Contained::absolute_name (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  char* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""absolute_name",
      18,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_Repository_ptr CORBA_Contained::containing_repository (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Repository_ptr _tao_retval = CORBA_Repository::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""containing_repository",
      26,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_Contained_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65642f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  2, // member count
  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  472, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    24, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Contained_Description (CORBA::tk_struct, sizeof (_oc_CORBA_Contained_Description), (char *) &_oc_CORBA_Contained_Description, 0, sizeof (CORBA_Contained::Description));
CORBA::TypeCode_ptr CORBA_Contained::_tc_Description = &_tc_TAO_tc_CORBA_Contained_Description;

CORBA_Contained::Description * CORBA_Contained::describe (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Contained::Description* _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_Contained::Description, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe",
      8,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_Contained::move (
    CORBA_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "move",
      4,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << new_container) &&
          (_tao_out << new_name) &&
          (_tao_out << new_version)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_Contained::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

static const CORBA::Long _oc_CORBA_Contained[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Contained (CORBA::tk_objref, sizeof (_oc_CORBA_Contained), (char *) &_oc_CORBA_Contained, 0, sizeof (CORBA_Contained));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Contained, &_tc_TAO_tc_CORBA_Contained)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_InterfaceDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_InterfaceDef **old = ACE_reinterpret_cast (CORBA_InterfaceDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA_InterfaceDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];

      if (this->release_)
        delete[] old;

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA_InterfaceDef **tmp = ACE_reinterpret_cast (CORBA_InterfaceDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_InterfaceDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void)
  {
    this->_deallocate_buffer ();
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA_InterfaceDef **tmp = ACE_reinterpret_cast (CORBA_InterfaceDef**, this->buffer_);

    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_InterfaceDef::_nil ();
    }
  }
  void
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA_InterfaceDef **tmp = ACE_static_cast (CORBA_InterfaceDef**, target);
    *tmp = CORBA_InterfaceDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq::_upcast (void *src) const
  {
    CORBA_InterfaceDef **tmp = ACE_static_cast (CORBA_InterfaceDef**, src);
    return *tmp;
  }

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_INTERFACEDEFSEQ_CS_)
#define _CORBA_INTERFACEDEFSEQ_CS_

// *************************************************************
// CORBA_InterfaceDefSeq
// *************************************************************

CORBA_InterfaceDefSeq::CORBA_InterfaceDefSeq (void)
{}
CORBA_InterfaceDefSeq::CORBA_InterfaceDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_InterfaceDef,CORBA_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_InterfaceDefSeq::CORBA_InterfaceDefSeq (CORBA::ULong max, CORBA::ULong length, CORBA_InterfaceDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_InterfaceDef,CORBA_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_InterfaceDefSeq::CORBA_InterfaceDefSeq (const CORBA_InterfaceDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_InterfaceDef,CORBA_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_InterfaceDefSeq::~CORBA_InterfaceDefSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_InterfaceDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/InterfaceDefSeq:1.0
  16, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = InterfaceDefSeq
  CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
      13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDefSeq (CORBA::tk_alias, sizeof (_oc_CORBA_InterfaceDefSeq), (char *) &_oc_CORBA_InterfaceDefSeq, 0, sizeof (CORBA_InterfaceDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDefSeq, &_tc_TAO_tc_CORBA_InterfaceDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_ValueDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_ValueDef **old = ACE_reinterpret_cast (CORBA_ValueDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA_ValueDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];

      if (this->release_)
        delete[] old;

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA_ValueDef **tmp = ACE_reinterpret_cast (CORBA_ValueDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_ValueDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (void)
  {
    this->_deallocate_buffer ();
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA_ValueDef **tmp = ACE_reinterpret_cast (CORBA_ValueDef**, this->buffer_);

    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_ValueDef::_nil ();
    }
  }
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA_ValueDef **tmp = ACE_static_cast (CORBA_ValueDef**, target);
    *tmp = CORBA_ValueDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq::_upcast (void *src) const
  {
    CORBA_ValueDef **tmp = ACE_static_cast (CORBA_ValueDef**, src);
    return *tmp;
  }

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_VALUEDEFSEQ_CS_)
#define _CORBA_VALUEDEFSEQ_CS_

// *************************************************************
// CORBA_ValueDefSeq
// *************************************************************

CORBA_ValueDefSeq::CORBA_ValueDefSeq (void)
{}
CORBA_ValueDefSeq::CORBA_ValueDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_ValueDef,CORBA_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ValueDefSeq::CORBA_ValueDefSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ValueDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_ValueDef,CORBA_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ValueDefSeq::CORBA_ValueDefSeq (const CORBA_ValueDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_ValueDef,CORBA_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ValueDefSeq::~CORBA_ValueDefSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ValueDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueDefSeq:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = ValueDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
      9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDefSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ValueDefSeq), (char *) &_oc_CORBA_ValueDefSeq, 0, sizeof (CORBA_ValueDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDefSeq, &_tc_TAO_tc_CORBA_ValueDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_Contained **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_Contained **old = ACE_reinterpret_cast (CORBA_Contained**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA_Contained::_duplicate (old[i]);
        else
          tmp[i] = old[i];

      if (this->release_)
        delete[] old;

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA_Contained **tmp = ACE_reinterpret_cast (CORBA_Contained**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_Contained::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void)
  {
    this->_deallocate_buffer ();
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA_Contained **tmp = ACE_reinterpret_cast (CORBA_Contained**, this->buffer_);

    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_Contained::_nil ();
    }
  }
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA_Contained **tmp = ACE_static_cast (CORBA_Contained**, target);
    *tmp = CORBA_Contained::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq::_upcast (void *src) const
  {
    CORBA_Contained **tmp = ACE_static_cast (CORBA_Contained**, src);
    return *tmp;
  }

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_CONTAINEDSEQ_CS_)
#define _CORBA_CONTAINEDSEQ_CS_

// *************************************************************
// CORBA_ContainedSeq
// *************************************************************

CORBA_ContainedSeq::CORBA_ContainedSeq (void)
{}
CORBA_ContainedSeq::CORBA_ContainedSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_Contained,CORBA_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ContainedSeq::CORBA_ContainedSeq (CORBA::ULong max, CORBA::ULong length, CORBA_Contained_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_Contained,CORBA_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ContainedSeq::CORBA_ContainedSeq (const CORBA_ContainedSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_Contained,CORBA_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ContainedSeq::~CORBA_ContainedSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ContainedSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e656453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContainedSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContainedSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
      10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ContainedSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ContainedSeq), (char *) &_oc_CORBA_ContainedSeq, 0, sizeof (CORBA_ContainedSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContainedSeq, &_tc_TAO_tc_CORBA_ContainedSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_StructMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
  13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
  3, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StructMember (CORBA::tk_struct, sizeof (_oc_CORBA_StructMember), (char *) &_oc_CORBA_StructMember, 0, sizeof (CORBA_StructMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMember, &_tc_TAO_tc_CORBA_StructMember)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_StructMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_StructMember *old = ACE_reinterpret_cast (CORBA_StructMember *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_StructMember *tmp = ACE_reinterpret_cast (CORBA_StructMember *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq::~_TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_STRUCTMEMBERSEQ_CS_)
#define _CORBA_STRUCTMEMBERSEQ_CS_

// *************************************************************
// CORBA_StructMemberSeq
// *************************************************************

CORBA_StructMemberSeq::CORBA_StructMemberSeq (void)
{}
CORBA_StructMemberSeq::CORBA_StructMemberSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_StructMemberSeq::CORBA_StructMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA_StructMember *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_StructMemberSeq::CORBA_StructMemberSeq (const CORBA_StructMemberSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_StructMemberSeq::~CORBA_StructMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_StructMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
  16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
  CORBA::tk_sequence, // typecode kind
  264, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    248, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
      13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
      3, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StructMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_StructMemberSeq), (char *) &_oc_CORBA_StructMemberSeq, 0, sizeof (CORBA_StructMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMemberSeq, &_tc_TAO_tc_CORBA_StructMemberSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_Initializer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
  12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
  1, // member count
  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  340, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
    16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
    CORBA::tk_sequence, // typecode kind
    264, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      248, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
        13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
        3, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Initializer (CORBA::tk_struct, sizeof (_oc_CORBA_Initializer), (char *) &_oc_CORBA_Initializer, 0, sizeof (CORBA_Initializer));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Initializer, &_tc_TAO_tc_CORBA_Initializer)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_Initializer* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_InitializerSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_Initializer *old = ACE_reinterpret_cast (CORBA_Initializer *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_Initializer *tmp = ACE_reinterpret_cast (CORBA_Initializer *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_InitializerSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_InitializerSeq::~_TAO_Unbounded_Sequence_CORBA_InitializerSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_INITIALIZERSEQ_CS_)
#define _CORBA_INITIALIZERSEQ_CS_

// *************************************************************
// CORBA_InitializerSeq
// *************************************************************

CORBA_InitializerSeq::CORBA_InitializerSeq (void)
{}
CORBA_InitializerSeq::CORBA_InitializerSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_InitializerSeq::CORBA_InitializerSeq (CORBA::ULong max, CORBA::ULong length, CORBA_Initializer *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_InitializerSeq::CORBA_InitializerSeq (const CORBA_InitializerSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_InitializerSeq::~CORBA_InitializerSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_InitializerSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InitializerSeq:1.0
  15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
  CORBA::tk_sequence, // typecode kind
  440, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    424, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
      12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
      1, // member count
      8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
      CORBA::tk_alias, // typecode kind for typedefs
      340, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
        16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
        CORBA::tk_sequence, // typecode kind
        264, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          248, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
            13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
            3, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string,
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            52, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InitializerSeq (CORBA::tk_alias, sizeof (_oc_CORBA_InitializerSeq), (char *) &_oc_CORBA_InitializerSeq, 0, sizeof (CORBA_InitializerSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InitializerSeq, &_tc_TAO_tc_CORBA_InitializerSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_UnionMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/UnionMember:1.0
  12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
  CORBA::tk_any,

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionMember (CORBA::tk_struct, sizeof (_oc_CORBA_UnionMember), (char *) &_oc_CORBA_UnionMember, 0, sizeof (CORBA_UnionMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMember, &_tc_TAO_tc_CORBA_UnionMember)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_UnionMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_UnionMember *old = ACE_reinterpret_cast (CORBA_UnionMember *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_UnionMember *tmp = ACE_reinterpret_cast (CORBA_UnionMember *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq::~_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_UNIONMEMBERSEQ_CS_)
#define _CORBA_UNIONMEMBERSEQ_CS_

// *************************************************************
// CORBA_UnionMemberSeq
// *************************************************************

CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (void)
{}
CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA_UnionMember *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_UnionMemberSeq::CORBA_UnionMemberSeq (const CORBA_UnionMemberSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_UnionMemberSeq::~CORBA_UnionMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_UnionMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/UnionMemberSeq:1.0
  15, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = UnionMemberSeq
  CORBA::tk_sequence, // typecode kind
  276, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    260, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/UnionMember:1.0
      12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = UnionMember
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
      CORBA::tk_any,

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_UnionMemberSeq), (char *) &_oc_CORBA_UnionMemberSeq, 0, sizeof (CORBA_UnionMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMemberSeq, &_tc_TAO_tc_CORBA_UnionMemberSeq)
TAO_NAMESPACE_END

#if !defined (_CORBA_ENUMMEMBERSEQ_CS_)
#define _CORBA_ENUMMEMBERSEQ_CS_

// *************************************************************
// CORBA_EnumMemberSeq
// *************************************************************

CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (void)
{}
CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_EnumMemberSeq::CORBA_EnumMemberSeq (const CORBA_EnumMemberSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_EnumMemberSeq::~CORBA_EnumMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_EnumMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f456e), ACE_NTOHL (0x756d4d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/EnumMemberSeq:1.0
  14, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x71000000),  // name = EnumMemberSeq
  CORBA::tk_sequence, // typecode kind
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string,
      0U, // string length

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_EnumMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_EnumMemberSeq), (char *) &_oc_CORBA_EnumMemberSeq, 0, sizeof (CORBA_EnumMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumMemberSeq, &_tc_TAO_tc_CORBA_EnumMemberSeq)
TAO_NAMESPACE_END
CORBA_Container_ptr CORBA_Container::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Container::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Container:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_Container::_nil ());
  if (is_a == 0)
    return CORBA_Container::_nil ();
  return CORBA_Container::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_Container_ptr CORBA_Container::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Container::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_Container_Stub_Factory_function_pointer != 0)
    {
      CORBA_Container_ptr retv = _TAO_collocation_CORBA_Container_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_Container_ptr retval = CORBA_Container::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_Container (stub),
                  CORBA_Container::_nil ());

  return retval;
}

CORBA_Container_ptr
CORBA_Container::_duplicate (CORBA_Container_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_Contained_ptr CORBA_Container::lookup (
    const char * search_name,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Contained_ptr _tao_retval = CORBA_Contained::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup",
      6,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << search_name)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ContainedSeq * CORBA_Container::contents (
   CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ContainedSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_ContainedSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "contents",
      8,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << limit_type) &&
          (_tao_out << CORBA_Any::from_boolean (exclude_inherited))
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ContainedSeq * CORBA_Container::lookup_name (
    const char * search_name,
    CORBA::Long levels_to_search,
   CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ContainedSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_ContainedSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_name",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << search_name) &&
          (_tao_out << levels_to_search) &&
          (_tao_out << limit_type) &&
          (_tao_out << CORBA_Any::from_boolean (exclude_inherited))
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_Container_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65722f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  3, // member count
  17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
    10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  472, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    24, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_Description (CORBA::tk_struct, sizeof (_oc_CORBA_Container_Description), (char *) &_oc_CORBA_Container_Description, 0, sizeof (CORBA_Container::Description));
CORBA::TypeCode_ptr CORBA_Container::_tc_Description = &_tc_TAO_tc_CORBA_Container_Description;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

  void
  CORBA_Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_Container::Description* tmp = 0;
    tmp = CORBA_Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_Container::Description *old = ACE_reinterpret_cast (CORBA_Container::Description *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        CORBA_Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  CORBA_Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_Container::Description *tmp = ACE_reinterpret_cast (CORBA_Container::Description *,this->buffer_);

    CORBA_Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  CORBA_Container::_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ_CS_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_Container::DescriptionSeq
// *************************************************************

CORBA_Container::DescriptionSeq::DescriptionSeq (void)
{}
CORBA_Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_Container::Description *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_Container::DescriptionSeq::~DescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_Container_DescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65722f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/Container/DescriptionSeq:1.0
  15, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = DescriptionSeq
  CORBA::tk_sequence, // typecode kind
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    668, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65722f), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container/Description:1.0
      12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
      3, // member count
      17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Contained:1.0
        10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = Contained

      5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
      CORBA::tk_enum, // typecode kind
      472, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4465), ACE_NTOHL (0x66696e69), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/DefinitionKind:1.0
        15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
        24, // member count
        8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
        7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
        13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
        12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
        13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
        13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
        10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
        13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
        11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
        9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
        8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
        13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
        12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
        14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
        11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
        9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
        9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
        12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
        15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
        10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native

      6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Container_DescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_Container_DescriptionSeq), (char *) &_oc_CORBA_Container_DescriptionSeq, 0, sizeof (CORBA_Container::DescriptionSeq));
CORBA::TypeCode_ptr CORBA_Container::_tc_DescriptionSeq = &_tc_TAO_tc_CORBA_Container_DescriptionSeq;

CORBA_Container::DescriptionSeq * CORBA_Container::describe_contents (
   CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Container::DescriptionSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_Container::DescriptionSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_contents",
      17,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << limit_type) &&
          (_tao_out << CORBA_Any::from_boolean (exclude_inherited)) &&
          (_tao_out << max_returned_objs)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ModuleDef_ptr CORBA_Container::create_module (
    const char * id,
    const char * name,
    const char * version,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ModuleDef_ptr _tao_retval = CORBA_ModuleDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_module",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ConstantDef_ptr CORBA_Container::create_constant (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    const CORBA_Any & value,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ConstantDef_ptr _tao_retval = CORBA_ConstantDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_constant",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << value)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_StructDef_ptr CORBA_Container::create_struct (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_StructDef_ptr _tao_retval = CORBA_StructDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_struct",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_UnionDef_ptr CORBA_Container::create_union (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr discriminator_type,
    const CORBA_UnionMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_UnionDef_ptr _tao_retval = CORBA_UnionDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_union",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << discriminator_type) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_EnumDef_ptr CORBA_Container::create_enum (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_EnumMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_EnumDef_ptr _tao_retval = CORBA_EnumDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_enum",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_AliasDef_ptr CORBA_Container::create_alias (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_AliasDef_ptr _tao_retval = CORBA_AliasDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_alias",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << original_type)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_InterfaceDef_ptr CORBA_Container::create_interface (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDef_ptr _tao_retval = CORBA_InterfaceDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_interface",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << base_interfaces)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ValueDef_ptr CORBA_Container::create_value (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA_ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA_ValueDefSeq & abstract_base_values,
    CORBA_InterfaceDef_ptr supported_interface,
    const CORBA_InitializerSeq & initializers,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueDef_ptr _tao_retval = CORBA_ValueDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << CORBA_Any::from_boolean (is_custom)) &&
          (_tao_out << CORBA_Any::from_boolean (is_abstract)) &&
          (_tao_out << base_value) &&
          (_tao_out << CORBA_Any::from_boolean (is_truncatable)) &&
          (_tao_out << abstract_base_values) &&
          (_tao_out << supported_interface) &&
          (_tao_out << initializers)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ValueBoxDef_ptr CORBA_Container::create_value_box (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr original_type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueBoxDef_ptr _tao_retval = CORBA_ValueBoxDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_box",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << original_type_def)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ExceptionDef_ptr CORBA_Container::create_exception (
    const char * id,
    const char * name,
    const char * version,
    const CORBA_StructMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ExceptionDef_ptr _tao_retval = CORBA_ExceptionDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_exception",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << members)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA_Container::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

static const CORBA::Long _oc_CORBA_Container[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746169), ACE_NTOHL (0x6e65723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/Container:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x72000000),  // name = Container
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Container (CORBA::tk_objref, sizeof (_oc_CORBA_Container), (char *) &_oc_CORBA_Container, 0, sizeof (CORBA_Container));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Container, &_tc_TAO_tc_CORBA_Container)
TAO_NAMESPACE_END
CORBA_IDLType_ptr CORBA_IDLType::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_IDLType::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IDLType:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_IDLType::_nil ());
  if (is_a == 0)
    return CORBA_IDLType::_nil ();
  return CORBA_IDLType::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_IDLType_ptr CORBA_IDLType::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_IDLType::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer != 0)
    {
      CORBA_IDLType_ptr retv = _TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_IDLType_ptr retval = CORBA_IDLType::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_IDLType (stub),
                  CORBA_IDLType::_nil ());

  return retval;
}

CORBA_IDLType_ptr
CORBA_IDLType::_duplicate (CORBA_IDLType_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA_IDLType::type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA_IDLType::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

static const CORBA::Long _oc_CORBA_IDLType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
  8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_IDLType (CORBA::tk_objref, sizeof (_oc_CORBA_IDLType), (char *) &_oc_CORBA_IDLType, 0, sizeof (CORBA_IDLType));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IDLType, &_tc_TAO_tc_CORBA_IDLType)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_PrimitiveKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5072), ACE_NTOHL (0x696d6974), ACE_NTOHL (0x6976654b), ACE_NTOHL (0x696e643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/PrimitiveKind:1.0
  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x654b696e), ACE_NTOHL (0x64000000),  // name = PrimitiveKind
  21, // member count
  8, ACE_NTOHL (0x706b5f6e), ACE_NTOHL (0x756c6c00),  // name = pk_null
  8, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x6f696400),  // name = pk_void
  9, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x686f7274), ACE_NTOHL (0x0),  // name = pk_short
  8, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6700),  // name = pk_long
  10, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x73686f72), ACE_NTOHL (0x74000000),  // name = pk_ushort
  9, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulong
  9, ACE_NTOHL (0x706b5f66), ACE_NTOHL (0x6c6f6174), ACE_NTOHL (0x0),  // name = pk_float
  10, ACE_NTOHL (0x706b5f64), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_double
  11, ACE_NTOHL (0x706b5f62), ACE_NTOHL (0x6f6f6c65), ACE_NTOHL (0x616e0000),  // name = pk_boolean
  8, ACE_NTOHL (0x706b5f63), ACE_NTOHL (0x68617200),  // name = pk_char
  9, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x63746574), ACE_NTOHL (0x0),  // name = pk_octet
  7, ACE_NTOHL (0x706b5f61), ACE_NTOHL (0x6e790000),  // name = pk_any
  12, ACE_NTOHL (0x706b5f54), ACE_NTOHL (0x79706543), ACE_NTOHL (0x6f646500),  // name = pk_TypeCode
  13, ACE_NTOHL (0x706b5f50), ACE_NTOHL (0x72696e63), ACE_NTOHL (0x6970616c), ACE_NTOHL (0x0),  // name = pk_Principal
  10, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = pk_string
  10, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x626a7265), ACE_NTOHL (0x66000000),  // name = pk_objref
  12, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e676c), ACE_NTOHL (0x6f6e6700),  // name = pk_longlong
  13, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulonglong
  14, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6764), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_longdouble
  9, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x63686172), ACE_NTOHL (0x0),  // name = pk_wchar
  11, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = pk_wstring
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_PrimitiveKind (CORBA::tk_enum, sizeof (_oc_CORBA_PrimitiveKind), (char *) &_oc_CORBA_PrimitiveKind, 0, sizeof (CORBA::PrimitiveKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveKind, &_tc_TAO_tc_CORBA_PrimitiveKind)
TAO_NAMESPACE_END
CORBA_Repository_ptr CORBA_Repository::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Repository::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/Repository:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_Repository::_nil ());
  if (is_a == 0)
    return CORBA_Repository::_nil ();
  return CORBA_Repository::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_Repository_ptr CORBA_Repository::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_Repository::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer != 0)
    {
      CORBA_Repository_ptr retv = _TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_Repository_ptr retval = CORBA_Repository::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_Repository (stub),
                  CORBA_Repository::_nil ());

  return retval;
}

CORBA_Repository_ptr
CORBA_Repository::_duplicate (CORBA_Repository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_Contained_ptr CORBA_Repository::lookup_id (
    const char * search_id,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Contained_ptr _tao_retval = CORBA_Contained::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_id",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << search_id)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_PrimitiveDef_ptr CORBA_Repository::get_primitive (
    CORBA::PrimitiveKind kind,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_PrimitiveDef_ptr _tao_retval = CORBA_PrimitiveDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primitive",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << kind)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_StringDef_ptr CORBA_Repository::create_string (
    CORBA::ULong bound,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_StringDef_ptr _tao_retval = CORBA_StringDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_string",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_WstringDef_ptr CORBA_Repository::create_wstring (
    CORBA::ULong bound,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_WstringDef_ptr _tao_retval = CORBA_WstringDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_wstring",
      14,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_SequenceDef_ptr CORBA_Repository::create_sequence (
    CORBA::ULong bound,
    CORBA_IDLType_ptr element_type,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_SequenceDef_ptr _tao_retval = CORBA_SequenceDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_sequence",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound) &&
          (_tao_out << element_type)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ArrayDef_ptr CORBA_Repository::create_array (
    CORBA::ULong length,
    CORBA_IDLType_ptr element_type,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ArrayDef_ptr _tao_retval = CORBA_ArrayDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_array",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << length) &&
          (_tao_out << element_type)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_FixedDef_ptr CORBA_Repository::create_fixed (
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_FixedDef_ptr _tao_retval = CORBA_FixedDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_fixed",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << digits) &&
          (_tao_out << scale)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA_Repository::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

static const CORBA::Long _oc_CORBA_Repository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Repository:1.0
  11, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72790000),  // name = Repository
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Repository (CORBA::tk_objref, sizeof (_oc_CORBA_Repository), (char *) &_oc_CORBA_Repository, 0, sizeof (CORBA_Repository));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Repository, &_tc_TAO_tc_CORBA_Repository)
TAO_NAMESPACE_END
CORBA_ModuleDef_ptr CORBA_ModuleDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ModuleDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ModuleDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_ModuleDef::_nil ());
  if (is_a == 0)
    return CORBA_ModuleDef::_nil ();
  return CORBA_ModuleDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_ModuleDef_ptr CORBA_ModuleDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ModuleDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ModuleDef_ptr retv = _TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_ModuleDef_ptr retval = CORBA_ModuleDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_ModuleDef (stub),
                  CORBA_ModuleDef::_nil ());

  return retval;
}

CORBA_ModuleDef_ptr
CORBA_ModuleDef::_duplicate (CORBA_ModuleDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean CORBA_ModuleDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

static const CORBA::Long _oc_CORBA_ModuleDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4d6f), ACE_NTOHL (0x64756c65), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ModuleDef:1.0
  10, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x66000000),  // name = ModuleDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ModuleDef (CORBA::tk_objref, sizeof (_oc_CORBA_ModuleDef), (char *) &_oc_CORBA_ModuleDef, 0, sizeof (CORBA_ModuleDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDef, &_tc_TAO_tc_CORBA_ModuleDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ModuleDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4d6f), ACE_NTOHL (0x64756c65), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ModuleDescription:1.0
  18, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = ModuleDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ModuleDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ModuleDescription), (char *) &_oc_CORBA_ModuleDescription, 0, sizeof (CORBA_ModuleDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDescription, &_tc_TAO_tc_CORBA_ModuleDescription)
TAO_NAMESPACE_END
CORBA_ConstantDef_ptr CORBA_ConstantDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ConstantDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ConstantDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_ConstantDef::_nil ());
  if (is_a == 0)
    return CORBA_ConstantDef::_nil ();
  return CORBA_ConstantDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_ConstantDef_ptr CORBA_ConstantDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ConstantDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ConstantDef_ptr retv = _TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_ConstantDef_ptr retval = CORBA_ConstantDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_ConstantDef (stub),
                  CORBA_ConstantDef::_nil ());

  return retval;
}

CORBA_ConstantDef_ptr
CORBA_ConstantDef::_duplicate (CORBA_ConstantDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA_ConstantDef::type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_IDLType_ptr CORBA_ConstantDef::type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type_def",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ConstantDef::type_def (
    CORBA_IDLType_ptr type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""type_def",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_Any * CORBA_ConstantDef::value (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_Any* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_Any, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ConstantDef::value (
    const CORBA_Any & value,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""value",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << value)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ConstantDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

static const CORBA::Long _oc_CORBA_ConstantDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e737461), ACE_NTOHL (0x6e744465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ConstantDef:1.0
  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44656600),  // name = ConstantDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ConstantDef (CORBA::tk_objref, sizeof (_oc_CORBA_ConstantDef), (char *) &_oc_CORBA_ConstantDef, 0, sizeof (CORBA_ConstantDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDef, &_tc_TAO_tc_CORBA_ConstantDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ConstantDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e737461), ACE_NTOHL (0x6e744465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e3a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ConstantDescription:1.0
  20, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ConstantDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ConstantDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ConstantDescription), (char *) &_oc_CORBA_ConstantDescription, 0, sizeof (CORBA_ConstantDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDescription, &_tc_TAO_tc_CORBA_ConstantDescription)
TAO_NAMESPACE_END
CORBA_TypedefDef_ptr CORBA_TypedefDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_TypedefDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/TypedefDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_TypedefDef::_nil ());
  if (is_a == 0)
    return CORBA_TypedefDef::_nil ();
  return CORBA_TypedefDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_TypedefDef_ptr CORBA_TypedefDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_TypedefDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_TypedefDef_ptr retv = _TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_TypedefDef_ptr retval = CORBA_TypedefDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_TypedefDef (stub),
                  CORBA_TypedefDef::_nil ());

  return retval;
}

CORBA_TypedefDef_ptr
CORBA_TypedefDef::_duplicate (CORBA_TypedefDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::Boolean CORBA_TypedefDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

static const CORBA::Long _oc_CORBA_TypedefDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5479), ACE_NTOHL (0x70656465), ACE_NTOHL (0x66446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/TypedefDef:1.0
  11, ACE_NTOHL (0x54797065), ACE_NTOHL (0x64656644), ACE_NTOHL (0x65660000),  // name = TypedefDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_TypedefDef (CORBA::tk_objref, sizeof (_oc_CORBA_TypedefDef), (char *) &_oc_CORBA_TypedefDef, 0, sizeof (CORBA_TypedefDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypedefDef, &_tc_TAO_tc_CORBA_TypedefDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_TypeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5479), ACE_NTOHL (0x70654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e3a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/TypeDescription:1.0
  16, ACE_NTOHL (0x54797065), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = TypeDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_TypeDescription (CORBA::tk_struct, sizeof (_oc_CORBA_TypeDescription), (char *) &_oc_CORBA_TypeDescription, 0, sizeof (CORBA_TypeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeDescription, &_tc_TAO_tc_CORBA_TypeDescription)
TAO_NAMESPACE_END
CORBA_StructDef_ptr CORBA_StructDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StructDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/StructDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_StructDef::_nil ());
  if (is_a == 0)
    return CORBA_StructDef::_nil ();
  return CORBA_StructDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_StructDef_ptr CORBA_StructDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StructDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_StructDef_ptr retv = _TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_StructDef_ptr retval = CORBA_StructDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_StructDef (stub),
                  CORBA_StructDef::_nil ());

  return retval;
}

CORBA_StructDef_ptr
CORBA_StructDef::_duplicate (CORBA_StructDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_StructMemberSeq * CORBA_StructDef::members (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_StructMemberSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_StructMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_StructDef::members (
    const CORBA_StructMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_StructDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

static const CORBA::Long _oc_CORBA_StructDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/StructDef:1.0
  10, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744465), ACE_NTOHL (0x66000000),  // name = StructDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StructDef (CORBA::tk_objref, sizeof (_oc_CORBA_StructDef), (char *) &_oc_CORBA_StructDef, 0, sizeof (CORBA_StructDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructDef, &_tc_TAO_tc_CORBA_StructDef)
TAO_NAMESPACE_END
CORBA_UnionDef_ptr CORBA_UnionDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_UnionDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/UnionDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_UnionDef::_nil ());
  if (is_a == 0)
    return CORBA_UnionDef::_nil ();
  return CORBA_UnionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_UnionDef_ptr CORBA_UnionDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_UnionDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_UnionDef_ptr retv = _TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_UnionDef_ptr retval = CORBA_UnionDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_UnionDef (stub),
                  CORBA_UnionDef::_nil ());

  return retval;
}

CORBA_UnionDef_ptr
CORBA_UnionDef::_duplicate (CORBA_UnionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA_UnionDef::discriminator_type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""discriminator_type",
      23,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_IDLType_ptr CORBA_UnionDef::discriminator_type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""discriminator_type_def",
      27,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_UnionDef::discriminator_type_def (
    CORBA_IDLType_ptr discriminator_type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""discriminator_type_def",
      27,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << discriminator_type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_UnionMemberSeq * CORBA_UnionDef::members (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_UnionMemberSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_UnionMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_UnionDef::members (
    const CORBA_UnionMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_UnionDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

static const CORBA::Long _oc_CORBA_UnionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f556e), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/UnionDef:1.0
  9, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = UnionDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_UnionDef (CORBA::tk_objref, sizeof (_oc_CORBA_UnionDef), (char *) &_oc_CORBA_UnionDef, 0, sizeof (CORBA_UnionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionDef, &_tc_TAO_tc_CORBA_UnionDef)
TAO_NAMESPACE_END
CORBA_EnumDef_ptr CORBA_EnumDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_EnumDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/EnumDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_EnumDef::_nil ());
  if (is_a == 0)
    return CORBA_EnumDef::_nil ();
  return CORBA_EnumDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_EnumDef_ptr CORBA_EnumDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_EnumDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_EnumDef_ptr retv = _TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_EnumDef_ptr retval = CORBA_EnumDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_EnumDef (stub),
                  CORBA_EnumDef::_nil ());

  return retval;
}

CORBA_EnumDef_ptr
CORBA_EnumDef::_duplicate (CORBA_EnumDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_EnumMemberSeq * CORBA_EnumDef::members (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_EnumMemberSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_EnumMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_EnumDef::members (
    const CORBA_EnumMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_EnumDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

static const CORBA::Long _oc_CORBA_EnumDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f456e), ACE_NTOHL (0x756d4465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/EnumDef:1.0
  8, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x44656600),  // name = EnumDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_EnumDef (CORBA::tk_objref, sizeof (_oc_CORBA_EnumDef), (char *) &_oc_CORBA_EnumDef, 0, sizeof (CORBA_EnumDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumDef, &_tc_TAO_tc_CORBA_EnumDef)
TAO_NAMESPACE_END
CORBA_AliasDef_ptr CORBA_AliasDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AliasDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/AliasDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_AliasDef::_nil ());
  if (is_a == 0)
    return CORBA_AliasDef::_nil ();
  return CORBA_AliasDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_AliasDef_ptr CORBA_AliasDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AliasDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_AliasDef_ptr retv = _TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_AliasDef_ptr retval = CORBA_AliasDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_AliasDef (stub),
                  CORBA_AliasDef::_nil ());

  return retval;
}

CORBA_AliasDef_ptr
CORBA_AliasDef::_duplicate (CORBA_AliasDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_IDLType_ptr CORBA_AliasDef::original_type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""original_type_def",
      22,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_AliasDef::original_type_def (
    CORBA_IDLType_ptr original_type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""original_type_def",
      22,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << original_type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_AliasDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

static const CORBA::Long _oc_CORBA_AliasDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f416c), ACE_NTOHL (0x69617344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AliasDef:1.0
  9, ACE_NTOHL (0x416c6961), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = AliasDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AliasDef (CORBA::tk_objref, sizeof (_oc_CORBA_AliasDef), (char *) &_oc_CORBA_AliasDef, 0, sizeof (CORBA_AliasDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AliasDef, &_tc_TAO_tc_CORBA_AliasDef)
TAO_NAMESPACE_END
CORBA_PrimitiveDef_ptr CORBA_PrimitiveDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_PrimitiveDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/PrimitiveDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_PrimitiveDef::_nil ());
  if (is_a == 0)
    return CORBA_PrimitiveDef::_nil ();
  return CORBA_PrimitiveDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_PrimitiveDef_ptr CORBA_PrimitiveDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_PrimitiveDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_PrimitiveDef_ptr retv = _TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_PrimitiveDef_ptr retval = CORBA_PrimitiveDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_PrimitiveDef (stub),
                  CORBA_PrimitiveDef::_nil ());

  return retval;
}

CORBA_PrimitiveDef_ptr
CORBA_PrimitiveDef::_duplicate (CORBA_PrimitiveDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::PrimitiveKind CORBA_PrimitiveDef::kind (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::PrimitiveKind _tao_retval = (CORBA::PrimitiveKind)0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""kind",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA_PrimitiveDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

static const CORBA::Long _oc_CORBA_PrimitiveDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5072), ACE_NTOHL (0x696d6974), ACE_NTOHL (0x69766544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/PrimitiveDef:1.0
  13, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = PrimitiveDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_PrimitiveDef (CORBA::tk_objref, sizeof (_oc_CORBA_PrimitiveDef), (char *) &_oc_CORBA_PrimitiveDef, 0, sizeof (CORBA_PrimitiveDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveDef, &_tc_TAO_tc_CORBA_PrimitiveDef)
TAO_NAMESPACE_END
CORBA_StringDef_ptr CORBA_StringDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StringDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/StringDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_StringDef::_nil ());
  if (is_a == 0)
    return CORBA_StringDef::_nil ();
  return CORBA_StringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_StringDef_ptr CORBA_StringDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_StringDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_StringDef_ptr retv = _TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_StringDef_ptr retval = CORBA_StringDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_StringDef (stub),
                  CORBA_StringDef::_nil ());

  return retval;
}

CORBA_StringDef_ptr
CORBA_StringDef::_duplicate (CORBA_StringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA_StringDef::bound (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""bound",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_StringDef::bound (
    CORBA::ULong bound,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""bound",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

     CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_StringDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

static const CORBA::Long _oc_CORBA_StringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72696e67), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/StringDef:1.0
  10, ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x66000000),  // name = StringDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_StringDef (CORBA::tk_objref, sizeof (_oc_CORBA_StringDef), (char *) &_oc_CORBA_StringDef, 0, sizeof (CORBA_StringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StringDef, &_tc_TAO_tc_CORBA_StringDef)
TAO_NAMESPACE_END
CORBA_WstringDef_ptr CORBA_WstringDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_WstringDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/WstringDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_WstringDef::_nil ());
  if (is_a == 0)
    return CORBA_WstringDef::_nil ();
  return CORBA_WstringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_WstringDef_ptr CORBA_WstringDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_WstringDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_WstringDef_ptr retv = _TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_WstringDef_ptr retval = CORBA_WstringDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_WstringDef (stub),
                  CORBA_WstringDef::_nil ());

  return retval;
}

CORBA_WstringDef_ptr
CORBA_WstringDef::_duplicate (CORBA_WstringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA_WstringDef::bound (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""bound",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_WstringDef::bound (
    CORBA::ULong bound,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""bound",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_WstringDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

static const CORBA::Long _oc_CORBA_WstringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5773), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/WstringDef:1.0
  11, ACE_NTOHL (0x57737472), ACE_NTOHL (0x696e6744), ACE_NTOHL (0x65660000),  // name = WstringDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_WstringDef (CORBA::tk_objref, sizeof (_oc_CORBA_WstringDef), (char *) &_oc_CORBA_WstringDef, 0, sizeof (CORBA_WstringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_WstringDef, &_tc_TAO_tc_CORBA_WstringDef)
TAO_NAMESPACE_END
CORBA_FixedDef_ptr CORBA_FixedDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_FixedDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/FixedDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_FixedDef::_nil ());
  if (is_a == 0)
    return CORBA_FixedDef::_nil ();
  return CORBA_FixedDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_FixedDef_ptr CORBA_FixedDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_FixedDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_FixedDef_ptr retv = _TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_FixedDef_ptr retval = CORBA_FixedDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_FixedDef (stub),
                  CORBA_FixedDef::_nil ());

  return retval;
}

CORBA_FixedDef_ptr
CORBA_FixedDef::_duplicate (CORBA_FixedDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::UShort CORBA_FixedDef::digits (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::UShort _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""digits",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_FixedDef::digits (
    CORBA::UShort digits,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""digits",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << digits)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Short CORBA_FixedDef::scale (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Short _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""scale",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_FixedDef::scale (
    CORBA::Short scale,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""scale",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << scale)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_FixedDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/FixedDef:1.0";
}

static const CORBA::Long _oc_CORBA_FixedDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4669), ACE_NTOHL (0x78656444), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/FixedDef:1.0
  9, ACE_NTOHL (0x46697865), ACE_NTOHL (0x64446566), ACE_NTOHL (0x0),  // name = FixedDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_FixedDef (CORBA::tk_objref, sizeof (_oc_CORBA_FixedDef), (char *) &_oc_CORBA_FixedDef, 0, sizeof (CORBA_FixedDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FixedDef, &_tc_TAO_tc_CORBA_FixedDef)
TAO_NAMESPACE_END
CORBA_SequenceDef_ptr CORBA_SequenceDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_SequenceDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/SequenceDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_SequenceDef::_nil ());
  if (is_a == 0)
    return CORBA_SequenceDef::_nil ();
  return CORBA_SequenceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_SequenceDef_ptr CORBA_SequenceDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_SequenceDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_SequenceDef_ptr retv = _TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_SequenceDef_ptr retval = CORBA_SequenceDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_SequenceDef (stub),
                  CORBA_SequenceDef::_nil ());

  return retval;
}

CORBA_SequenceDef_ptr
CORBA_SequenceDef::_duplicate (CORBA_SequenceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA_SequenceDef::bound (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""bound",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_SequenceDef::bound (
    CORBA::ULong bound,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""bound",
      10,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << bound)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::TypeCode_ptr CORBA_SequenceDef::element_type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type",
      17,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_IDLType_ptr CORBA_SequenceDef::element_type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type_def",
      21,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

     CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_SequenceDef::element_type_def (
    CORBA_IDLType_ptr element_type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""element_type_def",
      21,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << element_type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_SequenceDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

static const CORBA::Long _oc_CORBA_SequenceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5365), ACE_NTOHL (0x7175656e), ACE_NTOHL (0x63654465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/SequenceDef:1.0
  12, ACE_NTOHL (0x53657175), ACE_NTOHL (0x656e6365), ACE_NTOHL (0x44656600),  // name = SequenceDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_SequenceDef (CORBA::tk_objref, sizeof (_oc_CORBA_SequenceDef), (char *) &_oc_CORBA_SequenceDef, 0, sizeof (CORBA_SequenceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SequenceDef, &_tc_TAO_tc_CORBA_SequenceDef)
TAO_NAMESPACE_END
CORBA_ArrayDef_ptr CORBA_ArrayDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ArrayDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ArrayDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_ArrayDef::_nil ());
  if (is_a == 0)
    return CORBA_ArrayDef::_nil ();
  return CORBA_ArrayDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_ArrayDef_ptr CORBA_ArrayDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ArrayDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ArrayDef_ptr retv = _TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_ArrayDef_ptr retval = CORBA_ArrayDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_ArrayDef (stub),
                  CORBA_ArrayDef::_nil ());

  return retval;
}

CORBA_ArrayDef_ptr
CORBA_ArrayDef::_duplicate (CORBA_ArrayDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::ULong CORBA_ArrayDef::length (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::ULong _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""length",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

     CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ArrayDef::length (
    CORBA::ULong length,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""length",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << length)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::TypeCode_ptr CORBA_ArrayDef::element_type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type",
      17,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_IDLType_ptr CORBA_ArrayDef::element_type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""element_type_def",
      21,
      istub->orb_core ()
    );

  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ArrayDef::element_type_def (
    CORBA_IDLType_ptr element_type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""element_type_def",
      21,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << element_type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ArrayDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

static const CORBA::Long _oc_CORBA_ArrayDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4172), ACE_NTOHL (0x72617944), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ArrayDef:1.0
  9, ACE_NTOHL (0x41727261), ACE_NTOHL (0x79446566), ACE_NTOHL (0x0),  // name = ArrayDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ArrayDef (CORBA::tk_objref, sizeof (_oc_CORBA_ArrayDef), (char *) &_oc_CORBA_ArrayDef, 0, sizeof (CORBA_ArrayDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ArrayDef, &_tc_TAO_tc_CORBA_ArrayDef)
TAO_NAMESPACE_END
CORBA_ExceptionDef_ptr CORBA_ExceptionDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ExceptionDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ExceptionDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_ExceptionDef::_nil ());
  if (is_a == 0)
    return CORBA_ExceptionDef::_nil ();
  return CORBA_ExceptionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_ExceptionDef_ptr CORBA_ExceptionDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ExceptionDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ExceptionDef_ptr retv = _TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_ExceptionDef_ptr retval = CORBA_ExceptionDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_ExceptionDef (stub),
                  CORBA_ExceptionDef::_nil ());

  return retval;
}

CORBA_ExceptionDef_ptr
CORBA_ExceptionDef::_duplicate (CORBA_ExceptionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA_ExceptionDef::type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_StructMemberSeq * CORBA_ExceptionDef::members (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_StructMemberSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_StructMemberSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ExceptionDef::members (
    const CORBA_StructMemberSeq & members,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""members",
      12,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << members)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ExceptionDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

static const CORBA::Long _oc_CORBA_ExceptionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDef:1.0
  13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDef (CORBA::tk_objref, sizeof (_oc_CORBA_ExceptionDef), (char *) &_oc_CORBA_ExceptionDef, 0, sizeof (CORBA_ExceptionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDef, &_tc_TAO_tc_CORBA_ExceptionDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ExceptionDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
  21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ExceptionDescription), (char *) &_oc_CORBA_ExceptionDescription, 0, sizeof (CORBA_ExceptionDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDescription, &_tc_TAO_tc_CORBA_ExceptionDescription)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_AttributeMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
  14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
  2, // member count
  12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
  14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeMode (CORBA::tk_enum, sizeof (_oc_CORBA_AttributeMode), (char *) &_oc_CORBA_AttributeMode, 0, sizeof (CORBA::AttributeMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeMode, &_tc_TAO_tc_CORBA_AttributeMode)
TAO_NAMESPACE_END
CORBA_AttributeDef_ptr CORBA_AttributeDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AttributeDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/AttributeDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_AttributeDef::_nil ());
  if (is_a == 0)
    return CORBA_AttributeDef::_nil ();
  return CORBA_AttributeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_AttributeDef_ptr CORBA_AttributeDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_AttributeDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_AttributeDef_ptr retv = _TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_AttributeDef_ptr retval = CORBA_AttributeDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_AttributeDef (stub),
                  CORBA_AttributeDef::_nil ());

  return retval;
}

CORBA_AttributeDef_ptr
CORBA_AttributeDef::_duplicate (CORBA_AttributeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA_AttributeDef::type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_IDLType_ptr CORBA_AttributeDef::type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type_def",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_AttributeDef::type_def (
    CORBA_IDLType_ptr type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""type_def",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::AttributeMode CORBA_AttributeDef::mode (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::AttributeMode _tao_retval = (CORBA::AttributeMode)0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""mode",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_AttributeDef::mode (
    CORBA::AttributeMode mode,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""mode",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << mode)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_AttributeDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

static const CORBA::Long _oc_CORBA_AttributeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDef:1.0
  13, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = AttributeDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeDef (CORBA::tk_objref, sizeof (_oc_CORBA_AttributeDef), (char *) &_oc_CORBA_AttributeDef, 0, sizeof (CORBA_AttributeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDef, &_tc_TAO_tc_CORBA_AttributeDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_AttributeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
  21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  104, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
    14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
    2, // member count
    12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
    14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttributeDescription (CORBA::tk_struct, sizeof (_oc_CORBA_AttributeDescription), (char *) &_oc_CORBA_AttributeDescription, 0, sizeof (CORBA_AttributeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDescription, &_tc_TAO_tc_CORBA_AttributeDescription)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_OperationMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
  14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
  2, // member count
  10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
  10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationMode (CORBA::tk_enum, sizeof (_oc_CORBA_OperationMode), (char *) &_oc_CORBA_OperationMode, 0, sizeof (CORBA::OperationMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationMode, &_tc_TAO_tc_CORBA_OperationMode)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ParameterMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
  14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
  3, // member count
  9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
  10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
  12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ParameterMode (CORBA::tk_enum, sizeof (_oc_CORBA_ParameterMode), (char *) &_oc_CORBA_ParameterMode, 0, sizeof (CORBA::ParameterMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterMode, &_tc_TAO_tc_CORBA_ParameterMode)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ParameterDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
  21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  116, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
    14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
    3, // member count
    9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
    10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
    12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ParameterDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ParameterDescription), (char *) &_oc_CORBA_ParameterDescription, 0, sizeof (CORBA_ParameterDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterDescription, &_tc_TAO_tc_CORBA_ParameterDescription)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_PARDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_ParameterDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_ParameterDescription *old = ACE_reinterpret_cast (CORBA_ParameterDescription *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_ParameterDescription *tmp = ACE_reinterpret_cast (CORBA_ParameterDescription *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_PARDESCRIPTIONSEQ_CS_)
#define _CORBA_PARDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_ParDescriptionSeq
// *************************************************************

CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (void)
{}
CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ParameterDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ParDescriptionSeq::CORBA_ParDescriptionSeq (const CORBA_ParDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ParDescriptionSeq::~CORBA_ParDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ParDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
  18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  416, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    400, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
      21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      116, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
        14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
        3, // member count
        9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
        10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
        12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ParDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ParDescriptionSeq), (char *) &_oc_CORBA_ParDescriptionSeq, 0, sizeof (CORBA_ParDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParDescriptionSeq, &_tc_TAO_tc_CORBA_ParDescriptionSeq)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ContextIdentifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
  18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ContextIdentifier (CORBA::tk_alias, sizeof (_oc_CORBA_ContextIdentifier), (char *) &_oc_CORBA_ContextIdentifier, 0, sizeof (CORBA::ContextIdentifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdentifier, &_tc_TAO_tc_CORBA_ContextIdentifier)
TAO_NAMESPACE_END

#if !defined (_CORBA_CONTEXTIDSEQ_CS_)
#define _CORBA_CONTEXTIDSEQ_CS_

// *************************************************************
// CORBA_ContextIdSeq
// *************************************************************

CORBA_ContextIdSeq::CORBA_ContextIdSeq (void)
{}
CORBA_ContextIdSeq::CORBA_ContextIdSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ContextIdSeq::CORBA_ContextIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ContextIdSeq::CORBA_ContextIdSeq (const CORBA_ContextIdSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ContextIdSeq::~CORBA_ContextIdSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ContextIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
  CORBA::tk_sequence, // typecode kind
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    148, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
      18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ContextIdSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ContextIdSeq), (char *) &_oc_CORBA_ContextIdSeq, 0, sizeof (CORBA_ContextIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdSeq, &_tc_TAO_tc_CORBA_ContextIdSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_EXCEPTIONDEFSEQ_CS_

  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_ExceptionDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_ExceptionDef **old = ACE_reinterpret_cast (CORBA_ExceptionDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = CORBA_ExceptionDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];

      if (this->release_)
        delete[] old;

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    CORBA_ExceptionDef **tmp = ACE_reinterpret_cast (CORBA_ExceptionDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_ExceptionDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::~_TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq (void)
  {
    this->_deallocate_buffer ();
  }

  void
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    CORBA_ExceptionDef **tmp = ACE_reinterpret_cast (CORBA_ExceptionDef**, this->buffer_);

    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = CORBA_ExceptionDef::_nil ();
    }
  }
  void
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    CORBA_ExceptionDef **tmp = ACE_static_cast (CORBA_ExceptionDef**, target);
    *tmp = CORBA_ExceptionDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq::_upcast (void *src) const
  {
    CORBA_ExceptionDef **tmp = ACE_static_cast (CORBA_ExceptionDef**, src);
    return *tmp;
  }

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_EXCEPTIONDEFSEQ_CS_)
#define _CORBA_EXCEPTIONDEFSEQ_CS_

// *************************************************************
// CORBA_ExceptionDefSeq
// *************************************************************

CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (void)
{}
CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ExceptionDef_ptr *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ExceptionDefSeq::CORBA_ExceptionDefSeq (const CORBA_ExceptionDefSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_CORBA_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<CORBA_ExceptionDef,CORBA_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ExceptionDefSeq::~CORBA_ExceptionDefSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ExceptionDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ExceptionDefSeq:1.0
  16, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x53657100),  // name = ExceptionDefSeq
  CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDef:1.0
      13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = ExceptionDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExceptionDefSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ExceptionDefSeq), (char *) &_oc_CORBA_ExceptionDefSeq, 0, sizeof (CORBA_ExceptionDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDefSeq, &_tc_TAO_tc_CORBA_ExceptionDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_EXCDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_ExceptionDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_ExceptionDescription *old = ACE_reinterpret_cast (CORBA_ExceptionDescription *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_ExceptionDescription *tmp = ACE_reinterpret_cast (CORBA_ExceptionDescription *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_EXCDESCRIPTIONSEQ_CS_)
#define _CORBA_EXCDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_ExcDescriptionSeq
// *************************************************************

CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (void)
{}
CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ExceptionDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ExcDescriptionSeq::CORBA_ExcDescriptionSeq (const CORBA_ExcDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ExcDescriptionSeq::~CORBA_ExcDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ExcDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
  18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  476, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    460, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
      21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
      5, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ExcDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ExcDescriptionSeq), (char *) &_oc_CORBA_ExcDescriptionSeq, 0, sizeof (CORBA_ExcDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExcDescriptionSeq, &_tc_TAO_tc_CORBA_ExcDescriptionSeq)
TAO_NAMESPACE_END
CORBA_OperationDef_ptr CORBA_OperationDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_OperationDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/OperationDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_OperationDef::_nil ());
  if (is_a == 0)
    return CORBA_OperationDef::_nil ();
  return CORBA_OperationDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_OperationDef_ptr CORBA_OperationDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_OperationDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_OperationDef_ptr retv = _TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_OperationDef_ptr retval = CORBA_OperationDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_OperationDef (stub),
                  CORBA_OperationDef::_nil ());

  return retval;
}

CORBA_OperationDef_ptr
CORBA_OperationDef::_duplicate (CORBA_OperationDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA_OperationDef::result (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""result",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_IDLType_ptr CORBA_OperationDef::result_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""result_def",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_OperationDef::result_def (
    CORBA_IDLType_ptr result_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""result_def",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << result_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_ParDescriptionSeq * CORBA_OperationDef::params (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ParDescriptionSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_ParDescriptionSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""params",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_OperationDef::params (
    const CORBA_ParDescriptionSeq & params,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""params",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << params)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::OperationMode CORBA_OperationDef::mode (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::OperationMode _tao_retval = (CORBA::OperationMode)0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""mode",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_OperationDef::mode (
    CORBA::OperationMode mode,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""mode",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << mode)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_ContextIdSeq * CORBA_OperationDef::contexts (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ContextIdSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_ContextIdSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""contexts",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_OperationDef::contexts (
    const CORBA_ContextIdSeq & contexts,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""contexts",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << contexts)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_ExceptionDefSeq * CORBA_OperationDef::exceptions (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ExceptionDefSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_ExceptionDefSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""exceptions",
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_OperationDef::exceptions (
    const CORBA_ExceptionDefSeq & exceptions,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""exceptions",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << exceptions)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_OperationDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

static const CORBA::Long _oc_CORBA_OperationDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDef:1.0
  13, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = OperationDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationDef (CORBA::tk_objref, sizeof (_oc_CORBA_OperationDef), (char *) &_oc_CORBA_OperationDef, 0, sizeof (CORBA_OperationDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDef, &_tc_TAO_tc_CORBA_OperationDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_OperationDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
  21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
  9, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  100, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
    14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
    2, // member count
    10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
    10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

  9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
  CORBA::tk_alias, // typecode kind for typedefs
  236, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
    13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
    CORBA::tk_sequence, // typecode kind
    164, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      148, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
        18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length


      0U,


  11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
  CORBA::tk_alias, // typecode kind for typedefs
  496, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
    18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    416, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      400, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
        21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
        4, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        116, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
          14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
          3, // member count
          9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
          10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
          12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


      0U,


  11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  556, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    476, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      460, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OperationDescription (CORBA::tk_struct, sizeof (_oc_CORBA_OperationDescription), (char *) &_oc_CORBA_OperationDescription, 0, sizeof (CORBA_OperationDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDescription, &_tc_TAO_tc_CORBA_OperationDescription)
TAO_NAMESPACE_END

#if !defined (_CORBA_REPOSITORYIDSEQ_CS_)
#define _CORBA_REPOSITORYIDSEQ_CS_

// *************************************************************
// CORBA_RepositoryIdSeq
// *************************************************************

CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (void)
{}
CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_RepositoryIdSeq::CORBA_RepositoryIdSeq (const CORBA_RepositoryIdSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_RepositoryIdSeq::~CORBA_RepositoryIdSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_RepositoryIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
  16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
  CORBA::tk_sequence, // typecode kind
  88, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string,
      0U, // string length

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_RepositoryIdSeq (CORBA::tk_alias, sizeof (_oc_CORBA_RepositoryIdSeq), (char *) &_oc_CORBA_RepositoryIdSeq, 0, sizeof (CORBA_RepositoryIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_CORBA_RepositoryIdSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_OPDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_OperationDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_OperationDescription *old = ACE_reinterpret_cast (CORBA_OperationDescription *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_OperationDescription *tmp = ACE_reinterpret_cast (CORBA_OperationDescription *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_OPDESCRIPTIONSEQ_CS_)
#define _CORBA_OPDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_OpDescriptionSeq
// *************************************************************

CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (void)
{}
CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_OperationDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_OpDescriptionSeq::CORBA_OpDescriptionSeq (const CORBA_OpDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_OpDescriptionSeq::~CORBA_OpDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_OpDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
  17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  1956, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    1940, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
      21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
      9, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

      7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      100, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
        14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
        2, // member count
        10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
        10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

      9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
      CORBA::tk_alias, // typecode kind for typedefs
      236, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
        13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
        CORBA::tk_sequence, // typecode kind
        164, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_alias, // typecode kind for typedefs
          148, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
            18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string,
              0U, // string length


          0U,


      11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
      CORBA::tk_alias, // typecode kind for typedefs
      496, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
        18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        416, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          400, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
            21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
            4, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string,
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            52, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

            5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
            116, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
              14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
              3, // member count
              9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
              10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
              12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


          0U,


      11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      556, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        476, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          460, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string,
              0U, // string length

            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            72, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string,
              0U, // string length

            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            72, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string,
              0U, // string length

            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string,
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_OpDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_OpDescriptionSeq), (char *) &_oc_CORBA_OpDescriptionSeq, 0, sizeof (CORBA_OpDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OpDescriptionSeq, &_tc_TAO_tc_CORBA_OpDescriptionSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_ATTRDESCRIPTIONSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_AttributeDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_AttributeDescription *old = ACE_reinterpret_cast (CORBA_AttributeDescription *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_AttributeDescription *tmp = ACE_reinterpret_cast (CORBA_AttributeDescription *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq::~_TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_ATTRDESCRIPTIONSEQ_CS_)
#define _CORBA_ATTRDESCRIPTIONSEQ_CS_

// *************************************************************
// CORBA_AttrDescriptionSeq
// *************************************************************

CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (void)
{}
CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (CORBA::ULong max, CORBA::ULong length, CORBA_AttributeDescription *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_AttrDescriptionSeq::CORBA_AttrDescriptionSeq (const CORBA_AttrDescriptionSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_AttrDescriptionSeq::~CORBA_AttrDescriptionSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_AttrDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
  19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  600, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    584, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
      21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
      6, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      104, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
        14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
        2, // member count
        12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
        14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_AttrDescriptionSeq (CORBA::tk_alias, sizeof (_oc_CORBA_AttrDescriptionSeq), (char *) &_oc_CORBA_AttrDescriptionSeq, 0, sizeof (CORBA_AttrDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttrDescriptionSeq, &_tc_TAO_tc_CORBA_AttrDescriptionSeq)
TAO_NAMESPACE_END
CORBA_InterfaceDef_ptr CORBA_InterfaceDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_InterfaceDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/InterfaceDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_InterfaceDef::_nil ());
  if (is_a == 0)
    return CORBA_InterfaceDef::_nil ();
  return CORBA_InterfaceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_InterfaceDef_ptr CORBA_InterfaceDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_InterfaceDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_InterfaceDef_ptr retv = _TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_InterfaceDef_ptr retval = CORBA_InterfaceDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_InterfaceDef (stub),
                  CORBA_InterfaceDef::_nil ());

  return retval;
}

CORBA_InterfaceDef_ptr
CORBA_InterfaceDef::_duplicate (CORBA_InterfaceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_InterfaceDefSeq * CORBA_InterfaceDef::base_interfaces (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDefSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_InterfaceDefSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""base_interfaces",
      20,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_InterfaceDef::base_interfaces (
    const CORBA_InterfaceDefSeq & base_interfaces,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""base_interfaces",
      20,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << base_interfaces)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_InterfaceDef::is_a (
    const char * interface_id,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << interface_id)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA_Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_InterfaceDef_FullInterfaceDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  60, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65662f46), ACE_NTOHL (0x756c6c49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef/FullInterfaceDescription:1.0
  25, ACE_NTOHL (0x46756c6c), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = FullInterfaceDescription
  9, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2036, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1956, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1940, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          164, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            148, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length


            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        496, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          416, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            400, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string,
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      584, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        6, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


      0U,


  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      0U,


  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription (CORBA::tk_struct, sizeof (_oc_CORBA_InterfaceDef_FullInterfaceDescription), (char *) &_oc_CORBA_InterfaceDef_FullInterfaceDescription, 0, sizeof (CORBA_InterfaceDef::FullInterfaceDescription));
CORBA::TypeCode_ptr CORBA_InterfaceDef::_tc_FullInterfaceDescription = &_tc_TAO_tc_CORBA_InterfaceDef_FullInterfaceDescription;

CORBA_InterfaceDef::FullInterfaceDescription * CORBA_InterfaceDef::describe_interface (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDef::FullInterfaceDescription* _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_InterfaceDef::FullInterfaceDescription, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_interface",
      18,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_AttributeDef_ptr CORBA_InterfaceDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode mode,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_AttributeDef_ptr _tao_retval = CORBA_AttributeDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << mode)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_OperationDef_ptr CORBA_InterfaceDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_OperationDef_ptr _tao_retval = CORBA_OperationDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << result) &&
          (_tao_out << mode) &&
          (_tao_out << params) &&
          (_tao_out << exceptions) &&
          (_tao_out << contexts)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA_InterfaceDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

static const CORBA::Long _oc_CORBA_InterfaceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDef:1.0
  13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = InterfaceDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDef (CORBA::tk_objref, sizeof (_oc_CORBA_InterfaceDef), (char *) &_oc_CORBA_InterfaceDef, 0, sizeof (CORBA_InterfaceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDef, &_tc_TAO_tc_CORBA_InterfaceDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_InterfaceDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/InterfaceDescription:1.0
  21, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = InterfaceDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      0U,


  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_InterfaceDescription (CORBA::tk_struct, sizeof (_oc_CORBA_InterfaceDescription), (char *) &_oc_CORBA_InterfaceDescription, 0, sizeof (CORBA_InterfaceDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDescription, &_tc_TAO_tc_CORBA_InterfaceDescription)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_Visibility[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
  11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_Visibility (CORBA::tk_alias, sizeof (_oc_CORBA_Visibility), (char *) &_oc_CORBA_Visibility, 0, sizeof (CORBA::Visibility));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Visibility, &_tc_TAO_tc_CORBA_Visibility)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, PRIVATE_MEMBER, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, PUBLIC_MEMBER, 1)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ValueMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
  7, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

  7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
    11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
    CORBA::tk_short,


};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMember (CORBA::tk_struct, sizeof (_oc_CORBA_ValueMember), (char *) &_oc_CORBA_ValueMember, 0, sizeof (CORBA_ValueMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMember, &_tc_TAO_tc_CORBA_ValueMember)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_VALUEMEMBERSEQ_CS_

  void
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA_ValueMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA_ValueMember *old = ACE_reinterpret_cast (CORBA_ValueMember *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA_ValueMember *tmp = ACE_reinterpret_cast (CORBA_ValueMember *,this->buffer_);

    _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  }

  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq::~_TAO_Unbounded_Sequence_CORBA_ValueMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_VALUEMEMBERSEQ_CS_)
#define _CORBA_VALUEMEMBERSEQ_CS_

// *************************************************************
// CORBA_ValueMemberSeq
// *************************************************************

CORBA_ValueMemberSeq::CORBA_ValueMemberSeq (void)
{}
CORBA_ValueMemberSeq::CORBA_ValueMemberSeq (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
CORBA_ValueMemberSeq::CORBA_ValueMemberSeq (CORBA::ULong max, CORBA::ULong length, CORBA_ValueMember *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
CORBA_ValueMemberSeq::CORBA_ValueMemberSeq (const CORBA_ValueMemberSeq &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_CORBA_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
CORBA_ValueMemberSeq::~CORBA_ValueMemberSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_CORBA_ValueMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberSeq:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
  CORBA::tk_sequence, // typecode kind
  616, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
      12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
      7, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string,
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string,
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

      7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
        11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
        CORBA::tk_short,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMemberSeq (CORBA::tk_alias, sizeof (_oc_CORBA_ValueMemberSeq), (char *) &_oc_CORBA_ValueMemberSeq, 0, sizeof (CORBA_ValueMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberSeq, &_tc_TAO_tc_CORBA_ValueMemberSeq)
TAO_NAMESPACE_END
CORBA_ValueMemberDef_ptr CORBA_ValueMemberDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ValueMemberDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ValueMemberDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_ValueMemberDef::_nil ());
  if (is_a == 0)
    return CORBA_ValueMemberDef::_nil ();
  return CORBA_ValueMemberDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_ValueMemberDef_ptr CORBA_ValueMemberDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ValueMemberDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ValueMemberDef_ptr retv = _TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_ValueMemberDef_ptr retval = CORBA_ValueMemberDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_ValueMemberDef (stub),
                  CORBA_ValueMemberDef::_nil ());

  return retval;
}

CORBA_ValueMemberDef_ptr
CORBA_ValueMemberDef::_duplicate (CORBA_ValueMemberDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA::TypeCode_ptr CORBA_ValueMemberDef::type (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::TypeCode_ptr _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type",
      9,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_IDLType_ptr CORBA_ValueMemberDef::type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""type_def",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueMemberDef::type_def (
    CORBA_IDLType_ptr type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""type_def",
      13,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Visibility CORBA_ValueMemberDef::access (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Visibility _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""access",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueMemberDef::access (
    CORBA::Visibility access,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""access",
      11,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << access)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ValueMemberDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueMemberDef:1.0";
}

static const CORBA::Long _oc_CORBA_ValueMemberDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberDef:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657244), ACE_NTOHL (0x65660000),  // name = ValueMemberDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueMemberDef (CORBA::tk_objref, sizeof (_oc_CORBA_ValueMemberDef), (char *) &_oc_CORBA_ValueMemberDef, 0, sizeof (CORBA_ValueMemberDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberDef, &_tc_TAO_tc_CORBA_ValueMemberDef)
TAO_NAMESPACE_END
CORBA_ValueDef_ptr CORBA_ValueDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ValueDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ValueDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_ValueDef::_nil ());
  if (is_a == 0)
    return CORBA_ValueDef::_nil ();
  return CORBA_ValueDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_ValueDef_ptr CORBA_ValueDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ValueDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ValueDef_ptr retv = _TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_ValueDef_ptr retval = CORBA_ValueDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_ValueDef (stub),
                  CORBA_ValueDef::_nil ());

  return retval;
}

CORBA_ValueDef_ptr
CORBA_ValueDef::_duplicate (CORBA_ValueDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_InterfaceDef_ptr CORBA_ValueDef::supported_interface (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InterfaceDef_ptr _tao_retval = CORBA_InterfaceDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""supported_interface",
      24,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueDef::supported_interface (
    CORBA_InterfaceDef_ptr supported_interface,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""supported_interface",
      24,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << supported_interface)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_InitializerSeq * CORBA_ValueDef::initializers (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_InitializerSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_InitializerSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""initializers",
      17,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueDef::initializers (
    const CORBA_InitializerSeq & initializers,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""initializers",
      17,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << initializers)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_ValueDef_ptr CORBA_ValueDef::base_value (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueDef_ptr _tao_retval = CORBA_ValueDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""base_value",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueDef::base_value (
    CORBA_ValueDef_ptr base_value,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""base_value",
      15,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << base_value)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA_ValueDefSeq * CORBA_ValueDef::abstract_base_values (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueDefSeq* _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_ValueDefSeq, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""abstract_base_values",
      25,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueDef::abstract_base_values (
    const CORBA_ValueDefSeq & abstract_base_values,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""abstract_base_values",
      25,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << abstract_base_values)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ValueDef::is_abstract (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_abstract",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA_Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueDef::is_abstract (
    CORBA::Boolean is_abstract,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""is_abstract",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << CORBA_Any::from_boolean (is_abstract))
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ValueDef::is_custom (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_custom",
      14,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA_Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueDef::is_custom (
    CORBA::Boolean is_custom,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""is_custom",
      14,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << CORBA_Any::from_boolean (is_custom))
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ValueDef::is_truncatable (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_truncatable",
      19,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA_Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueDef::is_truncatable (
    CORBA::Boolean is_truncatable,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""is_truncatable",
      19,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << CORBA_Any::from_boolean (is_truncatable))
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ValueDef::is_a (
    const char * value_id,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << value_id)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA_Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

static const CORBA::Long _oc_CORBA_ValueDef_FullValueDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65662f46), ACE_NTOHL (0x756c6c56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ValueDef/FullValueDescription:1.0
  21, ACE_NTOHL (0x46756c6c), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = FullValueDescription
  15, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  2036, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1956, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1940, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f70), ACE_NTOHL (0x65726174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          164, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            148, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74496465), ACE_NTOHL (0x6e746966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length


            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        496, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          416, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            400, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x74657244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5061), ACE_NTOHL (0x72616d65), ACE_NTOHL (0x7465724d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        556, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          476, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            460, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e44), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              72, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string,
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string,
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  684, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    600, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      584, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x75746544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        6, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4174), ACE_NTOHL (0x74726962), ACE_NTOHL (0x7574654d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY


      0U,


  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  692, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ValueMemberSeq:1.0
    15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
    CORBA::tk_sequence, // typecode kind
    616, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      600, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueMember:1.0
        12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
        7, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string,
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        72, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string,
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string,
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        52, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType

        7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
          11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
          CORBA::tk_short,



      0U,


  13, ACE_NTOHL (0x696e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657273), ACE_NTOHL (0x0),  // name = initializers
  CORBA::tk_alias, // typecode kind for typedefs
  516, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/InitializerSeq:1.0
    15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = InitializerSeq
    CORBA::tk_sequence, // typecode kind
    440, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      424, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f496e), ACE_NTOHL (0x69746961), ACE_NTOHL (0x6c697a65), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/Initializer:1.0
        12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = Initializer
        1, // member count
        8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
        CORBA::tk_alias, // typecode kind for typedefs
        340, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/StructMemberSeq:1.0
          16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = StructMemberSeq
          CORBA::tk_sequence, // typecode kind
          264, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            248, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5374), ACE_NTOHL (0x72756374), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/StructMember:1.0
              13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = StructMember
              3, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string,
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              52, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4944), ACE_NTOHL (0x4c547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IDLType


            0U,



      0U,


  21, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636573), ACE_NTOHL (0x0),  // name = supported_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      0U,


  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      0U,


  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDef_FullValueDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ValueDef_FullValueDescription), (char *) &_oc_CORBA_ValueDef_FullValueDescription, 0, sizeof (CORBA_ValueDef::FullValueDescription));
CORBA::TypeCode_ptr CORBA_ValueDef::_tc_FullValueDescription = &_tc_TAO_tc_CORBA_ValueDef_FullValueDescription;

CORBA_ValueDef::FullValueDescription * CORBA_ValueDef::describe_value (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueDef::FullValueDescription* _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, CORBA_ValueDef::FullValueDescription, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_value",
      14,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_ValueMemberDef_ptr CORBA_ValueDef::create_value_member (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::Visibility access,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_ValueMemberDef_ptr _tao_retval = CORBA_ValueMemberDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_member",
      19,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << access)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_AttributeDef_ptr CORBA_ValueDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr type,
    CORBA::AttributeMode mode,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_AttributeDef_ptr _tao_retval = CORBA_AttributeDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << type) &&
          (_tao_out << mode)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA_OperationDef_ptr CORBA_ValueDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    CORBA_IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA_ParDescriptionSeq & params,
    const CORBA_ExceptionDefSeq & exceptions,
    const CORBA_ContextIdSeq & contexts,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_OperationDef_ptr _tao_retval = CORBA_OperationDef::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << id) &&
          (_tao_out << name) &&
          (_tao_out << version) &&
          (_tao_out << result) &&
          (_tao_out << mode) &&
          (_tao_out << params) &&
          (_tao_out << exceptions) &&
          (_tao_out << contexts)
      ))
      ACE_THROW_RETURN (CORBA_MARSHAL (), _tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean CORBA_ValueDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueDef:1.0";
}

static const CORBA::Long _oc_CORBA_ValueDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDef:1.0
  9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = ValueDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDef (CORBA::tk_objref, sizeof (_oc_CORBA_ValueDef), (char *) &_oc_CORBA_ValueDef, 0, sizeof (CORBA_ValueDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDef, &_tc_TAO_tc_CORBA_ValueDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ValueDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/ValueDescription:1.0
  17, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ValueDescription
  10, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5665), ACE_NTOHL (0x7273696f), ACE_NTOHL (0x6e537065), ACE_NTOHL (0x633a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string,
    0U, // string length

  20, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636500),  // name = supported_interface
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
  CORBA::tk_alias, // typecode kind for typedefs
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49645365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    88, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string,
        0U, // string length

      0U,


  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string,
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueDescription (CORBA::tk_struct, sizeof (_oc_CORBA_ValueDescription), (char *) &_oc_CORBA_ValueDescription, 0, sizeof (CORBA_ValueDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDescription, &_tc_TAO_tc_CORBA_ValueDescription)
TAO_NAMESPACE_END
CORBA_ValueBoxDef_ptr CORBA_ValueBoxDef::_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ValueBoxDef::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/ValueBoxDef:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (CORBA_ValueBoxDef::_nil ());
  if (is_a == 0)
    return CORBA_ValueBoxDef::_nil ();
  return CORBA_ValueBoxDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_ValueBoxDef_ptr CORBA_ValueBoxDef::_unchecked_narrow (
    CORBA_Object_ptr obj,
    CORBA_Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_ValueBoxDef::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  if (obj->_is_collocated () && _TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer != 0)
    {
      CORBA_ValueBoxDef_ptr retv = _TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer (obj);
      if (retv != 0)
        return retv;
    }

  CORBA_ValueBoxDef_ptr retval = CORBA_ValueBoxDef::_nil ();

  ACE_NEW_RETURN (retval,
                  CORBA_ValueBoxDef (stub),
                  CORBA_ValueBoxDef::_nil ());

  return retval;
}

CORBA_ValueBoxDef_ptr
CORBA_ValueBoxDef::_duplicate (CORBA_ValueBoxDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();
  return obj;
}

CORBA_IDLType_ptr CORBA_ValueBoxDef::original_type_def (
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA_IDLType_ptr _tao_retval = CORBA_IDLType::_nil ();


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA_INTERNAL (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""original_type_def",
      22,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA_MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void CORBA_ValueBoxDef::original_type_def (
    CORBA_IDLType_ptr original_type_def,
    CORBA_Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA_INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""original_type_def",
      22,
      istub->orb_core ()
    );


  for (;;)
  {
    _tao_call.start (ACE_TRY_ENV);
    ACE_CHECK;

    CORBA::Short flag = 131;

    _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag),
                              ACE_TRY_ENV);
    ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << original_type_def)
      ))
      ACE_THROW (CORBA_MARSHAL ());

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA_UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean CORBA_ValueBoxDef::_is_a (const CORBA::Char *value, CORBA_Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* CORBA_ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueBoxDef:1.0";
}

static const CORBA::Long _oc_CORBA_ValueBoxDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c756542), ACE_NTOHL (0x6f784465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/CORBA/ValueBoxDef:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65426f78), ACE_NTOHL (0x44656600),  // name = ValueBoxDef
};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueBoxDef (CORBA::tk_objref, sizeof (_oc_CORBA_ValueBoxDef), (char *) &_oc_CORBA_ValueBoxDef, 0, sizeof (CORBA_ValueBoxDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueBoxDef, &_tc_TAO_tc_CORBA_ValueBoxDef)
TAO_NAMESPACE_END
static const CORBA::Long _oc_CORBA_ValueModifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5661), ACE_NTOHL (0x6c75654d), ACE_NTOHL (0x6f646966), ACE_NTOHL (0x6965723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/ValueModifier:1.0
  14, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ValueModifier
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_CORBA_ValueModifier (CORBA::tk_alias, sizeof (_oc_CORBA_ValueModifier), (char *) &_oc_CORBA_ValueModifier, 0, sizeof (CORBA::ValueModifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueModifier, &_tc_TAO_tc_CORBA_ValueModifier)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_NONE, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_CUSTOM, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_ABSTRACT, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (CORBA)
TAO_NAMESPACE_DEFINE (const CORBA::Short, VM_TRUNCATABLE, 3)
TAO_NAMESPACE_END
void operator<<= (CORBA::Any &_tao_any, CORBA::DefinitionKind _tao_elem)
{
  CORBA::DefinitionKind *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::DefinitionKind (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_DefinitionKind,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::DefinitionKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_DefinitionKind, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::IRObject_ptr (*_TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::IRObject_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::IRObject::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_IRObject, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IRObject_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IRObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_IRObject, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::IRObject::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_IRObject,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::IRObject::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::IRObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::IRObject,CORBA::IRObject_var>;
  template class TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::IRObject,CORBA::IRObject_var>
#  pragma instantiate TAO_Object_Manager<CORBA::IRObject,CORBA::IRObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Contained_ptr (*_TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::Contained_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::Contained::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_Contained, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Contained_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Contained::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_Contained, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::Contained::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_Contained,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::Contained::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::Contained::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::Contained,CORBA::Contained_var>;
  template class TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::Contained,CORBA::Contained_var>
#  pragma instantiate TAO_Object_Manager<CORBA::Contained,CORBA::Contained_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::Contained::Description &_tao_elem) // copying
{
  CORBA::Contained::Description *_any_val = 0;
  ACE_NEW (_any_val, CORBA::Contained::Description (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::Contained::_tc_Description,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Contained::Description *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::Contained::_tc_Description,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Contained::Description *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::Contained::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Contained::Description *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Contained::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Contained::_tc_Description,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Contained::Description *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::Contained::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Contained::Description *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Contained::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::Contained::Description *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Contained::_tc_Description,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::Contained::Description *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::Contained::Description *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::Contained::Description *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InterfaceDefSeq &_tao_elem
  ) // copying
{
  CORBA::InterfaceDefSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::InterfaceDefSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_InterfaceDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDefSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_InterfaceDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_InterfaceDefSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InterfaceDefSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::InterfaceDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_InterfaceDefSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::InterfaceDefSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InterfaceDefSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::InterfaceDefSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::InterfaceDefSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::InterfaceDefSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueDefSeq &_tao_elem
  ) // copying
{
  CORBA::ValueDefSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ValueDefSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ValueDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDefSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ValueDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueDefSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueDefSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ValueDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueDefSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ValueDefSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueDefSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ValueDefSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ValueDefSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ValueDefSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ContainedSeq &_tao_elem
  ) // copying
{
  CORBA::ContainedSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ContainedSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ContainedSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ContainedSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ContainedSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ContainedSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ContainedSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ContainedSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ContainedSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ContainedSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ContainedSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ContainedSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ContainedSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ContainedSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ContainedSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ContainedSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ContainedSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ContainedSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ContainedSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::StructMember &_tao_elem) // copying
{
  CORBA::StructMember *_any_val = 0;
  ACE_NEW (_any_val, CORBA::StructMember (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_StructMember,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::StructMember *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_StructMember,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_StructMember, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::StructMember *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::StructMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_StructMember,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::StructMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_StructMember, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::StructMember *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::StructMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::StructMember *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_StructMember,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::StructMember *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::StructMember *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::StructMember *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::StructMemberSeq &_tao_elem
  ) // copying
{
  CORBA::StructMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::StructMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_StructMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::StructMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_StructMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_StructMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::StructMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::StructMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_StructMemberSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::StructMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_StructMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::StructMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::StructMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::StructMemberSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_StructMemberSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::StructMemberSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::StructMemberSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::StructMemberSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::Initializer &_tao_elem) // copying
{
  CORBA::Initializer *_any_val = 0;
  ACE_NEW (_any_val, CORBA::Initializer (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_Initializer,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Initializer *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_Initializer,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Initializer *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_Initializer, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Initializer *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Initializer, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_Initializer,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Initializer *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_Initializer, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Initializer *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Initializer, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::Initializer *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_Initializer,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::Initializer *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::Initializer *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::Initializer *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::InitializerSeq &_tao_elem
  ) // copying
{
  CORBA::InitializerSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::InitializerSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_InitializerSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InitializerSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_InitializerSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InitializerSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_InitializerSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InitializerSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InitializerSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InitializerSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::InitializerSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_InitializerSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InitializerSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InitializerSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::InitializerSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InitializerSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::InitializerSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::InitializerSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::InitializerSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::UnionMember &_tao_elem) // copying
{
  CORBA::UnionMember *_any_val = 0;
  ACE_NEW (_any_val, CORBA::UnionMember (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_UnionMember,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::UnionMember *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_UnionMember,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_UnionMember, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::UnionMember *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::UnionMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_UnionMember,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::UnionMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_UnionMember, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::UnionMember *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::UnionMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::UnionMember *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_UnionMember,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::UnionMember *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::UnionMember *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::UnionMember *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::UnionMemberSeq &_tao_elem
  ) // copying
{
  CORBA::UnionMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::UnionMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_UnionMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::UnionMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_UnionMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_UnionMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::UnionMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::UnionMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_UnionMemberSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::UnionMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_UnionMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::UnionMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::UnionMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::UnionMemberSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_UnionMemberSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::UnionMemberSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::UnionMemberSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::UnionMemberSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::EnumMemberSeq &_tao_elem
  ) // copying
{
  CORBA::EnumMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::EnumMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_EnumMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::EnumMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_EnumMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::EnumMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_EnumMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::EnumMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::EnumMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_EnumMemberSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::EnumMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_EnumMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::EnumMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::EnumMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::EnumMemberSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_EnumMemberSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::EnumMemberSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::EnumMemberSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::EnumMemberSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Container_ptr (*_TAO_collocation_CORBA_Container_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::Container_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::Container::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_Container, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Container::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_Container, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::Container::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_Container,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::Container::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::Container::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::Container,CORBA::Container_var>;
  template class TAO_Object_Manager<CORBA::Container,CORBA::Container_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::Container,CORBA::Container_var>
#  pragma instantiate TAO_Object_Manager<CORBA::Container,CORBA::Container_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::Container::Description &_tao_elem) // copying
{
  CORBA::Container::Description *_any_val = 0;
  ACE_NEW (_any_val, CORBA::Container::Description (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::Container::_tc_Description,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Container::Description *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::Container::_tc_Description,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container::Description *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::Container::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Container::Description *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Container::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Container::_tc_Description,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Container::Description *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::Container::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Container::Description *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Container::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::Container::Description *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Container::_tc_Description,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::Container::Description *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::Container::Description *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::Container::Description *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::Container::DescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::Container::DescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::Container::DescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::Container::_tc_DescriptionSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::Container::DescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::Container::_tc_DescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Container::DescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::Container::_tc_DescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Container::DescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Container::DescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Container::_tc_DescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::Container::DescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::Container::_tc_DescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::Container::DescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::Container::DescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::Container::DescriptionSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::Container::_tc_DescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::Container::DescriptionSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::Container::DescriptionSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::Container::DescriptionSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::IDLType_ptr (*_TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::IDLType_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::IDLType::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_IDLType, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::IDLType_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::IDLType::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_IDLType, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::IDLType::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_IDLType,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::IDLType::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::IDLType::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::IDLType,CORBA::IDLType_var>;
  template class TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::IDLType,CORBA::IDLType_var>
#  pragma instantiate TAO_Object_Manager<CORBA::IDLType,CORBA::IDLType_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, CORBA::PrimitiveKind _tao_elem)
{
  CORBA::PrimitiveKind *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::PrimitiveKind (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_PrimitiveKind,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PrimitiveKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_PrimitiveKind, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Repository_ptr (*_TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::Repository_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::Repository::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_Repository, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::Repository_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::Repository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_Repository, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::Repository::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_Repository,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::Repository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::Repository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::Repository,CORBA::Repository_var>;
  template class TAO_Object_Manager<CORBA::Repository,CORBA::Repository_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::Repository,CORBA::Repository_var>
#  pragma instantiate TAO_Object_Manager<CORBA::Repository,CORBA::Repository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ModuleDef_ptr (*_TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ModuleDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ModuleDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ModuleDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ModuleDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ModuleDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ModuleDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::ModuleDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ModuleDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::ModuleDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::ModuleDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::ModuleDef,CORBA::ModuleDef_var>;
  template class TAO_Object_Manager<CORBA::ModuleDef,CORBA::ModuleDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ModuleDef,CORBA::ModuleDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ModuleDef,CORBA::ModuleDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ModuleDescription &_tao_elem) // copying
{
  CORBA::ModuleDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::ModuleDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_ModuleDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ModuleDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ModuleDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ModuleDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ModuleDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ModuleDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ModuleDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ModuleDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ModuleDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ModuleDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ModuleDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ModuleDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ModuleDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ModuleDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ModuleDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ModuleDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ModuleDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::ConstantDef_ptr (*_TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ConstantDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ConstantDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ConstantDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ConstantDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ConstantDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ConstantDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::ConstantDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ConstantDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::ConstantDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::ConstantDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::ConstantDef,CORBA::ConstantDef_var>;
  template class TAO_Object_Manager<CORBA::ConstantDef,CORBA::ConstantDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ConstantDef,CORBA::ConstantDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ConstantDef,CORBA::ConstantDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ConstantDescription &_tao_elem) // copying
{
  CORBA::ConstantDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::ConstantDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_ConstantDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ConstantDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ConstantDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ConstantDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ConstantDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ConstantDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ConstantDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ConstantDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ConstantDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ConstantDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ConstantDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ConstantDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ConstantDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ConstantDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ConstantDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ConstantDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ConstantDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::TypedefDef_ptr (*_TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::TypedefDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::TypedefDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_TypedefDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::TypedefDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::TypedefDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_TypedefDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::TypedefDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_TypedefDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::TypedefDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::TypedefDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::TypedefDef,CORBA::TypedefDef_var>;
  template class TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::TypedefDef,CORBA::TypedefDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::TypedefDef,CORBA::TypedefDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::TypeDescription &_tao_elem) // copying
{
  CORBA::TypeDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::TypeDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_TypeDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::TypeDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_TypeDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::TypeDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_TypeDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::TypeDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::TypeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_TypeDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::TypeDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_TypeDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::TypeDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::TypeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::TypeDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_TypeDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::TypeDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::TypeDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::TypeDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::StructDef_ptr (*_TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::StructDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::StructDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_StructDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StructDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::StructDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_StructDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::StructDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_StructDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::StructDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::StructDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::StructDef,CORBA::StructDef_var>;
  template class TAO_Object_Manager<CORBA::StructDef,CORBA::StructDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::StructDef,CORBA::StructDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::StructDef,CORBA::StructDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::UnionDef_ptr (*_TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::UnionDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::UnionDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_UnionDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::UnionDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::UnionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_UnionDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::UnionDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_UnionDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::UnionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::UnionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::UnionDef,CORBA::UnionDef_var>;
  template class TAO_Object_Manager<CORBA::UnionDef,CORBA::UnionDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::UnionDef,CORBA::UnionDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::UnionDef,CORBA::UnionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::EnumDef_ptr (*_TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::EnumDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::EnumDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_EnumDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::EnumDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::EnumDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_EnumDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::EnumDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_EnumDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::EnumDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::EnumDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::EnumDef,CORBA::EnumDef_var>;
  template class TAO_Object_Manager<CORBA::EnumDef,CORBA::EnumDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::EnumDef,CORBA::EnumDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::EnumDef,CORBA::EnumDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::AliasDef_ptr (*_TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::AliasDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::AliasDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_AliasDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AliasDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::AliasDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_AliasDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::AliasDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_AliasDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::AliasDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::AliasDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::AliasDef,CORBA::AliasDef_var>;
  template class TAO_Object_Manager<CORBA::AliasDef,CORBA::AliasDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::AliasDef,CORBA::AliasDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::AliasDef,CORBA::AliasDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::PrimitiveDef_ptr (*_TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::PrimitiveDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::PrimitiveDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_PrimitiveDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::PrimitiveDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::PrimitiveDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_PrimitiveDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::PrimitiveDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_PrimitiveDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::PrimitiveDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::PrimitiveDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>;
  template class TAO_Object_Manager<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::PrimitiveDef,CORBA::PrimitiveDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::StringDef_ptr (*_TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::StringDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::StringDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_StringDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::StringDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::StringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_StringDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::StringDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_StringDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::StringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::StringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::StringDef,CORBA::StringDef_var>;
  template class TAO_Object_Manager<CORBA::StringDef,CORBA::StringDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::StringDef,CORBA::StringDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::StringDef,CORBA::StringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::WstringDef_ptr (*_TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::WstringDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::WstringDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_WstringDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::WstringDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::WstringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_WstringDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::WstringDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_WstringDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::WstringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::WstringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::WstringDef,CORBA::WstringDef_var>;
  template class TAO_Object_Manager<CORBA::WstringDef,CORBA::WstringDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::WstringDef,CORBA::WstringDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::WstringDef,CORBA::WstringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::FixedDef_ptr (*_TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::FixedDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::FixedDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_FixedDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::FixedDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::FixedDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_FixedDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::FixedDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_FixedDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::FixedDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::FixedDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::FixedDef,CORBA::FixedDef_var>;
  template class TAO_Object_Manager<CORBA::FixedDef,CORBA::FixedDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::FixedDef,CORBA::FixedDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::FixedDef,CORBA::FixedDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::SequenceDef_ptr (*_TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::SequenceDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::SequenceDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_SequenceDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::SequenceDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::SequenceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_SequenceDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::SequenceDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_SequenceDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::SequenceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::SequenceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::SequenceDef,CORBA::SequenceDef_var>;
  template class TAO_Object_Manager<CORBA::SequenceDef,CORBA::SequenceDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::SequenceDef,CORBA::SequenceDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::SequenceDef,CORBA::SequenceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ArrayDef_ptr (*_TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ArrayDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ArrayDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ArrayDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ArrayDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ArrayDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ArrayDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::ArrayDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ArrayDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::ArrayDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::ArrayDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::ArrayDef,CORBA::ArrayDef_var>;
  template class TAO_Object_Manager<CORBA::ArrayDef,CORBA::ArrayDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ArrayDef,CORBA::ArrayDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ArrayDef,CORBA::ArrayDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ExceptionDef_ptr (*_TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ExceptionDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ExceptionDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ExceptionDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExceptionDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ExceptionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ExceptionDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::ExceptionDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ExceptionDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::ExceptionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::ExceptionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::ExceptionDef,CORBA::ExceptionDef_var>;
  template class TAO_Object_Manager<CORBA::ExceptionDef,CORBA::ExceptionDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ExceptionDef,CORBA::ExceptionDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ExceptionDef,CORBA::ExceptionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ExceptionDescription &_tao_elem) // copying
{
  CORBA::ExceptionDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::ExceptionDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_ExceptionDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ExceptionDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ExceptionDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExceptionDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ExceptionDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExceptionDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExceptionDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExceptionDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ExceptionDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ExceptionDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExceptionDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExceptionDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ExceptionDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExceptionDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ExceptionDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ExceptionDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ExceptionDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::AttributeMode _tao_elem)
{
  CORBA::AttributeMode *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::AttributeMode (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_AttributeMode,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttributeMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_AttributeMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::AttributeDef_ptr (*_TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::AttributeDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::AttributeDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_AttributeDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttributeDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::AttributeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_AttributeDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::AttributeDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_AttributeDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::AttributeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::AttributeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::AttributeDef,CORBA::AttributeDef_var>;
  template class TAO_Object_Manager<CORBA::AttributeDef,CORBA::AttributeDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::AttributeDef,CORBA::AttributeDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::AttributeDef,CORBA::AttributeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::AttributeDescription &_tao_elem) // copying
{
  CORBA::AttributeDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::AttributeDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_AttributeDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::AttributeDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_AttributeDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttributeDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_AttributeDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::AttributeDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::AttributeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_AttributeDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::AttributeDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_AttributeDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::AttributeDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::AttributeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::AttributeDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_AttributeDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::AttributeDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::AttributeDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::AttributeDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::OperationMode _tao_elem)
{
  CORBA::OperationMode *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::OperationMode (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_OperationMode,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OperationMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_OperationMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ParameterMode _tao_elem)
{
  CORBA::ParameterMode *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ParameterMode (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_ParameterMode,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    // free allocated storage
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ParameterMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ParameterMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::ParameterDescription &_tao_elem) // copying
{
  CORBA::ParameterDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::ParameterDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_ParameterDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ParameterDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ParameterDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ParameterDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ParameterDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ParameterDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ParameterDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ParameterDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ParameterDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ParameterDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ParameterDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ParameterDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ParameterDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ParameterDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ParameterDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ParameterDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ParameterDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ParDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::ParDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ParDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ParDescriptionSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ParDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ParDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ParDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ParDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ParDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ParDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ParDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ParDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ParDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ParDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ParDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ParDescriptionSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ParDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ParDescriptionSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ParDescriptionSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ParDescriptionSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ContextIdSeq &_tao_elem
  ) // copying
{
  CORBA::ContextIdSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ContextIdSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ContextIdSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ContextIdSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ContextIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ContextIdSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ContextIdSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ContextIdSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ContextIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ContextIdSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ContextIdSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ContextIdSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ContextIdSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ContextIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ContextIdSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ContextIdSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ContextIdSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ContextIdSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ContextIdSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExceptionDefSeq &_tao_elem
  ) // copying
{
  CORBA::ExceptionDefSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ExceptionDefSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ExceptionDefSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ExceptionDefSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ExceptionDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExceptionDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ExceptionDefSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExceptionDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExceptionDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExceptionDefSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ExceptionDefSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ExceptionDefSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExceptionDefSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExceptionDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ExceptionDefSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExceptionDefSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ExceptionDefSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ExceptionDefSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ExceptionDefSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ExcDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::ExcDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ExcDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ExcDescriptionSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ExcDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ExcDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ExcDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ExcDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExcDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExcDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExcDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ExcDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ExcDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ExcDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ExcDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ExcDescriptionSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ExcDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ExcDescriptionSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ExcDescriptionSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ExcDescriptionSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::OperationDef_ptr (*_TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::OperationDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::OperationDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_OperationDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OperationDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::OperationDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_OperationDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::OperationDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_OperationDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::OperationDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::OperationDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::OperationDef,CORBA::OperationDef_var>;
  template class TAO_Object_Manager<CORBA::OperationDef,CORBA::OperationDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::OperationDef,CORBA::OperationDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::OperationDef,CORBA::OperationDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::OperationDescription &_tao_elem) // copying
{
  CORBA::OperationDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::OperationDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_OperationDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::OperationDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_OperationDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OperationDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_OperationDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::OperationDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::OperationDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_OperationDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::OperationDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_OperationDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::OperationDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::OperationDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::OperationDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_OperationDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::OperationDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::OperationDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::OperationDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::RepositoryIdSeq &_tao_elem
  ) // copying
{
  CORBA::RepositoryIdSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::RepositoryIdSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_RepositoryIdSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::RepositoryIdSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_RepositoryIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::RepositoryIdSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_RepositoryIdSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::RepositoryIdSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::RepositoryIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_RepositoryIdSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::RepositoryIdSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_RepositoryIdSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::RepositoryIdSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::RepositoryIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::RepositoryIdSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_RepositoryIdSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::RepositoryIdSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::RepositoryIdSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::RepositoryIdSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::OpDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::OpDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::OpDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_OpDescriptionSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::OpDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_OpDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::OpDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_OpDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::OpDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::OpDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_OpDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::OpDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_OpDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::OpDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::OpDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::OpDescriptionSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_OpDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::OpDescriptionSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::OpDescriptionSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::OpDescriptionSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::AttrDescriptionSeq &_tao_elem
  ) // copying
{
  CORBA::AttrDescriptionSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::AttrDescriptionSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_AttrDescriptionSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::AttrDescriptionSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_AttrDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::AttrDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_AttrDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::AttrDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::AttrDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_AttrDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::AttrDescriptionSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_AttrDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::AttrDescriptionSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::AttrDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::AttrDescriptionSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_AttrDescriptionSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::AttrDescriptionSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::AttrDescriptionSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::AttrDescriptionSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::InterfaceDef_ptr (*_TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::InterfaceDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_InterfaceDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::InterfaceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_InterfaceDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::InterfaceDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_InterfaceDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::InterfaceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::InterfaceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::InterfaceDef,CORBA::InterfaceDef_var>;
  template class TAO_Object_Manager<CORBA::InterfaceDef,CORBA::InterfaceDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::InterfaceDef,CORBA::InterfaceDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::InterfaceDef,CORBA::InterfaceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::InterfaceDef::FullInterfaceDescription &_tao_elem) // copying
{
  CORBA::InterfaceDef::FullInterfaceDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::InterfaceDef::FullInterfaceDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::InterfaceDef::_tc_FullInterfaceDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDef::FullInterfaceDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::InterfaceDef::_tc_FullInterfaceDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDef::FullInterfaceDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::InterfaceDef::_tc_FullInterfaceDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDef::FullInterfaceDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDef::FullInterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::InterfaceDef::_tc_FullInterfaceDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::InterfaceDef::FullInterfaceDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::InterfaceDef::_tc_FullInterfaceDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDef::FullInterfaceDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDef::FullInterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::InterfaceDef::FullInterfaceDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::InterfaceDef::_tc_FullInterfaceDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::InterfaceDef::FullInterfaceDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::InterfaceDef::FullInterfaceDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::InterfaceDef::FullInterfaceDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::InterfaceDescription &_tao_elem) // copying
{
  CORBA::InterfaceDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::InterfaceDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_InterfaceDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::InterfaceDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_InterfaceDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::InterfaceDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_InterfaceDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InterfaceDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::InterfaceDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_InterfaceDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::InterfaceDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::InterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::InterfaceDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_InterfaceDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::InterfaceDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::InterfaceDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::InterfaceDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::ValueMember &_tao_elem) // copying
{
  CORBA::ValueMember *_any_val = 0;
  ACE_NEW (_any_val, CORBA::ValueMember (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_ValueMember,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueMember *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ValueMember,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueMember, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueMember *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueMember,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ValueMember *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueMember, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueMember *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ValueMember *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueMember,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ValueMember *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ValueMember *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ValueMember *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const CORBA::ValueMemberSeq &_tao_elem
  ) // copying
{
  CORBA::ValueMemberSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, CORBA::ValueMemberSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    if (stream << *_tao_any_val)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ValueMemberSeq,
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_any_val,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK; 
    }
    else
    {
      delete _tao_any_val;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueMemberSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ValueMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueMemberSeq,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ValueMemberSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueMemberSeq, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueMemberSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ValueMemberSeq *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueMemberSeq,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ValueMemberSeq *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ValueMemberSeq *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ValueMemberSeq *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::ValueMemberDef_ptr (*_TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ValueMemberDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ValueMemberDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ValueMemberDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueMemberDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ValueMemberDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueMemberDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::ValueMemberDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ValueMemberDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::ValueMemberDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::ValueMemberDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>;
  template class TAO_Object_Manager<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ValueMemberDef,CORBA::ValueMemberDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::ValueDef_ptr (*_TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ValueDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ValueDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ValueDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::ValueDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ValueDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::ValueDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::ValueDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::ValueDef,CORBA::ValueDef_var>;
  template class TAO_Object_Manager<CORBA::ValueDef,CORBA::ValueDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ValueDef,CORBA::ValueDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ValueDef,CORBA::ValueDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const CORBA::ValueDef::FullValueDescription &_tao_elem) // copying
{
  CORBA::ValueDef::FullValueDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::ValueDef::FullValueDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::ValueDef::_tc_FullValueDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDef::FullValueDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::ValueDef::_tc_FullValueDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDef::FullValueDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::ValueDef::_tc_FullValueDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDef::FullValueDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDef::FullValueDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::ValueDef::_tc_FullValueDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ValueDef::FullValueDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::ValueDef::_tc_FullValueDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDef::FullValueDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDef::FullValueDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ValueDef::FullValueDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::ValueDef::_tc_FullValueDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ValueDef::FullValueDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ValueDef::FullValueDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ValueDef::FullValueDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const CORBA::ValueDescription &_tao_elem) // copying
{
  CORBA::ValueDescription *_any_val = 0;
  ACE_NEW (_any_val, CORBA::ValueDescription (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_any_val;
    _tao_any._tao_replace (
        CORBA::_tc_ValueDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _any_val,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, CORBA::ValueDescription *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    TAO_OutputCDR stream;
    stream << *_tao_elem;
    _tao_any._tao_replace (
        CORBA::_tc_ValueDescription,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        ACE_TRY_ENV
      );
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDescription *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueDescription,
            1,
            ACE_reinterpret_cast (void *, _tao_elem),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const CORBA::ValueDescription *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueDescription, ACE_TRY_ENV)) // not equal
      {
        _tao_elem = 0;
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (CORBA::ValueDescription *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, CORBA::ValueDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *(CORBA::ValueDescription *)_tao_elem)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            CORBA::_tc_ValueDescription,
            1,
            ACE_reinterpret_cast (void *, ACE_const_cast (CORBA::ValueDescription *&, _tao_elem)),
            ACE_TRY_ENV
          );
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete ACE_const_cast (CORBA::ValueDescription *&, _tao_elem);
        _tao_elem = 0;
      }
    }
  }
  ACE_CATCHANY
  {
    delete ACE_const_cast (CORBA::ValueDescription *&, _tao_elem);
    _tao_elem = 0;
    return 0; 
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::ValueBoxDef_ptr (*_TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, CORBA::ValueBoxDef_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = CORBA::ValueBoxDef::_duplicate (_tao_elem);
    TAO_OutputCDR stream;
    if (stream << *_tao_obj_ptr)
    {
      _tao_any._tao_replace (
          CORBA::_tc_ValueBoxDef, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          _tao_obj_ptr,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
    }
    else
    {
      delete _tao_obj_ptr;
    }
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA::ValueBoxDef_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA::ValueBoxDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_ValueBoxDef, ACE_TRY_ENV)) // not equal
      {
        delete tmp;
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    CORBA::Object_var _tao_obj_var;
    if (stream >> _tao_obj_var.out ())
    {
      _tao_elem = CORBA::ValueBoxDef::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_ValueBoxDef,
          1,
          tmp,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      return 1;
    }
    else    // failure
    {
      delete tmp;
    }
  }
  ACE_CATCHANY
  {
    delete tmp;
    _tao_elem = CORBA::ValueBoxDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA::ValueBoxDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Field_T<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>;
  template class TAO_Object_Manager<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Field_T<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>
#  pragma instantiate TAO_Object_Manager<CORBA::ValueBoxDef,CORBA::ValueBoxDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_InterfaceDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_InterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ValueDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ValueDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ContainedSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ContainedSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_StructMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_StructMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_InitializerSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_InitializerSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_UnionMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_UnionMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_EnumMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_EnumMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_Container::DescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_Container::DescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ParDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ParDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ContextIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ContextIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ExceptionDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ExceptionDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ExcDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ExcDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_RepositoryIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_OpDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_OpDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_AttrDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_AttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const CORBA_ValueMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    CORBA_ValueMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    return _tao_marshal_flag;
  }
  return 0; // error
}


#endif /* TAO_HAS_INTERFACE_REPOSITORY == 1 */
