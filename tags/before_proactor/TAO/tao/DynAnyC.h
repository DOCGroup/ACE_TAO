/* -*- C++ -*- */
// $Id$
// ============================================================================
//
// = LIBRARY
//    TAO
//
// = FILENAME
//    DynAnyC.h
//
// = AUTHOR
//
// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html
//
//
// Modified by Jeff Parsons <jp4@cs.wustl.edu>
//
// ============================================================================

#ifndef TAO_IDL_CORBA_DYNANYC_H_
#define TAO_IDL_CORBA_DYNANYC_H_

#include "tao/corbafwd.h"
#include "tao/Any.h"
#include "tao/ORB.h"
#include "tao/Object.h"
#include "tao/Sequence.h"
#include "tao/Sequence_T.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO
#if defined(_MSC_VER)
#pragma warning(disable:4250)
#endif /* _MSC_VER */


#if !defined (_CORBA_DYNANY___PTR_CH_)
#define _CORBA_DYNANY___PTR_CH_

class CORBA_DynAny;
typedef CORBA_DynAny *CORBA_DynAny_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY___VAR_CH_)
#define _CORBA_DYNANY___VAR_CH_

class  CORBA_DynAny_var
{
public:
  CORBA_DynAny_var (void); // default constructor
  CORBA_DynAny_var (CORBA_DynAny_ptr);
  CORBA_DynAny_var (const CORBA_DynAny_var &); // copy constructor
  ~CORBA_DynAny_var (void); // destructor

  CORBA_DynAny_var &operator= (CORBA_DynAny_ptr);
  CORBA_DynAny_var &operator= (const CORBA_DynAny_var &);
  CORBA_DynAny_ptr operator-> (void) const;

  operator const CORBA_DynAny_ptr &() const;
  operator CORBA_DynAny_ptr &();

  // in, inout, out, _retn
  CORBA_DynAny_ptr in (void) const;
  CORBA_DynAny_ptr &inout (void);
  CORBA_DynAny_ptr &out (void);
  CORBA_DynAny_ptr _retn (void);
  CORBA_DynAny_ptr ptr (void) const;

private:
  CORBA_DynAny_ptr ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY___OUT_CH_)
#define _CORBA_DYNANY___OUT_CH_

class  CORBA_DynAny_out
{
public:
  CORBA_DynAny_out (CORBA_DynAny_ptr &);
  CORBA_DynAny_out (CORBA_DynAny_var &);
  CORBA_DynAny_out (const CORBA_DynAny_out &);
  CORBA_DynAny_out &operator= (const CORBA_DynAny_out &);
  CORBA_DynAny_out &operator= (const CORBA_DynAny_var &);
  CORBA_DynAny_out &operator= (CORBA_DynAny_ptr);
  operator CORBA_DynAny_ptr &();
  CORBA_DynAny_ptr &ptr (void);
  CORBA_DynAny_ptr operator-> (void);

private:
  CORBA_DynAny_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_CH_)
#define _CORBA_DYNANY_CH_

class TAO_Export CORBA_DynAny : public virtual ACE_CORBA_1 (Object)
{
public:
  // the static operations
  static CORBA_DynAny_ptr _duplicate (CORBA_DynAny_ptr obj);
  static CORBA_DynAny_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  static CORBA_DynAny_ptr _nil (void);


#if !defined (_CORBA_DYNANY_INVALID___PTR_CH_)
#define _CORBA_DYNANY_INVALID___PTR_CH_

  class Invalid;
  typedef Invalid *Invalid_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_INVALID_CH_)
#define _CORBA_DYNANY_INVALID_CH_

  class TAO_Export Invalid : public CORBA::UserException
  {
  public:
    Invalid (void); // default ctor
    Invalid (const Invalid &); // copy ctor
    ~Invalid (void); // dtor
    Invalid &operator= (const Invalid &);


    virtual void _raise (void);

    static Invalid *_narrow (CORBA::Exception *);


    // = TAO extension
    static CORBA::Exception *_alloc (void);

  }; // exception CORBA_DynAny::Invalid

    static CORBA::TypeCode_ptr _tc_Invalid;


#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_INVALIDVALUE___PTR_CH_)
#define _CORBA_DYNANY_INVALIDVALUE___PTR_CH_

  class InvalidValue;
  typedef InvalidValue *InvalidValue_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_INVALIDVALUE_CH_)
#define _CORBA_DYNANY_INVALIDVALUE_CH_

  class TAO_Export InvalidValue : public CORBA::UserException
  {
  public:
    InvalidValue (void); // default ctor
    InvalidValue (const InvalidValue &); // copy ctor
    ~InvalidValue (void); // dtor
    InvalidValue &operator= (const InvalidValue &);


    virtual void _raise (void);

    static InvalidValue *_narrow (CORBA::Exception *);


    // = TAO extension
    static CORBA::Exception *_alloc (void);

  }; // exception CORBA_DynAny::InvalidValue

    static CORBA::TypeCode_ptr _tc_InvalidValue;


#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_TYPEMISMATCH___PTR_CH_)
#define _CORBA_DYNANY_TYPEMISMATCH___PTR_CH_

  class TypeMismatch;
  typedef TypeMismatch *TypeMismatch_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_TYPEMISMATCH_CH_)
#define _CORBA_DYNANY_TYPEMISMATCH_CH_

  class TAO_Export TypeMismatch : public CORBA::UserException
  {
  public:
    TypeMismatch (void); // default ctor
    TypeMismatch (const TypeMismatch &); // copy ctor
    ~TypeMismatch (void); // dtor
    TypeMismatch &operator= (const TypeMismatch &);


    virtual void _raise (void);

    static TypeMismatch *_narrow (CORBA::Exception *);


    // = TAO extension
    static CORBA::Exception *_alloc (void);

  }; // exception CORBA_DynAny::TypeMismatch

    static CORBA::TypeCode_ptr _tc_TypeMismatch;


#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_INVALIDSEQ___PTR_CH_)
#define _CORBA_DYNANY_INVALIDSEQ___PTR_CH_

  class InvalidSeq;
  typedef InvalidSeq *InvalidSeq_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNANY_INVALIDSEQ_CH_)
#define _CORBA_DYNANY_INVALIDSEQ_CH_

  class TAO_Export InvalidSeq : public CORBA::UserException
  {
  public:
    InvalidSeq (void); // default ctor
    InvalidSeq (const InvalidSeq &); // copy ctor
    ~InvalidSeq (void); // dtor
    InvalidSeq &operator= (const InvalidSeq &);


    virtual void _raise (void);

    static InvalidSeq *_narrow (CORBA::Exception *);


    // = TAO extension
    static CORBA::Exception *_alloc (void);

  }; // exception CORBA_DynAny::InvalidSeq

    static CORBA::TypeCode_ptr _tc_InvalidSeq;


#endif /* end #if !defined */

  virtual CORBA::TypeCode_ptr type (
      CORBA::Environment &_tao_environment =
      CORBA::Environment::default_environment ()
     );
  virtual void assign (
      CORBA_DynAny_ptr dyn_any,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void from_any (
      const CORBA::Any & value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Any * to_any (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void destroy (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA_DynAny_ptr copy (
      CORBA::Environment &_tao_environment =
      CORBA::Environment::default_environment ()
     );
  virtual void insert_boolean (
      CORBA::Boolean value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_octet (
      CORBA::Octet value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_char (
      CORBA::Char value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_short (
      CORBA::Short value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_ushort (
      CORBA::UShort value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_long (
      CORBA::Long value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_ulong (
      CORBA::ULong value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_float (
      CORBA::Float value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_double (
      CORBA::Double value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_string (
      const char * value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_reference (
      CORBA::Object_ptr value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_typecode (
      CORBA::TypeCode_ptr value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_longlong (
      CORBA::LongLong value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_ulonglong (
      CORBA::ULongLong value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_wchar (
      CORBA::WChar value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void insert_any (
      const CORBA::Any & value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean get_boolean (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Octet get_octet (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Char get_char (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Short get_short (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::UShort get_ushort (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Long get_long (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::ULong get_ulong (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Float get_float (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Double get_double (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual char * get_string (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Object_ptr get_reference (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::TypeCode_ptr get_typecode (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::LongLong get_longlong (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::ULongLong get_ulonglong (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::WChar get_wchar (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Any * get_any (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA_DynAny_ptr current_component (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean next (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean seek (
      CORBA::Long index,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void rewind (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  virtual const char* _interface_repository_id (void) const;
protected:
  CORBA_DynAny (void); // default constructor
  CORBA_DynAny (STUB_Object *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~CORBA_DynAny (void);
private:
  CORBA_DynAny (const CORBA_DynAny &);
  void operator= (const CORBA_DynAny &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_CORBA_DynAny;


#if !defined (_CORBA_DYNENUM___PTR_CH_)
#define _CORBA_DYNENUM___PTR_CH_

class CORBA_DynEnum;
typedef CORBA_DynEnum *CORBA_DynEnum_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNENUM___VAR_CH_)
#define _CORBA_DYNENUM___VAR_CH_

class  CORBA_DynEnum_var
{
public:
  CORBA_DynEnum_var (void); // default constructor
  CORBA_DynEnum_var (CORBA_DynEnum_ptr);
  CORBA_DynEnum_var (const CORBA_DynEnum_var &); // copy constructor
  ~CORBA_DynEnum_var (void); // destructor

  CORBA_DynEnum_var &operator= (CORBA_DynEnum_ptr);
  CORBA_DynEnum_var &operator= (const CORBA_DynEnum_var &);
  CORBA_DynEnum_ptr operator-> (void) const;

  operator const CORBA_DynEnum_ptr &() const;
  operator CORBA_DynEnum_ptr &();
  // in, inout, out, _retn
  CORBA_DynEnum_ptr in (void) const;
  CORBA_DynEnum_ptr &inout (void);
  CORBA_DynEnum_ptr &out (void);
  CORBA_DynEnum_ptr _retn (void);
  CORBA_DynEnum_ptr ptr (void) const;

private:
  CORBA_DynEnum_ptr ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNENUM___OUT_CH_)
#define _CORBA_DYNENUM___OUT_CH_

class  CORBA_DynEnum_out
{
public:
  CORBA_DynEnum_out (CORBA_DynEnum_ptr &);
  CORBA_DynEnum_out (CORBA_DynEnum_var &);
  CORBA_DynEnum_out (const CORBA_DynEnum_out &);
  CORBA_DynEnum_out &operator= (const CORBA_DynEnum_out &);
  CORBA_DynEnum_out &operator= (const CORBA_DynEnum_var &);
  CORBA_DynEnum_out &operator= (CORBA_DynEnum_ptr);
  operator CORBA_DynEnum_ptr &();
  CORBA_DynEnum_ptr &ptr (void);
  CORBA_DynEnum_ptr operator-> (void);

private:
  CORBA_DynEnum_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNENUM_CH_)
#define _CORBA_DYNENUM_CH_

class TAO_Export CORBA_DynEnum: public virtual CORBA_DynAny
{
public:
  // the static operations
  static CORBA_DynEnum_ptr _duplicate (CORBA_DynEnum_ptr obj);
  static CORBA_DynEnum_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  static CORBA_DynEnum_ptr _nil (void);

  virtual char * value_as_string (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void value_as_string (
      const char * value_as_string,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::ULong value_as_ulong (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void value_as_ulong (
      CORBA::ULong value_as_ulong,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  virtual const char* _interface_repository_id (void) const;
protected:
  CORBA_DynEnum (void); // default constructor
  CORBA_DynEnum (STUB_Object *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~CORBA_DynEnum (void);
private:
  CORBA_DynEnum (const CORBA_DynEnum &);
  void operator= (const CORBA_DynEnum &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_CORBA_DynEnum;

typedef char * FieldName;
typedef CORBA::String_var FieldName_var;
typedef CORBA::String_out FieldName_out;
extern  CORBA::TypeCode_ptr  _tc_FieldName;

struct  NameValuePair
{
  FieldName_var id;
  CORBA::Any value;
};

class  NameValuePair_var
{
public:
  NameValuePair_var (void); // default constructor
  NameValuePair_var (NameValuePair *);
  NameValuePair_var (const NameValuePair_var &); // copy constructor
  ~NameValuePair_var (void); // destructor

  NameValuePair_var &operator= (NameValuePair *);
  NameValuePair_var &operator= (const NameValuePair_var &);
  NameValuePair *operator-> (void);
  const NameValuePair *operator-> (void) const;

  operator const NameValuePair &() const;
  operator NameValuePair &();
  operator NameValuePair &() const;
  // in, inout, out, _retn
  const NameValuePair &in (void) const;
  NameValuePair &inout (void);
  NameValuePair *&out (void);
  NameValuePair *_retn (void);
  NameValuePair *ptr (void) const;

private:
  NameValuePair *ptr_;
};

class  NameValuePair_out
{
public:
  NameValuePair_out (NameValuePair *&);
  NameValuePair_out (NameValuePair_var &);
  NameValuePair_out (const NameValuePair_out &);
  NameValuePair_out &operator= (const NameValuePair_out &);
  NameValuePair_out &operator= (NameValuePair *);
  operator NameValuePair *&();
  NameValuePair *&ptr (void);
  NameValuePair *operator-> (void);

private:
  NameValuePair *&ptr_;
  // assignment from T_var not allowed
  void operator= (const NameValuePair_var &);
};

extern  CORBA::TypeCode_ptr  _tc_NameValuePair;


#if !defined (__TAO_UNBOUNDED_SEQUENCE_NAMEVALUEPAIRSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_NAMEVALUEPAIRSEQ_CH_

class _TAO_Unbounded_Sequence_NameValuePairSeq : public TAO_Unbounded_Base_Sequence
{
public:
  // = Initialization and termination methods.

  _TAO_Unbounded_Sequence_NameValuePairSeq (void) // Default constructor.
  {
  }

  _TAO_Unbounded_Sequence_NameValuePairSeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, allocbuf (maximum))
  {
  }

  _TAO_Unbounded_Sequence_NameValuePairSeq (CORBA::ULong maximum,
    CORBA::ULong length,
    NameValuePair *data,
    CORBA::Boolean release = 0)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }

  _TAO_Unbounded_Sequence_NameValuePairSeq (const _TAO_Unbounded_Sequence_NameValuePairSeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    NameValuePair *tmp1 = allocbuf (this->maximum_);
    NameValuePair * const tmp2 = ACE_reinterpret_cast (NameValuePair * ACE_CAST_CONST, rhs.buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];

    this->buffer_ = tmp1;
  }

  _TAO_Unbounded_Sequence_NameValuePairSeq &operator= (const _TAO_Unbounded_Sequence_NameValuePairSeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;

    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        NameValuePair *tmp = ACE_reinterpret_cast (NameValuePair *, this->buffer_);
        freebuf (tmp);
        this->buffer_ = allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = allocbuf (rhs.maximum_);

    TAO_Unbounded_Base_Sequence::operator= (rhs);

    NameValuePair *tmp1 = ACE_reinterpret_cast (NameValuePair *, this->buffer_);
    NameValuePair * const tmp2 = ACE_reinterpret_cast (NameValuePair * ACE_CAST_CONST, rhs.buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];

    return *this;
  }

  ~_TAO_Unbounded_Sequence_NameValuePairSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }

  // = Accessors.
  NameValuePair &operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    NameValuePair* tmp = ACE_reinterpret_cast(NameValuePair*,this->buffer_);
    return tmp[i];
  }

  const NameValuePair &operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    NameValuePair * const tmp = ACE_reinterpret_cast (NameValuePair* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }

  // = Static operations.
  static NameValuePair *allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    return new NameValuePair[size];
  }

  static void freebuf (NameValuePair *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }

  virtual void _allocate_buffer (CORBA::ULong length)
  {
    NameValuePair* tmp = allocbuf (length);

    if (this->buffer_ != 0)
    {
      NameValuePair *old = ACE_reinterpret_cast (NameValuePair *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        freebuf (old);

    }
    this->buffer_ = tmp;
  }

  virtual void _deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    NameValuePair *tmp = ACE_reinterpret_cast (NameValuePair *,this->buffer_);

    freebuf (tmp);
    this->buffer_ = 0;
  }

  // Implement the TAO_Base_Sequence methods (see Sequence.h)

  NameValuePair *get_buffer (CORBA::Boolean orphan = 0)
  {
    NameValuePair *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = allocbuf (this->length_);
        this->buffer_ = result;
      }
      else
      {
        result = ACE_reinterpret_cast (NameValuePair*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(NameValuePair*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }

  const NameValuePair *get_buffer (void) const
  {
    return ACE_reinterpret_cast(const NameValuePair * ACE_CAST_CONST, this->buffer_);
  }

  void replace (CORBA::ULong max,
  CORBA::ULong length,
  NameValuePair *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      NameValuePair *tmp = ACE_reinterpret_cast(NameValuePair*,this->buffer_);
      freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }

};

#endif /* end #if !defined */


#if !defined (_NAMEVALUEPAIRSEQ_CH_)
#define _NAMEVALUEPAIRSEQ_CH_

// *************************************************************
// NameValuePairSeq
// *************************************************************

class TAO_Export NameValuePairSeq : public
#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) \
       || !defined (ACE_HAS_TEMPLATE_SPECIALIZATION)
  _TAO_Unbounded_Sequence_NameValuePairSeq
#else /* AHETI */
  TAO_Unbounded_Sequence<NameValuePair>
#endif /* AHETI */
{
public:
  NameValuePairSeq (void); // default ctor
  NameValuePairSeq (CORBA::ULong max); // uses max size
  NameValuePairSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    NameValuePair *buffer,
    CORBA::Boolean release=0
  );
  NameValuePairSeq (const NameValuePairSeq &); // copy ctor
  ~NameValuePairSeq (void); // dtor
};
typedef NameValuePairSeq *NameValuePairSeq_ptr;

#endif /* end #if !defined */


#if !defined (_NAMEVALUEPAIRSEQ___VAR_CH_)
#define _NAMEVALUEPAIRSEQ___VAR_CH_

// *************************************************************
// class NameValuePairSeq_var
// *************************************************************

class  NameValuePairSeq_var
{
public:
  NameValuePairSeq_var (void); // default constructor
  NameValuePairSeq_var (NameValuePairSeq *);
  NameValuePairSeq_var (const NameValuePairSeq_var &); // copy constructor
  ~NameValuePairSeq_var (void); // destructor

  NameValuePairSeq_var &operator= (NameValuePairSeq *);
  NameValuePairSeq_var &operator= (const NameValuePairSeq_var &);
  NameValuePairSeq *operator-> (void);
  const NameValuePairSeq *operator-> (void) const;

  operator const NameValuePairSeq &() const;
  operator NameValuePairSeq &();
  operator NameValuePairSeq &() const;
  NameValuePair &operator[] (CORBA::ULong index);
  // in, inout, out, _retn
  const NameValuePairSeq &in (void) const;
  NameValuePairSeq &inout (void);
  NameValuePairSeq *&out (void);
  NameValuePairSeq *_retn (void);
  NameValuePairSeq *ptr (void) const;

private:
  NameValuePairSeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_NAMEVALUEPAIRSEQ___OUT_CH_)
#define _NAMEVALUEPAIRSEQ___OUT_CH_

class  NameValuePairSeq_out
{
public:
  NameValuePairSeq_out (NameValuePairSeq *&);
  NameValuePairSeq_out (NameValuePairSeq_var &);
  NameValuePairSeq_out (const NameValuePairSeq_out &);
  NameValuePairSeq_out &operator= (const NameValuePairSeq_out &);
  NameValuePairSeq_out &operator= (NameValuePairSeq *);
  operator NameValuePairSeq *&();
  NameValuePairSeq *&ptr (void);
  NameValuePairSeq *operator-> (void);
  NameValuePair &operator[] (CORBA::ULong index);

private:
  NameValuePairSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const NameValuePairSeq_var &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_NameValuePairSeq;


#if !defined (_CORBA_DYNSTRUCT___PTR_CH_)
#define _CORBA_DYNSTRUCT___PTR_CH_

class CORBA_DynStruct;
typedef CORBA_DynStruct *CORBA_DynStruct_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNSTRUCT___VAR_CH_)
#define _CORBA_DYNSTRUCT___VAR_CH_

class  CORBA_DynStruct_var
{
public:
  CORBA_DynStruct_var (void); // default constructor
  CORBA_DynStruct_var (CORBA_DynStruct_ptr);
  CORBA_DynStruct_var (const CORBA_DynStruct_var &); // copy constructor
  ~CORBA_DynStruct_var (void); // destructor

  CORBA_DynStruct_var &operator= (CORBA_DynStruct_ptr);
  CORBA_DynStruct_var &operator= (const CORBA_DynStruct_var &);
  CORBA_DynStruct_ptr operator-> (void) const;

  operator const CORBA_DynStruct_ptr &() const;
  operator CORBA_DynStruct_ptr &();
  // in, inout, out, _retn
  CORBA_DynStruct_ptr in (void) const;
  CORBA_DynStruct_ptr &inout (void);
  CORBA_DynStruct_ptr &out (void);
  CORBA_DynStruct_ptr _retn (void);
  CORBA_DynStruct_ptr ptr (void) const;

private:
  CORBA_DynStruct_ptr ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNSTRUCT___OUT_CH_)
#define _CORBA_DYNSTRUCT___OUT_CH_

class  CORBA_DynStruct_out
{
public:
  CORBA_DynStruct_out (CORBA_DynStruct_ptr &);
  CORBA_DynStruct_out (CORBA_DynStruct_var &);
  CORBA_DynStruct_out (const CORBA_DynStruct_out &);
  CORBA_DynStruct_out &operator= (const CORBA_DynStruct_out &);
  CORBA_DynStruct_out &operator= (const CORBA_DynStruct_var &);
  CORBA_DynStruct_out &operator= (CORBA_DynStruct_ptr);
  operator CORBA_DynStruct_ptr &();
  CORBA_DynStruct_ptr &ptr (void);
  CORBA_DynStruct_ptr operator-> (void);

private:
  CORBA_DynStruct_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNSTRUCT_CH_)
#define _CORBA_DYNSTRUCT_CH_

class TAO_Export CORBA_DynStruct: public virtual CORBA_DynAny
{
public:
  // the static operations
  static CORBA_DynStruct_ptr _duplicate (CORBA_DynStruct_ptr obj);
  static CORBA_DynStruct_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  static CORBA_DynStruct_ptr _nil (void);

  virtual char * current_member_name (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::TCKind current_member_kind (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual NameValuePairSeq * get_members (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void set_members (
      const NameValuePairSeq & value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  virtual const char* _interface_repository_id (void) const;
protected:
  CORBA_DynStruct (void); // default constructor
  CORBA_DynStruct (STUB_Object *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~CORBA_DynStruct (void);
private:
  CORBA_DynStruct (const CORBA_DynStruct &);
  void operator= (const CORBA_DynStruct &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_CORBA_DynStruct;


#if !defined (_CORBA_DYNUNION___PTR_CH_)
#define _CORBA_DYNUNION___PTR_CH_

class CORBA_DynUnion;
typedef CORBA_DynUnion *CORBA_DynUnion_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNUNION___VAR_CH_)
#define _CORBA_DYNUNION___VAR_CH_

class  CORBA_DynUnion_var
{
public:
  CORBA_DynUnion_var (void); // default constructor
  CORBA_DynUnion_var (CORBA_DynUnion_ptr);
  CORBA_DynUnion_var (const CORBA_DynUnion_var &); // copy constructor
  ~CORBA_DynUnion_var (void); // destructor

  CORBA_DynUnion_var &operator= (CORBA_DynUnion_ptr);
  CORBA_DynUnion_var &operator= (const CORBA_DynUnion_var &);
  CORBA_DynUnion_ptr operator-> (void) const;

  operator const CORBA_DynUnion_ptr &() const;
  operator CORBA_DynUnion_ptr &();
  // in, inout, out, _retn
  CORBA_DynUnion_ptr in (void) const;
  CORBA_DynUnion_ptr &inout (void);
  CORBA_DynUnion_ptr &out (void);
  CORBA_DynUnion_ptr _retn (void);
  CORBA_DynUnion_ptr ptr (void) const;

private:
  CORBA_DynUnion_ptr ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNUNION___OUT_CH_)
#define _CORBA_DYNUNION___OUT_CH_

class  CORBA_DynUnion_out
{
public:
  CORBA_DynUnion_out (CORBA_DynUnion_ptr &);
  CORBA_DynUnion_out (CORBA_DynUnion_var &);
  CORBA_DynUnion_out (const CORBA_DynUnion_out &);
  CORBA_DynUnion_out &operator= (const CORBA_DynUnion_out &);
  CORBA_DynUnion_out &operator= (const CORBA_DynUnion_var &);
  CORBA_DynUnion_out &operator= (CORBA_DynUnion_ptr);
  operator CORBA_DynUnion_ptr &();
  CORBA_DynUnion_ptr &ptr (void);
  CORBA_DynUnion_ptr operator-> (void);

private:
  CORBA_DynUnion_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNUNION_CH_)
#define _CORBA_DYNUNION_CH_

class TAO_Export CORBA_DynUnion: public virtual CORBA_DynAny
{
public:
  // the static operations
  static CORBA_DynUnion_ptr _duplicate (CORBA_DynUnion_ptr obj);
  static CORBA_DynUnion_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  static CORBA_DynUnion_ptr _nil (void);

  virtual CORBA::Boolean set_as_default (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void set_as_default (
      CORBA::Boolean set_as_default,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA_DynAny_ptr discriminator (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::TCKind discriminator_kind (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA_DynAny_ptr member (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual char * member_name (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void member_name (
      const char * member_name,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::TCKind member_kind (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  virtual const char* _interface_repository_id (void) const;
protected:
  CORBA_DynUnion (void); // default constructor
  CORBA_DynUnion (STUB_Object *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~CORBA_DynUnion (void);
private:
  CORBA_DynUnion (const CORBA_DynUnion &);
  void operator= (const CORBA_DynUnion &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_CORBA_DynUnion;


#if !defined (__TAO_UNBOUNDED_SEQUENCE_ANYSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_ANYSEQ_CH_

class _TAO_Unbounded_Sequence_AnySeq : public TAO_Unbounded_Base_Sequence
{
public:
  // = Initialization and termination methods.

  _TAO_Unbounded_Sequence_AnySeq (void) // Default constructor.
  {
  }

  _TAO_Unbounded_Sequence_AnySeq (CORBA::ULong maximum) // Constructor using a maximum length value.
    : TAO_Unbounded_Base_Sequence (maximum, allocbuf (maximum))
  {
  }

  _TAO_Unbounded_Sequence_AnySeq (CORBA::ULong maximum,
    CORBA::ULong length,
    CORBA::Any *data,
    CORBA::Boolean release = 0)
  : TAO_Unbounded_Base_Sequence (maximum, length, data, release)
  {
  }

  _TAO_Unbounded_Sequence_AnySeq (const _TAO_Unbounded_Sequence_AnySeq &rhs)
  // Copy constructor.
    : TAO_Unbounded_Base_Sequence (rhs)
  {
    CORBA::Any *tmp1 = allocbuf (this->maximum_);
    CORBA::Any * const tmp2 = ACE_reinterpret_cast (CORBA::Any * ACE_CAST_CONST, rhs.buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];

    this->buffer_ = tmp1;
  }

  _TAO_Unbounded_Sequence_AnySeq &operator= (const _TAO_Unbounded_Sequence_AnySeq &rhs)
  // Assignment operator.
  {
    if (this == &rhs)
      return *this;

    if (this->release_)
    {
      if (this->maximum_ < rhs.maximum_)
      {
        // free the old buffer
        CORBA::Any *tmp = ACE_reinterpret_cast (CORBA::Any *, this->buffer_);
        freebuf (tmp);
        this->buffer_ = allocbuf (rhs.maximum_);
      }
    }
    else
      this->buffer_ = allocbuf (rhs.maximum_);

    TAO_Unbounded_Base_Sequence::operator= (rhs);

    CORBA::Any *tmp1 = ACE_reinterpret_cast (CORBA::Any *, this->buffer_);
    CORBA::Any * const tmp2 = ACE_reinterpret_cast (CORBA::Any * ACE_CAST_CONST, rhs.buffer_);

    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp1[i] = tmp2[i];

    return *this;
  }

  ~_TAO_Unbounded_Sequence_AnySeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }

  // = Accessors.
  CORBA::Any &operator[] (CORBA::ULong i)
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    CORBA::Any* tmp = ACE_reinterpret_cast(CORBA::Any*,this->buffer_);
    return tmp[i];
  }

  const CORBA::Any &operator[] (CORBA::ULong i) const
  // operator []
  {
    ACE_ASSERT (i < this->maximum_);
    CORBA::Any * const tmp = ACE_reinterpret_cast (CORBA::Any* ACE_CAST_CONST, this->buffer_);
    return tmp[i];
  }

  // = Static operations.
  static CORBA::Any *allocbuf (CORBA::ULong size)
  // Allocate storage for the sequence.
  {
    return new CORBA::Any[size];
  }

  static void freebuf (CORBA::Any *buffer)
  // Free the sequence.
  {
    delete [] buffer;
  }

  virtual void _allocate_buffer (CORBA::ULong length)
  {
    CORBA::Any* tmp = allocbuf (length);

    if (this->buffer_ != 0)
    {
      CORBA::Any *old = ACE_reinterpret_cast (CORBA::Any *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        freebuf (old);

    }
    this->buffer_ = tmp;
  }

  virtual void _deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    CORBA::Any *tmp = ACE_reinterpret_cast (CORBA::Any *,this->buffer_);

    freebuf (tmp);
    this->buffer_ = 0;
  }

  // Implement the TAO_Base_Sequence methods (see Sequence.h)

  CORBA::Any *get_buffer (CORBA::Boolean orphan = 0)
  {
    CORBA::Any *result = 0;
    if (orphan == 0)
    {
      // We retain ownership.
      if (this->buffer_ == 0)
      {
        result = allocbuf (this->length_);
        this->buffer_ = result;
      }
      else
      {
        result = ACE_reinterpret_cast (CORBA::Any*, this->buffer_);
      }
    }
    else // if (orphan == 1)
    {
      if (this->release_ != 0)
      {
        // We set the state back to default and relinquish
        // ownership.
        result = ACE_reinterpret_cast(CORBA::Any*,this->buffer_);
        this->maximum_ = 0;
        this->length_ = 0;
        this->buffer_ = 0;
        this->release_ = 0;
      }
    }
    return result;
  }

  const CORBA::Any *get_buffer (void) const
  {
    return ACE_reinterpret_cast(const CORBA::Any * ACE_CAST_CONST, this->buffer_);
  }

  void replace (CORBA::ULong max,
  CORBA::ULong length,
  CORBA::Any *data,
  CORBA::Boolean release)
  {
    this->maximum_ = max;
    this->length_ = length;
    if (this->buffer_ && this->release_ == 1)
    {
      CORBA::Any *tmp = ACE_reinterpret_cast(CORBA::Any*,this->buffer_);
      freebuf (tmp);
    }
    this->buffer_ = data;
    this->release_ = release;
  }

};

#endif /* end #if !defined */


#if !defined (_ANYSEQ_CH_)
#define _ANYSEQ_CH_

// *************************************************************
// AnySeq
// *************************************************************

class TAO_Export AnySeq : public
#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) \
       || !defined (ACE_HAS_TEMPLATE_SPECIALIZATION)
  _TAO_Unbounded_Sequence_AnySeq
#else /* AHETI */
  TAO_Unbounded_Sequence<CORBA::Any>
#endif /* AHETI */
{
public:
  AnySeq (void); // default ctor
  AnySeq (CORBA::ULong max); // uses max size
  AnySeq (
    CORBA::ULong max,
    CORBA::ULong length,
    CORBA::Any *buffer,
    CORBA::Boolean release=0
  );
  AnySeq (const AnySeq &); // copy ctor
  ~AnySeq (void); // dtor
};
typedef AnySeq *AnySeq_ptr;

#endif /* end #if !defined */


#if !defined (_ANYSEQ___VAR_CH_)
#define _ANYSEQ___VAR_CH_

// *************************************************************
// class AnySeq_var
// *************************************************************

class  AnySeq_var
{
public:
  AnySeq_var (void); // default constructor
  AnySeq_var (AnySeq *);
  AnySeq_var (const AnySeq_var &); // copy constructor
  ~AnySeq_var (void); // destructor

  AnySeq_var &operator= (AnySeq *);
  AnySeq_var &operator= (const AnySeq_var &);
  AnySeq *operator-> (void);
  const AnySeq *operator-> (void) const;

  operator const AnySeq &() const;
  operator AnySeq &();
  operator AnySeq &() const;
  CORBA::Any &operator[] (CORBA::ULong index);
  // in, inout, out, _retn
  const AnySeq &in (void) const;
  AnySeq &inout (void);
  AnySeq *&out (void);
  AnySeq *_retn (void);
  AnySeq *ptr (void) const;

private:
  AnySeq *ptr_;
};


#endif /* end #if !defined */


#if !defined (_ANYSEQ___OUT_CH_)
#define _ANYSEQ___OUT_CH_

class  AnySeq_out
{
public:
  AnySeq_out (AnySeq *&);
  AnySeq_out (AnySeq_var &);
  AnySeq_out (const AnySeq_out &);
  AnySeq_out &operator= (const AnySeq_out &);
  AnySeq_out &operator= (AnySeq *);
  operator AnySeq *&();
  AnySeq *&ptr (void);
  AnySeq *operator-> (void);
  CORBA::Any &operator[] (CORBA::ULong index);

private:
  AnySeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const AnySeq_var &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_AnySeq;


#if !defined (_CORBA_DYNSEQUENCE___PTR_CH_)
#define _CORBA_DYNSEQUENCE___PTR_CH_

class CORBA_DynSequence;
typedef CORBA_DynSequence *CORBA_DynSequence_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNSEQUENCE___VAR_CH_)
#define _CORBA_DYNSEQUENCE___VAR_CH_

class  CORBA_DynSequence_var
{
public:
  CORBA_DynSequence_var (void); // default constructor
  CORBA_DynSequence_var (CORBA_DynSequence_ptr);
  CORBA_DynSequence_var (const CORBA_DynSequence_var &); // copy constructor
  ~CORBA_DynSequence_var (void); // destructor

  CORBA_DynSequence_var &operator= (CORBA_DynSequence_ptr);
  CORBA_DynSequence_var &operator= (const CORBA_DynSequence_var &);
  CORBA_DynSequence_ptr operator-> (void) const;

  operator const CORBA_DynSequence_ptr &() const;
  operator CORBA_DynSequence_ptr &();
  // in, inout, out, _retn
  CORBA_DynSequence_ptr in (void) const;
  CORBA_DynSequence_ptr &inout (void);
  CORBA_DynSequence_ptr &out (void);
  CORBA_DynSequence_ptr _retn (void);
  CORBA_DynSequence_ptr ptr (void) const;

private:
  CORBA_DynSequence_ptr ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNSEQUENCE___OUT_CH_)
#define _CORBA_DYNSEQUENCE___OUT_CH_

class  CORBA_DynSequence_out
{
public:
  CORBA_DynSequence_out (CORBA_DynSequence_ptr &);
  CORBA_DynSequence_out (CORBA_DynSequence_var &);
  CORBA_DynSequence_out (const CORBA_DynSequence_out &);
  CORBA_DynSequence_out &operator= (const CORBA_DynSequence_out &);
  CORBA_DynSequence_out &operator= (const CORBA_DynSequence_var &);
  CORBA_DynSequence_out &operator= (CORBA_DynSequence_ptr);
  operator CORBA_DynSequence_ptr &();
  CORBA_DynSequence_ptr &ptr (void);
  CORBA_DynSequence_ptr operator-> (void);

private:
  CORBA_DynSequence_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNSEQUENCE_CH_)
#define _CORBA_DYNSEQUENCE_CH_

class TAO_Export CORBA_DynSequence: public virtual CORBA_DynAny
{
public:
  // the static operations
  static CORBA_DynSequence_ptr _duplicate (CORBA_DynSequence_ptr obj);
  static CORBA_DynSequence_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  static CORBA_DynSequence_ptr _nil (void);

  virtual CORBA::ULong length (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void length (
      CORBA::ULong length,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual AnySeq * get_elements (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void set_elements (
      const AnySeq & value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  virtual const char* _interface_repository_id (void) const;
protected:
  CORBA_DynSequence (void); // default constructor
  CORBA_DynSequence (STUB_Object *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~CORBA_DynSequence (void);
private:
  CORBA_DynSequence (const CORBA_DynSequence &);
  void operator= (const CORBA_DynSequence &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_CORBA_DynSequence;


#if !defined (_CORBA_DYNARRAY___PTR_CH_)
#define _CORBA_DYNARRAY___PTR_CH_

class CORBA_DynArray;
typedef CORBA_DynArray *CORBA_DynArray_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_DYNARRAY___VAR_CH_)
#define _CORBA_DYNARRAY___VAR_CH_

class  CORBA_DynArray_var
{
public:
  CORBA_DynArray_var (void); // default constructor
  CORBA_DynArray_var (CORBA_DynArray_ptr);
  CORBA_DynArray_var (const CORBA_DynArray_var &); // copy constructor
  ~CORBA_DynArray_var (void); // destructor

  CORBA_DynArray_var &operator= (CORBA_DynArray_ptr);
  CORBA_DynArray_var &operator= (const CORBA_DynArray_var &);
  CORBA_DynArray_ptr operator-> (void) const;

  operator const CORBA_DynArray_ptr &() const;
  operator CORBA_DynArray_ptr &();
  // in, inout, out, _retn
  CORBA_DynArray_ptr in (void) const;
  CORBA_DynArray_ptr &inout (void);
  CORBA_DynArray_ptr &out (void);
  CORBA_DynArray_ptr _retn (void);
  CORBA_DynArray_ptr ptr (void) const;

private:
  CORBA_DynArray_ptr ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNARRAY___OUT_CH_)
#define _CORBA_DYNARRAY___OUT_CH_

class  CORBA_DynArray_out
{
public:
  CORBA_DynArray_out (CORBA_DynArray_ptr &);
  CORBA_DynArray_out (CORBA_DynArray_var &);
  CORBA_DynArray_out (const CORBA_DynArray_out &);
  CORBA_DynArray_out &operator= (const CORBA_DynArray_out &);
  CORBA_DynArray_out &operator= (const CORBA_DynArray_var &);
  CORBA_DynArray_out &operator= (CORBA_DynArray_ptr);
  operator CORBA_DynArray_ptr &();
  CORBA_DynArray_ptr &ptr (void);
  CORBA_DynArray_ptr operator-> (void);

private:
  CORBA_DynArray_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_DYNARRAY_CH_)
#define _CORBA_DYNARRAY_CH_

class TAO_Export CORBA_DynArray: public virtual CORBA_DynAny
{
public:
  // the static operations
  static CORBA_DynArray_ptr _duplicate (CORBA_DynArray_ptr obj);
  static CORBA_DynArray_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  static CORBA_DynArray_ptr _nil (void);

  virtual AnySeq * get_elements (
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual void set_elements (
      const AnySeq & value,
      CORBA::Environment &_tao_environment =
        CORBA::Environment::default_environment ()
     );
  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &TAO_IN_ENV =
        CORBA::Environment::default_environment ()
    );
  virtual const char* _interface_repository_id (void) const;
protected:
  CORBA_DynArray (void); // default constructor
  CORBA_DynArray (STUB_Object *objref,
      TAO_ServantBase *_tao_servant = 0,
      CORBA::Boolean _tao_collocated = 0
    );
  virtual ~CORBA_DynArray (void);
private:
  CORBA_DynArray (const CORBA_DynArray &);
  void operator= (const CORBA_DynArray &);
};


#endif /* end #if !defined */

extern  CORBA::TypeCode_ptr  _tc_CORBA_DynArray;

#if defined (__ACE_INLINE__)
#include "DynAnyC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER)
#pragma warning(default:4250)
#endif /* _MSC_VER */

#endif /* if !defined */
