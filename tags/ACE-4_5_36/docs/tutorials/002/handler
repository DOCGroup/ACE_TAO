	
1.	#include "ace/SOCK_Acceptor.h"
2.	#include "ace/Reactor.h"
	
	
3.	class Logging_Handler : public ACE_Svc_Handler<ACE_SOCK_STREAM, ACE_NULL_SYNCH>
	{
	
	public:
	
4.	  Logging_Handler (void)
		{
		}
	
5.	  virtual void destroy (void)
		{
6.		  g_reactor->cancel_timer (this);
7.		  this->peer ().close ();
		}
	
8.	  virtual int open (void *)
		{
9.		  ACE_INET_Addr addr;
		  
10.		  if (this->peer ().get_remote_addr (addr) == -1)
11.		    return -1;
12.		  else
		    {
13.		      ACE_OS::strncpy (this->peer_name_, addr.get_host_name (), MAXHOSTNAMELEN + 1);
		
14.		      if (g_reactor->register_handler(this, ACE_Event_Handler::READ_MASK) == -1)
15.			ACE_ERROR_RETURN ((LM_ERROR, "(%P|%t) can't register with reactor\n"), -1);
	
16.		      else if (g_reactor->schedule_timer (this, (const void *) this, ACE_Time_Value (2), ACE_Time_Value (2)) == -1)
17.			ACE_ERROR_RETURN ((LM_ERROR, "can'(%P|%t) t register with reactor\n"), -1);
	
18.		      else
19.		      	ACE_DEBUG ((LM_DEBUG, "(%P|%t) connected with %s\n", this->peer_name_));
	
20.		      return 0;
		    }
		}
	
21.	  virtual int close (u_long)
		{
22.		  this->destroy ();
23.		  return 0;
		}
	
	protected:
	
24.	  virtual int handle_input (ACE_HANDLE)
	        {
25.	          char buf[128];
26.	          memset(buf,0,sizeof(buf));
	        
27.	          switch( this->peer().recv(buf,sizeof buf) )
	          {
28.	          case -1:
29.	            ACE_ERROR_RETURN ((LM_ERROR, "(%P|%t) %p bad read\n", "client logger"), -1);
30.	          case 0:
31.	            ACE_ERROR_RETURN ((LM_ERROR, "(%P|%t) closing log daemon (fd = %d)\n", this->get_handle ()), -1);
32.	          default:
33.	            ACE_DEBUG ((LM_DEBUG, "(%P|%t) from client: %s",buf));
	          }
	          
34.	          return 0;
	        }
	
35.	  virtual int handle_timeout (const ACE_Time_Value &tv, const void *arg)
		{
36.		  ACE_ASSERT (arg == this);
37.		  ACE_DEBUG ((LM_DEBUG, "(%P|%t) handling timeout from this = %u\n", this));
38.		  return 0;
		}
	
	private:
	
39.	  char peer_name_[MAXHOSTNAMELEN + 1];
	
	};
