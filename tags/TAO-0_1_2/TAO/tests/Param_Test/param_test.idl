// $Id$

// ============================================================================
//
// = LIBRARY
//    TAO/tests/Param_Test
//
// = FILENAME
//    params.idl
//
// = DESCRIPTION
//    This IDL description is used to test all the parameter passing modes (in,
//    inout, out, and return) for a number of IDL data types. The goal is to
//    verify the correctness of the generated stubs and skeletons, and the
//    the marshaling engine of TAO.
//
// = AUTHORS
//    Aniruddha Gokhale
//
// ============================================================================

interface Coffee
{
  struct Desc
  {
    string name;
  };

  attribute Desc description; // provides us the coffee object type
};

//typedef sequence<Coffee> ObjSeq;

interface Param_Test
{
  // Add exceptions to each

  // primitive types
  short test_short (in short s1,
                    inout short s2,
                    out short s3);

  // strings unbounded
  string test_unbounded_string (in string s1,
                                inout string s2,
                                out string s3);

  // structures (fixed size)
  struct Fixed_Struct
  {
    long l;
    char c;
    short s;
    octet o;
    float f;
    boolean b;
    double d;
  };

  Fixed_Struct test_fixed_struct (in Fixed_Struct s1,
                                  inout Fixed_Struct s2,
                                  out Fixed_Struct s3);

  // sequences and typedefs
  typedef sequence<string> StrSeq1;
  typedef sequence<string> StrSeq;
  StrSeq test_strseq (in StrSeq s1,
                      inout StrSeq s2,
                      out StrSeq s3);


  typedef string DUMMY;
  // variable structures
  struct Var_Struct
  {
    DUMMY dummy1;
    DUMMY dummy2;
    StrSeq seq;
  };

  Var_Struct test_var_struct (in Var_Struct s1,
                              inout Var_Struct s2,
                              out Var_Struct s3);

  // nested structs (We reuse the var_struct defn above to make a very
  // complicated nested structure)
  struct Nested_Struct
  {
    Var_Struct vs;
  };

  Nested_Struct test_nested_struct (in Nested_Struct s1,
                                    inout Nested_Struct s2,
                                    out Nested_Struct s3);

  // sequences of structs
  typedef sequence<Var_Struct> StructSeq;

  StructSeq test_struct_sequence (in StructSeq s1,
                                  inout StructSeq s2,
                                  out StructSeq s3);
  // object references
  Coffee make_coffee (); // make a Coffee object
  Coffee test_objref (in Coffee o1, inout Coffee o2, out Coffee o3);

  /*
  long test_long (in long l1,
                  inout long l2,
                  out long l3);
  char test_char (in char c1,
                  inout char c2,
                  out char c3);
  octet test_octet (in octet o1,
                    inout octet o2,
                    out octet o3);

  double test_double (in double d1,
                      inout double d2,
                      out double d3);

  // strings bounded
  const unsigned long STRLEN = 10;
  string<STRLEN> test_bstring (in string<STRLEN> s1,
                               inout string<STRLEN> s2,
                               out string<STRLEN> s3);

  // typedefed string
  typedef string MYSTRING;
  MYSTRING test_tstring (in MYSTRING s1,
                         inout MYSTRING s2,
                         out MYSTRING s3);


  // arrays (fixed)

  // arrays (variable)

  // multidimensional arrays (fixed)

  // more combinations to follow
  union U switch (long)
    {
    case 0: sequence<char> cseq;
    case 1: sequence<octet> oseq;
    case 2: StrSeq sseq;
    };

  // complex (but meaningless) to test the naming scheme
  typedef sequence <sequence <sequence <long>, 5>, 10> complex;
  */
};
