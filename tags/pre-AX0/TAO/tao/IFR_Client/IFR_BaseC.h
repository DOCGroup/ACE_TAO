// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_IFR_BASEC_H_
#define _TAO_IDL_IFR_BASEC_H_

#include "ace/pre.h"
#include "ifr_client_export.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "tao/Invocation.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_IFR_Client_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_IFR_Client_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */


#if !defined (_CORBA_IROBJECT___PTR_CH_)
#define _CORBA_IROBJECT___PTR_CH_

class CORBA_IRObject;

#endif /* end #if !defined */


#if !defined (_CORBA_IROBJECT___VAR_CH_)
#define _CORBA_IROBJECT___VAR_CH_

class TAO_IFR_Client_Export CORBA_IRObject_var : public TAO_Base_var
{
public:
  CORBA_IRObject_var (void); // default constructor
  CORBA_IRObject_var (CORBA_IRObject_ptr p) : ptr_ (p) {}
  CORBA_IRObject_var (const CORBA_IRObject_var &); // copy constructor
  ~CORBA_IRObject_var (void); // destructor

  CORBA_IRObject_var &operator= (CORBA_IRObject_ptr);
  CORBA_IRObject_var &operator= (const CORBA_IRObject_var &);
  CORBA_IRObject_ptr operator-> (void) const;

  operator const CORBA_IRObject_ptr &() const;
  operator CORBA_IRObject_ptr &();
  // in, inout, out, _retn
  CORBA_IRObject_ptr in (void) const;
  CORBA_IRObject_ptr &inout (void);
  CORBA_IRObject_ptr &out (void);
  CORBA_IRObject_ptr _retn (void);
  CORBA_IRObject_ptr ptr (void) const;

  // Hooks used by template sequence and object manager classes
  // for non-defined forward declared interfaces.
  static CORBA_IRObject_ptr tao_duplicate (CORBA_IRObject_ptr);
  static void tao_release (CORBA_IRObject_ptr);
  static CORBA_IRObject_ptr tao_nil (void);
  static CORBA_IRObject_ptr tao_narrow (
      CORBA::Object *
      ACE_ENV_ARG_DECL_NOT_USED
    );
  static CORBA::Object * tao_upcast (void *);

private:
  CORBA_IRObject_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  CORBA_IRObject_var (const TAO_Base_var &rhs);
  CORBA_IRObject_var &operator= (const TAO_Base_var &rhs);
};


#endif /* end #if !defined */


#if !defined (_CORBA_IROBJECT___OUT_CH_)
#define _CORBA_IROBJECT___OUT_CH_

class TAO_IFR_Client_Export CORBA_IRObject_out
{
public:
  CORBA_IRObject_out (CORBA_IRObject_ptr &);
  CORBA_IRObject_out (CORBA_IRObject_var &);
  CORBA_IRObject_out (const CORBA_IRObject_out &);
  CORBA_IRObject_out &operator= (const CORBA_IRObject_out &);
  CORBA_IRObject_out &operator= (const CORBA_IRObject_var &);
  CORBA_IRObject_out &operator= (CORBA_IRObject_ptr);
  operator CORBA_IRObject_ptr &();
  CORBA_IRObject_ptr &ptr (void);
  CORBA_IRObject_ptr operator-> (void);

private:
  CORBA_IRObject_ptr &ptr_;
};


#endif /* end #if !defined */


#if !defined (_CORBA_IROBJECT_CH_)
#define _CORBA_IROBJECT_CH_

// Forward Classes Declaration
class _TAO_CORBA_IRObject_Proxy_Impl;
class _TAO_CORBA_IRObject_Remote_Proxy_Impl;
class _TAO_CORBA_IRObject_Proxy_Broker;
class _TAO_CORBA_IRObject_Remote_Proxy_Broker;

class TAO_IFR_Client_Export CORBA_IRObject
  : public virtual CORBA_Object
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef CORBA_IRObject_ptr _ptr_type;
  typedef CORBA_IRObject_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

  // the static operations
  static CORBA_IRObject_ptr _duplicate (CORBA_IRObject_ptr obj);

  static CORBA_IRObject_ptr _narrow (
      CORBA::Object_ptr obj
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  static CORBA_IRObject_ptr _unchecked_narrow (
      CORBA::Object_ptr obj
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  static CORBA_IRObject_ptr _nil (void)
    {
      return (CORBA_IRObject_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::DefinitionKind def_kind (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void destroy (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS);


  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_CORBA_IRObject_Proxy_Broker *the_TAO_CORBA_IRObject_Proxy_Broker_;

protected:
  CORBA_IRObject (int collocated = 0);

  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void CORBA_IRObject_setup_collocation (int collocated);

  CORBA_IRObject (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_CORBA_IRObject_Remote_Proxy_Impl;
  friend class _TAO_CORBA_IRObject_ThruPOA_Proxy_Impl;
  friend class _TAO_CORBA_IRObject_Direct_Proxy_Impl;

  virtual ~CORBA_IRObject (void);

private:
  CORBA_IRObject (const CORBA_IRObject &);
  void operator= (const CORBA_IRObject &);
};

// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base Proxy Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_IRObject_Proxy_Impl
  : public virtual TAO_Object_Proxy_Impl
{
public:
  virtual ~_TAO_CORBA_IRObject_Proxy_Impl (void) { }
  virtual CORBA::DefinitionKind def_kind (
      CORBA_Object *_collocated_tao_target_
      ACE_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void destroy (
      CORBA_Object *_collocated_tao_target_
      ACE_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;


protected:
  _TAO_CORBA_IRObject_Proxy_Impl (void);
};

//
//               End Base Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                Remote Proxy Impl. Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_IRObject_Remote_Proxy_Impl
  : public virtual _TAO_CORBA_IRObject_Proxy_Impl,
    public virtual TAO_Remote_Object_Proxy_Impl
{
public:
  _TAO_CORBA_IRObject_Remote_Proxy_Impl (void);

  virtual ~_TAO_CORBA_IRObject_Remote_Proxy_Impl (void) { }
  virtual CORBA::DefinitionKind def_kind (
      CORBA_Object *_collocated_tao_target_
      ACE_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void destroy (
      CORBA_Object *_collocated_tao_target_
      ACE_ENV_ARG_DECL
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));


};

//
//             End Remote Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////

// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.


///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_IRObject_Proxy_Broker
{
public:
  virtual ~_TAO_CORBA_IRObject_Proxy_Broker (void);
  virtual _TAO_CORBA_IRObject_Proxy_Impl &select_proxy (
      CORBA_IRObject *object
      ACE_ENV_ARG_DECL_WITH_DEFAULTS
    ) = 0;

protected:
  _TAO_CORBA_IRObject_Proxy_Broker (void);

};

//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_IFR_Client_Export _TAO_CORBA_IRObject_Remote_Proxy_Broker
  : public virtual _TAO_CORBA_IRObject_Proxy_Broker
{
public:
  _TAO_CORBA_IRObject_Remote_Proxy_Broker (void);

  virtual ~_TAO_CORBA_IRObject_Remote_Proxy_Broker (void);

  virtual _TAO_CORBA_IRObject_Proxy_Impl &select_proxy (
      CORBA_IRObject *object
      ACE_ENV_ARG_DECL
    );

  private:
    _TAO_CORBA_IRObject_Remote_Proxy_Impl remote_proxy_impl_;

  public:
    // This member function is used to get an handle to the unique instance
    // of the Remote Proxy Broker that is available for a given
    // interface.
    static _TAO_CORBA_IRObject_Remote_Proxy_Broker *the_TAO_CORBA_IRObject_Remote_Proxy_Broker (void);
  };

  //
  //              End Remote Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

  class CORBA_Repository;

#if !defined (_CORBA_REPOSITORY___VAR_CH_)
#define _CORBA_REPOSITORY___VAR_CH_

  class TAO_IFR_Client_Export CORBA_Repository_var : public TAO_Base_var
  {
  public:
    CORBA_Repository_var (void); // default constructor
    CORBA_Repository_var (CORBA_Repository_ptr p) : ptr_ (p) {}
    CORBA_Repository_var (const CORBA_Repository_var &); // copy constructor
    ~CORBA_Repository_var (void); // destructor

    CORBA_Repository_var &operator= (CORBA_Repository_ptr);
    CORBA_Repository_var &operator= (const CORBA_Repository_var &);
    CORBA_Repository_ptr operator-> (void) const;

    operator const CORBA_Repository_ptr &() const;
    operator CORBA_Repository_ptr &();
    // in, inout, out, _retn
    CORBA_Repository_ptr in (void) const;
    CORBA_Repository_ptr &inout (void);
    CORBA_Repository_ptr &out (void);
    CORBA_Repository_ptr _retn (void);
    CORBA_Repository_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static CORBA_Repository_ptr tao_duplicate (CORBA_Repository_ptr);
    static void tao_release (CORBA_Repository_ptr);
    static CORBA_Repository_ptr tao_nil (void);
    static CORBA_Repository_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    CORBA_Repository_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_Repository_var (const TAO_Base_var &rhs);
    CORBA_Repository_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_REPOSITORY___OUT_CH_)
#define _CORBA_REPOSITORY___OUT_CH_

  class TAO_IFR_Client_Export CORBA_Repository_out
  {
  public:
    CORBA_Repository_out (CORBA_Repository_ptr &);
    CORBA_Repository_out (CORBA_Repository_var &);
    CORBA_Repository_out (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_out &);
    CORBA_Repository_out &operator= (const CORBA_Repository_var &);
    CORBA_Repository_out &operator= (CORBA_Repository_ptr);
    operator CORBA_Repository_ptr &();
    CORBA_Repository_ptr &ptr (void);
    CORBA_Repository_ptr operator-> (void);

  private:
    CORBA_Repository_ptr &ptr_;
  };


#endif /* end #if !defined */

  class CORBA_Container;

#if !defined (_CORBA_CONTAINER___PTR_CH_)
#define _CORBA_CONTAINER___PTR_CH_

  typedef CORBA_Container *CORBA_Container_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER___VAR_CH_)
#define _CORBA_CONTAINER___VAR_CH_

  class TAO_IFR_Client_Export CORBA_Container_var : public TAO_Base_var
  {
  public:
    CORBA_Container_var (void); // default constructor
    CORBA_Container_var (CORBA_Container_ptr p) : ptr_ (p) {}
    CORBA_Container_var (const CORBA_Container_var &); // copy constructor
    ~CORBA_Container_var (void); // destructor

    CORBA_Container_var &operator= (CORBA_Container_ptr);
    CORBA_Container_var &operator= (const CORBA_Container_var &);
    CORBA_Container_ptr operator-> (void) const;

    operator const CORBA_Container_ptr &() const;
    operator CORBA_Container_ptr &();
    // in, inout, out, _retn
    CORBA_Container_ptr in (void) const;
    CORBA_Container_ptr &inout (void);
    CORBA_Container_ptr &out (void);
    CORBA_Container_ptr _retn (void);
    CORBA_Container_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static CORBA_Container_ptr tao_duplicate (CORBA_Container_ptr);
    static void tao_release (CORBA_Container_ptr);
    static CORBA_Container_ptr tao_nil (void);
    static CORBA_Container_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    CORBA_Container_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_Container_var (const TAO_Base_var &rhs);
    CORBA_Container_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER___OUT_CH_)
#define _CORBA_CONTAINER___OUT_CH_

  class TAO_IFR_Client_Export CORBA_Container_out
  {
  public:
    CORBA_Container_out (CORBA_Container_ptr &);
    CORBA_Container_out (CORBA_Container_var &);
    CORBA_Container_out (const CORBA_Container_out &);
    CORBA_Container_out &operator= (const CORBA_Container_out &);
    CORBA_Container_out &operator= (const CORBA_Container_var &);
    CORBA_Container_out &operator= (CORBA_Container_ptr);
    operator CORBA_Container_ptr &();
    CORBA_Container_ptr &ptr (void);
    CORBA_Container_ptr operator-> (void);

  private:
    CORBA_Container_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED___PTR_CH_)
#define _CORBA_CONTAINED___PTR_CH_

  class CORBA_Contained;
  typedef CORBA_Contained *CORBA_Contained_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED___VAR_CH_)
#define _CORBA_CONTAINED___VAR_CH_

  class TAO_IFR_Client_Export CORBA_Contained_var : public TAO_Base_var
  {
  public:
    CORBA_Contained_var (void); // default constructor
    CORBA_Contained_var (CORBA_Contained_ptr p) : ptr_ (p) {}
    CORBA_Contained_var (const CORBA_Contained_var &); // copy constructor
    ~CORBA_Contained_var (void); // destructor

    CORBA_Contained_var &operator= (CORBA_Contained_ptr);
    CORBA_Contained_var &operator= (const CORBA_Contained_var &);
    CORBA_Contained_ptr operator-> (void) const;

    operator const CORBA_Contained_ptr &() const;
    operator CORBA_Contained_ptr &();
    // in, inout, out, _retn
    CORBA_Contained_ptr in (void) const;
    CORBA_Contained_ptr &inout (void);
    CORBA_Contained_ptr &out (void);
    CORBA_Contained_ptr _retn (void);
    CORBA_Contained_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static CORBA_Contained_ptr tao_duplicate (CORBA_Contained_ptr);
    static void tao_release (CORBA_Contained_ptr);
    static CORBA_Contained_ptr tao_nil (void);
    static CORBA_Contained_ptr tao_narrow (
        CORBA::Object *
        ACE_ENV_ARG_DECL_NOT_USED
      );
    static CORBA::Object * tao_upcast (void *);

  private:
    CORBA_Contained_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_Contained_var (const TAO_Base_var &rhs);
    CORBA_Contained_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED___OUT_CH_)
#define _CORBA_CONTAINED___OUT_CH_

  class TAO_IFR_Client_Export CORBA_Contained_out
  {
  public:
    CORBA_Contained_out (CORBA_Contained_ptr &);
    CORBA_Contained_out (CORBA_Contained_var &);
    CORBA_Contained_out (const CORBA_Contained_out &);
    CORBA_Contained_out &operator= (const CORBA_Contained_out &);
    CORBA_Contained_out &operator= (const CORBA_Contained_var &);
    CORBA_Contained_out &operator= (CORBA_Contained_ptr);
    operator CORBA_Contained_ptr &();
    CORBA_Contained_ptr &ptr (void);
    CORBA_Contained_ptr operator-> (void);

  private:
    CORBA_Contained_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINED_CH_)
#define _CORBA_CONTAINED_CH_

  // Forward Classes Declaration
  class _TAO_CORBA_Contained_Proxy_Impl;
  class _TAO_CORBA_Contained_Remote_Proxy_Impl;
  class _TAO_CORBA_Contained_Proxy_Broker;
  class _TAO_CORBA_Contained_Remote_Proxy_Broker;

  class TAO_IFR_Client_Export CORBA_Contained
    : public virtual CORBA_IRObject
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef CORBA_Contained_ptr _ptr_type;
    typedef CORBA_Contained_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

    // the static operations
    static CORBA_Contained_ptr _duplicate (CORBA_Contained_ptr obj);

    static CORBA_Contained_ptr _narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);


    static CORBA_Contained_ptr _unchecked_narrow (
        CORBA::Object_ptr obj
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);


    static CORBA_Contained_ptr _nil (void)
      {
        return (CORBA_Contained_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual char * id (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void id (
        const char * id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * name (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void name (
        const char * name
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * version (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void version (
        const char * version
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_Container_ptr defined_in (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * absolute_name (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_Repository_ptr containing_repository (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    struct Description;
    class Description_var;

    struct TAO_IFR_Client_Export Description
    {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef Description_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

      static void _tao_any_destructor (void*);

      CORBA::DefinitionKind kind;
      CORBA::Any value;

    };

    class TAO_IFR_Client_Export Description_var
    {
    public:
      Description_var (void);
      Description_var (Description *);
      Description_var (const Description_var &);
      ~Description_var (void);

      Description_var &operator= (Description *);
      Description_var &operator= (const Description_var &);
      Description *operator-> (void);
      const Description *operator-> (void) const;

      operator const Description &() const;
      operator Description &();
      operator Description &() const;
      // Variable-size types only.
      operator Description *&();

      // in, inout, out, _retn
      const Description &in (void) const;
      Description &inout (void);
      Description *&out (void);
      Description *_retn (void);
      Description *ptr (void) const;

    private:
      Description *ptr_;
    };

    class TAO_IFR_Client_Export Description_out
    {
    public:
      Description_out (Description *&);
      Description_out (Description_var &);
      Description_out (const Description_out &);
      Description_out &operator= (const Description_out &);
      Description_out &operator= (Description *);
      operator Description *&();
      Description *&ptr (void);
      Description *operator-> (void);

    private:
      Description *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const Description_var &);
    };

    static CORBA::TypeCode_ptr _tc_Description;

    virtual CORBA_Contained::Description * describe (
        ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void move (
        CORBA_Container_ptr new_container,
        const char * new_name,
        const char * new_version
        ACE_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id
        ACE_ENV_ARG_DECL_WITH_DEFAULTS);


    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_CORBA_Contained_Proxy_Broker *the_TAO_CORBA_Contained_Proxy_Broker_;

  protected:
    CORBA_Contained (int collocated = 0);

    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void CORBA_Contained_setup_collocation (int collocated);

    CORBA_Contained (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );

    friend class _TAO_CORBA_Contained_Remote_Proxy_Impl;
    friend class _TAO_CORBA_Contained_ThruPOA_Proxy_Impl;
    friend class _TAO_CORBA_Contained_Direct_Proxy_Impl;

    virtual ~CORBA_Contained (void);

  private:
    CORBA_Contained (const CORBA_Contained &);
    void operator= (const CORBA_Contained &);
  };

  // The Proxy Implementations are used by each interface to
  // perform a call. Each different implementation encapsulate
  // an invocation logics.


  ///////////////////////////////////////////////////////////////////////
  //                    Base Proxy Impl. Declaration
  //

  class TAO_IFR_Client_Export _TAO_CORBA_Contained_Proxy_Impl
    : public virtual _TAO_CORBA_IRObject_Proxy_Impl
  {
  public:
    virtual ~_TAO_CORBA_Contained_Proxy_Impl (void) { }
    virtual char * id (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void id (
        CORBA_Object *_collocated_tao_target_,
        const char * id
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual char * name (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void name (
        CORBA_Object *_collocated_tao_target_,
        const char * name
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual char * version (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void version (
        CORBA_Object *_collocated_tao_target_,
        const char * version
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA_Container_ptr defined_in (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual char * absolute_name (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA_Repository_ptr containing_repository (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual CORBA_Contained::Description * describe (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;

    virtual void move (
        CORBA_Object *_collocated_tao_target_,
        CORBA_Container_ptr new_container,
        const char * new_name,
        const char * new_version
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      )) = 0;


  protected:
    _TAO_CORBA_Contained_Proxy_Impl (void);
  };

  //
  //               End Base Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                Remote Proxy Impl. Declaration
  //

  class TAO_IFR_Client_Export _TAO_CORBA_Contained_Remote_Proxy_Impl
    : public virtual _TAO_CORBA_Contained_Proxy_Impl,
      public virtual TAO_Remote_Object_Proxy_Impl,
      public virtual _TAO_CORBA_IRObject_Remote_Proxy_Impl
  {
  public:
    _TAO_CORBA_Contained_Remote_Proxy_Impl (void);

    virtual ~_TAO_CORBA_Contained_Remote_Proxy_Impl (void) { }
    virtual char * id (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void id (
        CORBA_Object *_collocated_tao_target_,
        const char * id
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * name (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void name (
        CORBA_Object *_collocated_tao_target_,
        const char * name
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * version (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void version (
        CORBA_Object *_collocated_tao_target_,
        const char * version
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_Container_ptr defined_in (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * absolute_name (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_Repository_ptr containing_repository (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA_Contained::Description * describe (
        CORBA_Object *_collocated_tao_target_
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void move (
        CORBA_Object *_collocated_tao_target_,
        CORBA_Container_ptr new_container,
        const char * new_name,
        const char * new_version
        ACE_ENV_ARG_DECL
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));


  };

  //
  //             End Remote Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////

  // The Proxy Brokers are used by each interface to get
  // the right proxy for performing a call. In the new
  // collocation scheme, the proxy to be used can vary on
  // a call by call basis.


  ///////////////////////////////////////////////////////////////////////
  //                 Base Proxy Broker Declaration
  //

    class TAO_IFR_Client_Export _TAO_CORBA_Contained_Proxy_Broker
  {
  public:
    virtual ~_TAO_CORBA_Contained_Proxy_Broker (void);
    virtual _TAO_CORBA_Contained_Proxy_Impl &select_proxy (
        CORBA_Contained *object
        ACE_ENV_ARG_DECL_WITH_DEFAULTS
      ) = 0;

  protected:
    _TAO_CORBA_Contained_Proxy_Broker (void);

  };

  //
  //              End Base Proxy Broker Declaration
  ///////////////////////////////////////////////////////////////////////


  ///////////////////////////////////////////////////////////////////////
  //                 Remote Proxy Broker Declaration
  //

  class TAO_IFR_Client_Export _TAO_CORBA_Contained_Remote_Proxy_Broker
    : public virtual _TAO_CORBA_Contained_Proxy_Broker
  {
  public:
    _TAO_CORBA_Contained_Remote_Proxy_Broker (void);

    virtual ~_TAO_CORBA_Contained_Remote_Proxy_Broker (void);

    virtual _TAO_CORBA_Contained_Proxy_Impl &select_proxy (
        CORBA_Contained *object
        ACE_ENV_ARG_DECL
      );

    private:
      _TAO_CORBA_Contained_Remote_Proxy_Impl remote_proxy_impl_;

    public:
      // This member function is used to get an handle to the unique instance
      // of the Remote Proxy Broker that is available for a given
      // interface.
      static _TAO_CORBA_Contained_Remote_Proxy_Broker *the_TAO_CORBA_Contained_Remote_Proxy_Broker (void);
    };

    //
    //              End Remote Proxy Broker Declaration
    ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_CONTAINEDSEQ_CH_

    class TAO_EXPORT_MACRO _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_Contained* *value,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (
          const _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq &rhs
        );
      _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq &operator= (
          const _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq &rhs
        );
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq (void);

      // = Accessors.
      TAO_Object_Manager<CORBA_Contained,CORBA_Contained_var> operator[] (CORBA::ULong index) const;

      // = Static operations.
      static CORBA_Contained **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_Contained **buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_Contained* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_Contained* *get_buffer (void) const;
      virtual void _shrink_buffer (
          CORBA::ULong nl,
          CORBA::ULong ol
        );

      virtual void _downcast (
          void* target,
          CORBA_Object *src
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);

      virtual CORBA_Object* _upcast (void *src) const;
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_CONTAINEDSEQ_CH_)
#define _CORBA_CONTAINEDSEQ_CH_

    class CORBA_ContainedSeq;
    class CORBA_ContainedSeq_var;

    // *************************************************************
    // CORBA_ContainedSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_ContainedSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_Contained,CORBA_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_ContainedSeq (void); // default ctor
      CORBA_ContainedSeq (CORBA::ULong max); // uses max size
      CORBA_ContainedSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_Contained_ptr *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_ContainedSeq (const CORBA_ContainedSeq &); // copy ctor
      ~CORBA_ContainedSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_ContainedSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINEDSEQ___VAR_CH_)
#define _CORBA_CONTAINEDSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_ContainedSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_ContainedSeq_var
    {
    public:
      CORBA_ContainedSeq_var (void);
      CORBA_ContainedSeq_var (CORBA_ContainedSeq *);
      CORBA_ContainedSeq_var (const CORBA_ContainedSeq_var &);
      ~CORBA_ContainedSeq_var (void);

      CORBA_ContainedSeq_var &operator= (CORBA_ContainedSeq *);
      CORBA_ContainedSeq_var &operator= (const CORBA_ContainedSeq_var &);
      CORBA_ContainedSeq *operator-> (void);
      const CORBA_ContainedSeq *operator-> (void) const;

      operator const CORBA_ContainedSeq &() const;
      operator CORBA_ContainedSeq &();
      operator CORBA_ContainedSeq &() const;
      operator CORBA_ContainedSeq *&(); // variable-size base types only

      TAO_Object_Manager<CORBA_Contained, CORBA_Contained_var> operator[] (CORBA::ULong index);

      // in, inout, out, _retn
      const CORBA_ContainedSeq &in (void) const;
      CORBA_ContainedSeq &inout (void);
      CORBA_ContainedSeq *&out (void);
      CORBA_ContainedSeq *_retn (void);
      CORBA_ContainedSeq *ptr (void) const;

    private:
      CORBA_ContainedSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINEDSEQ___OUT_CH_)
#define _CORBA_CONTAINEDSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ContainedSeq_out
    {
    public:
      CORBA_ContainedSeq_out (CORBA_ContainedSeq *&);
      CORBA_ContainedSeq_out (CORBA_ContainedSeq_var &);
      CORBA_ContainedSeq_out (const CORBA_ContainedSeq_out &);
      CORBA_ContainedSeq_out &operator= (const CORBA_ContainedSeq_out &);
      CORBA_ContainedSeq_out &operator= (CORBA_ContainedSeq *);
      operator CORBA_ContainedSeq *&();
      CORBA_ContainedSeq *&ptr (void);
      CORBA_ContainedSeq *operator-> (void);
      TAO_Object_Manager<CORBA_Contained, CORBA_Contained_var> operator[] (CORBA::ULong index);

    private:
      CORBA_ContainedSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_ContainedSeq_var &);
    };


#endif /* end #if !defined */

    class CORBA_ModuleDef;

#if !defined (_CORBA_MODULEDEF___PTR_CH_)
#define _CORBA_MODULEDEF___PTR_CH_

    typedef CORBA_ModuleDef *CORBA_ModuleDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF___VAR_CH_)
#define _CORBA_MODULEDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_ModuleDef_var : public TAO_Base_var
    {
    public:
      CORBA_ModuleDef_var (void); // default constructor
      CORBA_ModuleDef_var (CORBA_ModuleDef_ptr p) : ptr_ (p) {}
      CORBA_ModuleDef_var (const CORBA_ModuleDef_var &); // copy constructor
      ~CORBA_ModuleDef_var (void); // destructor

      CORBA_ModuleDef_var &operator= (CORBA_ModuleDef_ptr);
      CORBA_ModuleDef_var &operator= (const CORBA_ModuleDef_var &);
      CORBA_ModuleDef_ptr operator-> (void) const;

      operator const CORBA_ModuleDef_ptr &() const;
      operator CORBA_ModuleDef_ptr &();
      // in, inout, out, _retn
      CORBA_ModuleDef_ptr in (void) const;
      CORBA_ModuleDef_ptr &inout (void);
      CORBA_ModuleDef_ptr &out (void);
      CORBA_ModuleDef_ptr _retn (void);
      CORBA_ModuleDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_ModuleDef_ptr tao_duplicate (CORBA_ModuleDef_ptr);
      static void tao_release (CORBA_ModuleDef_ptr);
      static CORBA_ModuleDef_ptr tao_nil (void);
      static CORBA_ModuleDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_ModuleDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_ModuleDef_var (const TAO_Base_var &rhs);
      CORBA_ModuleDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_MODULEDEF___OUT_CH_)
#define _CORBA_MODULEDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ModuleDef_out
    {
    public:
      CORBA_ModuleDef_out (CORBA_ModuleDef_ptr &);
      CORBA_ModuleDef_out (CORBA_ModuleDef_var &);
      CORBA_ModuleDef_out (const CORBA_ModuleDef_out &);
      CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_out &);
      CORBA_ModuleDef_out &operator= (const CORBA_ModuleDef_var &);
      CORBA_ModuleDef_out &operator= (CORBA_ModuleDef_ptr);
      operator CORBA_ModuleDef_ptr &();
      CORBA_ModuleDef_ptr &ptr (void);
      CORBA_ModuleDef_ptr operator-> (void);

    private:
      CORBA_ModuleDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_ConstantDef;

#if !defined (_CORBA_CONSTANTDEF___PTR_CH_)
#define _CORBA_CONSTANTDEF___PTR_CH_

    typedef CORBA_ConstantDef *CORBA_ConstantDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_CONSTANTDEF___VAR_CH_)
#define _CORBA_CONSTANTDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_ConstantDef_var : public TAO_Base_var
    {
    public:
      CORBA_ConstantDef_var (void); // default constructor
      CORBA_ConstantDef_var (CORBA_ConstantDef_ptr p) : ptr_ (p) {}
      CORBA_ConstantDef_var (const CORBA_ConstantDef_var &); // copy constructor
      ~CORBA_ConstantDef_var (void); // destructor

      CORBA_ConstantDef_var &operator= (CORBA_ConstantDef_ptr);
      CORBA_ConstantDef_var &operator= (const CORBA_ConstantDef_var &);
      CORBA_ConstantDef_ptr operator-> (void) const;

      operator const CORBA_ConstantDef_ptr &() const;
      operator CORBA_ConstantDef_ptr &();
      // in, inout, out, _retn
      CORBA_ConstantDef_ptr in (void) const;
      CORBA_ConstantDef_ptr &inout (void);
      CORBA_ConstantDef_ptr &out (void);
      CORBA_ConstantDef_ptr _retn (void);
      CORBA_ConstantDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_ConstantDef_ptr tao_duplicate (CORBA_ConstantDef_ptr);
      static void tao_release (CORBA_ConstantDef_ptr);
      static CORBA_ConstantDef_ptr tao_nil (void);
      static CORBA_ConstantDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_ConstantDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_ConstantDef_var (const TAO_Base_var &rhs);
      CORBA_ConstantDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_CONSTANTDEF___OUT_CH_)
#define _CORBA_CONSTANTDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ConstantDef_out
    {
    public:
      CORBA_ConstantDef_out (CORBA_ConstantDef_ptr &);
      CORBA_ConstantDef_out (CORBA_ConstantDef_var &);
      CORBA_ConstantDef_out (const CORBA_ConstantDef_out &);
      CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_out &);
      CORBA_ConstantDef_out &operator= (const CORBA_ConstantDef_var &);
      CORBA_ConstantDef_out &operator= (CORBA_ConstantDef_ptr);
      operator CORBA_ConstantDef_ptr &();
      CORBA_ConstantDef_ptr &ptr (void);
      CORBA_ConstantDef_ptr operator-> (void);

    private:
      CORBA_ConstantDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_IDLType;

#if !defined (_CORBA_IDLTYPE___PTR_CH_)
#define _CORBA_IDLTYPE___PTR_CH_

    typedef CORBA_IDLType *CORBA_IDLType_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_IDLTYPE___VAR_CH_)
#define _CORBA_IDLTYPE___VAR_CH_

    class TAO_IFR_Client_Export CORBA_IDLType_var : public TAO_Base_var
    {
    public:
      CORBA_IDLType_var (void); // default constructor
      CORBA_IDLType_var (CORBA_IDLType_ptr p) : ptr_ (p) {}
      CORBA_IDLType_var (const CORBA_IDLType_var &); // copy constructor
      ~CORBA_IDLType_var (void); // destructor

      CORBA_IDLType_var &operator= (CORBA_IDLType_ptr);
      CORBA_IDLType_var &operator= (const CORBA_IDLType_var &);
      CORBA_IDLType_ptr operator-> (void) const;

      operator const CORBA_IDLType_ptr &() const;
      operator CORBA_IDLType_ptr &();
      // in, inout, out, _retn
      CORBA_IDLType_ptr in (void) const;
      CORBA_IDLType_ptr &inout (void);
      CORBA_IDLType_ptr &out (void);
      CORBA_IDLType_ptr _retn (void);
      CORBA_IDLType_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_IDLType_ptr tao_duplicate (CORBA_IDLType_ptr);
      static void tao_release (CORBA_IDLType_ptr);
      static CORBA_IDLType_ptr tao_nil (void);
      static CORBA_IDLType_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_IDLType_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_IDLType_var (const TAO_Base_var &rhs);
      CORBA_IDLType_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_IDLTYPE___OUT_CH_)
#define _CORBA_IDLTYPE___OUT_CH_

    class TAO_IFR_Client_Export CORBA_IDLType_out
    {
    public:
      CORBA_IDLType_out (CORBA_IDLType_ptr &);
      CORBA_IDLType_out (CORBA_IDLType_var &);
      CORBA_IDLType_out (const CORBA_IDLType_out &);
      CORBA_IDLType_out &operator= (const CORBA_IDLType_out &);
      CORBA_IDLType_out &operator= (const CORBA_IDLType_var &);
      CORBA_IDLType_out &operator= (CORBA_IDLType_ptr);
      operator CORBA_IDLType_ptr &();
      CORBA_IDLType_ptr &ptr (void);
      CORBA_IDLType_ptr operator-> (void);

    private:
      CORBA_IDLType_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_StructDef;

#if !defined (_CORBA_STRUCTDEF___PTR_CH_)
#define _CORBA_STRUCTDEF___PTR_CH_

    typedef CORBA_StructDef *CORBA_StructDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTDEF___VAR_CH_)
#define _CORBA_STRUCTDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_StructDef_var : public TAO_Base_var
    {
    public:
      CORBA_StructDef_var (void); // default constructor
      CORBA_StructDef_var (CORBA_StructDef_ptr p) : ptr_ (p) {}
      CORBA_StructDef_var (const CORBA_StructDef_var &); // copy constructor
      ~CORBA_StructDef_var (void); // destructor

      CORBA_StructDef_var &operator= (CORBA_StructDef_ptr);
      CORBA_StructDef_var &operator= (const CORBA_StructDef_var &);
      CORBA_StructDef_ptr operator-> (void) const;

      operator const CORBA_StructDef_ptr &() const;
      operator CORBA_StructDef_ptr &();
      // in, inout, out, _retn
      CORBA_StructDef_ptr in (void) const;
      CORBA_StructDef_ptr &inout (void);
      CORBA_StructDef_ptr &out (void);
      CORBA_StructDef_ptr _retn (void);
      CORBA_StructDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_StructDef_ptr tao_duplicate (CORBA_StructDef_ptr);
      static void tao_release (CORBA_StructDef_ptr);
      static CORBA_StructDef_ptr tao_nil (void);
      static CORBA_StructDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_StructDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_StructDef_var (const TAO_Base_var &rhs);
      CORBA_StructDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTDEF___OUT_CH_)
#define _CORBA_STRUCTDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_StructDef_out
    {
    public:
      CORBA_StructDef_out (CORBA_StructDef_ptr &);
      CORBA_StructDef_out (CORBA_StructDef_var &);
      CORBA_StructDef_out (const CORBA_StructDef_out &);
      CORBA_StructDef_out &operator= (const CORBA_StructDef_out &);
      CORBA_StructDef_out &operator= (const CORBA_StructDef_var &);
      CORBA_StructDef_out &operator= (CORBA_StructDef_ptr);
      operator CORBA_StructDef_ptr &();
      CORBA_StructDef_ptr &ptr (void);
      CORBA_StructDef_ptr operator-> (void);

    private:
      CORBA_StructDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_UnionDef;

#if !defined (_CORBA_UNIONDEF___PTR_CH_)
#define _CORBA_UNIONDEF___PTR_CH_

    typedef CORBA_UnionDef *CORBA_UnionDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF___VAR_CH_)
#define _CORBA_UNIONDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_UnionDef_var : public TAO_Base_var
    {
    public:
      CORBA_UnionDef_var (void); // default constructor
      CORBA_UnionDef_var (CORBA_UnionDef_ptr p) : ptr_ (p) {}
      CORBA_UnionDef_var (const CORBA_UnionDef_var &); // copy constructor
      ~CORBA_UnionDef_var (void); // destructor

      CORBA_UnionDef_var &operator= (CORBA_UnionDef_ptr);
      CORBA_UnionDef_var &operator= (const CORBA_UnionDef_var &);
      CORBA_UnionDef_ptr operator-> (void) const;

      operator const CORBA_UnionDef_ptr &() const;
      operator CORBA_UnionDef_ptr &();
      // in, inout, out, _retn
      CORBA_UnionDef_ptr in (void) const;
      CORBA_UnionDef_ptr &inout (void);
      CORBA_UnionDef_ptr &out (void);
      CORBA_UnionDef_ptr _retn (void);
      CORBA_UnionDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_UnionDef_ptr tao_duplicate (CORBA_UnionDef_ptr);
      static void tao_release (CORBA_UnionDef_ptr);
      static CORBA_UnionDef_ptr tao_nil (void);
      static CORBA_UnionDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_UnionDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_UnionDef_var (const TAO_Base_var &rhs);
      CORBA_UnionDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONDEF___OUT_CH_)
#define _CORBA_UNIONDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_UnionDef_out
    {
    public:
      CORBA_UnionDef_out (CORBA_UnionDef_ptr &);
      CORBA_UnionDef_out (CORBA_UnionDef_var &);
      CORBA_UnionDef_out (const CORBA_UnionDef_out &);
      CORBA_UnionDef_out &operator= (const CORBA_UnionDef_out &);
      CORBA_UnionDef_out &operator= (const CORBA_UnionDef_var &);
      CORBA_UnionDef_out &operator= (CORBA_UnionDef_ptr);
      operator CORBA_UnionDef_ptr &();
      CORBA_UnionDef_ptr &ptr (void);
      CORBA_UnionDef_ptr operator-> (void);

    private:
      CORBA_UnionDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_EnumDef;

#if !defined (_CORBA_ENUMDEF___PTR_CH_)
#define _CORBA_ENUMDEF___PTR_CH_

    typedef CORBA_EnumDef *CORBA_EnumDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF___VAR_CH_)
#define _CORBA_ENUMDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_EnumDef_var : public TAO_Base_var
    {
    public:
      CORBA_EnumDef_var (void); // default constructor
      CORBA_EnumDef_var (CORBA_EnumDef_ptr p) : ptr_ (p) {}
      CORBA_EnumDef_var (const CORBA_EnumDef_var &); // copy constructor
      ~CORBA_EnumDef_var (void); // destructor

      CORBA_EnumDef_var &operator= (CORBA_EnumDef_ptr);
      CORBA_EnumDef_var &operator= (const CORBA_EnumDef_var &);
      CORBA_EnumDef_ptr operator-> (void) const;

      operator const CORBA_EnumDef_ptr &() const;
      operator CORBA_EnumDef_ptr &();
      // in, inout, out, _retn
      CORBA_EnumDef_ptr in (void) const;
      CORBA_EnumDef_ptr &inout (void);
      CORBA_EnumDef_ptr &out (void);
      CORBA_EnumDef_ptr _retn (void);
      CORBA_EnumDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_EnumDef_ptr tao_duplicate (CORBA_EnumDef_ptr);
      static void tao_release (CORBA_EnumDef_ptr);
      static CORBA_EnumDef_ptr tao_nil (void);
      static CORBA_EnumDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_EnumDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_EnumDef_var (const TAO_Base_var &rhs);
      CORBA_EnumDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMDEF___OUT_CH_)
#define _CORBA_ENUMDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_EnumDef_out
    {
    public:
      CORBA_EnumDef_out (CORBA_EnumDef_ptr &);
      CORBA_EnumDef_out (CORBA_EnumDef_var &);
      CORBA_EnumDef_out (const CORBA_EnumDef_out &);
      CORBA_EnumDef_out &operator= (const CORBA_EnumDef_out &);
      CORBA_EnumDef_out &operator= (const CORBA_EnumDef_var &);
      CORBA_EnumDef_out &operator= (CORBA_EnumDef_ptr);
      operator CORBA_EnumDef_ptr &();
      CORBA_EnumDef_ptr &ptr (void);
      CORBA_EnumDef_ptr operator-> (void);

    private:
      CORBA_EnumDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_AliasDef;

#if !defined (_CORBA_ALIASDEF___PTR_CH_)
#define _CORBA_ALIASDEF___PTR_CH_

    typedef CORBA_AliasDef *CORBA_AliasDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF___VAR_CH_)
#define _CORBA_ALIASDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_AliasDef_var : public TAO_Base_var
    {
    public:
      CORBA_AliasDef_var (void); // default constructor
      CORBA_AliasDef_var (CORBA_AliasDef_ptr p) : ptr_ (p) {}
      CORBA_AliasDef_var (const CORBA_AliasDef_var &); // copy constructor
      ~CORBA_AliasDef_var (void); // destructor

      CORBA_AliasDef_var &operator= (CORBA_AliasDef_ptr);
      CORBA_AliasDef_var &operator= (const CORBA_AliasDef_var &);
      CORBA_AliasDef_ptr operator-> (void) const;

      operator const CORBA_AliasDef_ptr &() const;
      operator CORBA_AliasDef_ptr &();
      // in, inout, out, _retn
      CORBA_AliasDef_ptr in (void) const;
      CORBA_AliasDef_ptr &inout (void);
      CORBA_AliasDef_ptr &out (void);
      CORBA_AliasDef_ptr _retn (void);
      CORBA_AliasDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_AliasDef_ptr tao_duplicate (CORBA_AliasDef_ptr);
      static void tao_release (CORBA_AliasDef_ptr);
      static CORBA_AliasDef_ptr tao_nil (void);
      static CORBA_AliasDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_AliasDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_AliasDef_var (const TAO_Base_var &rhs);
      CORBA_AliasDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_ALIASDEF___OUT_CH_)
#define _CORBA_ALIASDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_AliasDef_out
    {
    public:
      CORBA_AliasDef_out (CORBA_AliasDef_ptr &);
      CORBA_AliasDef_out (CORBA_AliasDef_var &);
      CORBA_AliasDef_out (const CORBA_AliasDef_out &);
      CORBA_AliasDef_out &operator= (const CORBA_AliasDef_out &);
      CORBA_AliasDef_out &operator= (const CORBA_AliasDef_var &);
      CORBA_AliasDef_out &operator= (CORBA_AliasDef_ptr);
      operator CORBA_AliasDef_ptr &();
      CORBA_AliasDef_ptr &ptr (void);
      CORBA_AliasDef_ptr operator-> (void);

    private:
      CORBA_AliasDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_InterfaceDef;

#if !defined (_CORBA_INTERFACEDEF___PTR_CH_)
#define _CORBA_INTERFACEDEF___PTR_CH_

    typedef CORBA_InterfaceDef *CORBA_InterfaceDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___VAR_CH_)
#define _CORBA_INTERFACEDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_InterfaceDef_var : public TAO_Base_var
    {
    public:
      CORBA_InterfaceDef_var (void); // default constructor
      CORBA_InterfaceDef_var (CORBA_InterfaceDef_ptr p) : ptr_ (p) {}
      CORBA_InterfaceDef_var (const CORBA_InterfaceDef_var &); // copy constructor
      ~CORBA_InterfaceDef_var (void); // destructor

      CORBA_InterfaceDef_var &operator= (CORBA_InterfaceDef_ptr);
      CORBA_InterfaceDef_var &operator= (const CORBA_InterfaceDef_var &);
      CORBA_InterfaceDef_ptr operator-> (void) const;

      operator const CORBA_InterfaceDef_ptr &() const;
      operator CORBA_InterfaceDef_ptr &();
      // in, inout, out, _retn
      CORBA_InterfaceDef_ptr in (void) const;
      CORBA_InterfaceDef_ptr &inout (void);
      CORBA_InterfaceDef_ptr &out (void);
      CORBA_InterfaceDef_ptr _retn (void);
      CORBA_InterfaceDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_InterfaceDef_ptr tao_duplicate (CORBA_InterfaceDef_ptr);
      static void tao_release (CORBA_InterfaceDef_ptr);
      static CORBA_InterfaceDef_ptr tao_nil (void);
      static CORBA_InterfaceDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_InterfaceDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_InterfaceDef_var (const TAO_Base_var &rhs);
      CORBA_InterfaceDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEF___OUT_CH_)
#define _CORBA_INTERFACEDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_InterfaceDef_out
    {
    public:
      CORBA_InterfaceDef_out (CORBA_InterfaceDef_ptr &);
      CORBA_InterfaceDef_out (CORBA_InterfaceDef_var &);
      CORBA_InterfaceDef_out (const CORBA_InterfaceDef_out &);
      CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_out &);
      CORBA_InterfaceDef_out &operator= (const CORBA_InterfaceDef_var &);
      CORBA_InterfaceDef_out &operator= (CORBA_InterfaceDef_ptr);
      operator CORBA_InterfaceDef_ptr &();
      CORBA_InterfaceDef_ptr &ptr (void);
      CORBA_InterfaceDef_ptr operator-> (void);

    private:
      CORBA_InterfaceDef_ptr &ptr_;
    };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_INTERFACEDEFSEQ_CH_

    class TAO_EXPORT_MACRO _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_InterfaceDef* *value,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (
          const _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &rhs
        );
      _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &operator= (
          const _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq &rhs
        );
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq (void);

      // = Accessors.
      TAO_Object_Manager<CORBA_InterfaceDef,CORBA_InterfaceDef_var> operator[] (CORBA::ULong index) const;

      // = Static operations.
      static CORBA_InterfaceDef **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_InterfaceDef **buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_InterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_InterfaceDef* *get_buffer (void) const;
      virtual void _shrink_buffer (
          CORBA::ULong nl,
          CORBA::ULong ol
        );

      virtual void _downcast (
          void* target,
          CORBA_Object *src
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);

      virtual CORBA_Object* _upcast (void *src) const;
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_INTERFACEDEFSEQ_CH_)
#define _CORBA_INTERFACEDEFSEQ_CH_

    class CORBA_InterfaceDefSeq;
    class CORBA_InterfaceDefSeq_var;

    // *************************************************************
    // CORBA_InterfaceDefSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_InterfaceDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_InterfaceDef,CORBA_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_InterfaceDefSeq (void); // default ctor
      CORBA_InterfaceDefSeq (CORBA::ULong max); // uses max size
      CORBA_InterfaceDefSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_InterfaceDef_ptr *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_InterfaceDefSeq (const CORBA_InterfaceDefSeq &); // copy ctor
      ~CORBA_InterfaceDefSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_InterfaceDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEFSEQ___VAR_CH_)
#define _CORBA_INTERFACEDEFSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_InterfaceDefSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_InterfaceDefSeq_var
    {
    public:
      CORBA_InterfaceDefSeq_var (void);
      CORBA_InterfaceDefSeq_var (CORBA_InterfaceDefSeq *);
      CORBA_InterfaceDefSeq_var (const CORBA_InterfaceDefSeq_var &);
      ~CORBA_InterfaceDefSeq_var (void);

      CORBA_InterfaceDefSeq_var &operator= (CORBA_InterfaceDefSeq *);
      CORBA_InterfaceDefSeq_var &operator= (const CORBA_InterfaceDefSeq_var &);
      CORBA_InterfaceDefSeq *operator-> (void);
      const CORBA_InterfaceDefSeq *operator-> (void) const;

      operator const CORBA_InterfaceDefSeq &() const;
      operator CORBA_InterfaceDefSeq &();
      operator CORBA_InterfaceDefSeq &() const;
      operator CORBA_InterfaceDefSeq *&(); // variable-size base types only

      TAO_Object_Manager<CORBA_InterfaceDef, CORBA_InterfaceDef_var> operator[] (CORBA::ULong index);

      // in, inout, out, _retn
      const CORBA_InterfaceDefSeq &in (void) const;
      CORBA_InterfaceDefSeq &inout (void);
      CORBA_InterfaceDefSeq *&out (void);
      CORBA_InterfaceDefSeq *_retn (void);
      CORBA_InterfaceDefSeq *ptr (void) const;

    private:
      CORBA_InterfaceDefSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_INTERFACEDEFSEQ___OUT_CH_)
#define _CORBA_INTERFACEDEFSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_InterfaceDefSeq_out
    {
    public:
      CORBA_InterfaceDefSeq_out (CORBA_InterfaceDefSeq *&);
      CORBA_InterfaceDefSeq_out (CORBA_InterfaceDefSeq_var &);
      CORBA_InterfaceDefSeq_out (const CORBA_InterfaceDefSeq_out &);
      CORBA_InterfaceDefSeq_out &operator= (const CORBA_InterfaceDefSeq_out &);
      CORBA_InterfaceDefSeq_out &operator= (CORBA_InterfaceDefSeq *);
      operator CORBA_InterfaceDefSeq *&();
      CORBA_InterfaceDefSeq *&ptr (void);
      CORBA_InterfaceDefSeq *operator-> (void);
      TAO_Object_Manager<CORBA_InterfaceDef, CORBA_InterfaceDef_var> operator[] (CORBA::ULong index);

    private:
      CORBA_InterfaceDefSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_InterfaceDefSeq_var &);
    };


#endif /* end #if !defined */

    class CORBA_ExceptionDef;

#if !defined (_CORBA_EXCEPTIONDEF___PTR_CH_)
#define _CORBA_EXCEPTIONDEF___PTR_CH_

    typedef CORBA_ExceptionDef *CORBA_ExceptionDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF___VAR_CH_)
#define _CORBA_EXCEPTIONDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_ExceptionDef_var : public TAO_Base_var
    {
    public:
      CORBA_ExceptionDef_var (void); // default constructor
      CORBA_ExceptionDef_var (CORBA_ExceptionDef_ptr p) : ptr_ (p) {}
      CORBA_ExceptionDef_var (const CORBA_ExceptionDef_var &); // copy constructor
      ~CORBA_ExceptionDef_var (void); // destructor

      CORBA_ExceptionDef_var &operator= (CORBA_ExceptionDef_ptr);
      CORBA_ExceptionDef_var &operator= (const CORBA_ExceptionDef_var &);
      CORBA_ExceptionDef_ptr operator-> (void) const;

      operator const CORBA_ExceptionDef_ptr &() const;
      operator CORBA_ExceptionDef_ptr &();
      // in, inout, out, _retn
      CORBA_ExceptionDef_ptr in (void) const;
      CORBA_ExceptionDef_ptr &inout (void);
      CORBA_ExceptionDef_ptr &out (void);
      CORBA_ExceptionDef_ptr _retn (void);
      CORBA_ExceptionDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_ExceptionDef_ptr tao_duplicate (CORBA_ExceptionDef_ptr);
      static void tao_release (CORBA_ExceptionDef_ptr);
      static CORBA_ExceptionDef_ptr tao_nil (void);
      static CORBA_ExceptionDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_ExceptionDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_ExceptionDef_var (const TAO_Base_var &rhs);
      CORBA_ExceptionDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_EXCEPTIONDEF___OUT_CH_)
#define _CORBA_EXCEPTIONDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ExceptionDef_out
    {
    public:
      CORBA_ExceptionDef_out (CORBA_ExceptionDef_ptr &);
      CORBA_ExceptionDef_out (CORBA_ExceptionDef_var &);
      CORBA_ExceptionDef_out (const CORBA_ExceptionDef_out &);
      CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_out &);
      CORBA_ExceptionDef_out &operator= (const CORBA_ExceptionDef_var &);
      CORBA_ExceptionDef_out &operator= (CORBA_ExceptionDef_ptr);
      operator CORBA_ExceptionDef_ptr &();
      CORBA_ExceptionDef_ptr &ptr (void);
      CORBA_ExceptionDef_ptr operator-> (void);

    private:
      CORBA_ExceptionDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_NativeDef;

#if !defined (_CORBA_NATIVEDEF___PTR_CH_)
#define _CORBA_NATIVEDEF___PTR_CH_

    typedef CORBA_NativeDef *CORBA_NativeDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_NATIVEDEF___VAR_CH_)
#define _CORBA_NATIVEDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_NativeDef_var : public TAO_Base_var
    {
    public:
      CORBA_NativeDef_var (void); // default constructor
      CORBA_NativeDef_var (CORBA_NativeDef_ptr p) : ptr_ (p) {}
      CORBA_NativeDef_var (const CORBA_NativeDef_var &); // copy constructor
      ~CORBA_NativeDef_var (void); // destructor

      CORBA_NativeDef_var &operator= (CORBA_NativeDef_ptr);
      CORBA_NativeDef_var &operator= (const CORBA_NativeDef_var &);
      CORBA_NativeDef_ptr operator-> (void) const;

      operator const CORBA_NativeDef_ptr &() const;
      operator CORBA_NativeDef_ptr &();
      // in, inout, out, _retn
      CORBA_NativeDef_ptr in (void) const;
      CORBA_NativeDef_ptr &inout (void);
      CORBA_NativeDef_ptr &out (void);
      CORBA_NativeDef_ptr _retn (void);
      CORBA_NativeDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_NativeDef_ptr tao_duplicate (CORBA_NativeDef_ptr);
      static void tao_release (CORBA_NativeDef_ptr);
      static CORBA_NativeDef_ptr tao_nil (void);
      static CORBA_NativeDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_NativeDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_NativeDef_var (const TAO_Base_var &rhs);
      CORBA_NativeDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_NATIVEDEF___OUT_CH_)
#define _CORBA_NATIVEDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_NativeDef_out
    {
    public:
      CORBA_NativeDef_out (CORBA_NativeDef_ptr &);
      CORBA_NativeDef_out (CORBA_NativeDef_var &);
      CORBA_NativeDef_out (const CORBA_NativeDef_out &);
      CORBA_NativeDef_out &operator= (const CORBA_NativeDef_out &);
      CORBA_NativeDef_out &operator= (const CORBA_NativeDef_var &);
      CORBA_NativeDef_out &operator= (CORBA_NativeDef_ptr);
      operator CORBA_NativeDef_ptr &();
      CORBA_NativeDef_ptr &ptr (void);
      CORBA_NativeDef_ptr operator-> (void);

    private:
      CORBA_NativeDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_ValueDef;

#if !defined (_CORBA_VALUEDEF___PTR_CH_)
#define _CORBA_VALUEDEF___PTR_CH_

    typedef CORBA_ValueDef *CORBA_ValueDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___VAR_CH_)
#define _CORBA_VALUEDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_ValueDef_var : public TAO_Base_var
    {
    public:
      CORBA_ValueDef_var (void); // default constructor
      CORBA_ValueDef_var (CORBA_ValueDef_ptr p) : ptr_ (p) {}
      CORBA_ValueDef_var (const CORBA_ValueDef_var &); // copy constructor
      ~CORBA_ValueDef_var (void); // destructor

      CORBA_ValueDef_var &operator= (CORBA_ValueDef_ptr);
      CORBA_ValueDef_var &operator= (const CORBA_ValueDef_var &);
      CORBA_ValueDef_ptr operator-> (void) const;

      operator const CORBA_ValueDef_ptr &() const;
      operator CORBA_ValueDef_ptr &();
      // in, inout, out, _retn
      CORBA_ValueDef_ptr in (void) const;
      CORBA_ValueDef_ptr &inout (void);
      CORBA_ValueDef_ptr &out (void);
      CORBA_ValueDef_ptr _retn (void);
      CORBA_ValueDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_ValueDef_ptr tao_duplicate (CORBA_ValueDef_ptr);
      static void tao_release (CORBA_ValueDef_ptr);
      static CORBA_ValueDef_ptr tao_nil (void);
      static CORBA_ValueDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_ValueDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_ValueDef_var (const TAO_Base_var &rhs);
      CORBA_ValueDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEF___OUT_CH_)
#define _CORBA_VALUEDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ValueDef_out
    {
    public:
      CORBA_ValueDef_out (CORBA_ValueDef_ptr &);
      CORBA_ValueDef_out (CORBA_ValueDef_var &);
      CORBA_ValueDef_out (const CORBA_ValueDef_out &);
      CORBA_ValueDef_out &operator= (const CORBA_ValueDef_out &);
      CORBA_ValueDef_out &operator= (const CORBA_ValueDef_var &);
      CORBA_ValueDef_out &operator= (CORBA_ValueDef_ptr);
      operator CORBA_ValueDef_ptr &();
      CORBA_ValueDef_ptr &ptr (void);
      CORBA_ValueDef_ptr operator-> (void);

    private:
      CORBA_ValueDef_ptr &ptr_;
    };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_VALUEDEFSEQ_CH_

    class TAO_EXPORT_MACRO _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_ValueDef* *value,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (
          const _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq &rhs
        );
      _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq &operator= (
          const _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq &rhs
        );
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq (void);

      // = Accessors.
      TAO_Object_Manager<CORBA_ValueDef,CORBA_ValueDef_var> operator[] (CORBA::ULong index) const;

      // = Static operations.
      static CORBA_ValueDef **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_ValueDef **buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_ValueDef* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_ValueDef* *get_buffer (void) const;
      virtual void _shrink_buffer (
          CORBA::ULong nl,
          CORBA::ULong ol
        );

      virtual void _downcast (
          void* target,
          CORBA_Object *src
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);

      virtual CORBA_Object* _upcast (void *src) const;
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_VALUEDEFSEQ_CH_)
#define _CORBA_VALUEDEFSEQ_CH_

    class CORBA_ValueDefSeq;
    class CORBA_ValueDefSeq_var;

    // *************************************************************
    // CORBA_ValueDefSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_ValueDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_ValueDef,CORBA_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_ValueDefSeq (void); // default ctor
      CORBA_ValueDefSeq (CORBA::ULong max); // uses max size
      CORBA_ValueDefSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_ValueDef_ptr *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_ValueDefSeq (const CORBA_ValueDefSeq &); // copy ctor
      ~CORBA_ValueDefSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_ValueDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEFSEQ___VAR_CH_)
#define _CORBA_VALUEDEFSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_ValueDefSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_ValueDefSeq_var
    {
    public:
      CORBA_ValueDefSeq_var (void);
      CORBA_ValueDefSeq_var (CORBA_ValueDefSeq *);
      CORBA_ValueDefSeq_var (const CORBA_ValueDefSeq_var &);
      ~CORBA_ValueDefSeq_var (void);

      CORBA_ValueDefSeq_var &operator= (CORBA_ValueDefSeq *);
      CORBA_ValueDefSeq_var &operator= (const CORBA_ValueDefSeq_var &);
      CORBA_ValueDefSeq *operator-> (void);
      const CORBA_ValueDefSeq *operator-> (void) const;

      operator const CORBA_ValueDefSeq &() const;
      operator CORBA_ValueDefSeq &();
      operator CORBA_ValueDefSeq &() const;
      operator CORBA_ValueDefSeq *&(); // variable-size base types only

      TAO_Object_Manager<CORBA_ValueDef, CORBA_ValueDef_var> operator[] (CORBA::ULong index);

      // in, inout, out, _retn
      const CORBA_ValueDefSeq &in (void) const;
      CORBA_ValueDefSeq &inout (void);
      CORBA_ValueDefSeq *&out (void);
      CORBA_ValueDefSeq *_retn (void);
      CORBA_ValueDefSeq *ptr (void) const;

    private:
      CORBA_ValueDefSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEDEFSEQ___OUT_CH_)
#define _CORBA_VALUEDEFSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ValueDefSeq_out
    {
    public:
      CORBA_ValueDefSeq_out (CORBA_ValueDefSeq *&);
      CORBA_ValueDefSeq_out (CORBA_ValueDefSeq_var &);
      CORBA_ValueDefSeq_out (const CORBA_ValueDefSeq_out &);
      CORBA_ValueDefSeq_out &operator= (const CORBA_ValueDefSeq_out &);
      CORBA_ValueDefSeq_out &operator= (CORBA_ValueDefSeq *);
      operator CORBA_ValueDefSeq *&();
      CORBA_ValueDefSeq *&ptr (void);
      CORBA_ValueDefSeq *operator-> (void);
      TAO_Object_Manager<CORBA_ValueDef, CORBA_ValueDef_var> operator[] (CORBA::ULong index);

    private:
      CORBA_ValueDefSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_ValueDefSeq_var &);
    };


#endif /* end #if !defined */

    class CORBA_ValueBoxDef;

#if !defined (_CORBA_VALUEBOXDEF___PTR_CH_)
#define _CORBA_VALUEBOXDEF___PTR_CH_

    typedef CORBA_ValueBoxDef *CORBA_ValueBoxDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___VAR_CH_)
#define _CORBA_VALUEBOXDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_ValueBoxDef_var : public TAO_Base_var
    {
    public:
      CORBA_ValueBoxDef_var (void); // default constructor
      CORBA_ValueBoxDef_var (CORBA_ValueBoxDef_ptr p) : ptr_ (p) {}
      CORBA_ValueBoxDef_var (const CORBA_ValueBoxDef_var &); // copy constructor
      ~CORBA_ValueBoxDef_var (void); // destructor

      CORBA_ValueBoxDef_var &operator= (CORBA_ValueBoxDef_ptr);
      CORBA_ValueBoxDef_var &operator= (const CORBA_ValueBoxDef_var &);
      CORBA_ValueBoxDef_ptr operator-> (void) const;

      operator const CORBA_ValueBoxDef_ptr &() const;
      operator CORBA_ValueBoxDef_ptr &();
      // in, inout, out, _retn
      CORBA_ValueBoxDef_ptr in (void) const;
      CORBA_ValueBoxDef_ptr &inout (void);
      CORBA_ValueBoxDef_ptr &out (void);
      CORBA_ValueBoxDef_ptr _retn (void);
      CORBA_ValueBoxDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_ValueBoxDef_ptr tao_duplicate (CORBA_ValueBoxDef_ptr);
      static void tao_release (CORBA_ValueBoxDef_ptr);
      static CORBA_ValueBoxDef_ptr tao_nil (void);
      static CORBA_ValueBoxDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_ValueBoxDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_ValueBoxDef_var (const TAO_Base_var &rhs);
      CORBA_ValueBoxDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_VALUEBOXDEF___OUT_CH_)
#define _CORBA_VALUEBOXDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_ValueBoxDef_out
    {
    public:
      CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_ptr &);
      CORBA_ValueBoxDef_out (CORBA_ValueBoxDef_var &);
      CORBA_ValueBoxDef_out (const CORBA_ValueBoxDef_out &);
      CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_out &);
      CORBA_ValueBoxDef_out &operator= (const CORBA_ValueBoxDef_var &);
      CORBA_ValueBoxDef_out &operator= (CORBA_ValueBoxDef_ptr);
      operator CORBA_ValueBoxDef_ptr &();
      CORBA_ValueBoxDef_ptr &ptr (void);
      CORBA_ValueBoxDef_ptr operator-> (void);

    private:
      CORBA_ValueBoxDef_ptr &ptr_;
    };


#endif /* end #if !defined */

    class CORBA_AbstractInterfaceDef;

#if !defined (_CORBA_ABSTRACTINTERFACEDEF___PTR_CH_)
#define _CORBA_ABSTRACTINTERFACEDEF___PTR_CH_

    typedef CORBA_AbstractInterfaceDef *CORBA_AbstractInterfaceDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEF___VAR_CH_)
#define _CORBA_ABSTRACTINTERFACEDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_AbstractInterfaceDef_var : public TAO_Base_var
    {
    public:
      CORBA_AbstractInterfaceDef_var (void); // default constructor
      CORBA_AbstractInterfaceDef_var (CORBA_AbstractInterfaceDef_ptr p) : ptr_ (p) {}
      CORBA_AbstractInterfaceDef_var (const CORBA_AbstractInterfaceDef_var &); // copy constructor
      ~CORBA_AbstractInterfaceDef_var (void); // destructor

      CORBA_AbstractInterfaceDef_var &operator= (CORBA_AbstractInterfaceDef_ptr);
      CORBA_AbstractInterfaceDef_var &operator= (const CORBA_AbstractInterfaceDef_var &);
      CORBA_AbstractInterfaceDef_ptr operator-> (void) const;

      operator const CORBA_AbstractInterfaceDef_ptr &() const;
      operator CORBA_AbstractInterfaceDef_ptr &();
      // in, inout, out, _retn
      CORBA_AbstractInterfaceDef_ptr in (void) const;
      CORBA_AbstractInterfaceDef_ptr &inout (void);
      CORBA_AbstractInterfaceDef_ptr &out (void);
      CORBA_AbstractInterfaceDef_ptr _retn (void);
      CORBA_AbstractInterfaceDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_AbstractInterfaceDef_ptr tao_duplicate (CORBA_AbstractInterfaceDef_ptr);
      static void tao_release (CORBA_AbstractInterfaceDef_ptr);
      static CORBA_AbstractInterfaceDef_ptr tao_nil (void);
      static CORBA_AbstractInterfaceDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_AbstractInterfaceDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_AbstractInterfaceDef_var (const TAO_Base_var &rhs);
      CORBA_AbstractInterfaceDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEF___OUT_CH_)
#define _CORBA_ABSTRACTINTERFACEDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_AbstractInterfaceDef_out
    {
    public:
      CORBA_AbstractInterfaceDef_out (CORBA_AbstractInterfaceDef_ptr &);
      CORBA_AbstractInterfaceDef_out (CORBA_AbstractInterfaceDef_var &);
      CORBA_AbstractInterfaceDef_out (const CORBA_AbstractInterfaceDef_out &);
      CORBA_AbstractInterfaceDef_out &operator= (const CORBA_AbstractInterfaceDef_out &);
      CORBA_AbstractInterfaceDef_out &operator= (const CORBA_AbstractInterfaceDef_var &);
      CORBA_AbstractInterfaceDef_out &operator= (CORBA_AbstractInterfaceDef_ptr);
      operator CORBA_AbstractInterfaceDef_ptr &();
      CORBA_AbstractInterfaceDef_ptr &ptr (void);
      CORBA_AbstractInterfaceDef_ptr operator-> (void);

    private:
      CORBA_AbstractInterfaceDef_ptr &ptr_;
    };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_ABSTRACTINTERFACEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_ABSTRACTINTERFACEDEFSEQ_CH_

    class TAO_EXPORT_MACRO _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_AbstractInterfaceDef* *value,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (
          const _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq &rhs
        );
      _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq &operator= (
          const _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq &rhs
        );
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq (void);

      // = Accessors.
      TAO_Object_Manager<CORBA_AbstractInterfaceDef,CORBA_AbstractInterfaceDef_var> operator[] (CORBA::ULong index) const;

      // = Static operations.
      static CORBA_AbstractInterfaceDef **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_AbstractInterfaceDef **buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_AbstractInterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_AbstractInterfaceDef* *get_buffer (void) const;
      virtual void _shrink_buffer (
          CORBA::ULong nl,
          CORBA::ULong ol
        );

      virtual void _downcast (
          void* target,
          CORBA_Object *src
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);

      virtual CORBA_Object* _upcast (void *src) const;
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ_CH_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ_CH_

    class CORBA_AbstractInterfaceDefSeq;
    class CORBA_AbstractInterfaceDefSeq_var;

    // *************************************************************
    // CORBA_AbstractInterfaceDefSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_AbstractInterfaceDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_AbstractInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_AbstractInterfaceDef,CORBA_AbstractInterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_AbstractInterfaceDefSeq (void); // default ctor
      CORBA_AbstractInterfaceDefSeq (CORBA::ULong max); // uses max size
      CORBA_AbstractInterfaceDefSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_AbstractInterfaceDef_ptr *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_AbstractInterfaceDefSeq (const CORBA_AbstractInterfaceDefSeq &); // copy ctor
      ~CORBA_AbstractInterfaceDefSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_AbstractInterfaceDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ___VAR_CH_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_AbstractInterfaceDefSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_AbstractInterfaceDefSeq_var
    {
    public:
      CORBA_AbstractInterfaceDefSeq_var (void);
      CORBA_AbstractInterfaceDefSeq_var (CORBA_AbstractInterfaceDefSeq *);
      CORBA_AbstractInterfaceDefSeq_var (const CORBA_AbstractInterfaceDefSeq_var &);
      ~CORBA_AbstractInterfaceDefSeq_var (void);

      CORBA_AbstractInterfaceDefSeq_var &operator= (CORBA_AbstractInterfaceDefSeq *);
      CORBA_AbstractInterfaceDefSeq_var &operator= (const CORBA_AbstractInterfaceDefSeq_var &);
      CORBA_AbstractInterfaceDefSeq *operator-> (void);
      const CORBA_AbstractInterfaceDefSeq *operator-> (void) const;

      operator const CORBA_AbstractInterfaceDefSeq &() const;
      operator CORBA_AbstractInterfaceDefSeq &();
      operator CORBA_AbstractInterfaceDefSeq &() const;
      operator CORBA_AbstractInterfaceDefSeq *&(); // variable-size base types only

      TAO_Object_Manager<CORBA_AbstractInterfaceDef, CORBA_AbstractInterfaceDef_var> operator[] (CORBA::ULong index);

      // in, inout, out, _retn
      const CORBA_AbstractInterfaceDefSeq &in (void) const;
      CORBA_AbstractInterfaceDefSeq &inout (void);
      CORBA_AbstractInterfaceDefSeq *&out (void);
      CORBA_AbstractInterfaceDefSeq *_retn (void);
      CORBA_AbstractInterfaceDefSeq *ptr (void) const;

    private:
      CORBA_AbstractInterfaceDefSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ___OUT_CH_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_AbstractInterfaceDefSeq_out
    {
    public:
      CORBA_AbstractInterfaceDefSeq_out (CORBA_AbstractInterfaceDefSeq *&);
      CORBA_AbstractInterfaceDefSeq_out (CORBA_AbstractInterfaceDefSeq_var &);
      CORBA_AbstractInterfaceDefSeq_out (const CORBA_AbstractInterfaceDefSeq_out &);
      CORBA_AbstractInterfaceDefSeq_out &operator= (const CORBA_AbstractInterfaceDefSeq_out &);
      CORBA_AbstractInterfaceDefSeq_out &operator= (CORBA_AbstractInterfaceDefSeq *);
      operator CORBA_AbstractInterfaceDefSeq *&();
      CORBA_AbstractInterfaceDefSeq *&ptr (void);
      CORBA_AbstractInterfaceDefSeq *operator-> (void);
      TAO_Object_Manager<CORBA_AbstractInterfaceDef, CORBA_AbstractInterfaceDef_var> operator[] (CORBA::ULong index);

    private:
      CORBA_AbstractInterfaceDefSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_AbstractInterfaceDefSeq_var &);
    };


#endif /* end #if !defined */

    class CORBA_LocalInterfaceDef;

#if !defined (_CORBA_LOCALINTERFACEDEF___PTR_CH_)
#define _CORBA_LOCALINTERFACEDEF___PTR_CH_

    typedef CORBA_LocalInterfaceDef *CORBA_LocalInterfaceDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEF___VAR_CH_)
#define _CORBA_LOCALINTERFACEDEF___VAR_CH_

    class TAO_IFR_Client_Export CORBA_LocalInterfaceDef_var : public TAO_Base_var
    {
    public:
      CORBA_LocalInterfaceDef_var (void); // default constructor
      CORBA_LocalInterfaceDef_var (CORBA_LocalInterfaceDef_ptr p) : ptr_ (p) {}
      CORBA_LocalInterfaceDef_var (const CORBA_LocalInterfaceDef_var &); // copy constructor
      ~CORBA_LocalInterfaceDef_var (void); // destructor

      CORBA_LocalInterfaceDef_var &operator= (CORBA_LocalInterfaceDef_ptr);
      CORBA_LocalInterfaceDef_var &operator= (const CORBA_LocalInterfaceDef_var &);
      CORBA_LocalInterfaceDef_ptr operator-> (void) const;

      operator const CORBA_LocalInterfaceDef_ptr &() const;
      operator CORBA_LocalInterfaceDef_ptr &();
      // in, inout, out, _retn
      CORBA_LocalInterfaceDef_ptr in (void) const;
      CORBA_LocalInterfaceDef_ptr &inout (void);
      CORBA_LocalInterfaceDef_ptr &out (void);
      CORBA_LocalInterfaceDef_ptr _retn (void);
      CORBA_LocalInterfaceDef_ptr ptr (void) const;

      // Hooks used by template sequence and object manager classes
      // for non-defined forward declared interfaces.
      static CORBA_LocalInterfaceDef_ptr tao_duplicate (CORBA_LocalInterfaceDef_ptr);
      static void tao_release (CORBA_LocalInterfaceDef_ptr);
      static CORBA_LocalInterfaceDef_ptr tao_nil (void);
      static CORBA_LocalInterfaceDef_ptr tao_narrow (
          CORBA::Object *
          ACE_ENV_ARG_DECL_NOT_USED
        );
      static CORBA::Object * tao_upcast (void *);

    private:
      CORBA_LocalInterfaceDef_ptr ptr_;
      // Unimplemented - prevents widening assignment.
      CORBA_LocalInterfaceDef_var (const TAO_Base_var &rhs);
      CORBA_LocalInterfaceDef_var &operator= (const TAO_Base_var &rhs);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEF___OUT_CH_)
#define _CORBA_LOCALINTERFACEDEF___OUT_CH_

    class TAO_IFR_Client_Export CORBA_LocalInterfaceDef_out
    {
    public:
      CORBA_LocalInterfaceDef_out (CORBA_LocalInterfaceDef_ptr &);
      CORBA_LocalInterfaceDef_out (CORBA_LocalInterfaceDef_var &);
      CORBA_LocalInterfaceDef_out (const CORBA_LocalInterfaceDef_out &);
      CORBA_LocalInterfaceDef_out &operator= (const CORBA_LocalInterfaceDef_out &);
      CORBA_LocalInterfaceDef_out &operator= (const CORBA_LocalInterfaceDef_var &);
      CORBA_LocalInterfaceDef_out &operator= (CORBA_LocalInterfaceDef_ptr);
      operator CORBA_LocalInterfaceDef_ptr &();
      CORBA_LocalInterfaceDef_ptr &ptr (void);
      CORBA_LocalInterfaceDef_ptr operator-> (void);

    private:
      CORBA_LocalInterfaceDef_ptr &ptr_;
    };


#endif /* end #if !defined */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_LOCALINTERFACEDEFSEQ_CH_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_CORBA_LOCALINTERFACEDEFSEQ_CH_

    class TAO_EXPORT_MACRO _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (void);
      _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_LocalInterfaceDef* *value,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (
          const _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq &rhs
        );
      _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq &operator= (
          const _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq &rhs
        );
      virtual ~_TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq (void);

      // = Accessors.
      TAO_Object_Manager<CORBA_LocalInterfaceDef,CORBA_LocalInterfaceDef_var> operator[] (CORBA::ULong index) const;

      // = Static operations.
      static CORBA_LocalInterfaceDef **allocbuf (CORBA::ULong nelems);
      static void freebuf (CORBA_LocalInterfaceDef **buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_LocalInterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_LocalInterfaceDef* *get_buffer (void) const;
      virtual void _shrink_buffer (
          CORBA::ULong nl,
          CORBA::ULong ol
        );

      virtual void _downcast (
          void* target,
          CORBA_Object *src
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);

      virtual CORBA_Object* _upcast (void *src) const;
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_LOCALINTERFACEDEFSEQ_CH_)
#define _CORBA_LOCALINTERFACEDEFSEQ_CH_

    class CORBA_LocalInterfaceDefSeq;
    class CORBA_LocalInterfaceDefSeq_var;

    // *************************************************************
    // CORBA_LocalInterfaceDefSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_LocalInterfaceDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Object_Sequence_CORBA_LocalInterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Object_Sequence<CORBA_LocalInterfaceDef,CORBA_LocalInterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_LocalInterfaceDefSeq (void); // default ctor
      CORBA_LocalInterfaceDefSeq (CORBA::ULong max); // uses max size
      CORBA_LocalInterfaceDefSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_LocalInterfaceDef_ptr *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_LocalInterfaceDefSeq (const CORBA_LocalInterfaceDefSeq &); // copy ctor
      ~CORBA_LocalInterfaceDefSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_LocalInterfaceDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEFSEQ___VAR_CH_)
#define _CORBA_LOCALINTERFACEDEFSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_LocalInterfaceDefSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_LocalInterfaceDefSeq_var
    {
    public:
      CORBA_LocalInterfaceDefSeq_var (void);
      CORBA_LocalInterfaceDefSeq_var (CORBA_LocalInterfaceDefSeq *);
      CORBA_LocalInterfaceDefSeq_var (const CORBA_LocalInterfaceDefSeq_var &);
      ~CORBA_LocalInterfaceDefSeq_var (void);

      CORBA_LocalInterfaceDefSeq_var &operator= (CORBA_LocalInterfaceDefSeq *);
      CORBA_LocalInterfaceDefSeq_var &operator= (const CORBA_LocalInterfaceDefSeq_var &);
      CORBA_LocalInterfaceDefSeq *operator-> (void);
      const CORBA_LocalInterfaceDefSeq *operator-> (void) const;

      operator const CORBA_LocalInterfaceDefSeq &() const;
      operator CORBA_LocalInterfaceDefSeq &();
      operator CORBA_LocalInterfaceDefSeq &() const;
      operator CORBA_LocalInterfaceDefSeq *&(); // variable-size base types only

      TAO_Object_Manager<CORBA_LocalInterfaceDef, CORBA_LocalInterfaceDef_var> operator[] (CORBA::ULong index);

      // in, inout, out, _retn
      const CORBA_LocalInterfaceDefSeq &in (void) const;
      CORBA_LocalInterfaceDefSeq &inout (void);
      CORBA_LocalInterfaceDefSeq *&out (void);
      CORBA_LocalInterfaceDefSeq *_retn (void);
      CORBA_LocalInterfaceDefSeq *ptr (void) const;

    private:
      CORBA_LocalInterfaceDefSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_LOCALINTERFACEDEFSEQ___OUT_CH_)
#define _CORBA_LOCALINTERFACEDEFSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_LocalInterfaceDefSeq_out
    {
    public:
      CORBA_LocalInterfaceDefSeq_out (CORBA_LocalInterfaceDefSeq *&);
      CORBA_LocalInterfaceDefSeq_out (CORBA_LocalInterfaceDefSeq_var &);
      CORBA_LocalInterfaceDefSeq_out (const CORBA_LocalInterfaceDefSeq_out &);
      CORBA_LocalInterfaceDefSeq_out &operator= (const CORBA_LocalInterfaceDefSeq_out &);
      CORBA_LocalInterfaceDefSeq_out &operator= (CORBA_LocalInterfaceDefSeq *);
      operator CORBA_LocalInterfaceDefSeq *&();
      CORBA_LocalInterfaceDefSeq *&ptr (void);
      CORBA_LocalInterfaceDefSeq *operator-> (void);
      TAO_Object_Manager<CORBA_LocalInterfaceDef, CORBA_LocalInterfaceDef_var> operator[] (CORBA::ULong index);

    private:
      CORBA_LocalInterfaceDefSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_LocalInterfaceDefSeq_var &);
    };


#endif /* end #if !defined */

    struct CORBA_StructMember;
    class CORBA_StructMember_var;

    struct TAO_IFR_Client_Export CORBA_StructMember
    {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_StructMember_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

      static void _tao_any_destructor (void*);

      TAO_String_Manager name;
      CORBA::TypeCode_var type;
      CORBA_IDLType_var type_def;

    };

    class TAO_IFR_Client_Export CORBA_StructMember_var
    {
    public:
      CORBA_StructMember_var (void);
      CORBA_StructMember_var (CORBA_StructMember *);
      CORBA_StructMember_var (const CORBA_StructMember_var &);
      ~CORBA_StructMember_var (void);

      CORBA_StructMember_var &operator= (CORBA_StructMember *);
      CORBA_StructMember_var &operator= (const CORBA_StructMember_var &);
      CORBA_StructMember *operator-> (void);
      const CORBA_StructMember *operator-> (void) const;

      operator const CORBA_StructMember &() const;
      operator CORBA_StructMember &();
      operator CORBA_StructMember &() const;
      // Variable-size types only.
      operator CORBA_StructMember *&();

      // in, inout, out, _retn
      const CORBA_StructMember &in (void) const;
      CORBA_StructMember &inout (void);
      CORBA_StructMember *&out (void);
      CORBA_StructMember *_retn (void);
      CORBA_StructMember *ptr (void) const;

    private:
      CORBA_StructMember *ptr_;
    };

    class TAO_IFR_Client_Export CORBA_StructMember_out
    {
    public:
      CORBA_StructMember_out (CORBA_StructMember *&);
      CORBA_StructMember_out (CORBA_StructMember_var &);
      CORBA_StructMember_out (const CORBA_StructMember_out &);
      CORBA_StructMember_out &operator= (const CORBA_StructMember_out &);
      CORBA_StructMember_out &operator= (CORBA_StructMember *);
      operator CORBA_StructMember *&();
      CORBA_StructMember *&ptr (void);
      CORBA_StructMember *operator-> (void);

    private:
      CORBA_StructMember *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_StructMember_var &);
    };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_STRUCTMEMBERSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void);
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_StructMember *data,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq (
          const _TAO_Unbounded_Sequence_CORBA_StructMemberSeq &rhs
        );
      _TAO_Unbounded_Sequence_CORBA_StructMemberSeq &operator= (
          const _TAO_Unbounded_Sequence_CORBA_StructMemberSeq &rhs
        );
      virtual ~_TAO_Unbounded_Sequence_CORBA_StructMemberSeq (void);

      // = Accessors.
      CORBA_StructMember &operator[] (CORBA::ULong i);
      const CORBA_StructMember &operator[] (CORBA::ULong i) const;

      // = Static operations.
      static CORBA_StructMember *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_StructMember *buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_StructMember *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_StructMember *get_buffer (void) const;
      void replace (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_StructMember *data,
          CORBA::Boolean release
        );
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_STRUCTMEMBERSEQ_CH_)
#define _CORBA_STRUCTMEMBERSEQ_CH_

    class CORBA_StructMemberSeq;
    class CORBA_StructMemberSeq_var;

    // *************************************************************
    // CORBA_StructMemberSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_StructMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_StructMemberSeq (void); // default ctor
      CORBA_StructMemberSeq (CORBA::ULong max); // uses max size
      CORBA_StructMemberSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_StructMember *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_StructMemberSeq (const CORBA_StructMemberSeq &); // copy ctor
      ~CORBA_StructMemberSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_StructMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTMEMBERSEQ___VAR_CH_)
#define _CORBA_STRUCTMEMBERSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_StructMemberSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_StructMemberSeq_var
    {
    public:
      CORBA_StructMemberSeq_var (void);
      CORBA_StructMemberSeq_var (CORBA_StructMemberSeq *);
      CORBA_StructMemberSeq_var (const CORBA_StructMemberSeq_var &);
      ~CORBA_StructMemberSeq_var (void);

      CORBA_StructMemberSeq_var &operator= (CORBA_StructMemberSeq *);
      CORBA_StructMemberSeq_var &operator= (const CORBA_StructMemberSeq_var &);
      CORBA_StructMemberSeq *operator-> (void);
      const CORBA_StructMemberSeq *operator-> (void) const;

      operator const CORBA_StructMemberSeq &() const;
      operator CORBA_StructMemberSeq &();
      operator CORBA_StructMemberSeq &() const;
      operator CORBA_StructMemberSeq *&(); // variable-size base types only

      CORBA_StructMember & operator[] (CORBA::ULong index);
      const CORBA_StructMember & operator[] (CORBA::ULong index) const;

      // in, inout, out, _retn
      const CORBA_StructMemberSeq &in (void) const;
      CORBA_StructMemberSeq &inout (void);
      CORBA_StructMemberSeq *&out (void);
      CORBA_StructMemberSeq *_retn (void);
      CORBA_StructMemberSeq *ptr (void) const;

    private:
      CORBA_StructMemberSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_STRUCTMEMBERSEQ___OUT_CH_)
#define _CORBA_STRUCTMEMBERSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_StructMemberSeq_out
    {
    public:
      CORBA_StructMemberSeq_out (CORBA_StructMemberSeq *&);
      CORBA_StructMemberSeq_out (CORBA_StructMemberSeq_var &);
      CORBA_StructMemberSeq_out (const CORBA_StructMemberSeq_out &);
      CORBA_StructMemberSeq_out &operator= (const CORBA_StructMemberSeq_out &);
      CORBA_StructMemberSeq_out &operator= (CORBA_StructMemberSeq *);
      operator CORBA_StructMemberSeq *&();
      CORBA_StructMemberSeq *&ptr (void);
      CORBA_StructMemberSeq *operator-> (void);
      CORBA_StructMember & operator[] (CORBA::ULong index);

    private:
      CORBA_StructMemberSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_StructMemberSeq_var &);
    };


#endif /* end #if !defined */

    struct CORBA_Initializer;
    class CORBA_Initializer_var;

    struct TAO_IFR_Client_Export CORBA_Initializer
    {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_Initializer_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

      static void _tao_any_destructor (void*);

      CORBA_StructMemberSeq members;
      TAO_String_Manager name;

    };

    class TAO_IFR_Client_Export CORBA_Initializer_var
    {
    public:
      CORBA_Initializer_var (void);
      CORBA_Initializer_var (CORBA_Initializer *);
      CORBA_Initializer_var (const CORBA_Initializer_var &);
      ~CORBA_Initializer_var (void);

      CORBA_Initializer_var &operator= (CORBA_Initializer *);
      CORBA_Initializer_var &operator= (const CORBA_Initializer_var &);
      CORBA_Initializer *operator-> (void);
      const CORBA_Initializer *operator-> (void) const;

      operator const CORBA_Initializer &() const;
      operator CORBA_Initializer &();
      operator CORBA_Initializer &() const;
      // Variable-size types only.
      operator CORBA_Initializer *&();

      // in, inout, out, _retn
      const CORBA_Initializer &in (void) const;
      CORBA_Initializer &inout (void);
      CORBA_Initializer *&out (void);
      CORBA_Initializer *_retn (void);
      CORBA_Initializer *ptr (void) const;

    private:
      CORBA_Initializer *ptr_;
    };

    class TAO_IFR_Client_Export CORBA_Initializer_out
    {
    public:
      CORBA_Initializer_out (CORBA_Initializer *&);
      CORBA_Initializer_out (CORBA_Initializer_var &);
      CORBA_Initializer_out (const CORBA_Initializer_out &);
      CORBA_Initializer_out &operator= (const CORBA_Initializer_out &);
      CORBA_Initializer_out &operator= (CORBA_Initializer *);
      operator CORBA_Initializer *&();
      CORBA_Initializer *&ptr (void);
      CORBA_Initializer *operator-> (void);

    private:
      CORBA_Initializer *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_Initializer_var &);
    };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_INITIALIZERSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_InitializerSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (void);
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_Initializer *data,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq (
          const _TAO_Unbounded_Sequence_CORBA_InitializerSeq &rhs
        );
      _TAO_Unbounded_Sequence_CORBA_InitializerSeq &operator= (
          const _TAO_Unbounded_Sequence_CORBA_InitializerSeq &rhs
        );
      virtual ~_TAO_Unbounded_Sequence_CORBA_InitializerSeq (void);

      // = Accessors.
      CORBA_Initializer &operator[] (CORBA::ULong i);
      const CORBA_Initializer &operator[] (CORBA::ULong i) const;

      // = Static operations.
      static CORBA_Initializer *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_Initializer *buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_Initializer *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_Initializer *get_buffer (void) const;
      void replace (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_Initializer *data,
          CORBA::Boolean release
        );
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_INITIALIZERSEQ_CH_)
#define _CORBA_INITIALIZERSEQ_CH_

    class CORBA_InitializerSeq;
    class CORBA_InitializerSeq_var;

    // *************************************************************
    // CORBA_InitializerSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_InitializerSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_InitializerSeq (void); // default ctor
      CORBA_InitializerSeq (CORBA::ULong max); // uses max size
      CORBA_InitializerSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_Initializer *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_InitializerSeq (const CORBA_InitializerSeq &); // copy ctor
      ~CORBA_InitializerSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_InitializerSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_INITIALIZERSEQ___VAR_CH_)
#define _CORBA_INITIALIZERSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_InitializerSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_InitializerSeq_var
    {
    public:
      CORBA_InitializerSeq_var (void);
      CORBA_InitializerSeq_var (CORBA_InitializerSeq *);
      CORBA_InitializerSeq_var (const CORBA_InitializerSeq_var &);
      ~CORBA_InitializerSeq_var (void);

      CORBA_InitializerSeq_var &operator= (CORBA_InitializerSeq *);
      CORBA_InitializerSeq_var &operator= (const CORBA_InitializerSeq_var &);
      CORBA_InitializerSeq *operator-> (void);
      const CORBA_InitializerSeq *operator-> (void) const;

      operator const CORBA_InitializerSeq &() const;
      operator CORBA_InitializerSeq &();
      operator CORBA_InitializerSeq &() const;
      operator CORBA_InitializerSeq *&(); // variable-size base types only

      CORBA_Initializer & operator[] (CORBA::ULong index);
      const CORBA_Initializer & operator[] (CORBA::ULong index) const;

      // in, inout, out, _retn
      const CORBA_InitializerSeq &in (void) const;
      CORBA_InitializerSeq &inout (void);
      CORBA_InitializerSeq *&out (void);
      CORBA_InitializerSeq *_retn (void);
      CORBA_InitializerSeq *ptr (void) const;

    private:
      CORBA_InitializerSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_INITIALIZERSEQ___OUT_CH_)
#define _CORBA_INITIALIZERSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_InitializerSeq_out
    {
    public:
      CORBA_InitializerSeq_out (CORBA_InitializerSeq *&);
      CORBA_InitializerSeq_out (CORBA_InitializerSeq_var &);
      CORBA_InitializerSeq_out (const CORBA_InitializerSeq_out &);
      CORBA_InitializerSeq_out &operator= (const CORBA_InitializerSeq_out &);
      CORBA_InitializerSeq_out &operator= (CORBA_InitializerSeq *);
      operator CORBA_InitializerSeq *&();
      CORBA_InitializerSeq *&ptr (void);
      CORBA_InitializerSeq *operator-> (void);
      CORBA_Initializer & operator[] (CORBA::ULong index);

    private:
      CORBA_InitializerSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_InitializerSeq_var &);
    };


#endif /* end #if !defined */

    struct CORBA_UnionMember;
    class CORBA_UnionMember_var;

    struct TAO_IFR_Client_Export CORBA_UnionMember
    {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_UnionMember_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

      static void _tao_any_destructor (void*);

      TAO_String_Manager name;
      CORBA::Any label;
      CORBA::TypeCode_var type;
      CORBA_IDLType_var type_def;

    };

    class TAO_IFR_Client_Export CORBA_UnionMember_var
    {
    public:
      CORBA_UnionMember_var (void);
      CORBA_UnionMember_var (CORBA_UnionMember *);
      CORBA_UnionMember_var (const CORBA_UnionMember_var &);
      ~CORBA_UnionMember_var (void);

      CORBA_UnionMember_var &operator= (CORBA_UnionMember *);
      CORBA_UnionMember_var &operator= (const CORBA_UnionMember_var &);
      CORBA_UnionMember *operator-> (void);
      const CORBA_UnionMember *operator-> (void) const;

      operator const CORBA_UnionMember &() const;
      operator CORBA_UnionMember &();
      operator CORBA_UnionMember &() const;
      // Variable-size types only.
      operator CORBA_UnionMember *&();

      // in, inout, out, _retn
      const CORBA_UnionMember &in (void) const;
      CORBA_UnionMember &inout (void);
      CORBA_UnionMember *&out (void);
      CORBA_UnionMember *_retn (void);
      CORBA_UnionMember *ptr (void) const;

    private:
      CORBA_UnionMember *ptr_;
    };

    class TAO_IFR_Client_Export CORBA_UnionMember_out
    {
    public:
      CORBA_UnionMember_out (CORBA_UnionMember *&);
      CORBA_UnionMember_out (CORBA_UnionMember_var &);
      CORBA_UnionMember_out (const CORBA_UnionMember_out &);
      CORBA_UnionMember_out &operator= (const CORBA_UnionMember_out &);
      CORBA_UnionMember_out &operator= (CORBA_UnionMember *);
      operator CORBA_UnionMember *&();
      CORBA_UnionMember *&ptr (void);
      CORBA_UnionMember *operator-> (void);

    private:
      CORBA_UnionMember *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_UnionMember_var &);
    };


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_UNIONMEMBERSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
      : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void);
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (
          CORBA::ULong maximum,
          CORBA::ULong length,
          CORBA_UnionMember *data,
          CORBA::Boolean release = 0
        );
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (
          const _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq &rhs
        );
      _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq &operator= (
          const _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq &rhs
        );
      virtual ~_TAO_Unbounded_Sequence_CORBA_UnionMemberSeq (void);

      // = Accessors.
      CORBA_UnionMember &operator[] (CORBA::ULong i);
      const CORBA_UnionMember &operator[] (CORBA::ULong i) const;

      // = Static operations.
      static CORBA_UnionMember *allocbuf (CORBA::ULong size);
      static void freebuf (CORBA_UnionMember *buffer);

      // Implement the TAO_Base_Sequence methods (see Sequence.h)
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      CORBA_UnionMember *get_buffer (CORBA::Boolean orphan = 0);
      const CORBA_UnionMember *get_buffer (void) const;
      void replace (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_UnionMember *data,
          CORBA::Boolean release
        );
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_UNIONMEMBERSEQ_CH_)
#define _CORBA_UNIONMEMBERSEQ_CH_

    class CORBA_UnionMemberSeq;
    class CORBA_UnionMemberSeq_var;

    // *************************************************************
    // CORBA_UnionMemberSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_UnionMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_CORBA_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<CORBA_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_UnionMemberSeq (void); // default ctor
      CORBA_UnionMemberSeq (CORBA::ULong max); // uses max size
      CORBA_UnionMemberSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          CORBA_UnionMember *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_UnionMemberSeq (const CORBA_UnionMemberSeq &); // copy ctor
      ~CORBA_UnionMemberSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_UnionMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_UNIONMEMBERSEQ___VAR_CH_)
#define _CORBA_UNIONMEMBERSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_UnionMemberSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_UnionMemberSeq_var
    {
    public:
      CORBA_UnionMemberSeq_var (void);
      CORBA_UnionMemberSeq_var (CORBA_UnionMemberSeq *);
      CORBA_UnionMemberSeq_var (const CORBA_UnionMemberSeq_var &);
      ~CORBA_UnionMemberSeq_var (void);

      CORBA_UnionMemberSeq_var &operator= (CORBA_UnionMemberSeq *);
      CORBA_UnionMemberSeq_var &operator= (const CORBA_UnionMemberSeq_var &);
      CORBA_UnionMemberSeq *operator-> (void);
      const CORBA_UnionMemberSeq *operator-> (void) const;

      operator const CORBA_UnionMemberSeq &() const;
      operator CORBA_UnionMemberSeq &();
      operator CORBA_UnionMemberSeq &() const;
      operator CORBA_UnionMemberSeq *&(); // variable-size base types only

      CORBA_UnionMember & operator[] (CORBA::ULong index);
      const CORBA_UnionMember & operator[] (CORBA::ULong index) const;

      // in, inout, out, _retn
      const CORBA_UnionMemberSeq &in (void) const;
      CORBA_UnionMemberSeq &inout (void);
      CORBA_UnionMemberSeq *&out (void);
      CORBA_UnionMemberSeq *_retn (void);
      CORBA_UnionMemberSeq *ptr (void) const;

    private:
      CORBA_UnionMemberSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_UNIONMEMBERSEQ___OUT_CH_)
#define _CORBA_UNIONMEMBERSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_UnionMemberSeq_out
    {
    public:
      CORBA_UnionMemberSeq_out (CORBA_UnionMemberSeq *&);
      CORBA_UnionMemberSeq_out (CORBA_UnionMemberSeq_var &);
      CORBA_UnionMemberSeq_out (const CORBA_UnionMemberSeq_out &);
      CORBA_UnionMemberSeq_out &operator= (const CORBA_UnionMemberSeq_out &);
      CORBA_UnionMemberSeq_out &operator= (CORBA_UnionMemberSeq *);
      operator CORBA_UnionMemberSeq *&();
      CORBA_UnionMemberSeq *&ptr (void);
      CORBA_UnionMemberSeq *operator-> (void);
      CORBA_UnionMember & operator[] (CORBA::ULong index);

    private:
      CORBA_UnionMemberSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_UnionMemberSeq_var &);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMMEMBERSEQ_CH_)
#define _CORBA_ENUMMEMBERSEQ_CH_

    class CORBA_EnumMemberSeq;
    class CORBA_EnumMemberSeq_var;

    // *************************************************************
    // CORBA_EnumMemberSeq
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_EnumMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      CORBA_EnumMemberSeq (void); // default ctor
      CORBA_EnumMemberSeq (CORBA::ULong max); // uses max size
      CORBA_EnumMemberSeq (
          CORBA::ULong max,
          CORBA::ULong length,
          char * *buffer,
          CORBA::Boolean release = 0
        );
      CORBA_EnumMemberSeq (const CORBA_EnumMemberSeq &); // copy ctor
      ~CORBA_EnumMemberSeq (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_EnumMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


    };

#endif /* end #if !defined */


#if !defined (_CORBA_ENUMMEMBERSEQ___VAR_CH_)
#define _CORBA_ENUMMEMBERSEQ___VAR_CH_

    // *************************************************************
    // class CORBA_EnumMemberSeq_var
    // *************************************************************

    class TAO_IFR_Client_Export CORBA_EnumMemberSeq_var
    {
    public:
      CORBA_EnumMemberSeq_var (void);
      CORBA_EnumMemberSeq_var (CORBA_EnumMemberSeq *);
      CORBA_EnumMemberSeq_var (const CORBA_EnumMemberSeq_var &);
      ~CORBA_EnumMemberSeq_var (void);

      CORBA_EnumMemberSeq_var &operator= (CORBA_EnumMemberSeq *);
      CORBA_EnumMemberSeq_var &operator= (const CORBA_EnumMemberSeq_var &);
      CORBA_EnumMemberSeq *operator-> (void);
      const CORBA_EnumMemberSeq *operator-> (void) const;

      operator const CORBA_EnumMemberSeq &() const;
      operator CORBA_EnumMemberSeq &();
      operator CORBA_EnumMemberSeq &() const;
      operator CORBA_EnumMemberSeq *&(); // variable-size base types only

      TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

      // in, inout, out, _retn
      const CORBA_EnumMemberSeq &in (void) const;
      CORBA_EnumMemberSeq &inout (void);
      CORBA_EnumMemberSeq *&out (void);
      CORBA_EnumMemberSeq *_retn (void);
      CORBA_EnumMemberSeq *ptr (void) const;

    private:
      CORBA_EnumMemberSeq *ptr_;
    };


#endif /* end #if !defined */


#if !defined (_CORBA_ENUMMEMBERSEQ___OUT_CH_)
#define _CORBA_ENUMMEMBERSEQ___OUT_CH_

    class TAO_IFR_Client_Export CORBA_EnumMemberSeq_out
    {
    public:
      CORBA_EnumMemberSeq_out (CORBA_EnumMemberSeq *&);
      CORBA_EnumMemberSeq_out (CORBA_EnumMemberSeq_var &);
      CORBA_EnumMemberSeq_out (const CORBA_EnumMemberSeq_out &);
      CORBA_EnumMemberSeq_out &operator= (const CORBA_EnumMemberSeq_out &);
      CORBA_EnumMemberSeq_out &operator= (CORBA_EnumMemberSeq *);
      operator CORBA_EnumMemberSeq *&();
      CORBA_EnumMemberSeq *&ptr (void);
      CORBA_EnumMemberSeq *operator-> (void);
      TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

    private:
      CORBA_EnumMemberSeq *&ptr_;
      // Assignment from T_var not allowed.
      void operator= (const CORBA_EnumMemberSeq_var &);
    };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER_CH_)
#define _CORBA_CONTAINER_CH_

    // Forward Classes Declaration
    class _TAO_CORBA_Container_Proxy_Impl;
    class _TAO_CORBA_Container_Remote_Proxy_Impl;
    class _TAO_CORBA_Container_Proxy_Broker;
    class _TAO_CORBA_Container_Remote_Proxy_Broker;

    class TAO_IFR_Client_Export CORBA_Container
      : public virtual CORBA_IRObject
    {
    public:
    #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef CORBA_Container_ptr _ptr_type;
      typedef CORBA_Container_var _var_type;
    #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

      // the static operations
      static CORBA_Container_ptr _duplicate (CORBA_Container_ptr obj);

      static CORBA_Container_ptr _narrow (
          CORBA::Object_ptr obj
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);


      static CORBA_Container_ptr _unchecked_narrow (
          CORBA::Object_ptr obj
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);


      static CORBA_Container_ptr _nil (void)
        {
          return (CORBA_Container_ptr)0;
        }

      static void _tao_any_destructor (void*);

      virtual CORBA_Contained_ptr lookup (
          const char * search_name
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ContainedSeq * contents (
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ContainedSeq * lookup_name (
          const char * search_name,
          CORBA::Long levels_to_search,
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      struct Description;
      class Description_var;

      struct TAO_IFR_Client_Export Description
      {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef Description_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

        static void _tao_any_destructor (void*);

        CORBA_Contained_var contained_object;
        CORBA::DefinitionKind kind;
        CORBA::Any value;

      };

      class TAO_IFR_Client_Export Description_var
      {
      public:
        Description_var (void);
        Description_var (Description *);
        Description_var (const Description_var &);
        ~Description_var (void);

        Description_var &operator= (Description *);
        Description_var &operator= (const Description_var &);
        Description *operator-> (void);
        const Description *operator-> (void) const;

        operator const Description &() const;
        operator Description &();
        operator Description &() const;
        // Variable-size types only.
        operator Description *&();

        // in, inout, out, _retn
        const Description &in (void) const;
        Description &inout (void);
        Description *&out (void);
        Description *_retn (void);
        Description *ptr (void) const;

      private:
        Description *ptr_;
      };

      class TAO_IFR_Client_Export Description_out
      {
      public:
        Description_out (Description *&);
        Description_out (Description_var &);
        Description_out (const Description_out &);
        Description_out &operator= (const Description_out &);
        Description_out &operator= (Description *);
        operator Description *&();
        Description *&ptr (void);
        Description *operator-> (void);

      private:
        Description *&ptr_;
        // Assignment from T_var not allowed.
        void operator= (const Description_var &);
      };

      static CORBA::TypeCode_ptr _tc_Description;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_CORBA_CONTAINER_DESCRIPTIONSEQ_CH_

      class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
        : public TAO_Unbounded_Base_Sequence
      {
      public:
        // = Initialization and termination methods.
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void);
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (CORBA::ULong maximum);
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (
            CORBA::ULong maximum,
            CORBA::ULong length,
            Description *data,
            CORBA::Boolean release = 0
          );
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (
            const _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq &rhs
          );
        _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq &operator= (
            const _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq &rhs
          );
        virtual ~_TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq (void);

        // = Accessors.
        Description &operator[] (CORBA::ULong i);
        const Description &operator[] (CORBA::ULong i) const;

        // = Static operations.
        static Description *allocbuf (CORBA::ULong size);
        static void freebuf (Description *buffer);

        // Implement the TAO_Base_Sequence methods (see Sequence.h)
        virtual void _allocate_buffer (CORBA::ULong length);
        virtual void _deallocate_buffer (void);
        Description *get_buffer (CORBA::Boolean orphan = 0);
        const Description *get_buffer (void) const;
        void replace (
            CORBA::ULong max,
            CORBA::ULong length,
            Description *data,
            CORBA::Boolean release
          );
      };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ_CH_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ_CH_

      class DescriptionSeq;
      class DescriptionSeq_var;

      // *************************************************************
      // DescriptionSeq
      // *************************************************************

      class TAO_IFR_Client_Export DescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      _TAO_Unbounded_Sequence_CORBA_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
      {
      public:
        DescriptionSeq (void); // default ctor
        DescriptionSeq (CORBA::ULong max); // uses max size
        DescriptionSeq (
            CORBA::ULong max,
            CORBA::ULong length,
            Description *buffer,
            CORBA::Boolean release = 0
          );
        DescriptionSeq (const DescriptionSeq &); // copy ctor
        ~DescriptionSeq (void);
        static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef DescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


      };

#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ___VAR_CH_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ___VAR_CH_

      // *************************************************************
      // class CORBA_Container::DescriptionSeq_var
      // *************************************************************

      class TAO_IFR_Client_Export DescriptionSeq_var
      {
      public:
        DescriptionSeq_var (void);
        DescriptionSeq_var (DescriptionSeq *);
        DescriptionSeq_var (const DescriptionSeq_var &);
        ~DescriptionSeq_var (void);

        DescriptionSeq_var &operator= (DescriptionSeq *);
        DescriptionSeq_var &operator= (const DescriptionSeq_var &);
        DescriptionSeq *operator-> (void);
        const DescriptionSeq *operator-> (void) const;

        operator const DescriptionSeq &() const;
        operator DescriptionSeq &();
        operator DescriptionSeq &() const;
        operator DescriptionSeq *&(); // variable-size base types only

        Description & operator[] (CORBA::ULong index);
        const Description & operator[] (CORBA::ULong index) const;

        // in, inout, out, _retn
        const DescriptionSeq &in (void) const;
        DescriptionSeq &inout (void);
        DescriptionSeq *&out (void);
        DescriptionSeq *_retn (void);
        DescriptionSeq *ptr (void) const;

      private:
        DescriptionSeq *ptr_;
      };


#endif /* end #if !defined */


#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ___OUT_CH_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ___OUT_CH_

      class TAO_IFR_Client_Export DescriptionSeq_out
      {
      public:
        DescriptionSeq_out (DescriptionSeq *&);
        DescriptionSeq_out (DescriptionSeq_var &);
        DescriptionSeq_out (const DescriptionSeq_out &);
        DescriptionSeq_out &operator= (const DescriptionSeq_out &);
        DescriptionSeq_out &operator= (DescriptionSeq *);
        operator DescriptionSeq *&();
        DescriptionSeq *&ptr (void);
        DescriptionSeq *operator-> (void);
        Description & operator[] (CORBA::ULong index);

      private:
        DescriptionSeq *&ptr_;
        // Assignment from T_var not allowed.
        void operator= (const DescriptionSeq_var &);
      };


#endif /* end #if !defined */

      static CORBA::TypeCode_ptr _tc_DescriptionSeq;

      virtual CORBA_Container::DescriptionSeq * describe_contents (
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited,
          CORBA::Long max_returned_objs
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ModuleDef_ptr create_module (
          const char * id,
          const char * name,
          const char * version
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ConstantDef_ptr create_constant (
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          const CORBA::Any & value
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_StructDef_ptr create_struct (
          const char * id,
          const char * name,
          const char * version,
          const CORBA_StructMemberSeq & members
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_UnionDef_ptr create_union (
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr discriminator_type,
          const CORBA_UnionMemberSeq & members
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_EnumDef_ptr create_enum (
          const char * id,
          const char * name,
          const char * version,
          const CORBA_EnumMemberSeq & members
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_AliasDef_ptr create_alias (
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr original_type
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_InterfaceDef_ptr create_interface (
          const char * id,
          const char * name,
          const char * version,
          const CORBA_InterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueDef_ptr create_value (
          const char * id,
          const char * name,
          const char * version,
          CORBA::Boolean is_custom,
          CORBA::Boolean is_abstract,
          CORBA_ValueDef_ptr base_value,
          CORBA::Boolean is_truncatable,
          const CORBA_ValueDefSeq & abstract_base_values,
          const CORBA_InterfaceDefSeq & supported_interfaces,
          const CORBA_InitializerSeq & initializers
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueBoxDef_ptr create_value_box (
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr original_type_def
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ExceptionDef_ptr create_exception (
          const char * id,
          const char * name,
          const char * version,
          const CORBA_StructMemberSeq & members
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_NativeDef_ptr create_native (
          const char * id,
          const char * name,
          const char * version
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_AbstractInterfaceDef_ptr create_abstract_interface (
          const char * id,
          const char * name,
          const char * version,
          const CORBA_AbstractInterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_LocalInterfaceDef_ptr create_local_interface (
          const char * id,
          const char * name,
          const char * version,
          const CORBA_InterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL_WITH_DEFAULTS)

        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA::Boolean _is_a (
          const CORBA::Char *type_id
          ACE_ENV_ARG_DECL_WITH_DEFAULTS);


      virtual void *_tao_QueryInterface (ptr_arith_t type);

      virtual const char* _interface_repository_id (void) const;

    private:
      _TAO_CORBA_Container_Proxy_Broker *the_TAO_CORBA_Container_Proxy_Broker_;

    protected:
      CORBA_Container (int collocated = 0);

      // This methods travese the inheritance tree and set the
      // parents piece of the given class in the right mode
      virtual void CORBA_Container_setup_collocation (int collocated);

      CORBA_Container (
          TAO_Stub *objref,
          CORBA::Boolean _tao_collocated = 0,
          TAO_Abstract_ServantBase *servant = 0
        );

      friend class _TAO_CORBA_Container_Remote_Proxy_Impl;
      friend class _TAO_CORBA_Container_ThruPOA_Proxy_Impl;
      friend class _TAO_CORBA_Container_Direct_Proxy_Impl;

      virtual ~CORBA_Container (void);

    private:
      CORBA_Container (const CORBA_Container &);
      void operator= (const CORBA_Container &);
    };

    // The Proxy Implementations are used by each interface to
    // perform a call. Each different implementation encapsulate
    // an invocation logics.


    ///////////////////////////////////////////////////////////////////////
    //                    Base Proxy Impl. Declaration
    //

    class TAO_IFR_Client_Export _TAO_CORBA_Container_Proxy_Impl
      : public virtual _TAO_CORBA_IRObject_Proxy_Impl
    {
    public:
      virtual ~_TAO_CORBA_Container_Proxy_Impl (void) { }
      virtual CORBA_Contained_ptr lookup (
          CORBA_Object *_collocated_tao_target_,
          const char * search_name
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ContainedSeq * contents (
          CORBA_Object *_collocated_tao_target_,
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ContainedSeq * lookup_name (
          CORBA_Object *_collocated_tao_target_,
          const char * search_name,
          CORBA::Long levels_to_search,
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_Container::DescriptionSeq * describe_contents (
          CORBA_Object *_collocated_tao_target_,
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited,
          CORBA::Long max_returned_objs
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ModuleDef_ptr create_module (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ConstantDef_ptr create_constant (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          const CORBA::Any & value
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_StructDef_ptr create_struct (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_StructMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_UnionDef_ptr create_union (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr discriminator_type,
          const CORBA_UnionMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_EnumDef_ptr create_enum (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_EnumMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_AliasDef_ptr create_alias (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr original_type
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_InterfaceDef_ptr create_interface (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_InterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ValueDef_ptr create_value (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA::Boolean is_custom,
          CORBA::Boolean is_abstract,
          CORBA_ValueDef_ptr base_value,
          CORBA::Boolean is_truncatable,
          const CORBA_ValueDefSeq & abstract_base_values,
          const CORBA_InterfaceDefSeq & supported_interfaces,
          const CORBA_InitializerSeq & initializers
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ValueBoxDef_ptr create_value_box (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr original_type_def
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_ExceptionDef_ptr create_exception (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_StructMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_NativeDef_ptr create_native (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_AbstractInterfaceDef_ptr create_abstract_interface (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_AbstractInterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;

      virtual CORBA_LocalInterfaceDef_ptr create_local_interface (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_InterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        )) = 0;


    protected:
      _TAO_CORBA_Container_Proxy_Impl (void);
    };

    //
    //               End Base Proxy Impl. Declaration
    ///////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////
    //                Remote Proxy Impl. Declaration
    //

    class TAO_IFR_Client_Export _TAO_CORBA_Container_Remote_Proxy_Impl
      : public virtual _TAO_CORBA_Container_Proxy_Impl,
        public virtual TAO_Remote_Object_Proxy_Impl,
        public virtual _TAO_CORBA_IRObject_Remote_Proxy_Impl
    {
    public:
      _TAO_CORBA_Container_Remote_Proxy_Impl (void);

      virtual ~_TAO_CORBA_Container_Remote_Proxy_Impl (void) { }
      virtual CORBA_Contained_ptr lookup (
          CORBA_Object *_collocated_tao_target_,
          const char * search_name
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ContainedSeq * contents (
          CORBA_Object *_collocated_tao_target_,
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ContainedSeq * lookup_name (
          CORBA_Object *_collocated_tao_target_,
          const char * search_name,
          CORBA::Long levels_to_search,
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_Container::DescriptionSeq * describe_contents (
          CORBA_Object *_collocated_tao_target_,
          CORBA::DefinitionKind limit_type,
          CORBA::Boolean exclude_inherited,
          CORBA::Long max_returned_objs
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ModuleDef_ptr create_module (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ConstantDef_ptr create_constant (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr type,
          const CORBA::Any & value
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_StructDef_ptr create_struct (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_StructMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_UnionDef_ptr create_union (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr discriminator_type,
          const CORBA_UnionMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_EnumDef_ptr create_enum (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_EnumMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_AliasDef_ptr create_alias (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr original_type
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_InterfaceDef_ptr create_interface (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_InterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueDef_ptr create_value (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA::Boolean is_custom,
          CORBA::Boolean is_abstract,
          CORBA_ValueDef_ptr base_value,
          CORBA::Boolean is_truncatable,
          const CORBA_ValueDefSeq & abstract_base_values,
          const CORBA_InterfaceDefSeq & supported_interfaces,
          const CORBA_InitializerSeq & initializers
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ValueBoxDef_ptr create_value_box (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          CORBA_IDLType_ptr original_type_def
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_ExceptionDef_ptr create_exception (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_StructMemberSeq & members
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_NativeDef_ptr create_native (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_AbstractInterfaceDef_ptr create_abstract_interface (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_AbstractInterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));

      virtual CORBA_LocalInterfaceDef_ptr create_local_interface (
          CORBA_Object *_collocated_tao_target_,
          const char * id,
          const char * name,
          const char * version,
          const CORBA_InterfaceDefSeq & base_interfaces
          ACE_ENV_ARG_DECL
        )
        ACE_THROW_SPEC ((
          CORBA::SystemException
        ));


    };

    //
    //             End Remote Proxy Impl. Declaration
    ///////////////////////////////////////////////////////////////////////

    // The Proxy Brokers are used by each interface to get
    // the right proxy for performing a call. In the new
    // collocation scheme, the proxy to be used can vary on
    // a call by call basis.


    ///////////////////////////////////////////////////////////////////////
    //                 Base Proxy Broker Declaration
    //

        class TAO_IFR_Client_Export _TAO_CORBA_Container_Proxy_Broker
    {
    public:
      virtual ~_TAO_CORBA_Container_Proxy_Broker (void);
      virtual _TAO_CORBA_Container_Proxy_Impl &select_proxy (
          CORBA_Container *object
          ACE_ENV_ARG_DECL_WITH_DEFAULTS
        ) = 0;

    protected:
      _TAO_CORBA_Container_Proxy_Broker (void);

    };

    //
    //              End Base Proxy Broker Declaration
    ///////////////////////////////////////////////////////////////////////


    ///////////////////////////////////////////////////////////////////////
    //                 Remote Proxy Broker Declaration
    //

    class TAO_IFR_Client_Export _TAO_CORBA_Container_Remote_Proxy_Broker
      : public virtual _TAO_CORBA_Container_Proxy_Broker
    {
    public:
      _TAO_CORBA_Container_Remote_Proxy_Broker (void);

      virtual ~_TAO_CORBA_Container_Remote_Proxy_Broker (void);

      virtual _TAO_CORBA_Container_Proxy_Impl &select_proxy (
          CORBA_Container *object
          ACE_ENV_ARG_DECL
        );

      private:
        _TAO_CORBA_Container_Remote_Proxy_Impl remote_proxy_impl_;

      public:
        // This member function is used to get an handle to the unique instance
        // of the Remote Proxy Broker that is available for a given
        // interface.
        static _TAO_CORBA_Container_Remote_Proxy_Broker *the_TAO_CORBA_Container_Remote_Proxy_Broker (void);
      };

      //
      //              End Remote Proxy Broker Declaration
      ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

#if !defined (_CORBA_IDLTYPE_CH_)
#define _CORBA_IDLTYPE_CH_

      // Forward Classes Declaration
      class _TAO_CORBA_IDLType_Proxy_Impl;
      class _TAO_CORBA_IDLType_Remote_Proxy_Impl;
      class _TAO_CORBA_IDLType_Proxy_Broker;
      class _TAO_CORBA_IDLType_Remote_Proxy_Broker;

      class TAO_IFR_Client_Export CORBA_IDLType
        : public virtual CORBA_IRObject
      {
      public:
      #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
        typedef CORBA_IDLType_ptr _ptr_type;
        typedef CORBA_IDLType_var _var_type;
      #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

        // the static operations
        static CORBA_IDLType_ptr _duplicate (CORBA_IDLType_ptr obj);

        static CORBA_IDLType_ptr _narrow (
            CORBA::Object_ptr obj
            ACE_ENV_ARG_DECL_WITH_DEFAULTS);


        static CORBA_IDLType_ptr _unchecked_narrow (
            CORBA::Object_ptr obj
            ACE_ENV_ARG_DECL_WITH_DEFAULTS);


        static CORBA_IDLType_ptr _nil (void)
          {
            return (CORBA_IDLType_ptr)0;
          }

        static void _tao_any_destructor (void*);

        virtual CORBA::TypeCode_ptr type (
            ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)

          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));

        virtual CORBA::Boolean _is_a (
            const CORBA::Char *type_id
            ACE_ENV_ARG_DECL_WITH_DEFAULTS);


        virtual void *_tao_QueryInterface (ptr_arith_t type);

        virtual const char* _interface_repository_id (void) const;

      private:
        _TAO_CORBA_IDLType_Proxy_Broker *the_TAO_CORBA_IDLType_Proxy_Broker_;

      protected:
        CORBA_IDLType (int collocated = 0);

        // This methods travese the inheritance tree and set the
        // parents piece of the given class in the right mode
        virtual void CORBA_IDLType_setup_collocation (int collocated);

        CORBA_IDLType (
            TAO_Stub *objref,
            CORBA::Boolean _tao_collocated = 0,
            TAO_Abstract_ServantBase *servant = 0
          );

        friend class _TAO_CORBA_IDLType_Remote_Proxy_Impl;
        friend class _TAO_CORBA_IDLType_ThruPOA_Proxy_Impl;
        friend class _TAO_CORBA_IDLType_Direct_Proxy_Impl;

        virtual ~CORBA_IDLType (void);

      private:
        CORBA_IDLType (const CORBA_IDLType &);
        void operator= (const CORBA_IDLType &);
      };

      // The Proxy Implementations are used by each interface to
      // perform a call. Each different implementation encapsulate
      // an invocation logics.


      ///////////////////////////////////////////////////////////////////////
      //                    Base Proxy Impl. Declaration
      //

      class TAO_IFR_Client_Export _TAO_CORBA_IDLType_Proxy_Impl
        : public virtual _TAO_CORBA_IRObject_Proxy_Impl
      {
      public:
        virtual ~_TAO_CORBA_IDLType_Proxy_Impl (void) { }
        virtual CORBA::TypeCode_ptr type (
            CORBA_Object *_collocated_tao_target_
            ACE_ENV_ARG_DECL
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          )) = 0;


      protected:
        _TAO_CORBA_IDLType_Proxy_Impl (void);
      };

      //
      //               End Base Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////


      ///////////////////////////////////////////////////////////////////////
      //                Remote Proxy Impl. Declaration
      //

      class TAO_IFR_Client_Export _TAO_CORBA_IDLType_Remote_Proxy_Impl
        : public virtual _TAO_CORBA_IDLType_Proxy_Impl,
          public virtual TAO_Remote_Object_Proxy_Impl,
          public virtual _TAO_CORBA_IRObject_Remote_Proxy_Impl
      {
      public:
        _TAO_CORBA_IDLType_Remote_Proxy_Impl (void);

        virtual ~_TAO_CORBA_IDLType_Remote_Proxy_Impl (void) { }
        virtual CORBA::TypeCode_ptr type (
            CORBA_Object *_collocated_tao_target_
            ACE_ENV_ARG_DECL
          )
          ACE_THROW_SPEC ((
            CORBA::SystemException
          ));


      };

      //
      //             End Remote Proxy Impl. Declaration
      ///////////////////////////////////////////////////////////////////////

      // The Proxy Brokers are used by each interface to get
      // the right proxy for performing a call. In the new
      // collocation scheme, the proxy to be used can vary on
      // a call by call basis.


      ///////////////////////////////////////////////////////////////////////
      //                 Base Proxy Broker Declaration
      //

            class TAO_IFR_Client_Export _TAO_CORBA_IDLType_Proxy_Broker
      {
      public:
        virtual ~_TAO_CORBA_IDLType_Proxy_Broker (void);
        virtual _TAO_CORBA_IDLType_Proxy_Impl &select_proxy (
            CORBA_IDLType *object
            ACE_ENV_ARG_DECL_WITH_DEFAULTS
          ) = 0;

      protected:
        _TAO_CORBA_IDLType_Proxy_Broker (void);

      };

      //
      //              End Base Proxy Broker Declaration
      ///////////////////////////////////////////////////////////////////////


      ///////////////////////////////////////////////////////////////////////
      //                 Remote Proxy Broker Declaration
      //

      class TAO_IFR_Client_Export _TAO_CORBA_IDLType_Remote_Proxy_Broker
        : public virtual _TAO_CORBA_IDLType_Proxy_Broker
      {
      public:
        _TAO_CORBA_IDLType_Remote_Proxy_Broker (void);

        virtual ~_TAO_CORBA_IDLType_Remote_Proxy_Broker (void);

        virtual _TAO_CORBA_IDLType_Proxy_Impl &select_proxy (
            CORBA_IDLType *object
            ACE_ENV_ARG_DECL
          );

        private:
          _TAO_CORBA_IDLType_Remote_Proxy_Impl remote_proxy_impl_;

        public:
          // This member function is used to get an handle to the unique instance
          // of the Remote Proxy Broker that is available for a given
          // interface.
          static _TAO_CORBA_IDLType_Remote_Proxy_Broker *the_TAO_CORBA_IDLType_Remote_Proxy_Broker (void);
        };

        //
        //              End Remote Proxy Broker Declaration
        ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */


#if !defined (_CORBA_TYPEDEFDEF___PTR_CH_)
#define _CORBA_TYPEDEFDEF___PTR_CH_

        class CORBA_TypedefDef;
        typedef CORBA_TypedefDef *CORBA_TypedefDef_ptr;

#endif /* end #if !defined */


#if !defined (_CORBA_TYPEDEFDEF___VAR_CH_)
#define _CORBA_TYPEDEFDEF___VAR_CH_

        class TAO_IFR_Client_Export CORBA_TypedefDef_var : public TAO_Base_var
        {
        public:
          CORBA_TypedefDef_var (void); // default constructor
          CORBA_TypedefDef_var (CORBA_TypedefDef_ptr p) : ptr_ (p) {}
          CORBA_TypedefDef_var (const CORBA_TypedefDef_var &); // copy constructor
          ~CORBA_TypedefDef_var (void); // destructor

          CORBA_TypedefDef_var &operator= (CORBA_TypedefDef_ptr);
          CORBA_TypedefDef_var &operator= (const CORBA_TypedefDef_var &);
          CORBA_TypedefDef_ptr operator-> (void) const;

          operator const CORBA_TypedefDef_ptr &() const;
          operator CORBA_TypedefDef_ptr &();
          // in, inout, out, _retn
          CORBA_TypedefDef_ptr in (void) const;
          CORBA_TypedefDef_ptr &inout (void);
          CORBA_TypedefDef_ptr &out (void);
          CORBA_TypedefDef_ptr _retn (void);
          CORBA_TypedefDef_ptr ptr (void) const;

          // Hooks used by template sequence and object manager classes
          // for non-defined forward declared interfaces.
          static CORBA_TypedefDef_ptr tao_duplicate (CORBA_TypedefDef_ptr);
          static void tao_release (CORBA_TypedefDef_ptr);
          static CORBA_TypedefDef_ptr tao_nil (void);
          static CORBA_TypedefDef_ptr tao_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          static CORBA::Object * tao_upcast (void *);

        private:
          CORBA_TypedefDef_ptr ptr_;
          // Unimplemented - prevents widening assignment.
          CORBA_TypedefDef_var (const TAO_Base_var &rhs);
          CORBA_TypedefDef_var &operator= (const TAO_Base_var &rhs);
        };


#endif /* end #if !defined */


#if !defined (_CORBA_TYPEDEFDEF___OUT_CH_)
#define _CORBA_TYPEDEFDEF___OUT_CH_

        class TAO_IFR_Client_Export CORBA_TypedefDef_out
        {
        public:
          CORBA_TypedefDef_out (CORBA_TypedefDef_ptr &);
          CORBA_TypedefDef_out (CORBA_TypedefDef_var &);
          CORBA_TypedefDef_out (const CORBA_TypedefDef_out &);
          CORBA_TypedefDef_out &operator= (const CORBA_TypedefDef_out &);
          CORBA_TypedefDef_out &operator= (const CORBA_TypedefDef_var &);
          CORBA_TypedefDef_out &operator= (CORBA_TypedefDef_ptr);
          operator CORBA_TypedefDef_ptr &();
          CORBA_TypedefDef_ptr &ptr (void);
          CORBA_TypedefDef_ptr operator-> (void);

        private:
          CORBA_TypedefDef_ptr &ptr_;
        };


#endif /* end #if !defined */


#if !defined (_CORBA_TYPEDEFDEF_CH_)
#define _CORBA_TYPEDEFDEF_CH_

        // Forward Classes Declaration
        class _TAO_CORBA_TypedefDef_Proxy_Impl;
        class _TAO_CORBA_TypedefDef_Remote_Proxy_Impl;
        class _TAO_CORBA_TypedefDef_Proxy_Broker;
        class _TAO_CORBA_TypedefDef_Remote_Proxy_Broker;

        class TAO_IFR_Client_Export CORBA_TypedefDef
          : public virtual CORBA_Contained,
            public virtual CORBA_IDLType
        {
        public:
        #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
          typedef CORBA_TypedefDef_ptr _ptr_type;
          typedef CORBA_TypedefDef_var _var_type;
        #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

          // the static operations
          static CORBA_TypedefDef_ptr _duplicate (CORBA_TypedefDef_ptr obj);

          static CORBA_TypedefDef_ptr _narrow (
              CORBA::Object_ptr obj
              ACE_ENV_ARG_DECL_WITH_DEFAULTS);


          static CORBA_TypedefDef_ptr _unchecked_narrow (
              CORBA::Object_ptr obj
              ACE_ENV_ARG_DECL_WITH_DEFAULTS);


          static CORBA_TypedefDef_ptr _nil (void)
            {
              return (CORBA_TypedefDef_ptr)0;
            }

          static void _tao_any_destructor (void*);

          virtual CORBA::Boolean _is_a (
              const CORBA::Char *type_id
              ACE_ENV_ARG_DECL_WITH_DEFAULTS);


          virtual void *_tao_QueryInterface (ptr_arith_t type);

          virtual const char* _interface_repository_id (void) const;

        private:
          _TAO_CORBA_TypedefDef_Proxy_Broker *the_TAO_CORBA_TypedefDef_Proxy_Broker_;

        protected:
          CORBA_TypedefDef (int collocated = 0);

          // This methods travese the inheritance tree and set the
          // parents piece of the given class in the right mode
          virtual void CORBA_TypedefDef_setup_collocation (int collocated);

          CORBA_TypedefDef (
              TAO_Stub *objref,
              CORBA::Boolean _tao_collocated = 0,
              TAO_Abstract_ServantBase *servant = 0
            );

          friend class _TAO_CORBA_TypedefDef_Remote_Proxy_Impl;
          friend class _TAO_CORBA_TypedefDef_ThruPOA_Proxy_Impl;
          friend class _TAO_CORBA_TypedefDef_Direct_Proxy_Impl;

          virtual ~CORBA_TypedefDef (void);

        private:
          CORBA_TypedefDef (const CORBA_TypedefDef &);
          void operator= (const CORBA_TypedefDef &);
        };

        // The Proxy Implementations are used by each interface to
        // perform a call. Each different implementation encapsulate
        // an invocation logics.


        ///////////////////////////////////////////////////////////////////////
        //                    Base Proxy Impl. Declaration
        //

        class TAO_IFR_Client_Export _TAO_CORBA_TypedefDef_Proxy_Impl
          : public virtual _TAO_CORBA_Contained_Proxy_Impl,
            public virtual _TAO_CORBA_IDLType_Proxy_Impl
        {
        public:
          virtual ~_TAO_CORBA_TypedefDef_Proxy_Impl (void) { }

        protected:
          _TAO_CORBA_TypedefDef_Proxy_Impl (void);
        };

        //
        //               End Base Proxy Impl. Declaration
        ///////////////////////////////////////////////////////////////////////


        ///////////////////////////////////////////////////////////////////////
        //                Remote Proxy Impl. Declaration
        //

        class TAO_IFR_Client_Export _TAO_CORBA_TypedefDef_Remote_Proxy_Impl
          : public virtual _TAO_CORBA_TypedefDef_Proxy_Impl,
            public virtual TAO_Remote_Object_Proxy_Impl,
            public virtual _TAO_CORBA_Contained_Remote_Proxy_Impl,
            public virtual _TAO_CORBA_IDLType_Remote_Proxy_Impl
        {
        public:
          _TAO_CORBA_TypedefDef_Remote_Proxy_Impl (void);

          virtual ~_TAO_CORBA_TypedefDef_Remote_Proxy_Impl (void) { }

        };

        //
        //             End Remote Proxy Impl. Declaration
        ///////////////////////////////////////////////////////////////////////

        // The Proxy Brokers are used by each interface to get
        // the right proxy for performing a call. In the new
        // collocation scheme, the proxy to be used can vary on
        // a call by call basis.


        ///////////////////////////////////////////////////////////////////////
        //                 Base Proxy Broker Declaration
        //

                class TAO_IFR_Client_Export _TAO_CORBA_TypedefDef_Proxy_Broker
        {
        public:
          virtual ~_TAO_CORBA_TypedefDef_Proxy_Broker (void);
          virtual _TAO_CORBA_TypedefDef_Proxy_Impl &select_proxy (
              CORBA_TypedefDef *object
              ACE_ENV_ARG_DECL_WITH_DEFAULTS
            ) = 0;

        protected:
          _TAO_CORBA_TypedefDef_Proxy_Broker (void);

        };

        //
        //              End Base Proxy Broker Declaration
        ///////////////////////////////////////////////////////////////////////


        ///////////////////////////////////////////////////////////////////////
        //                 Remote Proxy Broker Declaration
        //

        class TAO_IFR_Client_Export _TAO_CORBA_TypedefDef_Remote_Proxy_Broker
          : public virtual _TAO_CORBA_TypedefDef_Proxy_Broker
        {
        public:
          _TAO_CORBA_TypedefDef_Remote_Proxy_Broker (void);

          virtual ~_TAO_CORBA_TypedefDef_Remote_Proxy_Broker (void);

          virtual _TAO_CORBA_TypedefDef_Proxy_Impl &select_proxy (
              CORBA_TypedefDef *object
              ACE_ENV_ARG_DECL
            );

          private:
            _TAO_CORBA_TypedefDef_Remote_Proxy_Impl remote_proxy_impl_;

          public:
            // This member function is used to get an handle to the unique instance
            // of the Remote Proxy Broker that is available for a given
            // interface.
            static _TAO_CORBA_TypedefDef_Remote_Proxy_Broker *the_TAO_CORBA_TypedefDef_Remote_Proxy_Broker (void);
          };

          //
          //              End Remote Proxy Broker Declaration
          ///////////////////////////////////////////////////////////////////////


#endif /* end #if !defined */

          struct CORBA_TypeDescription;
          class CORBA_TypeDescription_var;

          struct TAO_IFR_Client_Export CORBA_TypeDescription
          {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
            typedef CORBA_TypeDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

            static void _tao_any_destructor (void*);

            TAO_String_Manager name;
            TAO_String_Manager id;
            TAO_String_Manager defined_in;
            TAO_String_Manager version;
            CORBA::TypeCode_var type;

          };

          class TAO_IFR_Client_Export CORBA_TypeDescription_var
          {
          public:
            CORBA_TypeDescription_var (void);
            CORBA_TypeDescription_var (CORBA_TypeDescription *);
            CORBA_TypeDescription_var (const CORBA_TypeDescription_var &);
            ~CORBA_TypeDescription_var (void);

            CORBA_TypeDescription_var &operator= (CORBA_TypeDescription *);
            CORBA_TypeDescription_var &operator= (const CORBA_TypeDescription_var &);
            CORBA_TypeDescription *operator-> (void);
            const CORBA_TypeDescription *operator-> (void) const;

            operator const CORBA_TypeDescription &() const;
            operator CORBA_TypeDescription &();
            operator CORBA_TypeDescription &() const;
            // Variable-size types only.
            operator CORBA_TypeDescription *&();

            // in, inout, out, _retn
            const CORBA_TypeDescription &in (void) const;
            CORBA_TypeDescription &inout (void);
            CORBA_TypeDescription *&out (void);
            CORBA_TypeDescription *_retn (void);
            CORBA_TypeDescription *ptr (void) const;

          private:
            CORBA_TypeDescription *ptr_;
          };

          class TAO_IFR_Client_Export CORBA_TypeDescription_out
          {
          public:
            CORBA_TypeDescription_out (CORBA_TypeDescription *&);
            CORBA_TypeDescription_out (CORBA_TypeDescription_var &);
            CORBA_TypeDescription_out (const CORBA_TypeDescription_out &);
            CORBA_TypeDescription_out &operator= (const CORBA_TypeDescription_out &);
            CORBA_TypeDescription_out &operator= (CORBA_TypeDescription *);
            operator CORBA_TypeDescription *&();
            CORBA_TypeDescription *&ptr (void);
            CORBA_TypeDescription *operator-> (void);

          private:
            CORBA_TypeDescription *&ptr_;
            // Assignment from T_var not allowed.
            void operator= (const CORBA_TypeDescription_var &);
          };

          // Proxy Broker Factory function pointer declarations.

          extern TAO_IFR_Client_Export
          _TAO_CORBA_IRObject_Proxy_Broker *
          (*_TAO_CORBA_IRObject_Proxy_Broker_Factory_function_pointer) (
              CORBA::Object_ptr obj
            );

          extern TAO_IFR_Client_Export
          _TAO_CORBA_Contained_Proxy_Broker *
          (*_TAO_CORBA_Contained_Proxy_Broker_Factory_function_pointer) (
              CORBA::Object_ptr obj
            );

          extern TAO_IFR_Client_Export
          _TAO_CORBA_Container_Proxy_Broker *
          (*_TAO_CORBA_Container_Proxy_Broker_Factory_function_pointer) (
              CORBA::Object_ptr obj
            );

          extern TAO_IFR_Client_Export
          _TAO_CORBA_IDLType_Proxy_Broker *
          (*_TAO_CORBA_IDLType_Proxy_Broker_Factory_function_pointer) (
              CORBA::Object_ptr obj
            );

          extern TAO_IFR_Client_Export
          _TAO_CORBA_TypedefDef_Proxy_Broker *
          (*_TAO_CORBA_TypedefDef_Proxy_Broker_Factory_function_pointer) (
              CORBA::Object_ptr obj
            );

          // External declarations for undefined interface
          // CORBA_Repository
          TAO_IFR_Client_Export
          CORBA_Repository_ptr
          tao_CORBA_Repository_duplicate (
              CORBA_Repository_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_Repository_release (
              CORBA_Repository_ptr
            );
          TAO_IFR_Client_Export
          CORBA_Repository_ptr
          tao_CORBA_Repository_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_Repository_ptr
          tao_CORBA_Repository_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_Repository_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_ModuleDef
          TAO_IFR_Client_Export
          CORBA_ModuleDef_ptr
          tao_CORBA_ModuleDef_duplicate (
              CORBA_ModuleDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_ModuleDef_release (
              CORBA_ModuleDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_ModuleDef_ptr
          tao_CORBA_ModuleDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_ModuleDef_ptr
          tao_CORBA_ModuleDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_ModuleDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_ConstantDef
          TAO_IFR_Client_Export
          CORBA_ConstantDef_ptr
          tao_CORBA_ConstantDef_duplicate (
              CORBA_ConstantDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_ConstantDef_release (
              CORBA_ConstantDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_ConstantDef_ptr
          tao_CORBA_ConstantDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_ConstantDef_ptr
          tao_CORBA_ConstantDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_ConstantDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_StructDef
          TAO_IFR_Client_Export
          CORBA_StructDef_ptr
          tao_CORBA_StructDef_duplicate (
              CORBA_StructDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_StructDef_release (
              CORBA_StructDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_StructDef_ptr
          tao_CORBA_StructDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_StructDef_ptr
          tao_CORBA_StructDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_StructDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_UnionDef
          TAO_IFR_Client_Export
          CORBA_UnionDef_ptr
          tao_CORBA_UnionDef_duplicate (
              CORBA_UnionDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_UnionDef_release (
              CORBA_UnionDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_UnionDef_ptr
          tao_CORBA_UnionDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_UnionDef_ptr
          tao_CORBA_UnionDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_UnionDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_EnumDef
          TAO_IFR_Client_Export
          CORBA_EnumDef_ptr
          tao_CORBA_EnumDef_duplicate (
              CORBA_EnumDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_EnumDef_release (
              CORBA_EnumDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_EnumDef_ptr
          tao_CORBA_EnumDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_EnumDef_ptr
          tao_CORBA_EnumDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_EnumDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_AliasDef
          TAO_IFR_Client_Export
          CORBA_AliasDef_ptr
          tao_CORBA_AliasDef_duplicate (
              CORBA_AliasDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_AliasDef_release (
              CORBA_AliasDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_AliasDef_ptr
          tao_CORBA_AliasDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_AliasDef_ptr
          tao_CORBA_AliasDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_AliasDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_InterfaceDef
          TAO_IFR_Client_Export
          CORBA_InterfaceDef_ptr
          tao_CORBA_InterfaceDef_duplicate (
              CORBA_InterfaceDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_InterfaceDef_release (
              CORBA_InterfaceDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_InterfaceDef_ptr
          tao_CORBA_InterfaceDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_InterfaceDef_ptr
          tao_CORBA_InterfaceDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_InterfaceDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_ExceptionDef
          TAO_IFR_Client_Export
          CORBA_ExceptionDef_ptr
          tao_CORBA_ExceptionDef_duplicate (
              CORBA_ExceptionDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_ExceptionDef_release (
              CORBA_ExceptionDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_ExceptionDef_ptr
          tao_CORBA_ExceptionDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_ExceptionDef_ptr
          tao_CORBA_ExceptionDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_ExceptionDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_NativeDef
          TAO_IFR_Client_Export
          CORBA_NativeDef_ptr
          tao_CORBA_NativeDef_duplicate (
              CORBA_NativeDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_NativeDef_release (
              CORBA_NativeDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_NativeDef_ptr
          tao_CORBA_NativeDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_NativeDef_ptr
          tao_CORBA_NativeDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_NativeDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_ValueDef
          TAO_IFR_Client_Export
          CORBA_ValueDef_ptr
          tao_CORBA_ValueDef_duplicate (
              CORBA_ValueDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_ValueDef_release (
              CORBA_ValueDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_ValueDef_ptr
          tao_CORBA_ValueDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_ValueDef_ptr
          tao_CORBA_ValueDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_ValueDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_ValueBoxDef
          TAO_IFR_Client_Export
          CORBA_ValueBoxDef_ptr
          tao_CORBA_ValueBoxDef_duplicate (
              CORBA_ValueBoxDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_ValueBoxDef_release (
              CORBA_ValueBoxDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_ValueBoxDef_ptr
          tao_CORBA_ValueBoxDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_ValueBoxDef_ptr
          tao_CORBA_ValueBoxDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_ValueBoxDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_AbstractInterfaceDef
          TAO_IFR_Client_Export
          CORBA_AbstractInterfaceDef_ptr
          tao_CORBA_AbstractInterfaceDef_duplicate (
              CORBA_AbstractInterfaceDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_AbstractInterfaceDef_release (
              CORBA_AbstractInterfaceDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_AbstractInterfaceDef_ptr
          tao_CORBA_AbstractInterfaceDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_AbstractInterfaceDef_ptr
          tao_CORBA_AbstractInterfaceDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_AbstractInterfaceDef_upcast (
              void *
            );

          // External declarations for undefined interface
          // CORBA_LocalInterfaceDef
          TAO_IFR_Client_Export
          CORBA_LocalInterfaceDef_ptr
          tao_CORBA_LocalInterfaceDef_duplicate (
              CORBA_LocalInterfaceDef_ptr
            );
          TAO_IFR_Client_Export
          void
          tao_CORBA_LocalInterfaceDef_release (
              CORBA_LocalInterfaceDef_ptr
            );
          TAO_IFR_Client_Export
          CORBA_LocalInterfaceDef_ptr
          tao_CORBA_LocalInterfaceDef_nil (
              void
            );
          TAO_IFR_Client_Export
          CORBA_LocalInterfaceDef_ptr
          tao_CORBA_LocalInterfaceDef_narrow (
              CORBA::Object *
              ACE_ENV_ARG_DECL_NOT_USED
            );
          TAO_IFR_Client_Export
          CORBA::Object *
          tao_CORBA_LocalInterfaceDef_upcast (
              void *
            );

                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA::DefinitionKind);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA::DefinitionKind &);
          // Any operators for interface CORBA_IRObject
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_IRObject_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_IRObject *&);
          // Any operators for interface CORBA_Repository
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_Repository_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_Repository *&);
          // Any operators for interface CORBA_Contained
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_Contained_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_Contained *&);
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_Contained::Description &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_Contained::Description*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_Contained::Description *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_Contained::Description *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ContainedSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ContainedSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ContainedSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ContainedSeq *&);
          // Any operators for interface CORBA_ModuleDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ModuleDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ModuleDef *&);
          // Any operators for interface CORBA_ConstantDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ConstantDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ConstantDef *&);
          // Any operators for interface CORBA_StructDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_StructDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_StructDef *&);
          // Any operators for interface CORBA_UnionDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_UnionDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_UnionDef *&);
          // Any operators for interface CORBA_EnumDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_EnumDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_EnumDef *&);
          // Any operators for interface CORBA_AliasDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_AliasDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_AliasDef *&);
          // Any operators for interface CORBA_InterfaceDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_InterfaceDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_InterfaceDef *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_InterfaceDefSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_InterfaceDefSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_InterfaceDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_InterfaceDefSeq *&);
          // Any operators for interface CORBA_ExceptionDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ExceptionDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ExceptionDef *&);
          // Any operators for interface CORBA_NativeDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_NativeDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_NativeDef *&);
          // Any operators for interface CORBA_ValueDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDef *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_ValueDefSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueDefSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_ValueDefSeq *&);
          // Any operators for interface CORBA_ValueBoxDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_ValueBoxDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_ValueBoxDef *&);
          // Any operators for interface CORBA_AbstractInterfaceDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_AbstractInterfaceDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_AbstractInterfaceDef *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_AbstractInterfaceDefSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_AbstractInterfaceDefSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_AbstractInterfaceDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_AbstractInterfaceDefSeq *&);
          // Any operators for interface CORBA_LocalInterfaceDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_LocalInterfaceDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_LocalInterfaceDef *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_LocalInterfaceDefSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_LocalInterfaceDefSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_LocalInterfaceDefSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_LocalInterfaceDefSeq *&);
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_StructMember &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_StructMember*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_StructMember *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_StructMember *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_StructMemberSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_StructMemberSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_StructMemberSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_StructMemberSeq *&);
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_Initializer &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_Initializer*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_Initializer *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_Initializer *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_InitializerSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_InitializerSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_InitializerSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_InitializerSeq *&);
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_UnionMember &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_UnionMember*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_UnionMember *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_UnionMember *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_UnionMemberSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_UnionMemberSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_UnionMemberSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_UnionMemberSeq *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_EnumMemberSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_EnumMemberSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_EnumMemberSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_EnumMemberSeq *&);
          // Any operators for interface CORBA_Container
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_Container_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_Container *&);
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_Container::Description &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_Container::Description*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_Container::Description *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_Container::Description *&);
                    TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_Container::DescriptionSeq &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_Container::DescriptionSeq*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_Container::DescriptionSeq *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_Container::DescriptionSeq *&);
          // Any operators for interface CORBA_IDLType
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_IDLType_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_IDLType *&);
          // Any operators for interface CORBA_TypedefDef
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_TypedefDef_ptr);
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_TypedefDef *&);
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, const CORBA_TypeDescription &); // copying version
          TAO_IFR_Client_Export void operator<<= (CORBA::Any &, CORBA_TypeDescription*); // noncopying version
          TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_TypeDescription *&); // deprecated
TAO_IFR_Client_Export CORBA::Boolean operator>>= (const CORBA::Any &, const CORBA_TypeDescription *&);

          #ifndef __ACE_INLINE__

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA::DefinitionKind &); //
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA::DefinitionKind &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_IRObject_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_IRObject_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_Repository_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_Repository_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_Contained_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_Contained_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_Contained::Description &);
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_Contained::Description &);

#if !defined _TAO_CDR_OP_CORBA_ContainedSeq_H_
          #define _TAO_CDR_OP_CORBA_ContainedSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_ContainedSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_ContainedSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_ContainedSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ModuleDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ModuleDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ConstantDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ConstantDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_StructDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_StructDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_UnionDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_UnionDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_EnumDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_EnumDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_AliasDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_AliasDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_InterfaceDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_InterfaceDef_ptr &);

#if !defined _TAO_CDR_OP_CORBA_InterfaceDefSeq_H_
          #define _TAO_CDR_OP_CORBA_InterfaceDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_InterfaceDefSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_InterfaceDefSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_InterfaceDefSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ExceptionDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ExceptionDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_NativeDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_NativeDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueDef_ptr &);

#if !defined _TAO_CDR_OP_CORBA_ValueDefSeq_H_
          #define _TAO_CDR_OP_CORBA_ValueDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_ValueDefSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_ValueDefSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_ValueDefSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_ValueBoxDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_ValueBoxDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_AbstractInterfaceDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_AbstractInterfaceDef_ptr &);

#if !defined _TAO_CDR_OP_CORBA_AbstractInterfaceDefSeq_H_
          #define _TAO_CDR_OP_CORBA_AbstractInterfaceDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_AbstractInterfaceDefSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_AbstractInterfaceDefSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_AbstractInterfaceDefSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_LocalInterfaceDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_LocalInterfaceDef_ptr &);

#if !defined _TAO_CDR_OP_CORBA_LocalInterfaceDefSeq_H_
          #define _TAO_CDR_OP_CORBA_LocalInterfaceDefSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_LocalInterfaceDefSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_LocalInterfaceDefSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_LocalInterfaceDefSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_StructMember &);
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_StructMember &);

#if !defined _TAO_CDR_OP_CORBA_StructMemberSeq_H_
          #define _TAO_CDR_OP_CORBA_StructMemberSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_StructMemberSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_StructMemberSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_StructMemberSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_Initializer &);
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_Initializer &);

#if !defined _TAO_CDR_OP_CORBA_InitializerSeq_H_
          #define _TAO_CDR_OP_CORBA_InitializerSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_InitializerSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_InitializerSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_InitializerSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_UnionMember &);
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_UnionMember &);

#if !defined _TAO_CDR_OP_CORBA_UnionMemberSeq_H_
          #define _TAO_CDR_OP_CORBA_UnionMemberSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_UnionMemberSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_UnionMemberSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_UnionMemberSeq_H_ */


#if !defined _TAO_CDR_OP_CORBA_EnumMemberSeq_H_
          #define _TAO_CDR_OP_CORBA_EnumMemberSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_EnumMemberSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_EnumMemberSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_EnumMemberSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_Container_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_Container_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_Container::Description &);
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_Container::Description &);

#if !defined _TAO_CDR_OP_CORBA_Container_DescriptionSeq_H_
          #define _TAO_CDR_OP_CORBA_Container_DescriptionSeq_H_

TAO_IFR_Client_Export CORBA::Boolean operator<< (
              TAO_OutputCDR &,
              const CORBA_Container::DescriptionSeq &
            );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (
              TAO_InputCDR &,
              CORBA_Container::DescriptionSeq &
            );

#endif /* _TAO_CDR_OP_CORBA_Container_DescriptionSeq_H_ */

          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_IDLType_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_IDLType_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_TypedefDef_ptr );
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_TypedefDef_ptr &);
          TAO_IFR_Client_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_TypeDescription &);
          TAO_IFR_Client_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_TypeDescription &);

          #endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "IFR_BaseC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
