/* -*- C++ -*- */
/* $Id$ */

module SFP
{
  enum message_type
  {
    // Messages in the forward direction 
    START, 
    ENDOFSTREAM, 
    SIMPLEFRAME, 
    SEQUENCEDFRAME, 
    FRAME, 
    SPECIALFRAME, 
    // Messages in the reverse direction 
    STARTREPLY, 
    CREDIT
  }; 
  
  struct frame_header
  { 
    sequence <char> magic_number; 
    // '=', 'S', 'F', 'P' 
    octet flags;   
    // bit 0 = byte order, 
    // 1 = fragments, 2-7 always 0 
    octet message_type; 
    unsigned long message_size; 
    // Size following this header 
  }; 
  
  struct fragment
  { 
    sequence <char> magic_number; 
    // 'F', 'R', 'A', 'G' 
    octet flags; 
    // bit 1 = more fragments 
    unsigned long frag_number; 
    // 0,..,n 
    unsigned long frag_sz; 
    unsigned long source_id; 
    // Required for UDP multicast with multiple sources 
  };                    
  
  struct start_message
  { 
    //    sequence <char> magic_number; 
    // '=', 'S', 'T', 'A' 
    unsigned long magic_number;
    octet major_version; 
    octet minor_version; 
    octet flags; 
    // bit 0 = byte order 
  }; 
  
  // Acknowledge successful processing of 
  // Start 
  
  struct start_reply
  { 
    octet flags; 
    // bit 0 = byte order, 1 = exception 
  }; 
  
  // If the message_type in frameHeader is sequencedFrame 
  // the the frameHeader will be followed by this 
  // (See also RTP note) 
  
  struct sequenced_frame 
  { 
    unsigned long sequence_num; 
  }; 
  // If the message_type is Frame then 
  // the frameHeader is followed by this 
  // See also RTP note 
  
  struct frame
  { 
    unsigned long timestamp; 
    unsigned long synch_source; 
    sequence<unsigned long> source_ids;
  };
};
