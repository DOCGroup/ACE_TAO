// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from
// be\be_codegen.cpp:603

#ifndef _TAO_IDL____ORBSVCS_ORBSVCS_IFRSERVICE_IFR_BASES_CPP_
#define _TAO_IDL____ORBSVCS_ORBSVCS_IFRSERVICE_IFR_BASES_CPP_


#include "IFR_BaseS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/Any_SArg_Traits.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/PortableServer/get_arg.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/AnyTypeCode/Any_Arg_Traits.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "IFR_BaseS.inl"
#endif /* !defined INLINE */

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:72


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_DEFINITIONKIND__SARG_TRAITS_)
#define _CORBA_DEFINITIONKIND__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::DefinitionKind>
    : public
        Basic_SArg_Traits_T<
            CORBA::DefinitionKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINED__SARG_TRAITS_)
#define _CORBA_CONTAINED__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Contained>
    : public
        Object_SArg_Traits_T<
            CORBA::Contained_ptr,
            CORBA::Contained_var,
            CORBA::Contained_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_CONTAINED_DESCRIPTION__SARG_TRAITS_)
#define _CORBA_CONTAINED_DESCRIPTION__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::Contained::Description>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::Contained::Description,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_REPOSITORY__SARG_TRAITS_)
#define _CORBA_REPOSITORY__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Repository>
    : public
        Object_SArg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINER__SARG_TRAITS_)
#define _CORBA_CONTAINER__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::Container>
    : public
        Object_SArg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ__SARG_TRAITS_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::Container::DescriptionSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::Container::DescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_MODULEDEF__SARG_TRAITS_)
#define _CORBA_MODULEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ModuleDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ModuleDef_ptr,
            CORBA::ModuleDef_var,
            CORBA::ModuleDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONSTANTDEF__SARG_TRAITS_)
#define _CORBA_CONSTANTDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ConstantDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ConstantDef_ptr,
            CORBA::ConstantDef_var,
            CORBA::ConstantDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_IDLTYPE__SARG_TRAITS_)
#define _CORBA_IDLTYPE__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::IDLType>
    : public
        Object_SArg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_STRUCTDEF__SARG_TRAITS_)
#define _CORBA_STRUCTDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::StructDef>
    : public
        Object_SArg_Traits_T<
            CORBA::StructDef_ptr,
            CORBA::StructDef_var,
            CORBA::StructDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_UNIONDEF__SARG_TRAITS_)
#define _CORBA_UNIONDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::UnionDef>
    : public
        Object_SArg_Traits_T<
            CORBA::UnionDef_ptr,
            CORBA::UnionDef_var,
            CORBA::UnionDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ENUMDEF__SARG_TRAITS_)
#define _CORBA_ENUMDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::EnumDef>
    : public
        Object_SArg_Traits_T<
            CORBA::EnumDef_ptr,
            CORBA::EnumDef_var,
            CORBA::EnumDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ALIASDEF__SARG_TRAITS_)
#define _CORBA_ALIASDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::AliasDef>
    : public
        Object_SArg_Traits_T<
            CORBA::AliasDef_ptr,
            CORBA::AliasDef_var,
            CORBA::AliasDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_INTERFACEDEF__SARG_TRAITS_)
#define _CORBA_INTERFACEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::InterfaceDef>
    : public
        Object_SArg_Traits_T<
            CORBA::InterfaceDef_ptr,
            CORBA::InterfaceDef_var,
            CORBA::InterfaceDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INTERFACEDEFSEQ__SARG_TRAITS_)
#define _CORBA_INTERFACEDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_EXCEPTIONDEF__SARG_TRAITS_)
#define _CORBA_EXCEPTIONDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ExceptionDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ExceptionDef_ptr,
            CORBA::ExceptionDef_var,
            CORBA::ExceptionDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_NATIVEDEF__SARG_TRAITS_)
#define _CORBA_NATIVEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::NativeDef>
    : public
        Object_SArg_Traits_T<
            CORBA::NativeDef_ptr,
            CORBA::NativeDef_var,
            CORBA::NativeDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_VALUEDEF__SARG_TRAITS_)
#define _CORBA_VALUEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ValueDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ValueDef_ptr,
            CORBA::ValueDef_var,
            CORBA::ValueDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_VALUEDEFSEQ__SARG_TRAITS_)
#define _CORBA_VALUEDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ValueDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ValueDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_VALUEBOXDEF__SARG_TRAITS_)
#define _CORBA_VALUEBOXDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ValueBoxDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ValueBoxDef_ptr,
            CORBA::ValueBoxDef_var,
            CORBA::ValueBoxDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ABSTRACTINTERFACEDEF__SARG_TRAITS_)
#define _CORBA_ABSTRACTINTERFACEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::AbstractInterfaceDef>
    : public
        Object_SArg_Traits_T<
            CORBA::AbstractInterfaceDef_ptr,
            CORBA::AbstractInterfaceDef_var,
            CORBA::AbstractInterfaceDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ__SARG_TRAITS_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::AbstractInterfaceDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::AbstractInterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_LOCALINTERFACEDEF__SARG_TRAITS_)
#define _CORBA_LOCALINTERFACEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::LocalInterfaceDef>
    : public
        Object_SArg_Traits_T<
            CORBA::LocalInterfaceDef_ptr,
            CORBA::LocalInterfaceDef_var,
            CORBA::LocalInterfaceDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_EXTVALUEDEF__SARG_TRAITS_)
#define _CORBA_EXTVALUEDEF__SARG_TRAITS_

  template<>
  class  SArg_Traits<CORBA::ExtValueDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ExtValueDef_ptr,
            CORBA::ExtValueDef_var,
            CORBA::ExtValueDef_out,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTAINEDSEQ__SARG_TRAITS_)
#define _CORBA_CONTAINEDSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ContainedSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ContainedSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_STRUCTMEMBERSEQ__SARG_TRAITS_)
#define _CORBA_STRUCTMEMBERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::StructMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::StructMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INITIALIZERSEQ__SARG_TRAITS_)
#define _CORBA_INITIALIZERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::InitializerSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXTINITIALIZERSEQ__SARG_TRAITS_)
#define _CORBA_EXTINITIALIZERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::ExtInitializerSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExtInitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_UNIONMEMBERSEQ__SARG_TRAITS_)
#define _CORBA_UNIONMEMBERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::UnionMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::UnionMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_ENUMMEMBERSEQ__SARG_TRAITS_)
#define _CORBA_ENUMMEMBERSEQ__SARG_TRAITS_

  template<>
  class SArg_Traits<CORBA::EnumMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::EnumMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:72


TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:817

#if !defined (_CORBA_DEFINITIONKIND__ARG_TRAITS_)
#define _CORBA_DEFINITIONKIND__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::DefinitionKind>
    : public
        Basic_Arg_Traits_T<
            CORBA::DefinitionKind,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINED__ARG_TRAITS_)
#define _CORBA_CONTAINED__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Contained>
    : public
        Object_Arg_Traits_T<
            CORBA::Contained_ptr,
            CORBA::Contained_var,
            CORBA::Contained_out,
            TAO::Objref_Traits<CORBA::Contained>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:859

#if !defined (_CORBA_CONTAINED_DESCRIPTION__ARG_TRAITS_)
#define _CORBA_CONTAINED_DESCRIPTION__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::Contained::Description>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::Contained::Description,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_REPOSITORY__ARG_TRAITS_)
#define _CORBA_REPOSITORY__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Repository>
    : public
        Object_Arg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out,
            TAO::Objref_Traits<CORBA::Repository>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONTAINER__ARG_TRAITS_)
#define _CORBA_CONTAINER__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::Container>
    : public
        Object_Arg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out,
            TAO::Objref_Traits<CORBA::Container>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTAINER_DESCRIPTIONSEQ__ARG_TRAITS_)
#define _CORBA_CONTAINER_DESCRIPTIONSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::Container::DescriptionSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::Container::DescriptionSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_MODULEDEF__ARG_TRAITS_)
#define _CORBA_MODULEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ModuleDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ModuleDef_ptr,
            CORBA::ModuleDef_var,
            CORBA::ModuleDef_out,
            TAO::Objref_Traits<CORBA::ModuleDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_CONSTANTDEF__ARG_TRAITS_)
#define _CORBA_CONSTANTDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ConstantDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ConstantDef_ptr,
            CORBA::ConstantDef_var,
            CORBA::ConstantDef_out,
            TAO::Objref_Traits<CORBA::ConstantDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_IDLTYPE__ARG_TRAITS_)
#define _CORBA_IDLTYPE__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::IDLType>
    : public
        Object_Arg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out,
            TAO::Objref_Traits<CORBA::IDLType>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_STRUCTDEF__ARG_TRAITS_)
#define _CORBA_STRUCTDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::StructDef>
    : public
        Object_Arg_Traits_T<
            CORBA::StructDef_ptr,
            CORBA::StructDef_var,
            CORBA::StructDef_out,
            TAO::Objref_Traits<CORBA::StructDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_UNIONDEF__ARG_TRAITS_)
#define _CORBA_UNIONDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::UnionDef>
    : public
        Object_Arg_Traits_T<
            CORBA::UnionDef_ptr,
            CORBA::UnionDef_var,
            CORBA::UnionDef_out,
            TAO::Objref_Traits<CORBA::UnionDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ENUMDEF__ARG_TRAITS_)
#define _CORBA_ENUMDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::EnumDef>
    : public
        Object_Arg_Traits_T<
            CORBA::EnumDef_ptr,
            CORBA::EnumDef_var,
            CORBA::EnumDef_out,
            TAO::Objref_Traits<CORBA::EnumDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ALIASDEF__ARG_TRAITS_)
#define _CORBA_ALIASDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::AliasDef>
    : public
        Object_Arg_Traits_T<
            CORBA::AliasDef_ptr,
            CORBA::AliasDef_var,
            CORBA::AliasDef_out,
            TAO::Objref_Traits<CORBA::AliasDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_INTERFACEDEF__ARG_TRAITS_)
#define _CORBA_INTERFACEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::InterfaceDef>
    : public
        Object_Arg_Traits_T<
            CORBA::InterfaceDef_ptr,
            CORBA::InterfaceDef_var,
            CORBA::InterfaceDef_out,
            TAO::Objref_Traits<CORBA::InterfaceDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INTERFACEDEFSEQ__ARG_TRAITS_)
#define _CORBA_INTERFACEDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_EXCEPTIONDEF__ARG_TRAITS_)
#define _CORBA_EXCEPTIONDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ExceptionDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ExceptionDef_ptr,
            CORBA::ExceptionDef_var,
            CORBA::ExceptionDef_out,
            TAO::Objref_Traits<CORBA::ExceptionDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_NATIVEDEF__ARG_TRAITS_)
#define _CORBA_NATIVEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::NativeDef>
    : public
        Object_Arg_Traits_T<
            CORBA::NativeDef_ptr,
            CORBA::NativeDef_var,
            CORBA::NativeDef_out,
            TAO::Objref_Traits<CORBA::NativeDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_VALUEDEF__ARG_TRAITS_)
#define _CORBA_VALUEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ValueDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ValueDef_ptr,
            CORBA::ValueDef_var,
            CORBA::ValueDef_out,
            TAO::Objref_Traits<CORBA::ValueDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_VALUEDEFSEQ__ARG_TRAITS_)
#define _CORBA_VALUEDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ValueDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ValueDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_VALUEBOXDEF__ARG_TRAITS_)
#define _CORBA_VALUEBOXDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ValueBoxDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ValueBoxDef_ptr,
            CORBA::ValueBoxDef_var,
            CORBA::ValueBoxDef_out,
            TAO::Objref_Traits<CORBA::ValueBoxDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_ABSTRACTINTERFACEDEF__ARG_TRAITS_)
#define _CORBA_ABSTRACTINTERFACEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::AbstractInterfaceDef>
    : public
        Object_Arg_Traits_T<
            CORBA::AbstractInterfaceDef_ptr,
            CORBA::AbstractInterfaceDef_var,
            CORBA::AbstractInterfaceDef_out,
            TAO::Objref_Traits<CORBA::AbstractInterfaceDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_ABSTRACTINTERFACEDEFSEQ__ARG_TRAITS_)
#define _CORBA_ABSTRACTINTERFACEDEFSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::AbstractInterfaceDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::AbstractInterfaceDefSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_LOCALINTERFACEDEF__ARG_TRAITS_)
#define _CORBA_LOCALINTERFACEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::LocalInterfaceDef>
    : public
        Object_Arg_Traits_T<
            CORBA::LocalInterfaceDef_ptr,
            CORBA::LocalInterfaceDef_var,
            CORBA::LocalInterfaceDef_out,
            TAO::Objref_Traits<CORBA::LocalInterfaceDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:140

#if !defined (_CORBA_EXTVALUEDEF__ARG_TRAITS_)
#define _CORBA_EXTVALUEDEF__ARG_TRAITS_

  template<>
  class  Arg_Traits<CORBA::ExtValueDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ExtValueDef_ptr,
            CORBA::ExtValueDef_var,
            CORBA::ExtValueDef_out,
            TAO::Objref_Traits<CORBA::ExtValueDef>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_CONTAINEDSEQ__ARG_TRAITS_)
#define _CORBA_CONTAINEDSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ContainedSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ContainedSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_STRUCTMEMBERSEQ__ARG_TRAITS_)
#define _CORBA_STRUCTMEMBERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::StructMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::StructMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_INITIALIZERSEQ__ARG_TRAITS_)
#define _CORBA_INITIALIZERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::InitializerSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_EXTINITIALIZERSEQ__ARG_TRAITS_)
#define _CORBA_EXTINITIALIZERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::ExtInitializerSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExtInitializerSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_UNIONMEMBERSEQ__ARG_TRAITS_)
#define _CORBA_UNIONMEMBERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::UnionMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::UnionMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:611

#if !defined (_CORBA_ENUMMEMBERSEQ__ARG_TRAITS_)
#define _CORBA_ENUMMEMBERSEQ__ARG_TRAITS_

  template<>
  class Arg_Traits<CORBA::EnumMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::EnumMemberSeq,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL




// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_IRObject_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::IRObject::_is_a_skel, 0},
      {"",0,0},
      {"destroy", &POA_CORBA::IRObject::destroy_skel, 0},
      {"",0,0},{"",0,0},
      {"_interface", &POA_CORBA::IRObject::_interface_skel, 0},
      {"",0,0},{"",0,0},
      {"_get_def_kind", &POA_CORBA::IRObject::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::IRObject::_repository_id_skel, 0},
      {"_component", &POA_CORBA::IRObject::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBA::IRObject::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_IRObject_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_IRObject_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_IRObject_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_IRObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_IRObject_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_IRObject_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::IRObject::IRObject (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

POA_CORBA::IRObject::IRObject (const IRObject& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CORBA::IRObject::~IRObject (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_def_kind_IRObject
    : public TAO::Upcall_Command
  {
  public:
    inline _get_def_kind_IRObject (
      POA_CORBA::IRObject * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::DefinitionKind>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::DefinitionKind> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->def_kind ();
    }

  private:
    POA_CORBA::IRObject * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::IRObject::_get_def_kind_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::DefinitionKind>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IRObject * const impl =
    static_cast<POA_CORBA::IRObject *> (servant);

  _get_def_kind_IRObject command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class destroy_IRObject
    : public TAO::Upcall_Command
  {
  public:
    inline destroy_IRObject (
      POA_CORBA::IRObject * servant)
      : servant_ (servant)
    {
    }

    virtual void execute (void)
    {
      this->servant_->destroy ();
    }

  private:
    POA_CORBA::IRObject * const servant_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::IRObject::destroy_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IRObject * const impl =
    static_cast<POA_CORBA::IRObject *> (servant);

  destroy_IRObject command (
    impl);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_IRObject_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_IRObject_Upcall_Command (
      POA_CORBA::IRObject * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::IRObject * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IRObject::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::IRObject * const impl =
    static_cast<POA_CORBA::IRObject *> (servant);

  _is_a_IRObject_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_IRObject_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_IRObject_Upcall_Command (
      POA_CORBA::IRObject * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::IRObject * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IRObject::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IRObject * const impl =
    static_cast<POA_CORBA::IRObject *> (servant);

  _non_existent_IRObject_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_IRObject_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_IRObject_Upcall_Command (
      POA_CORBA::IRObject * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::IRObject * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IRObject::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IRObject * const impl =
    static_cast<POA_CORBA::IRObject *> (servant);

  _repository_id_IRObject_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::IRObject::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::IRObject * const impl =
    static_cast<POA_CORBA::IRObject *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_IRObject_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_IRObject_Upcall_Command (
      POA_CORBA::IRObject * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::IRObject * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IRObject::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IRObject * const impl =
    static_cast<POA_CORBA::IRObject *> (servant);

  _get_component_IRObject_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::IRObject::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::IRObject::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::IRObject *
POA_CORBA::IRObject::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::IRObject STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_IRObject_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_Contained_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4,
      WORDLIST_SIZE = 22
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::Contained::move_skel, 0},
      {"_is_a", &POA_CORBA::Contained::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::Contained::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::Contained::_set_id_skel, 0},
      {"describe", &POA_CORBA::Contained::describe_skel, 0},
      {"_get_name", &POA_CORBA::Contained::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::Contained::_set_name_skel, 0},
      {"_interface", &POA_CORBA::Contained::_interface_skel, 0},
      {"_get_version", &POA_CORBA::Contained::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::Contained::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::Contained::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::Contained::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::Contained::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::Contained::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::Contained::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::Contained::_component_skel, 0},
      {"_non_existent", &POA_CORBA::Contained::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::Contained::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -2, -12,  -2,   4,   5,  -1,  50,   8, -45,  11,  -1, -46,  14,
       15,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_Contained_Perfect_Hash_OpTable tao_CORBA_Contained_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_Contained_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_Contained_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_Contained_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_Contained_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_Contained_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_Contained_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::Contained::Contained (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_Contained_optable;
}

POA_CORBA::Contained::Contained (const Contained& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs)
{
}

POA_CORBA::Contained::~Contained (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_id_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _get_id_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::RepositoryId>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->id ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_get_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::RepositoryId>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _get_id_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_id_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _set_id_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->id (
        arg_1);
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_set_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id
    };

  static size_t const nargs = 2;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _set_id_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_name_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _get_name_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Identifier>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->name ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_get_name_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Identifier>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _get_name_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_name_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _set_name_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->name (
        arg_1);
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_set_name_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_name
    };

  static size_t const nargs = 2;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _set_name_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_version_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _get_version_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::VersionSpec>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->version ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_get_version_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::VersionSpec>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _get_version_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _set_version_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _set_version_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          1);

      this->servant_->version (
        arg_1);
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_set_version_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_version
    };

  static size_t const nargs = 2;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _set_version_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_defined_in_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _get_defined_in_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Container>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Container> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->defined_in ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_get_defined_in_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Container>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _get_defined_in_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_absolute_name_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _get_absolute_name_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ScopedName>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ScopedName> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->absolute_name ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_get_absolute_name_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ScopedName>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _get_absolute_name_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_containing_repository_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline _get_containing_repository_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Repository>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Repository> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->containing_repository ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::_get_containing_repository_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Repository>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _get_containing_repository_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class describe_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline describe_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Contained::Description>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Contained::Description> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->describe ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::describe_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Contained::Description>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  describe_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class move_Contained
    : public TAO::Upcall_Command
  {
  public:
    inline move_Contained (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Container>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Container> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      this->servant_->move (
        arg_1
        , arg_2
        , arg_3);
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Contained::move_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Container>::in_arg_val _tao_new_container;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_new_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_new_version;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_new_container,
      &_tao_new_name,
      &_tao_new_version
    };

  static size_t const nargs = 4;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  move_Contained command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_Contained_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_Contained_Upcall_Command (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Contained::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _is_a_Contained_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_Contained_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_Contained_Upcall_Command (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Contained::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _non_existent_Contained_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_Contained_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_Contained_Upcall_Command (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Contained::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _repository_id_Contained_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::Contained::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_Contained_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_Contained_Upcall_Command (
      POA_CORBA::Contained * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::Contained * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Contained::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Contained * const impl =
    static_cast<POA_CORBA::Contained *> (servant);

  _get_component_Contained_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::Contained::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::Contained::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::Contained *
POA_CORBA::Contained::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::Contained STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_Contained_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_Container_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 20,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 15,
     41,  0,  0,  0, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41,  0, 20,  5,
     41,  0, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 15,  5, 41, 41, 41, 10,  0, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41,
#else
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
     41, 41, 41, 41, 41, 20, 41, 15, 41,  0,
      0,  0, 41, 41, 41, 41, 41, 41,  0, 20,
      5, 41,  0, 41, 41, 15,  5, 41, 41, 41,
     10,  0, 41, 41, 41, 41, 41, 41,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 25,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 40,
      HASH_VALUE_RANGE = 35,
      DUPLICATES = 3,
      WORDLIST_SIZE = 31
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"lookup", &POA_CORBA::Container::lookup_skel, 0},
      {"destroy", &POA_CORBA::Container::destroy_skel, 0},
      {"lookup_name", &POA_CORBA::Container::lookup_name_skel, 0},
      {"create_value", &POA_CORBA::Container::create_value_skel, 0},
      {"create_module", &POA_CORBA::Container::create_module_skel, 0},
      {"create_native", &POA_CORBA::Container::create_native_skel, 0},
      {"create_interface", &POA_CORBA::Container::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Container::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Container::create_union_skel, 0},
      {"create_struct", &POA_CORBA::Container::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::Container::create_constant_skel, 0},
      {"create_exception", &POA_CORBA::Container::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::Container::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::Container::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Container::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::Container::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::Container::create_alias_skel, 0},
      {"_interface", &POA_CORBA::Container::_interface_skel, 0},
      {"create_enum", &POA_CORBA::Container::create_enum_skel, 0},
      {"describe_contents", &POA_CORBA::Container::describe_contents_skel, 0},
      {"_get_def_kind", &POA_CORBA::Container::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::Container::_repository_id_skel, 0},
      {"_component", &POA_CORBA::Container::_component_skel, 0},
      {"_non_existent", &POA_CORBA::Container::_non_existent_skel, 0},
      {"_is_a", &POA_CORBA::Container::_is_a_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,   7,  -1, -10,  -2,   8,   9, -44,
      -12,  -2, -42,  14,  15,  -1,  16,  17,  18,  19,  -1,  20,  21,  22,
       -1,  -1,  23,  24,  25,  26,  27,  28,  -1,  -1,  29,  -1,  30,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_Container_Perfect_Hash_OpTable tao_CORBA_Container_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_Container_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_Container_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_Container_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_Container_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_Container_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::Container::Container (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_Container_optable;
}

POA_CORBA::Container::Container (const Container& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs)
{
}

POA_CORBA::Container::~Container (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class lookup_Container
    : public TAO::Upcall_Command
  {
  public:
    inline lookup_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Contained>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Contained> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::ScopedName>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ScopedName> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_->lookup (
          arg_1);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::lookup_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Contained>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ScopedName>::in_arg_val _tao_search_name;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_search_name
    };

  static size_t const nargs = 2;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  lookup_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class contents_Container
    : public TAO::Upcall_Command
  {
  public:
    inline contents_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ContainedSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ContainedSeq> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::DefinitionKind>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::DefinitionKind> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          2);

      retval =
        this->servant_->contents (
          arg_1
          , arg_2);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::contents_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ContainedSeq>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::DefinitionKind>::in_arg_val _tao_limit_type;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_exclude_inherited;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_limit_type,
      &_tao_exclude_inherited
    };

  static size_t const nargs = 3;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  contents_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class lookup_name_Container
    : public TAO::Upcall_Command
  {
  public:
    inline lookup_name_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ContainedSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ContainedSeq> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::DefinitionKind>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::DefinitionKind> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->lookup_name (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::lookup_name_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ContainedSeq>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_search_name;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_levels_to_search;
  TAO::SArg_Traits< ::CORBA::DefinitionKind>::in_arg_val _tao_limit_type;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_exclude_inherited;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_search_name,
      &_tao_levels_to_search,
      &_tao_limit_type,
      &_tao_exclude_inherited
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  lookup_name_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class describe_contents_Container
    : public TAO::Upcall_Command
  {
  public:
    inline describe_contents_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Container::DescriptionSeq>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Container::DescriptionSeq> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::DefinitionKind>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::DefinitionKind> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::Long>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Long> (
          this->operation_details_,
          this->args_,
          3);

      retval =
        this->servant_->describe_contents (
          arg_1
          , arg_2
          , arg_3);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::describe_contents_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Container::DescriptionSeq>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::DefinitionKind>::in_arg_val _tao_limit_type;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_exclude_inherited;
  TAO::SArg_Traits< ::CORBA::Long>::in_arg_val _tao_max_returned_objs;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_limit_type,
      &_tao_exclude_inherited,
      &_tao_max_returned_objs
    };

  static size_t const nargs = 4;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  describe_contents_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_module_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_module_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ModuleDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ModuleDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      retval =
        this->servant_->create_module (
          arg_1
          , arg_2
          , arg_3);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_module_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ModuleDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version
    };

  static size_t const nargs = 4;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_module_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_constant_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_constant_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ConstantDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ConstantDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);

      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          5);

      retval =
        this->servant_->create_constant (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_constant_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ConstantDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_type;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_value;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_type,
      &_tao_value
    };

  static size_t const nargs = 6;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_constant_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_struct_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_struct_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::StructDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::StructDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_struct (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_struct_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::StructDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_members
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_struct_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_union_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_union_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::UnionDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::UnionDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);

      TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::CORBA::UnionMemberSeq> (
          this->operation_details_,
          this->args_,
          5);

      retval =
        this->servant_->create_union (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_union_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::UnionDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_discriminator_type;
  TAO::SArg_Traits< ::CORBA::UnionMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_discriminator_type,
      &_tao_members
    };

  static size_t const nargs = 6;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_union_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_enum_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_enum_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::EnumDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::EnumDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::EnumMemberSeq> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_enum (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_enum_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::EnumDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::EnumMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_members
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_enum_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_alias_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_alias_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AliasDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::AliasDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_alias (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_alias_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::AliasDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_original_type;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_original_type
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_alias_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_interface_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_interface_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::InterfaceDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::InterfaceDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_interface (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_interface_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::InterfaceDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_base_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_base_interfaces
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_interface_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_value_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_value_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ValueDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ValueDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          4);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          5);

      TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ValueDef> (
          this->operation_details_,
          this->args_,
          6);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_7 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          7);

      TAO::SArg_Traits< ::CORBA::ValueDefSeq>::in_arg_type arg_8 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ValueDefSeq> (
          this->operation_details_,
          this->args_,
          8);

      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_9 =
        TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          9);

      TAO::SArg_Traits< ::CORBA::InitializerSeq>::in_arg_type arg_10 =
        TAO::Portable_Server::get_in_arg< ::CORBA::InitializerSeq> (
          this->operation_details_,
          this->args_,
          10);

      retval =
        this->servant_->create_value (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7
          , arg_8
          , arg_9
          , arg_10);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_value_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ValueDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_custom;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_abstract;
  TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_val _tao_base_value;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_truncatable;
  TAO::SArg_Traits< ::CORBA::ValueDefSeq>::in_arg_val _tao_abstract_base_values;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_supported_interfaces;
  TAO::SArg_Traits< ::CORBA::InitializerSeq>::in_arg_val _tao_initializers;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_is_custom,
      &_tao_is_abstract,
      &_tao_base_value,
      &_tao_is_truncatable,
      &_tao_abstract_base_values,
      &_tao_supported_interfaces,
      &_tao_initializers
    };

  static size_t const nargs = 11;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_value_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_value_box_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_value_box_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ValueBoxDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ValueBoxDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_value_box (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_value_box_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ValueBoxDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::IDLType>::in_arg_val _tao_original_type_def;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_original_type_def
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_value_box_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_exception_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_exception_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExceptionDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExceptionDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_exception (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_exception_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExceptionDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::StructMemberSeq>::in_arg_val _tao_members;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_members
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_exception_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_native_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_native_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::NativeDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::NativeDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      retval =
        this->servant_->create_native (
          arg_1
          , arg_2
          , arg_3);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_native_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::NativeDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version
    };

  static size_t const nargs = 4;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_native_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_abstract_interface_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_abstract_interface_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::AbstractInterfaceDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::AbstractInterfaceDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::AbstractInterfaceDefSeq>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::AbstractInterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_abstract_interface (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_abstract_interface_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::AbstractInterfaceDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::AbstractInterfaceDefSeq>::in_arg_val _tao_base_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_base_interfaces
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_abstract_interface_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_local_interface_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_local_interface_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::LocalInterfaceDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::LocalInterfaceDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          4);

      retval =
        this->servant_->create_local_interface (
          arg_1
          , arg_2
          , arg_3
          , arg_4);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_local_interface_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::LocalInterfaceDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_base_interfaces;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_base_interfaces
    };

  static size_t const nargs = 5;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_local_interface_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class create_ext_value_Container
    : public TAO::Upcall_Command
  {
  public:
    inline create_ext_value_Container (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::ExtValueDef>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::ExtValueDef> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);

      TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_type arg_2 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);

      TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_type arg_3 =
        TAO::Portable_Server::get_in_arg< ::CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_4 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          4);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_5 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          5);

      TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_type arg_6 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ValueDef> (
          this->operation_details_,
          this->args_,
          6);

      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_type arg_7 =
        TAO::Portable_Server::get_in_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_,
          7);

      TAO::SArg_Traits< ::CORBA::ValueDefSeq>::in_arg_type arg_8 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ValueDefSeq> (
          this->operation_details_,
          this->args_,
          8);

      TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_type arg_9 =
        TAO::Portable_Server::get_in_arg< ::CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          9);

      TAO::SArg_Traits< ::CORBA::ExtInitializerSeq>::in_arg_type arg_10 =
        TAO::Portable_Server::get_in_arg< ::CORBA::ExtInitializerSeq> (
          this->operation_details_,
          this->args_,
          10);

      retval =
        this->servant_->create_ext_value (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7
          , arg_8
          , arg_9
          , arg_10);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::Container::create_ext_value_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::ExtValueDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< ::CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< ::CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_custom;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_abstract;
  TAO::SArg_Traits< ::CORBA::ValueDef>::in_arg_val _tao_base_value;
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::in_arg_val _tao_is_truncatable;
  TAO::SArg_Traits< ::CORBA::ValueDefSeq>::in_arg_val _tao_abstract_base_values;
  TAO::SArg_Traits< ::CORBA::InterfaceDefSeq>::in_arg_val _tao_supported_interfaces;
  TAO::SArg_Traits< ::CORBA::ExtInitializerSeq>::in_arg_val _tao_initializers;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_is_custom,
      &_tao_is_abstract,
      &_tao_base_value,
      &_tao_is_truncatable,
      &_tao_abstract_base_values,
      &_tao_supported_interfaces,
      &_tao_initializers
    };

  static size_t const nargs = 11;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  create_ext_value_Container command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_Container_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_Container_Upcall_Command (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Container::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  _is_a_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_Container_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_Container_Upcall_Command (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Container::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  _non_existent_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_Container_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_Container_Upcall_Command (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Container::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  _repository_id_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::Container::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_Container_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_Container_Upcall_Command (
      POA_CORBA::Container * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::Container * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::Container::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::Container * const impl =
    static_cast<POA_CORBA::Container *> (servant);

  _get_component_Container_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::Container::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::Container::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::Container *
POA_CORBA::Container::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::Container STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_Container_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_IDLType_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::IDLType::_is_a_skel, 0},
      {"",0,0},
      {"destroy", &POA_CORBA::IDLType::destroy_skel, 0},
      {"",0,0},
      {"_get_type", &POA_CORBA::IDLType::_get_type_skel, 0},
      {"_interface", &POA_CORBA::IDLType::_interface_skel, 0},
      {"",0,0},{"",0,0},
      {"_get_def_kind", &POA_CORBA::IDLType::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::IDLType::_repository_id_skel, 0},
      {"_component", &POA_CORBA::IDLType::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBA::IDLType::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_IDLType_Perfect_Hash_OpTable tao_CORBA_IDLType_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_IDLType_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_IDLType_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_IDLType_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_IDLType_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_IDLType_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_IDLType_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::IDLType::IDLType (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_IDLType_optable;
}

POA_CORBA::IDLType::IDLType (const IDLType& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs)
{
}

POA_CORBA::IDLType::~IDLType (void)
{
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_type_IDLType
    : public TAO::Upcall_Command
  {
  public:
    inline _get_type_IDLType (
      POA_CORBA::IDLType * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_->type ();
    }

  private:
    POA_CORBA::IDLType * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from
// be\be_visitor_operation/operation_ss.cpp:190

void POA_CORBA::IDLType::_get_type_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IDLType * const impl =
    static_cast<POA_CORBA::IDLType *> (servant);

  _get_type_IDLType command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_IDLType_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_IDLType_Upcall_Command (
      POA_CORBA::IDLType * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::IDLType * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IDLType::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::IDLType * const impl =
    static_cast<POA_CORBA::IDLType *> (servant);

  _is_a_IDLType_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_IDLType_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_IDLType_Upcall_Command (
      POA_CORBA::IDLType * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::IDLType * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IDLType::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IDLType * const impl =
    static_cast<POA_CORBA::IDLType *> (servant);

  _non_existent_IDLType_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_IDLType_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_IDLType_Upcall_Command (
      POA_CORBA::IDLType * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::IDLType * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IDLType::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IDLType * const impl =
    static_cast<POA_CORBA::IDLType *> (servant);

  _repository_id_IDLType_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::IDLType::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::IDLType * const impl =
    static_cast<POA_CORBA::IDLType *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_IDLType_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_IDLType_Upcall_Command (
      POA_CORBA::IDLType * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::IDLType * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::IDLType::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::IDLType * const impl =
    static_cast<POA_CORBA::IDLType *> (servant);

  _get_component_IDLType_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::IDLType::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::IDLType::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::IDLType *
POA_CORBA::IDLType::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::IDLType STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_IDLType_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1499

class TAO_CORBA_TypedefDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: C:\ACE\latest\ACE_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5,
      WORDLIST_SIZE = 23
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::TypedefDef::move_skel, 0},
      {"_is_a", &POA_CORBA::TypedefDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::TypedefDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::TypedefDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::TypedefDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::TypedefDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::TypedefDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::TypedefDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::TypedefDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::TypedefDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::TypedefDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::TypedefDef::_get_def_kind_skel, 0},
      {"_repository_id", &POA_CORBA::TypedefDef::_repository_id_skel, 0},
      {"_get_defined_in", &POA_CORBA::TypedefDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::TypedefDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::TypedefDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::TypedefDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::TypedefDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::TypedefDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  50,   8, -45,  12,  -1, -46,  15,
       16,  17,  -1,  18,  19,  -1,  20,  -6,  -2,  21,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  22,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_TypedefDef_Perfect_Hash_OpTable tao_CORBA_TypedefDef_optable;

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:966

TAO::Collocation_Proxy_Broker *
CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
CORBA__TAO_TypedefDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer =
    CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function;

  return 0;
}

static int
CORBA__TAO_TypedefDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_TypedefDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (CORBA__TAO_TypedefDef_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::TypedefDef::TypedefDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_TypedefDef_optable;
}

POA_CORBA::TypedefDef::TypedefDef (const TypedefDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    POA_CORBA::IRObject (rhs),
    POA_CORBA::Contained (rhs),
    POA_CORBA::IDLType (rhs)
{
}

POA_CORBA::TypedefDef::~TypedefDef (void)
{
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:169

namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _is_a_TypedefDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_TypedefDef_Upcall_Command (
      POA_CORBA::TypedefDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);

      retval =
        this->servant_-> _is_a (
          arg_1);
    }

  private:
    POA_CORBA::TypedefDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::TypedefDef::_is_a_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;

  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };

  static size_t const nargs = 2;

  POA_CORBA::TypedefDef * const impl =
    static_cast<POA_CORBA::TypedefDef *> (servant);

  _is_a_TypedefDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _non_existent_TypedefDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_TypedefDef_Upcall_Command (
      POA_CORBA::TypedefDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _non_existent ();
    }

  private:
    POA_CORBA::TypedefDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::TypedefDef::_non_existent_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::TypedefDef * const impl =
    static_cast<POA_CORBA::TypedefDef *> (servant);

  _non_existent_TypedefDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _repository_id_TypedefDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_TypedefDef_Upcall_Command (
      POA_CORBA::TypedefDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _repository_id ();
    }

  private:
    POA_CORBA::TypedefDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::TypedefDef::_repository_id_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::TypedefDef * const impl =
    static_cast<POA_CORBA::TypedefDef *> (servant);

  _repository_id_TypedefDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:513

void POA_CORBA::TypedefDef::_interface_skel (
    TAO_ServerRequest & server_request,
    void * /* servant_upcall */,
    void * servant
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );

  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (
        ::CORBA::OMGVMCID | 1,
        ::CORBA::COMPLETED_NO);
    }

  POA_CORBA::TypedefDef * const impl =
    static_cast<POA_CORBA::TypedefDef *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval =
    impl->_get_interface ();

  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();

  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );

  _tao_adapter->dispose (_tao_retval);

  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}namespace POA_CORBA
{


  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:127

  class _get_component_TypedefDef_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_TypedefDef_Upcall_Command (
      POA_CORBA::TypedefDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }

    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);

      retval =
        this->servant_-> _get_component ();
    }

  private:
    POA_CORBA::TypedefDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_CORBA::TypedefDef::_component_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */

  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;

  TAO::Argument * const args[] =
    {
      &retval
    };

  static size_t const nargs = 1;

  POA_CORBA::TypedefDef * const impl =
    static_cast<POA_CORBA::TypedefDef *> (servant);

  _get_component_TypedefDef_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);

  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_CORBA::TypedefDef::_is_a (
    const char* value
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:903

void POA_CORBA::TypedefDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:851

CORBA::TypedefDef *
POA_CORBA::TypedefDef::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();

  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();

  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );

  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();

  typedef ::CORBA::TypedefDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_TypedefDef_Proxy_Broker_Factory_function_pointer
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* ifndef */

