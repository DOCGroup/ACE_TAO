// $Id

// ============================================================================
//
// = LIBRARY
//    TAO/tests/Param_Test
//
// = FILENAME
//    params.idl
//
// = DESCRIPTION
//    This IDL description is used to test all the parameter passing modes (in,
//    inout, out, and return) for a number of IDL data types. The goal is to
//    verify the correctness of the generated stubs and skeletons, and the
//    the marshaling engine of TAO.
//
// = AUTHORS
//    Aniruddha Gokhale
//
// ============================================================================

/*
interface Coffee
{
  struct Desc
  {
    string name;
    long   count;
  };
  readonly attribute Desc description;
};
*/

interface Param_Test
{
  // Add exceptions to each

  // primitive types
  short test_short (in short s1,
                    inout short s2,
                    out short s3);
  /*
  long test_long (in long l1,
                  inout long l2,
                  out long l3);
  char test_char (in char c1,
                  inout char c2,
                  out char c3);
  octet test_octet (in octet o1,
                    inout octet o2,
                    out octet o3);

  double test_double (in double d1,
                      inout double d2,
                      out double d3);

  // object references
  Coffee make_coffee (); // make an Coffee object
  Coffee test_Coffee (in Coffee o1, inout Coffee o2, out Coffee o3);

  // strings unbounded
  string test_ubstring (in string s1,
                        inout string s2,
                        out string s3);

  // strings bounded
  const unsigned long STRLEN = 10;
  string<STRLEN> test_bstring (in string<STRLEN> s1,
                               inout string<STRLEN> s2,
                               out string<STRLEN> s3);

  // typedefed string
  typedef string MYSTRING;
  MYSTRING test_tstring (in MYSTRING s1,
                         inout MYSTRING s2,
                         out MYSTRING s3);


  // structures (fixed size)
  struct fixed_struct
  {
    long l;
  };
  fixed_struct test_fstruct (in fixed_struct s1,
                             inout fixed_struct s2,
                             out fixed_struct s3);

  // structures (variable)
  struct var_struct
  {
    Coffee o;
    string s;
    sequence<octet> ObjectKey;
    sequence<octet> bogus;
  };
  var_struct test_vstruct (in var_struct s1,
                           inout var_struct s2,
                           out var_struct s3);
  // arrays (fixed)

  // arrays (variable)

  // multidimensional arrays (fixed)

  // sequences
  typedef sequence<string> StrSeq;
  StrSeq test_seq (in StrSeq s1,
                   inout StrSeq s2,
                   out StrSeq s3);

  // more combinations to follow
  union U switch (long)
    {
    case 0: sequence<char> cseq;
    case 1: sequence<octet> oseq;
    case 2: StrSeq sseq;
    };

  // complex (but meaningless) to test the naming scheme
  typedef sequence <sequence <sequence <long>, 5>, 10> complex;
  */
};
