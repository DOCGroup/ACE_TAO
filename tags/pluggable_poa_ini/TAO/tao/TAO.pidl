//
// $Id$
//
// ================================================================
//
// = LIBRARY
//   TAO
//
// = FILENAME
//   TAO.pidl
//
// = DESCRIPTION
//   This file contains TAO-specific idl interfaces (not part of CORBA
//   2.3).
//
//   The command used to generate code from this file is:
//
//   tao_idl -o orig -Gp -Gd -Ge 1 -Gv  \
//       -Wb,export_macro=TAO_Export \
//       -Wb,pre_include="ace/pre.h" \
//       -Wb,post_include="ace/post.h" \
//       -Wb,export_include="tao/corbafwd.h" TAO.pidl
//
//   after the file is generated a patch must be applied.  The patch
//   fixes the interface repository IDs, disables the code under
//   certain configurations, and eliminates cycles in the include
//   dependencies.  Those changes are required because the generated
//   code is part of the TAO library, it hardly makes any sense to
//   change the IDL compiler to support changes that are very
//   occasional.
//
// ================================================================

#ifndef TAO_TAO_IDL
#define TAO_TAO_IDL

#include "Policy.pidl"
#include "TimeBase.pidl"

#pragma prefix ""

module TAO
{
  //
  // Client priority.
  //
  typedef short PrioritySelectionMode;
  const PrioritySelectionMode USE_NO_PRIORITY     = 0;
  const PrioritySelectionMode USE_THREAD_PRIORITY = 1;
  const PrioritySelectionMode USE_PRIORITY_RANGE  = 2;

  struct PrioritySpecification
  {
    PrioritySelectionMode mode;
    short min_priority;
    short max_priority;
  };

  const CORBA::PolicyType CLIENT_PRIORITY_POLICY_TYPE = 0x54410000;
  local interface ClientPriorityPolicy : CORBA::Policy
    {
      readonly attribute PrioritySpecification priority_specification;
    };

  // ****************************************************************

  //
  // Buffering constraint.
  //
  typedef unsigned short BufferingConstraintMode;
  const BufferingConstraintMode BUFFER_FLUSH         = 0x00;

  // Note that timeout, message_count, and message_bytes can be or'd.
  const BufferingConstraintMode BUFFER_TIMEOUT       = 0x01;
  const BufferingConstraintMode BUFFER_MESSAGE_COUNT = 0x02;
  const BufferingConstraintMode BUFFER_MESSAGE_BYTES = 0x04;

  struct BufferingConstraint
  {
    BufferingConstraintMode mode;
    TimeBase::TimeT timeout;
    unsigned long message_count;
    unsigned long message_bytes;
  };

  const CORBA::PolicyType BUFFERING_CONSTRAINT_POLICY_TYPE = 0x54410001;
  local interface BufferingConstraintPolicy : CORBA::Policy
    {
      readonly attribute BufferingConstraint buffering_constraint;
    };

  // @@ I (coryan) found the following comment on the generated code:
  //
  //       It seems easier to have copies of these here than to use
  //       #if (TAO_HAS_CORBA_MESSAGING == 1) everywhere or to define
  //       a new class TAO_GIOP_Reliable_Oneway_Invocation
  //
  // I don't agree, but this is not the time to fix this stuff,
  // instead I added the code to the .pidl file so at least it is
  // automatically generated.
  //
  typedef short SyncScope;
  const SyncScope SYNC_NONE           = 0;
  const SyncScope SYNC_WITH_TRANSPORT = 1;
  const SyncScope SYNC_WITH_SERVER    = 2;
  const SyncScope SYNC_WITH_TARGET    = 3;
  // = TAO specific.
  const SyncScope SYNC_EAGER_BUFFERING   = SYNC_NONE;
  const SyncScope SYNC_DELAYED_BUFFERING = -2;
};

#pragma prefix ""

#endif /* TAO_TAO_IDL */
