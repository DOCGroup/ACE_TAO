// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_ORIG_IMPLREPOS_CPP_
#define _TAO_IDL_ORIG_IMPLREPOS_CPP_

#include "ImplRepoS.h"

#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/PICurrent.h"
#include "tao/PortableServer/ServerRequestInfo.h"
#include "tao/PortableServer/ServerInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "ace/Dynamic_Service.h"
#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "ImplRepoS.i"
#endif /* !defined INLINE */

class TAO_ImplementationRepository_ServerObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:26:32 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /project/sirion/coryan/amh/ACE_wrappers/build/Linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_ImplementationRepository_ServerObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ImplementationRepository_ServerObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14,  0, 14,  0, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14,  0, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14,  0,  0, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14,
#else
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14,  0, 14,  0, 14, 14,
     14,  0, 14,  0, 14, 14, 14, 14, 14, 14,
      0, 14,  0, 14, 14,  0,  0, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_ImplementationRepository_ServerObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 13,
      HASH_VALUE_RANGE = 10,
      DUPLICATES = 0,
      WORDLIST_SIZE = 9
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"ping", 	&POA_ImplementationRepository::ServerObject::ping_skel},
      {"_is_a",  &POA_ImplementationRepository::ServerObject::_is_a_skel},
      {"",0},{"",0},
      {"shutdown", 	&POA_ImplementationRepository::ServerObject::shutdown_skel},
      {"",0},
      {"_interface",  &POA_ImplementationRepository::ServerObject::_interface_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_ImplementationRepository::ServerObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 10:26:32 */
static TAO_ImplementationRepository_ServerObject_Perfect_Hash_OpTable tao_ImplementationRepository_ServerObject_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::ServerObject *tao_impl
     ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping (const TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping &);
  
private:
  POA_ImplementationRepository::ServerObject *_tao_impl;
  
};

TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping::TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::ServerObject *tao_impl ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::ServerObject *tao_impl
     ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown (const TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown &);
  
private:
  POA_ImplementationRepository::ServerObject *_tao_impl;
  
};

TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown::TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::ServerObject *tao_impl ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker *POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker::the_TAO_ServerObject_Strategized_Proxy_Broker (void)
{
  static POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker::_TAO_ServerObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker::~_TAO_ServerObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

ImplementationRepository::_TAO_ServerObject_Proxy_Impl&
POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker::select_proxy (
    ::ImplementationRepository::ServerObject *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_ImplementationRepository::_TAO_ServerObject_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_DIRECT_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_ImplementationRepository::_TAO_ServerObject_Direct_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::ImplementationRepository::_TAO_ServerObject_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


ImplementationRepository::_TAO_ServerObject_Proxy_Broker *
ImplementationRepository__TAO_ServerObject_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_ImplementationRepository::_TAO_ServerObject_Strategized_Proxy_Broker::the_TAO_ServerObject_Strategized_Proxy_Broker();
}

int
ImplementationRepository__TAO_ServerObject_Proxy_Broker_Factory_Initializer (long)
{
  ImplementationRepository__TAO_ServerObject_Proxy_Broker_Factory_function_pointer = 
    ImplementationRepository__TAO_ServerObject_Proxy_Broker_Factory_function;
  
  return 0;
}

static int ImplementationRepository__TAO_ServerObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  ImplementationRepository__TAO_ServerObject_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, ImplementationRepository__TAO_ServerObject_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_ImplementationRepository::_TAO_ServerObject_ThruPOA_Proxy_Impl::_TAO_ServerObject_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_ImplementationRepository::_TAO_ServerObject_ThruPOA_Proxy_Impl::ping (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "ping",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/ServerObject:1.0"
        )
    )->ping (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
  return;
}

void POA_ImplementationRepository::_TAO_ServerObject_ThruPOA_Proxy_Impl::shutdown (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "shutdown",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/ServerObject:1.0"
        )
    )->shutdown (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Direct Proxy  Implementation
//

POA_ImplementationRepository::_TAO_ServerObject_Direct_Proxy_Impl::_TAO_ServerObject_Direct_Proxy_Impl (void)
{}

void POA_ImplementationRepository::_TAO_ServerObject_Direct_Proxy_Impl::ping  (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerObject_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/ServerObject:1.0")
    )->ping (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_ServerObject_Direct_Proxy_Impl::shutdown  (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerObject_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/ServerObject:1.0")
    )->shutdown (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
  
}


//
//           End Direct Proxy Implementation
///////////////////////////////////////////////////////////////////////
// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:100
POA_ImplementationRepository::ServerObject::ServerObject (void)
{
  this->optable_ = &tao_ImplementationRepository_ServerObject_optable;
}

POA_ImplementationRepository::ServerObject::ServerObject (const ServerObject& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_ImplementationRepository::ServerObject::~ServerObject (void)
{
}

void POA_ImplementationRepository::ServerObject::ping_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::ServerObject *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::ServerObject *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_ServerObject_ping _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->ping (
            ACE_ENV_SINGLE_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::ServerObject::shutdown_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::ServerObject *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::ServerObject *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_ServerObject_shutdown _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->shutdown (
            ACE_ENV_SINGLE_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::ServerObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::ServerObject *_tao_impl = (POA_ImplementationRepository::ServerObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_ImplementationRepository::ServerObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::ServerObject *_tao_impl = (POA_ImplementationRepository::ServerObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_ImplementationRepository::ServerObject::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::ServerObject *_tao_impl = (POA_ImplementationRepository::ServerObject *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_ImplementationRepository::ServerObject::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:ImplementationRepository/ServerObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_ImplementationRepository::ServerObject::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:ImplementationRepository/ServerObject:1.0") == 0)
    return ACE_static_cast (POA_ImplementationRepository::ServerObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_ImplementationRepository::ServerObject::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/ServerObject:1.0";
}

void POA_ImplementationRepository::ServerObject::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


ImplementationRepository::ServerObject*
POA_ImplementationRepository::ServerObject::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::ImplementationRepository::ServerObject::_unchecked_narrow (obj.in ());
}


class TAO_ImplementationRepository_Administration_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:26:32 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /project/sirion/coryan/amh/ACE_wrappers/build/Linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_ImplementationRepository_Administration_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ImplementationRepository_Administration_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  0,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29,  4,
     29, 29,  0,  0,  0,  0, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29,  5, 29,  0,
     29, 29, 29,  0, 29, 29, 29, 29, 29, 29,
     29, 29,  5,  5, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29,
#else
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
     29, 29, 29, 29, 29,  0, 29,  4, 29, 29,
      0,  0,  0,  0, 29, 29, 29, 29,  5, 29,
      0, 29, 29, 29,  0,  5,  5, 29, 29, 29,
     29, 29, 29, 29, 29, 29, 29, 29,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_ImplementationRepository_Administration_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 12,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 23,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 28,
      HASH_VALUE_RANGE = 25,
      DUPLICATES = 0,
      WORDLIST_SIZE = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"find", 	&POA_ImplementationRepository::Administration::find_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_ImplementationRepository::Administration::_is_a_skel},
      {"_interface",  &POA_ImplementationRepository::Administration::_interface_skel},
      {"",0},{"",0},
      {"remove_server", 	&POA_ImplementationRepository::Administration::remove_server_skel},
      {"list", 	&POA_ImplementationRepository::Administration::list_skel},
      {"register_server", 	&POA_ImplementationRepository::Administration::register_server_skel},
      {"",0},
      {"reregister_server", 	&POA_ImplementationRepository::Administration::reregister_server_skel},
      {"_non_existent",  &POA_ImplementationRepository::Administration::_non_existent_skel},
      {"activate_server", 	&POA_ImplementationRepository::Administration::activate_server_skel},
      {"shutdown_server", 	&POA_ImplementationRepository::Administration::shutdown_server_skel},
      {"",0},
      {"server_is_running", 	&POA_ImplementationRepository::Administration::server_is_running_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"server_is_shutting_down", 	&POA_ImplementationRepository::Administration::server_is_shutting_down_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 10:26:32 */
static TAO_ImplementationRepository_Administration_Perfect_Hash_OpTable tao_ImplementationRepository_Administration_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server (const TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server::TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_ImplementationRepository_Administration_activate_server_exceptiondata[] = 
  {
    ImplementationRepository::Administration::_tc_NotFound,
    ImplementationRepository::Administration::_tc_CannotActivate
  };
  
  exception_list->length (2);
  for (CORBA::ULong i = 0; i < 2; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_ImplementationRepository_Administration_activate_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server,
    const ImplementationRepository::StartupOptions & options ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server (const TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  const ImplementationRepository::StartupOptions & options_;
  
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server::TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server,
    const ImplementationRepository::StartupOptions & options ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server),
    options_ (options)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->options_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_ImplementationRepository_Administration_register_server_exceptiondata[] = 
  {
    ImplementationRepository::Administration::_tc_AlreadyRegistered
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_ImplementationRepository_Administration_register_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server,
    const ImplementationRepository::StartupOptions & options ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server (const TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  const ImplementationRepository::StartupOptions & options_;
  
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server::TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server,
    const ImplementationRepository::StartupOptions & options ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server),
    options_ (options)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (2);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->options_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server (const TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server::TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_ImplementationRepository_Administration_remove_server_exceptiondata[] = 
  {
    ImplementationRepository::Administration::_tc_NotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_ImplementationRepository_Administration_remove_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server (const TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server::TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_ImplementationRepository_Administration_shutdown_server_exceptiondata[] = 
  {
    ImplementationRepository::Administration::_tc_NotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_ImplementationRepository_Administration_shutdown_server_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server,
    const char * addr,
    ImplementationRepository::ServerObject_ptr server_object ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (char * result);

private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running (const TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  const char * addr_;
  ImplementationRepository::ServerObject_ptr server_object_;
  char * _result;
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running::TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server,
    const char * addr,
    ImplementationRepository::ServerObject_ptr server_object ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server),
    addr_ (addr),
    server_object_ (server_object)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (3);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<= addr_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    (*parameter_list)[len].argument <<=  this->server_object_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_ImplementationRepository_Administration_server_is_running_exceptiondata[] = 
  {
    ImplementationRepository::Administration::_tc_NotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_ImplementationRepository_Administration_server_is_running_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running::result (char * result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down (const TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down::TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_ImplementationRepository_Administration_server_is_shutting_down_exceptiondata[] = 
  {
    ImplementationRepository::Administration::_tc_NotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_ImplementationRepository_Administration_server_is_shutting_down_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_find : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_find (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const char * server ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_find (const TAO_ServerRequestInfo_ImplementationRepository_Administration_find &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_find &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const char * server_;
  
};

TAO_ServerRequestInfo_ImplementationRepository_Administration_find::TAO_ServerRequestInfo_ImplementationRepository_Administration_find (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const char * server ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    server_ (server)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_find::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= server_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_find::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ExceptionList_var safe_exception_list = exception_list;
    
  static CORBA::TypeCode_ptr _tao_ImplementationRepository_Administration_find_exceptiondata[] = 
  {
    ImplementationRepository::Administration::_tc_NotFound
  };
  
  exception_list->length (1);
  for (CORBA::ULong i = 0; i < 1; ++i)
    {
      CORBA::TypeCode_ptr tcp = _tao_ImplementationRepository_Administration_find_exceptiondata[i];
      TAO_Pseudo_Object_Manager<CORBA::TypeCode, CORBA::TypeCode_var> tcp_object (&tcp, 1);
      (*exception_list)[i] = tcp_object;
    }

  return safe_exception_list._retn ();
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_find::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_find::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_find::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

class TAO_ServerRequestInfo_ImplementationRepository_Administration_list : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_list (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::Administration *tao_impl
    ,
    const CORBA::ULong & how_many    
 ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_Administration_list (const TAO_ServerRequestInfo_ImplementationRepository_Administration_list &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_Administration_list &);
  
private:
  POA_ImplementationRepository::Administration *_tao_impl;
  const CORBA::ULong & how_many_;
    

};

TAO_ServerRequestInfo_ImplementationRepository_Administration_list::TAO_ServerRequestInfo_ImplementationRepository_Administration_list (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::Administration *tao_impl,
    const CORBA::ULong & how_many    
 ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    how_many_ (how_many)  

{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_list::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= how_many_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
    

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_Administration_list::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_Administration_list::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_Administration_list::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_Administration_list::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker *POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker::the_TAO_Administration_Strategized_Proxy_Broker (void)
{
  static POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker::_TAO_Administration_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker::~_TAO_Administration_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

ImplementationRepository::_TAO_Administration_Proxy_Impl&
POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker::select_proxy (
    ::ImplementationRepository::Administration *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_DIRECT_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::ImplementationRepository::_TAO_Administration_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


ImplementationRepository::_TAO_Administration_Proxy_Broker *
ImplementationRepository__TAO_Administration_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_ImplementationRepository::_TAO_Administration_Strategized_Proxy_Broker::the_TAO_Administration_Strategized_Proxy_Broker();
}

int
ImplementationRepository__TAO_Administration_Proxy_Broker_Factory_Initializer (long)
{
  ImplementationRepository__TAO_Administration_Proxy_Broker_Factory_function_pointer = 
    ImplementationRepository__TAO_Administration_Proxy_Broker_Factory_function;
  
  return 0;
}

static int ImplementationRepository__TAO_Administration_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  ImplementationRepository__TAO_Administration_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, ImplementationRepository__TAO_Administration_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::_TAO_Administration_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::activate_server (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
    , ImplementationRepository::Administration::CannotActivate
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "activate_server",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->activate_server (
        server ACE_ENV_ARG_PARAMETER
      );
  return;
}

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::register_server (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    const ImplementationRepository::StartupOptions & options
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::AlreadyRegistered
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "register_server",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->register_server (
        server,
        options ACE_ENV_ARG_PARAMETER
      );
  return;
}

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::reregister_server (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    const ImplementationRepository::StartupOptions & options
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "reregister_server",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->reregister_server (
        server,
        options ACE_ENV_ARG_PARAMETER
      );
  return;
}

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::remove_server (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "remove_server",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->remove_server (
        server ACE_ENV_ARG_PARAMETER
      );
  return;
}

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::shutdown_server (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "shutdown_server",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->shutdown_server (
        server ACE_ENV_ARG_PARAMETER
      );
  return;
}

char * POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::server_is_running (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    const char * addr,
    ImplementationRepository::ServerObject_ptr server_object
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "server_is_running",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (_tao_retval._retn ());
  return ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->server_is_running (
        server,
        addr,
        server_object ACE_ENV_ARG_PARAMETER
      );
}

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::server_is_shutting_down (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "server_is_shutting_down",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->server_is_shutting_down (
        server ACE_ENV_ARG_PARAMETER
      );
  return;
}

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::find (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    ImplementationRepository::ServerInformation_out info
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "find",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->find (
        server,
        info ACE_ENV_ARG_PARAMETER
      );
  return;
}

void POA_ImplementationRepository::_TAO_Administration_ThruPOA_Proxy_Impl::list (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list,
    ImplementationRepository::ServerInformationIterator_out server_iterator
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "list",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/Administration:1.0"
        )
    )->list (
        how_many,
        server_list,
        server_iterator ACE_ENV_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Direct Proxy  Implementation
//

POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::_TAO_Administration_Direct_Proxy_Impl (void)
{}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::activate_server  (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
    , ImplementationRepository::Administration::CannotActivate
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->activate_server (
          server ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::register_server  (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    const ImplementationRepository::StartupOptions & options
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::AlreadyRegistered
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->register_server (
          server,
          options ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::reregister_server  (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    const ImplementationRepository::StartupOptions & options
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->reregister_server (
          server,
          options ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::remove_server  (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->remove_server (
          server ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::shutdown_server  (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->shutdown_server (
          server ACE_ENV_ARG_PARAMETER
        );
  
}

char * POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::server_is_running  (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    const char * addr,
    ImplementationRepository::ServerObject_ptr server_object
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  return ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->server_is_running (
          server,
          addr,
          server_object ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::server_is_shutting_down  (
    CORBA_Object *_collocated_tao_target_,
    const char * server
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->server_is_shutting_down (
          server ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::find  (
    CORBA_Object *_collocated_tao_target_,
    const char * server,
    ImplementationRepository::ServerInformation_out info
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    , ImplementationRepository::Administration::NotFound
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->find (
          server,
          info ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_Administration_Direct_Proxy_Impl::list  (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list,
    ImplementationRepository::ServerInformationIterator_out server_iterator
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::Administration_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/Administration:1.0")
    )->list (
          how_many,
          server_list,
          server_iterator ACE_ENV_ARG_PARAMETER
        );
  
}


//
//           End Direct Proxy Implementation
///////////////////////////////////////////////////////////////////////
// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:100
POA_ImplementationRepository::Administration::Administration (void)
{
  this->optable_ = &tao_ImplementationRepository_Administration_optable;
}

POA_ImplementationRepository::Administration::Administration (const Administration& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_ImplementationRepository::Administration::~Administration (void)
{
}

void POA_ImplementationRepository::Administration::activate_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var server;
  if (!(
    (_tao_in >> server.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_activate_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in () ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->activate_server (
            server.in () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::register_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var server;
  ImplementationRepository::StartupOptions options;
  if (!(
    (_tao_in >> server.out ()) &&
    (_tao_in >> options)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_register_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in (),
      options ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->register_server (
            server.in (),
            options ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::reregister_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var server;
  ImplementationRepository::StartupOptions options;
  if (!(
    (_tao_in >> server.out ()) &&
    (_tao_in >> options)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_reregister_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in (),
      options ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->reregister_server (
            server.in (),
            options ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::remove_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var server;
  if (!(
    (_tao_in >> server.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_remove_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in () ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->remove_server (
            server.in () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::shutdown_server_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var server;
  if (!(
    (_tao_in >> server.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_shutdown_server _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in () ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->shutdown_server (
            server.in () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::server_is_running_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
  CORBA::String_var _tao_retval;
  CORBA::String_var server;
  CORBA::String_var addr;
  ImplementationRepository::ServerObject_var server_object;
  if (!(
    (_tao_in >> server.out ()) &&
    (_tao_in >> addr.out ()) &&
    (_tao_in >> server_object.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_running _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in (),
      addr.in (),
      server_object.in () ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        _tao_retval = 
        _tao_impl->server_is_running (
            server.in (),
            addr.in (),
            server_object.in () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      char * _tao_retval_info = _tao_retval._retn ();
      _tao_ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << _tao_retval.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::server_is_shutting_down_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
    CORBA::String_var server;
  if (!(
    (_tao_in >> server.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_server_is_shutting_down _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in () ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->server_is_shutting_down (
            server.in () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::find_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
    CORBA::String_var server;
  ImplementationRepository::ServerInformation_var info;
  if (!(
    (_tao_in >> server.out ())
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_find _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      server.in () ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->find (
            server.in (),
            info.out () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << info.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::list_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::Administration *,
        _tao_object_reference
      );
    CORBA::ULong how_many;
  ImplementationRepository::ServerInformationList_var server_list;
    ImplementationRepository::ServerInformationIterator_var server_iterator;
  if (!(
    (_tao_in >> how_many)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_Administration_list _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      how_many      
 ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->list (
            how_many,
            server_list.out (),
            server_iterator.out () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << server_list.in ()) &&
      (_tao_out << server_iterator.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::Administration::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::Administration *_tao_impl = (POA_ImplementationRepository::Administration *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_ImplementationRepository::Administration::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::Administration *_tao_impl = (POA_ImplementationRepository::Administration *) _tao_object_reference;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_ImplementationRepository::Administration::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::Administration *_tao_impl = (POA_ImplementationRepository::Administration *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_ImplementationRepository::Administration::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:ImplementationRepository/Administration:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_ImplementationRepository::Administration::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:ImplementationRepository/Administration:1.0") == 0)
    return ACE_static_cast (POA_ImplementationRepository::Administration_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_ImplementationRepository::Administration::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/Administration:1.0";
}

void POA_ImplementationRepository::Administration::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


ImplementationRepository::Administration*
POA_ImplementationRepository::Administration::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::ImplementationRepository::Administration::_unchecked_narrow (obj.in ());
}


class TAO_ImplementationRepository_ServerInformationIterator_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 10:26:32 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /project/sirion/coryan/amh/ACE_wrappers/build/Linux/bin/gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_ImplementationRepository_ServerInformationIterator_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_ImplementationRepository_ServerInformationIterator_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14,  0,  0, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14,  0,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14,  0, 14, 14, 14, 14,  0, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14,
#else
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
     14, 14, 14, 14, 14,  0, 14,  0, 14, 14,
      0,  0, 14, 14, 14, 14, 14, 14, 14, 14,
      0, 14, 14, 14, 14, 14,  0, 14, 14, 14,
     14,  0, 14, 14, 14, 14, 14, 14,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_ImplementationRepository_ServerInformationIterator_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 13,
      HASH_VALUE_RANGE = 9,
      DUPLICATES = 0,
      WORDLIST_SIZE = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_ImplementationRepository::ServerInformationIterator::_is_a_skel},
      {"next_n", 	&POA_ImplementationRepository::ServerInformationIterator::next_n_skel},
      {"destroy", 	&POA_ImplementationRepository::ServerInformationIterator::destroy_skel},
      {"",0},{"",0},
      {"_interface",  &POA_ImplementationRepository::ServerInformationIterator::_interface_skel},
      {"",0},{"",0},
      {"_non_existent",  &POA_ImplementationRepository::ServerInformationIterator::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 10:26:32 */
static TAO_ImplementationRepository_ServerInformationIterator_Perfect_Hash_OpTable tao_ImplementationRepository_ServerInformationIterator_optable;

#if (TAO_HAS_INTERCEPTORS == 1)
class TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::ServerInformationIterator *tao_impl
    ,
    const CORBA::ULong & how_many ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  void result (CORBA::Boolean result);

private:
  TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n (const TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n &);
  
private:
  POA_ImplementationRepository::ServerInformationIterator *_tao_impl;
  const CORBA::ULong & how_many_;
  CORBA::Boolean _result;
};

TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n::TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::ServerInformationIterator *tao_impl,
    const CORBA::ULong & how_many ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl),
    how_many_ (how_many)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
  
  parameter_list->length (1);
  CORBA::ULong len = 0;
  
    (*parameter_list)[len].argument <<= how_many_;
  (*parameter_list)[len].mode = CORBA::PARAM_IN;
  len++;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  
  return safe_result_any._retn ();
}

char *
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

void 
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

class TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy : public TAO_ServerRequestInfo
{
public:
  TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *tao_servant_upcall,POA_ImplementationRepository::ServerInformationIterator *tao_impl
     ACE_ENV_ARG_DECL_WITH_DEFAULTS
  );

  virtual Dynamic::ParameterList * arguments (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual Dynamic::ExceptionList * exceptions (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Any * result (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS
    )
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual char * target_most_derived_interface (
      ACE_ENV_SINGLE_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));
  
  virtual CORBA::Boolean target_is_a (
      const char * id
      ACE_ENV_ARG_DECL_WITH_DEFAULTS)
    ACE_THROW_SPEC ((CORBA::SystemException));

  
private:
  TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy (const TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy &);
  void operator= (const TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy &);
  
private:
  POA_ImplementationRepository::ServerInformationIterator *_tao_impl;
  
};

TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy::TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy (
    TAO_ServerRequest &_tao_server_request,
    TAO_Object_Adapter::Servant_Upcall *_tao_servant_upcall,
    POA_ImplementationRepository::ServerInformationIterator *tao_impl ACE_ENV_ARG_DECL_NOT_USED
  )
  : TAO_ServerRequestInfo (_tao_server_request, _tao_servant_upcall),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy::arguments (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy::exceptions (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy::result (ACE_ENV_SINGLE_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

char *
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy::target_most_derived_interface (
    ACE_ENV_SINGLE_ARG_DECL_NOT_USED)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy::target_is_a (
    const char * id
    ACE_ENV_ARG_DECL)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id ACE_ENV_ARG_PARAMETER);
}

#endif /* TAO_HAS_INTERCEPTORS */

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker *POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker::the_TAO_ServerInformationIterator_Strategized_Proxy_Broker (void)
{
  static POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker::_TAO_ServerInformationIterator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker::~_TAO_ServerInformationIterator_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];
  
}

ImplementationRepository::_TAO_ServerInformationIterator_Proxy_Impl&
POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker::select_proxy (
    ::ImplementationRepository::ServerInformationIterator *object
    ACE_ENV_ARG_DECL
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object ACE_ENV_ARG_PARAMETER);
    ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker::create_proxy (
    int strategy
    ACE_ENV_ARG_DECL
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_ImplementationRepository::_TAO_ServerInformationIterator_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_DIRECT_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_ImplementationRepository::_TAO_ServerInformationIterator_Direct_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::ImplementationRepository::_TAO_ServerInformationIterator_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


ImplementationRepository::_TAO_ServerInformationIterator_Proxy_Broker *
ImplementationRepository__TAO_ServerInformationIterator_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_ImplementationRepository::_TAO_ServerInformationIterator_Strategized_Proxy_Broker::the_TAO_ServerInformationIterator_Strategized_Proxy_Broker();
}

int
ImplementationRepository__TAO_ServerInformationIterator_Proxy_Broker_Factory_Initializer (long)
{
  ImplementationRepository__TAO_ServerInformationIterator_Proxy_Broker_Factory_function_pointer = 
    ImplementationRepository__TAO_ServerInformationIterator_Proxy_Broker_Factory_function;
  
  return 0;
}

static int ImplementationRepository__TAO_ServerInformationIterator_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  ImplementationRepository__TAO_ServerInformationIterator_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, ImplementationRepository__TAO_ServerInformationIterator_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_ImplementationRepository::_TAO_ServerInformationIterator_ThruPOA_Proxy_Impl::_TAO_ServerInformationIterator_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_ImplementationRepository::_TAO_ServerInformationIterator_ThruPOA_Proxy_Impl::next_n (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "next_n",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK_RETURN (_tao_retval);
  return ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerInformationIterator_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/ServerInformationIterator:1.0"
        )
    )->next_n (
        how_many,
        server_list ACE_ENV_ARG_PARAMETER
      );
}

void POA_ImplementationRepository::_TAO_ServerInformationIterator_ThruPOA_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "destroy",
      forward_to.out ()
      ACE_ENV_ARG_PARAMETER
    );
      ACE_CHECK;
  ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerInformationIterator_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:ImplementationRepository/ServerInformationIterator:1.0"
        )
    )->destroy (
        ACE_ENV_SINGLE_ARG_PARAMETER
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Direct Proxy  Implementation
//

POA_ImplementationRepository::_TAO_ServerInformationIterator_Direct_Proxy_Impl::_TAO_ServerInformationIterator_Direct_Proxy_Impl (void)
{}

CORBA::Boolean POA_ImplementationRepository::_TAO_ServerInformationIterator_Direct_Proxy_Impl::next_n  (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerInformationIterator_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/ServerInformationIterator:1.0")
    )->next_n (
          how_many,
          server_list ACE_ENV_ARG_PARAMETER
        );
  
}

void POA_ImplementationRepository::_TAO_ServerInformationIterator_Direct_Proxy_Impl::destroy  (
    CORBA_Object *_collocated_tao_target_
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_reinterpret_cast (
      POA_ImplementationRepository::ServerInformationIterator_ptr,
      _collocated_tao_target_->_servant ()->_downcast ("IDL:ImplementationRepository/ServerInformationIterator:1.0")
    )->destroy (
          ACE_ENV_SINGLE_ARG_PARAMETER
        );
  
}


//
//           End Direct Proxy Implementation
///////////////////////////////////////////////////////////////////////
// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:100
POA_ImplementationRepository::ServerInformationIterator::ServerInformationIterator (void)
{
  this->optable_ = &tao_ImplementationRepository_ServerInformationIterator_optable;
}

POA_ImplementationRepository::ServerInformationIterator::ServerInformationIterator (const ServerInformationIterator& rhs)
  :  TAO_ServantBase (rhs)
{}

POA_ImplementationRepository::ServerInformationIterator::~ServerInformationIterator (void)
{
}

void POA_ImplementationRepository::ServerInformationIterator::next_n_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::ServerInformationIterator *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::ServerInformationIterator *,
        _tao_object_reference
      );
  CORBA::Boolean _tao_retval = 0;
  CORBA::ULong how_many;
  ImplementationRepository::ServerInformationList_var server_list;
    if (!(
    (_tao_in >> how_many)
  ))
ACE_THROW (CORBA::MARSHAL ());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_next_n _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl,
      how_many ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        _tao_retval = 
        _tao_impl->next_n (
            how_many,
            server_list.out () ACE_ENV_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      CORBA::Boolean _tao_retval_info = _tao_retval;
      _tao_ri.result (_tao_retval_info);
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  
  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval)) &&
      (_tao_out << server_list.in ())
    ))
ACE_THROW (CORBA::MARSHAL ());

  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::ServerInformationIterator::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void *_tao_servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::ServerInformationIterator *_tao_impl =
    ACE_static_cast (
        POA_ImplementationRepository::ServerInformationIterator *,
        _tao_object_reference
      );
  _tao_server_request.argument_flag (0);
  
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_Object_Adapter::Servant_Upcall *_tao_upcall =
    ACE_static_cast (TAO_Object_Adapter::Servant_Upcall *, _tao_servant_upcall);
  
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );
  
  TAO_ServerRequestInfo_ImplementationRepository_ServerInformationIterator_destroy _tao_ri (
      _tao_server_request,
      _tao_upcall,
      _tao_impl ACE_ENV_ARG_PARAMETER
    );
  
  ACE_TRY
    {
      {
        TAO_PICurrent_Guard _tao_pi_guard (_tao_ri.server_request (),
                                           1  /* Copy TSC to RSC */);
        
        _tao_vfr.receive_request (&_tao_ri ACE_ENV_ARG_PARAMETER);
        ACE_TRY_CHECK;
        
#endif /* TAO_HAS_INTERCEPTORS */
        
        _tao_impl->destroy (
            ACE_ENV_SINGLE_ARG_PARAMETER
          );
        TAO_INTERCEPTOR_CHECK;
        
#if (TAO_HAS_INTERCEPTORS == 1)
        }
      
      _tao_ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&_tao_ri ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &_tao_ri
          ACE_ENV_ARG_PARAMETER
        );
      ACE_TRY_CHECK;
      
      PortableInterceptor::ReplyStatus _tao_status =
        _tao_ri.reply_status (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      if (_tao_status == PortableInterceptor::SYSTEM_EXCEPTION
          || _tao_status == PortableInterceptor::USER_EXCEPTION)
        ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */
  
  _tao_server_request.init_reply ();
  
  // In case _tao_servant_upcall is not used in this function
  ACE_UNUSED_ARG (_tao_servant_upcall);
  
  }

void POA_ImplementationRepository::ServerInformationIterator::_is_a_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_ImplementationRepository::ServerInformationIterator *_tao_impl = (POA_ImplementationRepository::ServerInformationIterator *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!(_tao_in >> value.out ()))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in () ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_ImplementationRepository::ServerInformationIterator::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::ServerInformationIterator *_tao_impl = (POA_ImplementationRepository::ServerInformationIterator *) _tao_object_reference;
  CORBA::Boolean _tao_retval =
    _tao_impl->_non_existent (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(_tao_out << CORBA::Any::from_boolean (_tao_retval)))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_ImplementationRepository::ServerInformationIterator::_interface_skel (
    TAO_ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* Servant_Upcall */
    ACE_ENV_ARG_DECL
  )
{
  POA_ImplementationRepository::ServerInformationIterator *_tao_impl = (POA_ImplementationRepository::ServerInformationIterator *) _tao_object_reference;
  CORBA_InterfaceDef_ptr _tao_retval = 0;
  CORBA::Boolean _tao_result = 0;
  
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS ());
    }
  
  ACE_TRY
    {
      _tao_retval = 
        _tao_impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
      ACE_TRY_CHECK;
      
      _tao_server_request.init_reply ();
      
      TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
      
      _tao_result =
        _tao_adapter->interfacedef_cdr_insert (
            _tao_out,
            _tao_retval
          );
    }
  ACE_CATCHALL
    {
      _tao_adapter->dispose (_tao_retval);
    }
  ACE_ENDTRY;
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

CORBA::Boolean POA_ImplementationRepository::ServerInformationIterator::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  const char *base_id = "IDL:org.omg/CORBA/Object:1.0";
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:ImplementationRepository/ServerInformationIterator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, base_id)))
      return 1;
    else
      return 0;
}

void* POA_ImplementationRepository::ServerInformationIterator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:ImplementationRepository/ServerInformationIterator:1.0") == 0)
    return ACE_static_cast (POA_ImplementationRepository::ServerInformationIterator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_ImplementationRepository::ServerInformationIterator::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/ServerInformationIterator:1.0";
}

void POA_ImplementationRepository::ServerInformationIterator::_dispatch (
    TAO_ServerRequest &req,
    void *servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}


ImplementationRepository::ServerInformationIterator*
POA_ImplementationRepository::ServerInformationIterator::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  
  (void) safe_stub.release ();
  
  return ::ImplementationRepository::ServerInformationIterator::_unchecked_narrow (obj.in ());
}



#endif /* ifndef */
