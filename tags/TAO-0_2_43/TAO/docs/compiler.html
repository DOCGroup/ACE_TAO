<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (X11; U; SunOS 5.5.1 sun4u) [Netscape]">
   <TITLE>TAO IDL compiler User's Guide</TITLE>
<!-- $Id$ -->
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" VLINK="#CC0000">

<HR>
<H3>
TAO IDL compiler User's Guide</H3>

<H2>
Scope</H2>
This document describes the options and features of TAO IDL compiler, it
is not a reference manual or tutorial on IDL.
<H2>
Generated Files</H2>
The IDL compiler generates 6 files from each <TT>.idl</TT> file, the file
names are obtained by taking the IDL basename and appending <TT>C.h</TT>,
<TT>C.i</TT>, <TT>C.cpp</TT>, <TT>S.h</TT>, <TT>S.i</TT> and <TT>S.cpp</TT>;
the client stubs are declared in the <TT>C.h</TT> file, the skeletons in
the <TT>S.h</TT> file. Please see the Options list on how to get different
suffixes for these files.

<P>Both clients and servers should link against the object files for the
stubs and skeletons, this is needed to transparently support collocated
objects.
<H2>
Operation Lookup Strategies</H2>
The server skeleton can make use of different lookup strategies to match
the incoming operation with the correct operation at the servant.
<BR>Dynamic Hashing and Perfect Hashing are the two different operation
lookup strategies that are currently supported in tao_idl.
<BR>By default, tao_idl tries to use Perfect Hashing strategy. <A HREF="http://www.cs.wustl.edu/~schmidt/gperf.ps.gz">gperf
</A>generates the lookup methods for this strategy.
<BR>ACE_HAS_GPERF has been defined for the platforms where gperf works.
This includes Solaris and NT.

<P>To make use of Perfect Hashing:
<UL>
<LI>
Build the gperf program at $ACE_ROOT/apps/gperf. (This build also leaves
a copy/link of the gperf program at the $ACE_ROOT/bin directory).</LI>

<LI>
Set the environment variable $ACE_ROOT appropriately or add $ACE_ROOT/bin
to the PATH.</LI>

<LI>
Use -g option for the tao_idl or set the PATH accordingly to use gperf
located at other places other than $ACE_ROOT/bin.</LI>
</UL>

<H2>
Options</H2>
The IDL compiler invokes your <TT>C</TT> (or <TT>C++</TT>) preprocessor
to resolve included IDL files, it receives the common options for preprocessors
(such as <TT>-D</TT> or <TT>-I</TT>); but also receives other options that
are specific to it.
<TABLE BORDER=2 CELLSPACING=2 CELLPADDING=0 >
  <TR>
    <TH>Option</TH>

    <TH>Description</TH>
  </TR>

  <TR NAME="V">
<TD><TT>-V</TT></TD>

<TD>The compiler printouts its version and exits</TD>
</TR>

<TR NAME="Wb">
<TD><TT>-Wb,</TT><I>option_list</EM</TD>&nbsp;</I></TD>

<TD>Pass options to the backend.</TD>
</TR>

<TR NAME="export_macro">
<TD></TD>

<TD><TT>export_macro=</TT><I>macro_name</I></TD>

<TD>The compiler will emit <I>macro_name</I> right after each <TT>class</TT>
    or <TT>extern</TT> keyword, this is needed for Windows/NT that requires
    special directives to export symbols from DLLs, usually the definition
    is just a space on unix platforms.&nbsp;</TD>
</TR>

<TR NAME="export_include">
<TD></TD>

<TD><TT>export_include=</TT><I>include_path</I></TD>

<TD>The compiler will generate code to include <I>include_path</I> at the
    top of the client header, this is usually a good place to define the export
    macro.&nbsp;</TD>
</TR>

<TR NAME="E">
<TD><TT>-E</TT></TD>

<TD>Only invoke the preprocessor</TD>
</TR>

<TR NAME="Wp">
<TD><TT>-Wp,</TT><I>option_list</EM</TD>&nbsp;</I></TD>

<TD>Pass options to the preprocessor.</TD>
</TR>

<TR NAME="D">
<TD><TT>-D</TT><I>macro_definition</I></TD>

<TD>It is passed to the preprocessor</TD>
</TR>

<TR NAME="U">
<TD><TT>-U</TT><I>macro_name</I></TD>

<TD>It is passed to the preprocessor</TD>
</TR>

<TR NAME="I">
<TD><TT>-I</TT><I>include_path</I></TD>

<TD>It is passed to the preprocessor</TD>
</TR>

<TR NAME="A">
<TD><TT>-A</TT><I>assertion</I></TD>

<TD>It is passed to the preprocessor</TD>
</TR>

<TR NAME="Y">
<TD><TT>-Y</TT></TD>

<TD>It is passed to the preprocessor</TD>
</TR>

<TR NAME="H perfect_hashing">
<TD><TT>-H perfect_hashing</TT></TD>

<TD>To specify the IDL compiler to generate skelton code that uses perfect
    hashed operation lookup strategy, which is the default strategy. Perfect
    hashing uses <A HREF="http://www.cs.wustl.edu/~schmidt/gperf.ps.gz">gperf
    </A>program, to generate lookup methods.&nbsp;</TD>
</TR>

<TR NAME="H dynamic_hashing">
<TD><TT>-H dynamic_hashing</TT></TD>

<TD>To specify the IDL compiler to generate skelton code that uses dynamic
    hashed operation lookup strategy.&nbsp;</TD>
</TR>

<TR NAME="H binary_search">
<TD><TT>-H binary_search</TT></TD>

<TD>To specify the IDL compiler to generate skelton code that uses
    binary search based operation lookup strategy.&nbsp;</TD> 
</TR>

<TR NAME="g">
<TD><TT>-g</TT></TD>

<TD>To specify the path for the perfect hasing program (GPERF). Default
    is $ACE_ROOT/bin/gperf.&nbsp;</TD>
</TR>

<TR NAME="o">
<TD><TT>-o</TT></TD>

<TD>To specify the output directory to IDL compiler as to where all the
    IDL-compiler-generated files are to be put. By default, all the files are
    put in the current directory from where&nbsp;<tao_idl>is called.&nbsp;</TD>
</TR>

<TR NAME="hc">
<TD><TT>-hc</TT></TD>

<TD>Client's header file name ending. Default is "C.h".</TD>
</TR>

<TR NAME="hs">
<TD><TT>-hs</TT></TD>

<TD>Server's header file name ending. Default is "S.h".</TD>
</TR>

<TR NAME="hT">
<TD><TT>-hT</TT></TD>

<TD>Server's template header file name ending. Default is "S_T.h".</TD>
</TR>

<TR NAME="cs">
<TD><TT>-cs</TT></TD>

<TD>Client stub's file name ending. Default is "C.cpp".</TD>
</TR>

<TR NAME="ci">
<TD><TT>-ci</TT></TD>

<TD>Client inline file name ending. Default is "C.i".</TD>
</TR>

<TR NAME="ss">
<TD><TT>-ss</TT></TD>

<TD>Server skeleton file name ending. Default is "S.cpp".</TD>
</TR>

<TR NAME="sT">
<TD><TT>-sT</TT></TD>

<TD>Server template skeleton file name ending. Default is "S_T.cpp".</TD>
</TR>

<TR NAME="si">
<TD><TT>-si</TT></TD>

<TD>Server inline skeleton file name ending. Default is "S_i.cpp".</TD>
</TR>

<TR NAME="st">
<TD><TT>-st</TT></TD>

<TD>Server's template inline file name ending. Default is "S_T.i".</TD>
</TR>

<TR NAME="Gc">
<TD><TT>-Gc</TT></TD>

<TD> Generate stubs and skeletons using compiled marshaling </TD>
</TR>

<TR NAME="Gi">
<TD><TT>-Gi</TT></TD>

<TD> Generate stubs and skeletons using interpretive marshaling
(default for now) </TD>
</TR>

<TR NAME="Ge">
<TD><TT>-Ge</TT></TD>
<TD> 
  Generate code that uses C++ exceptions (unimplemented as yet)
</TD>
</TR>

<TR NAME="Gt">
<TD><TT>-Gt</TT></TD>
<TD> 
  Generate optimized TypeCodes (unimplemented as yet)
</TD>
</TR>

<TR NAME="Sa">
<TD><TT>-Sa</TT></TD>
<TD> 
  Suppress generation of the Any operators
</TD>
</TR>

<TR NAME="St">
<TD><TT>-St</TT></TD>
<TD> 
     Suppress generation of the TypeCodes
</TD>
</TR>

</TABLE>

<HR>
<ADDRESS>
<I><A HREF="mailto:coryan@cs.wustl.edu">Carlos O'Ryan</A></I></ADDRESS>

</BODY>
</HTML>
